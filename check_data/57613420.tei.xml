<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">MadMax: Surviving Out-of-Gas Conditions in Ethereum Smart Contracts</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neville</forename><surname>Grech</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Kong</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anton</forename><surname>Jurisevic</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernhard</forename><surname>Scholz</surname></persName>
							<email>bernhard.scholz@sydney.edu.au</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Brent</surname></persName>
							<email>lexi.brent@sydney.edu.au</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Smaragdakis</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Athens</orgName>
								<orgName type="institution" key="instit2">University of Malta</orgName>
								<address>
									<settlement>Greece</settlement>
									<country key="MT">Malta</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">The University of Sydney</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">LEXI BRENT</orgName>
								<orgName type="institution">The University of Sydney</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">The University of Sydney</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="department">YANNIS SMARAGDAKIS</orgName>
								<orgName type="institution">The University of Sydney</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">University of Athens</orgName>
								<address>
									<country key="GR">Greece</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">MadMax: Surviving Out-of-Gas Conditions in Ethereum Smart Contracts</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3276486</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Program Analysis</term>
					<term>Smart Contracts</term>
					<term>Security</term>
					<term>Blockchain shaStmt:[structureOffsetVar := SHA3(start</term>
					<term>keySizeVar)]</term>
					<term>MemContents(shaStmt</term>
					<term>start</term>
					<term>keyVar)</term>
					<term>HasConstantValue(keySizeVar</term>
					<term>keySize)</term>
					<term>VarIndexesStorage(*</term>
					<term>structureOffsetVar). RelatedKeys(keyVar</term>
					<term>keyVar&apos;</term>
					<term>keySize)</term>
					<term>KeyToOffset(keyVar</term>
					<term>structureOffsetVar&apos;</term>
					<term>keySize) ← KeyToOffset(keyVar</term>
					<term>structureOffsetVar</term>
					<term>*)</term>
					<term>Flows(structureOffsetVar</term>
					<term>keyVar&apos;)</term>
					<term>KeyToOffset(keyVar&apos;</term>
					<term>structureOffsetVar&apos;</term>
					<term>keySize). ArrayIdToStorageIndex(arrayId</term>
					<term>storeOffsetVar) ← KeyToOffset(keyVar</term>
					<term>storeOffsetVar</term>
					<term>32)</term>
					<term>HasConstantValue(keyVar</term>
					<term>arrayId)</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Ethereum is a distributed blockchain platform, serving as an ecosystem for smart contracts: full-fledged intercommunicating programs that capture the transaction logic of an account. Unlike programs in mainstream languages, a gas limit restricts the execution of an Ethereum smart contract: execution proceeds as long as gas is available. Thus, gas is a valuable resource that can be manipulated by an attacker to provoke unwanted behavior in a victim&apos;s smart contract (e.g., wasting or blocking funds of said victim). Gas-focused vulnerabilities exploit undesired behavior when a contract (directly or through other interacting contracts) runs out of gas. Such vulnerabilities are among the hardest for programmers to protect against, as out-of-gas behavior may be uncommon in non-attack scenarios and reasoning about it is far from trivial. In this paper, we classify and identify gas-focused vulnerabilities, and present MadMax: a static program analysis technique to automatically detect gas-focused vulnerabilities with very high confidence. Our approach combines a control-flow-analysis-based decompiler and declarative program-structure queries. The combined analysis captures high-level domain-specific concepts (such as łdynamic data structure storagež and łsafely resumable loopsž) and achieves high precision and scalability. MadMax analyzes the entirety of smart contracts in the Ethereum blockchain in just 10 hours (with decompilation timeouts in 8% of the cases) and flags contracts with a (highly volatile) monetary value of over $2.8B as vulnerable. Manual inspection of a sample of flagged contracts shows that 81% of the sampled warnings do indeed lead to vulnerabilities, which we report on in our experiment. CCS Concepts: • Software and its engineering → General programming languages;</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Ethereum is a decentralized blockchain platform that can execute arbitrarily-expressive computational smart contracts. Developers typically write smart contracts in a high-level language that a compiler translates into immutable low-level EVM bytecode for a persistent distributed virtual machine. Smart contracts handle transactions in Ether, a cryptocurrency with a current market capitalization in the tens of billions of dollars. Smart contracts (as opposed to non-computational łwalletsž) hold a considerable portion of the total Ether available in circulation, which makes them ripe targets for attackers. Hence, developers and auditors have a strong incentive to make extensive use of various tools and programming techniques that minimize the risk of their contract being attacked.</p><p>Analysis and verification of smart contracts is, therefore, a high-value task, possibly more so than in any other programming setting. The combination of monetary value and public availability makes the early detection of vulnerabilities a task of paramount importance. (Detection may occur after contract deployment. Despite the code immutability, which prevents bug fixes, discovering a vulnerability before an attacker may exploit it could enable a trusted party to move vulnerable funds to safety.)</p><p>A broad family of contract vulnerabilities concerns out-of-gas behavior. Gas is the fuel of computation in Ethereum. Due to the massively replicated execution platform, wasting the resources of others is prevented by charging users for running a contract. Each executed instruction costs gas, which is traded with the Ether cryptocurrency. Since a user pays gas upfront, a transaction's computation may exceed its allotted amount of gas. As a consequence, the Ethereum Virtual Machine (EVM) raises an out-of-gas exception and aborts the transaction. A contract that does not correctly handle the possible abortion of a transaction, is at risk for a gas-focused vulnerability. Typically, a vulnerable smart contract will be blocked forever due to the incorrect handling of out-of-gas conditions: re-executing the contract's function will fail to make progress, re-yielding out-of-gas exceptions, indefinitely. Thus, a contract is susceptible to, effectively, denial-of-service attacks, locking its balance away.</p><p>In this work, we present MadMax : a static program analysis framework for detecting gas-focused vulnerabilities in smart contracts. MadMax is a static analysis pipeline consisting of a decompiler (from low-level EVM bytecode to a structured intermediate language) and a logic-based analysis specification producing a high-level program model. MadMax is highly efficient and effective: it analyzes the whole Ethereum blockchain in 10 hours and reports numerous vulnerable contracts holding a total value exceeding $2.8B, with high precision, as determined from a random sample.</p><p>MadMax is unique in the landscape of smart contract analyzers and verifiers. (Section 7 contains a more detailed treatment of related work.) It is an approach employing cutting-edge static program analysis techniques (e.g., data-flow analysis together with context-sensitive flow analysis and memory layout modeling for data structures), whereas past analyzers have primarily focused on symbolic execution or full-fledged verification for functional correctness. As MadMax demonstrates, static program analysis offers a unique combination of advantages: very high scalability, universal applicability, and high coverage of potential vulnerabilities.</p><p>We speculate that past approaches have not employed static analysis techniques due to three main reasons: a) the belief that the thoroughness of static analysis is unnecessary for smart contracts since they are small in size; b) the possibility that static analysis, although thorough, can yield a high number of false positivesÐfull-fledged, less automated verification techniques may be necessary; and c) the difficulty of applying static analysis techniques uniformly, at a low level: decompiling the low-level EVM bytecode into a manageable representation is a non-trivial challenge.</p><p>MadMax addresses or disproves these objections. It provides an effective decompilation substrate for analyzing low-level EVM bytecode. MadMax exhibits high precision, due to the sophisticated modeling of the gas-focused concepts it examines. Finally, our study of the Ethereum blockchain (and the subsequent application of MadMax to it) reveals that smart contracts can significantly benefit from static analysis. against the Ether held. We can see that relatively complex contracts (measured in the number of basic blocks) contain most of the Ether. Hence, the potential risk compounds for sophisticated smart contracts because complex contracts are harder to get right. This observation strongly supports the use of static program analysis, which scales well to relatively complex programs.</p><p>The main contributions of our work are:</p><p>• A decompiler from EVM bytecode to structured low-level IR: We propose the use of static program analysis directly on the EVM bytecode. Analyzing EVM bytecode is challenging due to the stack-based low-level nature of the EVM with minimal control-flow structures. • The identification of gas-focused vulnerabilities: The semantics of limited, gas-based execution on top of smart contracts handling monetary transactions introduces a new class of vulnerabilities that does not occur in other programming language paradigms. We identify out-of-gas vulnerabilities thoroughly and explain their essence. • Abstractions for high-level data-structures and program constructs: We construct high-level abstractions for EVM bytecode for bridging the gap between the low-level EVM and the high-level vulnerabilities. We express analysis concepts that include safely resumable loops, data structures whose size increases in repeat invocations of public functions, and recognition of nested dynamic structures in low-level memory. • Validation: We validate the approach for all 6.3 million contracts deployed on the entire blockchain. To our knowledge, no other work in the smart contract security literature has performed program analysis on such a number of contracts. Our analysis does not require source code to run, nor external input, and at the same time is highly scalable. The analysis reports vulnerabilities for contracts holding a total value of over $2.8B. Even though it is uncertain whether most vulnerabilities are real and how easily exploitable they might be, manual inspection of a small sample reveals over 80% precision and the existence of specific issues, which we detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>Next, we provide a concise background on the setting of our work including blockchain platforms, Ethereum smart contracts, and the language abstractions behind them.</p><p>116:4 N.Grech, M.Kong, A.Jurisevic, L.Brent, B.Scholz, Y.Smaragdakis</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Blockchain Platforms, Ethereum, and Smart Contracts</head><p>A blockchain is a shared, transparent distributed ledger of transactions, secured using cryptography. One can think of a blockchain as a long and ever-growing list of blocks, each encoding a sequence of individual transactions, always available for inspection and safe from tampering. Each block contains a cryptographic signature of its previous block. Thus no previous block can be changed or rejected without also rejecting all its successors. Peers/Miners run a special software for separately maintaining the current version of the blockchain. Each of the peers considers the longest valid chain starting from a genesis block to be the accepted version of the blockchain. To encourage transaction validation by all peers and discourage wasted or misleading work, a blockchain protocol typically combines two factors: an incentive that is given as a reward to peers successfully performing validation, and a proof-of-work, requiring costly computation to produce a block. To see how distributed consensus and permanent record-keeping arises, consider a malicious client who tries to double-spend a certain amount. The client may propagate conflicting transactions (e.g., paying sellers A and B) to different parts of the network. As different peers become aware of the two versions of the truth, a majority will arise, since the peers will build further blocks over the version they perceived as current. Thus, a majority will soon accept one of the two spending transactions as authoritative and will reject the other. The minority has to follow suit, or its further participation in growing the blockchain will also be invalidated: the rest of the peers will disregard any of the blocks not resulting in the longest chain. Using this approach, a blockchain can serve to coordinate all multi-party interactions with trust arising from the majority of peers, instead of being given to an authority by default. This property has created excitement and led to well-founded assertions that łBlockchain is a foundational technology: It has the potential to create new foundations for our economic and social systemsž <ref type="bibr" target="#b29">[Iansiti and Lakhani 2017]</ref>.</p><p>The original blockchain, at least in its popular form, is due to the Bitcoin platform <ref type="bibr" target="#b42">[Nakamoto 2009]</ref>. Bitcoin is explicitly a special-purpose cryptocurrency platform. Therefore, the data registered on the Bitcoin ledger can be seen as (transaction and balance) amounts. The blockchain formulation we are interested in is the one popularized by the Ethereum platform [Buterin 2013; Wood 2014]: registered accounts are not mere balances, but may contain smart contracts, i.e., code that can perform arbitrary computations, enabling the encoding of complex logic. Virtually any complex interaction can be captured, with its logic permanently and transparently stored on the blockchain: responding to communication from other accounts, dispensing or accepting funds, etc. The possibilities for such logic are endless: it can encode a payoff schedule, investment assumptions, interest policy, conditional trading directives, payment-upon-receipt agreements, pricing dependent on geographic or other environmental input, and a lot more. Gaming, music distribution, remote purchases, and many other business interactions can utilize automatically-enforced smart contracts for secure and verified transactions, without a need for intermediaries or third-party trust.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Smart Contract Programming: Solidity and the EVM</head><p>Ethereum smart contract programming is most commonly done in the Solidity language <ref type="bibr" target="#b53">[Various 2018c</ref>]. Solidity is a JavaScript-like scripting language, enhanced with static types, contracts as a class-like encapsulation construct, contract inheritance, and numerous other features.</p><p>Although Solidity is commonly used, it is far from the only language for writing smart contracts (others are Serpent, Viper, and LLL <ref type="bibr">[Various 2018a,b,d]</ref>). Furthermore, its level of abstraction is significantly removed from that of the code that directly runs on the Ethereum blockchain.</p><p>Instead, Ethereum natively supports a low-level bytecode languageÐthe Ethereum platform is essentially a distributed, replicated virtual machine, called the Ethereum VM (EVM). The EVM is a low-level stack-machine with an instruction set including standard arithmetic instructions, basic cryptography primitives (mainly cryptographic hashing), primitives for identifying contracts and calling out to different contracts (based on cryptographic signatures), exception-related instructions, and primitives for gas computation. Data is stored either on the blockchain, in the form of persistent data structures, or in contract-local memory.</p><p>The EVM supports a segregated, near-infinite (256-bit) memory space per contract. Addresses are cryptographic hashes so that a dynamic structure's location in the virtual memory space is merely the hash of the structure's identifier. This model is an unconventional memory layout and is not straightforward to discern in low-level code. The EVM bytecode language is typeless and unstructured, with several low-level elements, as will be discussed in Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Analysis Level</head><p>In our work, we focus on analyzing smart contracts at the bytecode level. This is a high-cost design decision (due to the low-level nature of the bytecode) and, therefore, not commonly encountered in past work on contract analysis.</p><p>At the same time, the EVM bytecode level of abstraction yields a high payoff for analyses that target it. A bytecode-level analysis does not require a contract's source, allowing the analysis of both new and deployed contracts. It is estimated that high-level source code of EVM contracts is only available for a tiny fraction (just 0.34%) of contracts on etherscan.io <ref type="bibr">[etherscan.io [n. d.]</ref>]. Various high-level languages that target the EVM are in use and, additionally, Solidity contracts can be interleaved with inline assembly, which is similar in structure to EVM bytecode.</p><p>Furthermore, the impedance mismatch between a high-level language and the EVM bytecode is often a source of confusion and errors. For instance, consider the code pattern below:</p><formula xml:id="formula_0">creditorAddresses = new address []( size );</formula><p>This code results in iteration over all locations of an array, to set them to zero. This iteration can well run out of gas. (This code was behind a vulnerability <ref type="bibr" target="#b12">[Atzei et al. 2016]</ref> in the GovernMental <ref type="bibr">[Various [n. d.]</ref>a] smart contract, for example.) Other similar patterns aboundÐwe will also see an illustration in a common gas-focused vulnerability in Section 3.3.</p><p>Therefore, a reliable analysis needs to capture the full semantics of Solidity, which is often far from trivial. An analysis at the EVM bytecode level eschews this complexity, dealing instead only with features that offer uniform power, for all contract source languages.</p><p>Even if Solidity code is available, an analysis at the abstract syntax tree (AST) or text level will need to handle several code complexities and indirections, such as performing intermediate assignments before using a value, or calling a function to perform an effect on storage, instead of doing it locally. This limits the power of AST-based or text-matching (grep-like) techniques for vulnerability analysis. Instead, at the EVM bytecode level, the input is normalized, with all control flow being explicit, uniform, and simplified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EVM GAS-FOCUSED VULNERABILITIES</head><p>In this section, we identify some of the most common patterns of gas-focused vulnerabilities and illustrate them with examples. We employ Solidity for demonstration purposes, even though our entire analysis work is at the EVM bytecode level.</p><p>The mechanism underpinning Ethereum contracts is designed to incentivize users to minimize the number of instructions executed by making them pay up front for the gas required to execute a single transaction. Running out of gas is common, but, in most cases, this is not catastrophic: the transaction is reverted and re-run with a higher gas budget by the end user. Unfortunately, this is not always an option. Many times the amount of gas budgeted is hard-coded in other contracts that have already been deployed, so it cannot be increased. Furthermore, Solidity's send or transfer implementation, which can call other smart contracts, can only send 2300 units of gas. Finally, the Ethereum network has a block gas limit that cannot be surpassed. Therefore, contracts may reach a state (e.g., the size of a data structure in storage can grow a lot) such that they will never have enough gas to run their code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Unbounded Mass Operations</head><p>The most standard form of a gas-focused vulnerability is that of unbounded mass operations. Loops whose behavior is determined by user input could iterate too many times, exceeding the block gas limit, or becoming too economically expensive to perform. The code may not have predicted this possibility, thus failing to ensure that the contract can continue to operate as desired under these conditions. This will commonly lead to a łDenial of Servicež for all transactions that must attempt to iterate the loop. Consider the contract below: As the number of accounts is increased, the gas requirements for executing applyInterest will rise. Eventually, the function may be impossible to execute without raising an out-of-gas exception.</p><p>Ethereum programming safety recommendations <ref type="bibr">[Various [n. d.]</ref>b] suggest that programs should avoid having to perform operations for an unbounded number of clients (instead merely enabling the clients to łpullž from the contract). This practice is typically phrased in terms of payments (łfavor pull over push paymentsž) although it applies more generally. (As we shall see, a large number of existing contracts, holding very substantial sums, violate this practice.)</p><p>A further recommendation is that when loops do need to perform operations for an unbounded number of clients, the amount of gas should be checked at every iteration and the contract should łkeep track of how far [it has] gone, and be able to resume from that pointž <ref type="bibr">[Various [n. d.]</ref></p><formula xml:id="formula_1">b].</formula><p>The above NaiveBank function can be re-written so that it can resume if it did not manage to complete all its operations as follows: This pattern is, as we determine, rarely used correctly in existing contracts, demonstrating the community's unawareness of the dangers inherent in certain smart contract designs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Non-Isolated External Calls (Wallet Griefing)</head><p>In addition to running out of gas because of unbounded, externally-controlled data structures, a contract may run into trouble because of invoking external functionality that may itself throw an out-of-gas exception. This is not a realistic threat in a direct setting: an external call to an unknown party is by definition untrusted, and therefore the contract programmer is highly likely to have considered malicious behavior. Note that Solidity primitives are also designed to encourage such defensive design. However, the vulnerability is realistic when combined with several other complicating factors: implicit code invocation at an Ether transfer, handling multiple clients without isolation, and standard practices for aborting on a send failure.</p><p>The first element of the problem is a call that the programmer may not have considered extensively. Such calls are typically implicit, as part of Ether transfer. Sending Ether involves calling a fallback function on the recipient's side. Therefore, sending Ether may fail, as it invokes arbitrary, possibly untrusted, code. The failure is usually, but does not have to be, an out-of-gas exception.</p><p>It is illustrative to see the issue based on the Solidity primitives and recommended practices. In Solidity, sending Ether is performed via either the send or the transfer primitive. These have different ways to handle transfer errors. For instance, send returns false if sending Ether fails:</p><formula xml:id="formula_2">&lt; address &gt;. send ( uint256 ) returns ( bool )</formula><p>On the other hand, transfer raises an error (i.e., throws an exception) if sending Ether fails. Importantly, both the send and the transfer Solidity primitives are designed with failure in mind. Both are translated into regular calls at the EVM bytecode level, but with a limited gas budget of 2,300 given to the callee. This is typically barely enough to allow executing some logging code on the recipient's side. Therefore, the emphasis is placed on the error handling.</p><p>A good practice locally (and also used in recommended Ethereum security code patterns <ref type="bibr">[Various [n. d.]</ref>b]) is to use the send primitive always with a check of the result, and aborting the transaction by throwing an exception, if a send fails. This effectively turns a send into a transfer plus any other code the user wants.</p><p>The problem arises when that exception is thrown in the middle of a loop, which is also handling other external accounts. 2 Naïve error handling, i.e., just aborting the transaction, is no longer sufficient. We can see the issue in example code for a vulnerability appealingly termed wallet griefing <ref type="bibr" target="#b56">[Vessenes 2016</ref>]. 3 Consider a simple fragment (adapted from <ref type="bibr" target="#b56">[Vessenes 2016]</ref>) of code that tries to refund investments below a minimum amount: The pattern of doing external calls in a loop is also avoided by the łfavor pull over push paymentsž recommendation, which is, however, still, just a recommendation, and has only recently reached broad awareness. <ref type="bibr">3</ref> The slang term łgriefingž comes from the gaming community, where it is used to denote targeted destructive behavior meant to harass.</p><formula xml:id="formula_3">for ( uint i = 0; i &lt; investors . length ; i ++) { if ( investors [i ]. invested &lt; min_investment ) { // Refund ,</formula><formula xml:id="formula_4">116:8 N.Grech, M.Kong, A.Jurisevic, L.Brent, B.Scholz, Y.Smaragdakis</formula><p>The problem is that the send command will also result in the callback function of the selected investor being executed. All it takes for the contract to be vulnerable is for an attacker to make themselves an investor below the minimum threshold, and then provide a callback function that runs out of gas.</p><p>Importantly, it is not enough for the above loop to be resumable, as in Section 3.1. Picking up from the same point will not lead to progress (as it would have if the contract had merely run out of gas): the failed send will re-fail if repeated. More advanced handling of failure-to-send errors is required, so that, e.g., future executions of the contract will be advised that the earlier Ether transfer failed (and will not re-attempt it blindly).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Integer Overflows</head><p>A programming error that commonly expresses itself as a gas-focused vulnerability results from the Solidity type inference approach and its resulting possible integer overflows. This is a separate pattern from the general attack of Section 3.1, since the iteration is not merely unbounded but literally non-terminating, due to an overflow condition producing unexpected values.</p><p>Consider the following contract that exhibits an insidious bug:</p><formula xml:id="formula_5">contract Overflow { Payee payees []; function goOverAll () { for ( var i = 0; i &lt; payees . length ; i ++) { ... } } ... }</formula><p>The use of var induces the problem in the type inference. The inferred type of variable i is uint8 (i.e., a byte), since the variable is initialized to 0 and uint8 is the most precise type that can hold 0 while being compatible with all operations on i. Unfortunately, this means that a mere addition of 256 members to payees is enough to cause the loop to not terminate, quickly resulting in gas exhaustion. An attacker can exploit this vulnerability by adding fake payees using appropriate public functions (not shown) until the overflow is triggered.</p><p>Beyond unexpected type inference, there are indeed more possibilities for overflow in realistic contracts. As we discuss in our evaluation, integer overflows may also tend to creep in when the contract designer is trying to optimize storage requirements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Possible Attacks and Incentives</head><p>The most direct exploitation of the vulnerabilities identified above would result in locking down a contract, rendering it unusable. The attacker typically needs to expend funds to exploit a vulnerabilityÐe.g., consume Ether to populate a dynamic data structure. In the cryptocurrencies ecosystem, some incentives for performing such an attack include:</p><p>• bringing down the price of ETH;</p><p>• amassing fame in the relevant subcommunity;</p><p>• destroying competitors' contracts;</p><p>• blackmailing of contract holders (of the contract under attack, or any other).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ANALYZING EVM BYTECODE</head><p>The first step of our gas-focused vulnerability analysis is a decompilation step, raising the level of abstraction from that of EVM bytecode to a structured intermediate language (IR): control-flow graphs (CFGs) over the three-address code. The decompilation step is non-trivial, since EVM 116:9 bytecode is low-level: much closer to machine-specific assembly than to structured IRs (e.g., Java bytecode or .NET IL). We explain the challenges and decompilation techniques in the next sections.</p><p>Our decompiler, code named Vandal <ref type="bibr" target="#b16">[Brent et al. 2018;</ref>, has been released as a freely-available, self-standing tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Challenges for EVM Bytecode Analysis</head><p>The EVM is a stack-based low-level IR with minimal structured language characteristics. In the bytecode form of a smart contract, symbolic information has been replaced by numeric constants, functions have been fused together, and control flow is hard to reconstruct. To highlight this issue, compare the EVM bytecode language to the best-known bytecode: Java (JVM) bytecodeÐa much higher-level IR. The design differences include:</p><p>• Unlike JVM bytecode, EVM does not have the notion of structs or objects, nor does it have a concept of methods. • Java bytecode is a typed bytecode, while EVM bytecode is not.</p><p>• In JVM bytecode, stack depth is fixed under different control flow paths: execution cannot get to the same program point with different stack sizes. In EVM bytecode, no such structure exists, which means that standard control-flow structures are more accessible to infer from JVM bytecode than from EVM. • All control-flow edges (i.e., jumps) are to variables, not constants. The destination of a jump is a value that is read from the stack. Therefore, a value-flow analysis is necessary even to determine the connectivity of basic blocks. In contrast, JVM bytecode has a clearly-defined set of targets of every jump, independent of value flow (i.e., independent of stack contents). • JVM bytecode has defined method invocation and return instructions. In EVM bytecode, although calls to outside a smart contract can be resolved, function calls inside a contract get translated to just jumps (to variable destinations, per the above point). All functions of a contract are fused in one, with low-level jumps as the means to transfer control.</p><p>To call an intra-contract function, the code pushes a return address to the stack, pushes arguments, pushes the destination block's identifier (a hash), and performs a jump (which pops the top stack element, to use it as a jump destination). To return, the code pops the caller basic block's identifier from the stack and jumps to it.</p><p>These challenges have often prevented past work from attempting a static analysis directly on the EVM bytecode. Instead, the literature is more abundant in semi-dynamic techniques, such as symbolic execution, as we discuss in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Vandal Decompiler Analysis</head><p>The Vandal decompiler <ref type="bibr" target="#b16">[Brent et al. 2018;</ref> accepts EVM bytecode as input and produces output in a standard structured intermediate representation: a control-flow graph (of basic blocks and the edges connecting them); three-address code for all operations (instead of operations acting on the stack); and recognized (likely) function boundaries. This representation is encoded as relations (i.e., tables) and queried, recursively, to formulate higher-level program analyses.</p><p>Because of the complexities we saw in Section 4.1, producing a structured intermediate representation for an EVM bytecode program is not as simple as for other stack-machine IRs (e.g., the conversion of JVM bytecode into the Jimple intermediate language in the Soot framework <ref type="bibr" target="#b49">[Vallée-Rai et al. 1999;</ref><ref type="bibr" target="#b50">Vallée-Rai et al. 2000]</ref>).</p><p>Our earlier discussion directly suggests the challenges:</p><p>• Detecting basic blocks is trivial (because of explicit jump labels), but identifying their connectivity to form a control-flow graph (i.e., the possible targets of every jump) requires a value-flow analysis. The same is true for detecting possible values (or types) of arguments for every operation, that is, the shape of the stack (i.e., its size and static types at every position). • Detecting function boundaries requires a high-fidelity analysis. Common patterns in the compilation of contract code exacerbate this, e.g., in the Solidity compiler, since most smart contracts are written in Solidity. The Solidity compiler translates local contract calls into jumps to a dispatcher routine, which then redirects the call to the initial basic block of the target function.</p><p>We observe that the EVM bytecode input is much like a functional language in continuationpassing-style (CPS) form: all calls and returns are forward calls (jumps), where calls add the continuation (return-to instruction) as one of the arguments. This equivalence of CPS and low-level jumps has been observed beforeÐmost explicitly by <ref type="bibr" target="#b48">Thielecke [1999]</ref>. The only differences in our setting are somewhat superficial: instead of a łcallž instruction, we have jumps, which could well be encoding non-call control-flow transfer (i.e., inside a single function). However, it is possible to recognize, with only local code inspection, jumps that push a return address (i.e., forward calls with a continuation) and distinguish them from local jumps and non-local returns.</p><p>The setting of CPS input and needing to detect value and control flow is precisely that of controlflow analysis (CFA) <ref type="bibr" target="#b46">[Shivers 1991</ref><ref type="bibr" target="#b47">[Shivers , 2004</ref>. Control-flow analysis is also one of the original proposals for a context-sensitive (call-site sensitive) static analysis of value flow: for a k-CFA analysis, every call target gets analyzed separately for each caller (i.e., calling instruction), caller's caller, etc., up to a maximum depth, k.</p><p>This is a good fit for the need of our analysis to detect calls that go through the dispatcher code emitted by the Solidity compiler. Beyond forming the CFG, we want to distinguish flows that go through the dispatcher, where a single caller (i.e., block that jumps to the dispatcher) in reality always reaches a single target (i.e., block that the dispatcher jumps to). Consider the control-flow graph fragment shown in <ref type="figure">Figure</ref> 2 (automatically produced by Vandal using a contract scraped from the blockchain). As can be seen in the figure, the dispatcher node (0x1cc) has a high in-degree and outdegree. However, flow through the dispatcher may disguise a more informative calling pattern. For instance, block 0x620 may always be calling block 0x998 and not any of the other blocks that the dispatcher calls out to. A 1-CFA analysis is likely enough to track the flow through the dispatcher when the latter is used for straightforward transfer of control between local functions of the same contract: the dispatcher code is analyzed separately for each of its predecessors.</p><p>Vandal, therefore, adopts the standard form of a control-flow analysis <ref type="bibr" target="#b47">[Shivers 2004]</ref>, formulated as an abstract-interpretation. There are a few realistic design choices that we employ:</p><p>• We implement context sensitivity by cloning basic blocks. Cloning proceeds breadth-first:</p><p>initially at depth 1 (essentially capturing a 1-CFA analysis), then at depth 2, 3, etc., with no a priori bound. The process terminates either a) when recursion is detected; or b) when there is no cloning to be performed at the given depth; or c) when a global timeout (e.g., 20sec in our current implementation) for the analysis is reached. This means that the context sensitivity of our analysis is in principle unbounded. However, in practice it rarely goes beyond a depth of 2 due to the global timeout. Reaching the timeout is an indication of the analysis being unscalable: the practice of cloning basic blocks (i.e., inlining called functions, with no depth limit) has led to an explosion of the analysis model, up to much larger-than-expected levels.</p><p>Such an explosion of analysis information typically would also indicate (at least partial) imprecision in analysis results. • We short-circuit value sets to a ⊺ (łtopž) value, if they grow larger than a pre-set number of elements, m, (e.g., 5 in our current setting). In terms of the abstract interpretation formulation of the analysis, this is a common-practice restriction of the abstraction lattice, to be a powersetlattice (i.e., with sets of values as points) for sets with size up to m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Schema of Decompiler Output</head><p>Vandal produces 3-address code using the schema listed in <ref type="figure" target="#fig_4">Figure 3</ref>. Syntax sugar and minor detail elision are employed for presentation purposes. Language syntax is quoted using [ and ] and implicitly unquoted for meta-variables. For instance, s:[to := BinOp(x, y)] indicates that statement s is some binary operation on x and y with its result in to, where x, y, and to are the meta-variables referring to the bytecode variables. The distinction between variables in the analyzed program and meta-variables in the analysis is clear from context, therefore we simply refer to łvariablesž, henceforth. We omit the statement identifier, s, when it does not affect a rule. We also use * as a wildcard, i.e., it denotes any variable, which is ignored. The schema captures all elements of EVM bytecode, slightly abstracted. The form is that of a standard, structured intermediate language. As can be seen, JUMPI instructions have statements, and not arbitrary values, as targets. All binary operations are treated equivalently, since we currently do not attempt to analyze arithmetic. We do not include unary operations or direct assignment between variables in the figure, although we do so in the implementation, since these can be treated as special cases of binary operations. RUNTIMEKNOWABLE gives a uniform treatment of instructions that return the cost of gas, transaction id, code size, caller, and other run-time quantities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ANALYSIS OF GAS VULNERABILITIES</head><p>The MadMax pipeline, from the Vandal decompiler to the final analysis output, is depicted in <ref type="figure">Figure 4</ref>. The main MadMax analysis operates on the output of Vandal using logic-based specifications. The analysis is implemented in the Datalog language: a logic-based language, equivalent to firstorder logic with recursion <ref type="bibr" target="#b30">[Immerman 1999</ref>]. The Datalog implementation treats the relations of <ref type="figure" target="#fig_4">Figure 3</ref> as its input schema. We also use Datalog in the paper, as a means for precise specification of the analysis. Although the form of the rules presented here is simplified relative to the full implementation, the essence is kept unchanged.</p><p>The MadMax analysis consists of several analysis layers that progressively infer higher-level concepts about the analyzed smart contract. Starting from the 3-address-code representation, concepts such as loops, induction variables, and data flow are first recognized. Then an analysis of memory and dynamic data structures is performed, inferring concepts such as dynamic data structures, contracts whose storage increases upon re-entry, nested arrays, etc. This step is nontrivial, since it needs to model the EVM dynamic data representation. Finally, concepts at the level of analysis for gas-focused vulnerabilities (e.g., loop with unbounded mass storage) are inferred.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Flow and Loop Analyses</head><p>Ethereum gas-focused vulnerabilities tend to require a high-level semantic understanding of the underlying contract. There are various initial low-level analyses that need to happen before where</p><formula xml:id="formula_6">s ∶ S, index ∶ V , to ∶ V store to (volatile) memory s:[MSTORE(from, index)]</formula><p>where</p><formula xml:id="formula_7">s ∶ S, index ∶ V , from ∶ V conditional jump s:[JUMPI(cond, label)]</formula><p>where</p><formula xml:id="formula_8">s ∶ S, cond ∶ V , label ∶ S conditional throw s:[THROWI(cond)]</formula><p>where</p><formula xml:id="formula_9">s ∶ S, cond ∶ V keccak 256 hash s:[to := SHA3(index, length)]</formula><p>where</p><formula xml:id="formula_10">s ∶ S, index ∶ V , length ∶ V , to ∶ V</formula><p>call external contract s:[to := CALL(addr, gas ...)]</p><p>where where  expressing deeper semantics. Thus, the first step of a MadMax analysis is the derivation of loop and data flow information. This yields several relations, on which further analysis steps are built. The relations, together with some extra domain and input context definitions, are given in <ref type="figure" target="#fig_5">Figure 5</ref>. We do not provide the Datalog rules for any of these relationsÐtheir implementation, although not always straightforward, is standard. For instance, it resembles the flow computation in standard Datalog frameworks for Java bytecode, such as JChord <ref type="bibr" target="#b40">[Naik 2011;</ref><ref type="bibr" target="#b41">Naik et al. 2009]</ref> or Doop <ref type="bibr" target="#b15">[Bravenboer and Smaragdakis 2009]</ref>.</p><formula xml:id="formula_11">s ∶ S, addr ∶ V , gas ∶ V , to ∶ V</formula><formula xml:id="formula_12">s ∶ S, a ∶ V ,b ∶ V , to ∶ V</formula><p>The first three computed relations in <ref type="figure" target="#fig_5">Figure 5</ref> (InLoop, InductionVar, and LoopExitCond) encode useful concepts in structured loops. Note that loops in low-level programs do not have to be structured, e.g., there may not be a loop head that dominates all loop statements. However, Solidity and other EVM languages produce structured loops as part of their compilation process. The loop analysis finds induction variables, i.e. variables that are incremented by a predictable (but not necessarily statically known) amount in each iteration.</p><p>The next four relations capture a data-flow analysis. Relation Flows expresses a data-flow dependency between variables. In its simplest form, Flows is just the reflexive transitive closure of the BinOp input relation, i.e., it ignores storage and memory load and store instructions. However, one can give more sophisticated Flows definitions without affecting the rest of the analysis. VarAlias is a similar relation but more restrictive, for variables directly assigned to each other with no further arithmetic. Accordingly, HasConstantValue does a simple constant propagation: it is just the composition of VarAlias with the input CONST relation.</p><p>Finally, MemContents does a simple analysis of MSTORE operations given the results of VarAlias, and propagates the results to every statement reachable from an MSTORE in the controlflow graph.</p><p>There are two points worth mentioning about the above relations:</p><p>• The data-flow analysis (i.e., relations HasConstantValue, Flows, VarAlias, MemContents) is best-effort, i.e., neither sound nor complete. This means that, first, not all possible flows, aliases, etc. are guaranteed to be found: two variables may hold the same value as a result of complex arithmetic, run-time operations, memory load and stores, etc., without the analysis computing this. Second, not all inferences are guaranteed to hold. E.g., an inference that is known to hold in one control-flow path but not in another will be optimistically propagated when paths are merged. The property of being neither sound nor complete carries over to our overall analysis results. MadMax neither guarantees to detect all gas vulnerabilities, nor guarantees that every gas vulnerability reported is a real bug. This design choice is well-aligned with the intended purpose of a bug-detecting static analysis. To quote <ref type="bibr" target="#b23">Flanagan et al. [2002]</ref>: Insisting that the checker meet either ideal [soundness or completeness] is mistaken on engineering grounds: if the checker finds enough errors to repay the cost of running it and studying its output, then the checker will be cost-effective, and a success. To achieve a cost-effective tool requires making good engineering trade-offs between a variety of factors, including: missed errors (unsoundness), spurious warnings (incompleteness), annotation overhead, and performance. However, compared to past techniques that do not employ static analysis, MadMax can be argued to be soundy <ref type="bibr" target="#b35">[Livshits et al. 2014]</ref>: it makes an effort to achieve soundness (i.e., exhaustive modeling of all program behaviors) up to features that would make its modeling so imprecise as to be unscalable. The main unsoundness of the MadMax modeling has to do with ad hoc construction of memory/storage pointers. MadMax models the most standard way to produce memory/storage pointers in EVM bytecode: either from constants, or by using SHA3 to dereference previously-derived pointers (plus any applicable constant offsets). However, this is not guaranteed to be the only pointer construction employed in a real programÐ e.g., a pointer could be produced via any arbitrary arithmetic operations. An additional important source of unsoundness concerns the identification of induction variables: a loop may take many forms and MadMax only recognizes a constant-increment pattern, instead of conservatively identifying all induction variables (which would sacrifice the precision of the analysis for slim soundness gains). • Relations Flows and VarAlias are pervasive in the MadMax analysis. Most other relations we shall see henceforth are transitively closed with respect to either Flows or (the weaker) VarAlias. For example, in Section 5.2 we define a relation RelatedKeys, which is transitively closed with respect to VarAlias: variables (used as data structure keys) that are related make their aliases also related. For purposes of simplicity, we elide such transitive-closure Datalog rules from our exposition and only focus on the seed logic of each interesting concept.</p><p>Armed with the above basic loop and data-flow analyses we can establish higher-level concepts, such as a loop's bound. This is defined as LoopBoundBy in <ref type="figure" target="#fig_6">Figure 6</ref>. If both an induction variable i and a non-induction variable c flow to a loop exit condition then we infer that the loop may be bound by the contents of c. A further refinement of this relation is DynamicallyBound, which infers which loops are bound by either storage or some other value that is only known at run-time.</p><p>Finally, we define predicate PossiblyResumableLoop, to match loops that appear to implement the Ethereum secure coding recommendations <ref type="bibr">[Various [n. d.]</ref>b], by checking the amount of remaining gas, saving to (permanent) storage an induction variable, and loading the same induction variable from storage. Note that this is not an entirely precise detection of resumable loopsÐit may well be finding instances of code that just happen to match these abstract conditions, e.g., gas check, store, load of induction variable. However, the existence of all three conditions is a very strong indication that the programmer has considered the possibility of an out-of-gas exception and has taken precautions to make the loop resumable on a re-execution of the contract function. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Memory Layout and Analysis of Data Structures</head><p>A faithful modeling of the Ethereum VM memory layout for dynamic data structures is a key part of MadMax. This modeling is necessary for reducing the false positive rate of the analysis. An intuitive but naïve approach to find gas vulnerabilities may be to flag any contract that contains loops that are łdynamically boundž, or loops where the number of iterations depends on some value stored in storage or passed as external input. After all, gas limits are always finite numbers, at most up to a constant (the block limit). Would not any unbound iteration be in principle vulnerable, especially since as fully resumable loops are rare? Unfortunately, a precise analysis requires more sophistication. We find experimentally that around half of the currently deployed contracts have dynamically bound loopsÐit would be entirely unrealistic to expect that half of smart contracts currently deployed are vulnerable. This should not be a surprising insightÐa program's behavior largely depends on its input and persistent state. Many of these dynamically-bound loops are in fact iterating over data structures, as we shall see in Section 6.3.</p><p>The Ethereum virtual machine does not have notions of high-level data structures. Instead, operations on high-level data structures are compiled down to low-level operations on addressable storage. Solidity offers two main kinds of dynamically-sized data structures: dynamically-sized arrays and associative arrays, i.e., maps. Solidity offers fixed-sized arrays or structs as well. Throughout the development of our high-level analyses, we found that modeling dynamically-sized data structures is essential for precisely detecting gas-focused vulnerabilities. For example, an application that iterates over a data structure in storage is not at risk of most vulnerabilities if the data structure is of a fixed size.</p><p>Although both arrays and maps can be dynamically resized, no mechanism exists for iterating over maps. Instead, contract implementers need to keep track of entries on both arrays and maps to be able to both index by key or iterate through entries. Furthermore, all of the gas-focused vulnerabilities that involve data structures also involve unbounded loops making arrays the prime data structure to model.</p><p>The Ethereum memory layout is highly unconventional from a traditional programming languages standpoint, although perfectly reasonable if one considers the specifics of the execution environment (i.e., a segregated, 256-bit memory space per contract, cryptographic hashing as a primitive). The main idea is that a key represents an array The key is the address of the memory location holding the array's size. At the same time the key is hashed to yield the address of the memory location that holds the array's contents.  <ref type="figure">Fig. 7</ref>. Storage structure and contents (right) for given contract (left). sha3 is the keccak256 hash function. <ref type="figure">Figure 7</ref> depicts an example of storage allocation for a simple contract with two scalar variables and a two-dimensional dynamic array. Fixed-sized data structures in Solidity are stored consecutively in storage as these appear in program order, starting from offset 0. The individual elements in arrays are also stored consecutively in storage, however, the starting offset of the elements requires some calculation to be determined. Due to their unpredictable size, dynamically-sized array types use a keccak256 hash function (sha3) to find the starting position of the array data. The dynamic array value itself occupies an empty slot in storage at some position p. For a dynamic array, this slot stores the number of elements in the array. The array data, however, are located at keccak256(p). The implementation of arrays is extended to arbitrarily-nested dynamic data structures, by recursively mapping the above implementation, necessitating a recursive analysis.</p><formula xml:id="formula_13">sha3(sha3(2)) a[0][0] sha3(sha3(2)) + 1 a[0][1] sha3(sha3(2) + 1) a[1][0] sha3(sha3(2) + 1) + 1 a[1][1]</formula><p>An analysis for identifying dynamic data structures in smart contracts is shown in <ref type="figure" target="#fig_8">Figure 8</ref>. Relation KeyToOffset links variables that are assigned with a data structure's key (array or map key) with a variable that contains said structure's offset in storage. Variable keySize represents the size of the key, i.e., the number of bytes hashed to produce the offset in storage. This is a constant value in the bytecode, as provided in the rule. In the case of arrays the key size is 32.</p><p>RelatedKeys relates data structure keys to each other if one is contained in the other or if there is aliasing. Effectively, if keyVar was used to compute keyVar', which is also used as an offset, the latter is likely to be a substructure of the former.</p><p>ArrayIdToStorageIndex maps variables that represent offsets in storage to a unique array identity. For instance, array a in <ref type="figure">Figure 7</ref> has an identity of '2'. This is static knowledge, encoded in the program itself: every variable has a static memory offset. It is worth noting that the rules are general enough to map any substructure, even if, for instance, an array is inside a map or vice versa. All substructures are mapped back to their top-level structure's identity. Note that arrays are identified using a single 32 byte word, whereas map items are identified by two 32 byte words (i.e. 64 bytes).</p><p>The above relations, together with VarAlias (for local variable aliasingÐsee Section 5.1) form the MadMax static memory model. The model is not fully general. Notably, alias analysis is  only localÐheap memory is modeled fully only for arrays and maps, not for arbitrary low-level address manipulation. Still, arrays and maps are the native Solidity data structures, and all others are typically built out of them. The model captures the information necessary for identifying substructures and the variables that may refer to them.</p><p>Finally, to statically reason about storage requirements, the analysis needs to find which variables represent array sizes, as captured by relation ArraySizeVariable. Note how the definition uses RelatedKeys, so that the sizes of all sub-arrays also get associated with the containing array, to capture all possible size changes conservatively.</p><p>Based on the above relations that model the memory layout, we define key concepts for gasfocused analyses, as shown in <ref type="figure">Figure 9</ref>. An important concept is IncreasedStorageOnPublic-Function. Storage variables that are increased and stored in their corresponding storage slot imply that a contract's array size is increased when some public function is invoked.</p><p>Moreover, we can find loops that iterate over arrays. We define ArrayIterator as a loop that is bound by an array's size. This uses our previously defined query on loops DynamicBound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Top Level Vulnerability Queries</head><p>The analysis concepts of the previous sections set up the final queries for gas-focused vulnerabilities. These are made precise, by combining several distinct concepts. <ref type="figure" target="#fig_9">Figure 10</ref> shows the final output relations of the MadMax analysis in inlined-to-single-rule and in a slightly simplified form. Consider, for instance, the UnboundedMassOp logic: it examines whether an array that can grow in size as the result of a public function has contents that are loaded or stored (the Flows(storeOffsetVar, index) allows dereferencing from the beginning of the contents), inside a loop whose bound is based on the array size and that contains an induction variable that affects the address loaded or stored.</p><p>The WalletGriefing query is even more precise, requiring a load from the dynamic array, flow of the loaded value to a call whose result is the condition of a throw statement. The call and throw need to be in the same loop, which also has an induction variable that affects the address loaded.</p><p>Finally, loop overflows are conservatively asserted to be likely if the induction variable is cast to a short integer or ideally one byte. The loop has to be łdynamically boundž to be vulnerable, i.e., the number of iterations is determined by some run-time value.</p><p>The common theme behind our analyses for these vulnerabilities is that we only look for them in the presence of loops. There is further commonality between UnboundedMassOp and the WalletGriefing analysis: to exploit any of these, the attacker must be able to append elements to the array that is iterated upon. An important difference, however, is that having resumable loops that keep track of gas will not help against wallet griefing, as the attack only depends upon Ether transfer to an uncooperative fallback function, which can be set up as part of the attack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATION</head><p>In this section, we present the results of our evaluation of MadMax. MadMax is implemented in Python for the Vandal decompiler and scaffolding, and in Datalog for the main analysis. The decompiler produces 3-address relations in a normalized form that are loaded into a Datalog-based database. We use Soufflé <ref type="bibr" target="#b32">[Jordan et al. 2016]</ref> as our Datalog engine. Soufflé compiles its Datalog input program into a C++ application, with specialized data structures for performing relational operations. In addition, we have implemented blockchain scrapers to get contracts and data off the Ethereum blockchain. Our experimental setup consists of all programs available on the Ethereum blockchain on Apr. 9, 2018. This makes up the universe set of łcontracts in the wildž.</p><p>We ran MadMax on an idle machine with an Intel Xeon E5-2687W v4 3.00GHz and 512GB of RAM. Due to time constraints, we set a cutoff of 20s for decompilation. Any contracts that take longer to decompile are considered to timeout.</p><p>There are several research questions that our experiments intend to answer: We evaluate the relevance of the analysis and vulnerabilities by examining the number of contracts that are flagged as vulnerable and the amount of currency (ETH) these contracts hold. Naturally, this metric has to be qualified by a false positive rate (RQ1.B). This is a question that we can only answer approximately: we take a sample of contracts and manually inspect them to see whether the contracts are really vulnerable, and comment on the insights acquired by the inspection. The contracts that are flagged for vulnerabilities, combined, contain 7.07 million ETH, or roughly $2.8 billion. <ref type="bibr">4</ref> In total there are 6.33 million contract instances deployed at the time of our blockchain scraping, produced from 91.8k unique programs.</p><formula xml:id="formula_14">RQ1.</formula><p>4.1% of the contracts are flagged by MadMax as being susceptible to unbounded iteration, 0.12% to wallet griefing and 1.2% to overflows of loop induction variables.</p><p>To estimate a false positive rate, we manually inspected a subset of the contracts flagged. Our unbiased sampling process involves taking unique bytecode programs and selecting the first and last few contracts by block-hash order. However, a bias factor is introduced by the need to have source code available onlineÐcontracts without source code were not considered, since manual inspection of low-level bytecode is highly time-consuming and unreliable.</p><p>We select the first 13 contracts, and manual inspection reveals that 11 of these contracts indeed exhibit 13 distinct vulnerabilities, of 16 flagged, for a precision of 13⇑16 = 81%. By manually inspecting these contracts we have gained important insights about the effectiveness of MadMax. We present a subset of them next. We refer to the manually inspected contracts as Contract #1 to Contract #13. <ref type="bibr">5</ref> The subset of contracts selected for manual inspection include casino and gambling contracts, bidding contracts, ICOs, multi-sig wallets and even a łmarriage contractž.</p><p>Contract #1 (a betting contract) is flagged for wallet griefing, unbounded loops, and loop overflow. The wallet griefing case is a false positive as we could not establish it through manual inspection. We noticed that it is likely that the inferred control-flow graph has imprecision due to a simple function being used in many locations. The contract is also flagged for unbounded iteration and loop overflow, and indeed it is vulnerable to these. In particular, loop overflow will certainly happen if the contract owner tries to withdraw and there are more than 256 bets for the same event. Interestingly, the developer is aware of possible loop overflows and, for instance, acknowledges checks for such an eventuality in other parts of the contract: Contract #2 is flagged for unbounded loop iteration, but since there is an additional check that breaks the loop when the size of a data structure is too large, the warning is actually a false positive.</p><p>Contract #3, flagged for wallet griefing and unbounded mass iteration (both true), does not use a standard for loop for iterations, which is not a challenge for our analysis. We have simplified/obfuscated some details in this contract for security and readability reasons, as follows: Dynamically bound loops. <ref type="figure">Figure 11a</ref> shows that half of the contracts have dynamically bounded loops; many of these are in fact iterating over data structures. This fact highlights the importance of fully analyzing data structures to reason about the resource behavior of smart contracts.</p><p>Loops bounded by gas. Although checking and budgeting loops by gas at run-time is sometimes recommended as a way to avoid gas-focused vulnerabilities, this pattern has not been taken on board by smart contract programmers, as shown in <ref type="figure">Figure 11b</ref>.</p><p>Arrays used for iteration. Iterating loops over arrays is a surprisingly common pattern in smart contracts, as we can see in <ref type="figure" target="#fig_1">Figure 12a</ref>. These arrays typically represent user accounts, bids, game rounds, etc., and can sometimes be manipulated by simply calling public functions.</p><p>Many contracts have nested data structures. Nested data structures are quite popular in Ethereum smart contracts and <ref type="figure" target="#fig_1">Figure 12b</ref> illustrates the importance of reverse-engineering these data structures from bytecode as part of the analysis.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Threats to Validity and Clarifications</head><p>There are a number of threats to validity and clarifications of our experimental evaluation which are worth mentioning:</p><p>Difficulty in establishing the base truth. Unlike other popular łstatic analysis for securityž topics, such as Android taint analysis, smart contracts are a relatively new technology. As such, no labeled contracts are available for benchmarking, and the vulnerabilities we are demonstrating in this work have not been published. Manually inspecting contracts is hard and error-prone, taking at least 1 to 2 hours per contract to establish whether a flagged vulnerability is indeed admissible. In addition, many contracts on the blockchain do not have source code. We have partially addressed these threats by manually inspecting contracts with sources to reduce manual errors. We think that our work can be part of the solution to this problem by releasing a small, labeled benchmark suite based on the manually inspected contracts.</p><p>Bias. We may be introducing an element of bias by only inspecting contracts that have source code available online. This sample set may either be more sophisticated and tested than the average contract on the blockchain, or, conversely, toys, used for learning and exposition. The contracts we chose to manually inspect hold very little Ether. However, this is a natural consequence of the Pareto distribution of Ether between different contracts. Only 1195 contract programs (out of the 90k+) hold more than 1 Ether, and one (1) contract program deployed over 43 instances holds 28% of all the Ether held by all the contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Consequences of vulnerabilities.</head><p>Although we claim that the contracts that are flagged as vulnerable hold more than the equivalent of $2.8B, this does not mean that: (1) exploiting these vulnerabilities, e.g., to block a contract, is easy or cheap, or (2) the vulnerability blocks all Ether in a contract. For instance, it takes resources to execute the unbounded mass operation vulnerability, as it takes an order of magnitude as much gas to add an element to an array than to iterate over one more array element.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>Analysis and verification for smart contracts have received substantial attention recently due to the security issues inherent in the high-risk paradigm of smart contract development. A precursor of this work is Michael Kong's thesis <ref type="bibr" target="#b34">[Kong 2017</ref>] that has been based on Vandal <ref type="bibr" target="#b16">[Brent et al. 2018;</ref>. The thesis introduces various types of gas vulnerabilities and exploits and provides also algorithms to compute loop bounds which expose gas vulnerabilities. The Vandal framework is an open-source framework for decompiling EVM bytecode and analyzing the bytecode via logic specification expressed in Soufflé <ref type="bibr" target="#b32">[Jordan et al. 2016]</ref>.</p><p>Overall, our approach is distinguished by being fully static (i.e., more exhaustive, yet possibly with false positives), applicable to the EVM bytecode level, and focused on modeling data structures and high-level gas vulnerabilities.</p><p>Previous works can be classified according to their underlying techniques, including symbolic execution, formal verification, and abstract interpretation. Systems including Oyente <ref type="bibr" target="#b37">[Luu et al. 2016a]</ref>, MAIAN <ref type="bibr" target="#b43">[Nikolic et al. 2018]</ref>, GASPER <ref type="bibr" target="#b18">[Chen et al. 2017]</ref> and recent work <ref type="bibr" target="#b26">[Grossman et al. 2017</ref>] use a symbolic execution/trace semantics approach that is fundamentally unsound, since only some program paths of smart contracts can be explored.</p><p>Semi-automated formal verification approaches have also been proposed <ref type="bibr" target="#b11">[Amani et al. 2018;</ref><ref type="bibr" target="#b14">Bhargavan et al. 2016;</ref><ref type="bibr" target="#b25">Grishchenko et al. 2018;</ref><ref type="bibr" target="#b27">Hildenbrandt et al. 2017;</ref><ref type="bibr" target="#b28">Hirai 2017;</ref><ref type="bibr">Why3 2018]</ref> for performing complete analyses of smart contracts using interactive theorem provers such as Isabelle/HOL <ref type="bibr" target="#b31">[Isabelle 2018</ref>], F* [FStarLang 2018], Why3 [Why3 2018], and K [K Framework 2018]. These approaches have a common theme: a formal model of a smart contract is constructed and mathematical properties are shown via the use of a semi-automated theorem prover. Recently a complete small-step semantics of EVM bytecode has been formalized for the F* proof assistant <ref type="bibr" target="#b25">[Grishchenko et al. 2018]</ref>. Other systems such as KEVM <ref type="bibr" target="#b27">[Hildenbrandt et al. 2017]</ref> use the K framework based on reachability logic. Due to their reliance on semi-automated theorem provers which require substantial manual intervention for proof construction, these formal verification approaches do not scale for analyzing the millions of smart contracts currently deployed on the blockchain.</p><p>In contrast to formal verification work for smart contracts, abstract interpretation approaches <ref type="bibr" target="#b33">[Kalra et al. 2018;</ref><ref type="bibr" target="#b39">Mavridou and Laszka 2018]</ref> do not require human intervention; however, they introduce false-positives. The Zeus framework <ref type="bibr" target="#b33">[Kalra et al. 2018]</ref> translates Solidity source code to LLVM [LLVM 2018] before performing the actual analysis in the SeaHorn verification framework <ref type="bibr" target="#b44">[SeaHorn 2018</ref>]. An alternative approach is that of <ref type="bibr" target="#b39">[Mavridou and Laszka 2018]</ref>, in which Solidity code is abstracted to finite-state automata. Our approach is also partly that of abstract interpretation. However, in contrast to existing abstract interpretation frameworks, our analysis is performed directly on EVM bytecode. For this purpose, we built a decompiler that translates EVM bytecode to an analyzable form.</p><p>Various exploits have been broadly identified in the literature <ref type="bibr" target="#b12">[Atzei et al. 2016;</ref><ref type="bibr" target="#b13">Bartoletti et al. 2017;</ref><ref type="bibr" target="#b21">Delmolino et al. 2015;</ref><ref type="bibr" target="#b45">Sergey and Hobor 2017]</ref>: exploits related to Solidity, the EVM and the blockchain itself. These exploits have been highlighted by the community outside of publications. For instance, the company Consensys <ref type="bibr" target="#b19">[Consensys 2018a</ref>] maintains a website <ref type="bibr" target="#b20">[Consensys 2018b]</ref> outlining the exploits mentioned in the literature, as well as additional exploits such as data overflows and underflows, and suggestions to write better smart contracts (such as isolating external calls into their own transactions, instead of executing them in a single transaction to minimize the risk of failures and side-effects).</p><p>Oyente <ref type="bibr" target="#b38">[Luu et al. 2016b</ref>] identifies four exploits: Transaction-Ordering Dependence, Timestamp Dependence, exceeding the call stack limit of 1024 (Callstack attack) and reentrancy. Transactionordering dependence refers to issues of concurrency where multiple transactions are required to be executed in a particular order, but a miner can manipulate the transaction order. The formal verification tool by <ref type="bibr" target="#b14">[Bhargavan et al. 2016]</ref> detects three classes of vulnerabilities, two of which were covered by Oyente. These include checking the return value of external address calls, and reentrancy. However, an upper bound analysis on gas required for a given transaction was created. These patterns were verified in F* by translating the contracts into F* code, from which patterns were applied to detect vulnerabilities. Similarly, the FSolidM framework <ref type="bibr" target="#b39">[Mavridou and Laszka 2018]</ref> checks for reentrancy and transaction ordering vulnerabilities. It can also detect coding patterns such as time constraint and authorization issues as outlined in <ref type="bibr" target="#b13">[Bartoletti et al. 2017]</ref>. The MAIAN framework <ref type="bibr" target="#b43">[Nikolic et al. 2018</ref>] focuses on finding vulnerabilities in smart contracts such as locking of funds indefinitely, leaking funds to arbitrary users, and smart contracts that can be killed by anyone. The GASPER <ref type="bibr" target="#b18">[Chen et al. 2017]</ref> identifies GAS-costly programming patterns. The ZEUS system <ref type="bibr" target="#b33">[Kalra et al. 2018]</ref> conducts policy checking for a set of policies including reentrancy, unchecked send, failed send, integer overflow, transaction state dependence/order and block state dependence. <ref type="bibr" target="#b26">Grossman et al. [2017]</ref> focus exclusively on detecting non-callback-free contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS</head><p>We presented MadMax, a tool for finding gas-focused vulnerabilities in Ethereum smart contracts. We identify new vulnerabilities for Ethereum smart contracts and demonstrate the first successful design of a static analysis tool at the EVM bytecode level, that painstakingly decompiles and reconstructs the program's higher level semantics. The MadMax approach utilizes best-of-breed techniques and technologies: from abstract-interpretation-based low-level analysis for decompilation to declarative program analysis techniques for higher-level analysis. Our approach is validated using all 6.6 million deployed smart contracts on the blockchain and demonstrates scalability and concrete effectiveness. The threat to some of these smart contracts presented by our tools is overwhelming in financial terms, especially considering the high precision of warnings in a manually-inspected sample.</p><p>As part of future work we will be investigating how further improvements can be made to the decompilation infrastructure to further increase precision and scalability, as well as how different semantic aspects of smart contracts can be modeled to identify more and unexpected vulnerabilities.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure givesan early indication, by plotting smart contract size MadMax: Surviving Out-of-Gas Conditions in Ethereum Smart Contracts 116:3 Fig. 1. Complexity (as the number of basic blocks) vs. balance held for all smart contracts as of April 2018.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Part of control-flow graph produced for actual contract. Dispatcher block shown in the middle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>V</head><label></label><figDesc>is a set of program variables C is a set of constants, C ⊆ Z S is a set of statement identifiers N is the set of natural numbers, Z is the set of integers constant assignment s:[to := CONST(c)] where s ∶ S, to ∶ V , c ∶ C load from storage s:[to := SLOAD(index)] where s ∶ S, index ∶ V , to ∶ V store to storage s:[SSTORE(from, index)] where s ∶ S, index ∶ V , from ∶ V load from (volatile) memory s:[to := MLOAD(index)]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>get remaining gas s:[to := GAS()] where to ∶ V get run-time value (e.g. current block size) s:[to := RUNTIMEKNOWABLE()] where to ∶ V CAST integer to a number of bits s:[to := CASTN(from)] where to ∶ V , from ∶ V , n ∶ N binary operator e.g. ϕ, ADD, AND, etc. s:[to := BinOp(a, b)]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .F</head><label>3</label><figDesc>Our domains and decompiler output primitives (i.e., input relations for main analysis) for EVM 3-address code. is a set of function hashes L is a set of structured loopsInPublicFunction(s : S, f : F) Statement s is part of function f InLoop(s : S, l : L) Statement s is part of loop l InductionVar(v : V, l : L) vis an induction variable of loop l LoopExitCond(condVar: V, l: L) Loop condition of l is captured by condVar HasConstantValue(v : V, c : C) Constant c may propagate to variable v Flows(from : V, to : V ) Data flow analysis: the value of from flows to to VarAlias(v : V, u : V ) Local alias analysis: v,u may be aliased via direct assignment MemContents(s : S, p : V, v : V ) At statement s, contents at memory location p may be v</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 5 .</head><label>5</label><figDesc>Extra domains, input, and output schema for baseline loop and data flow analyses.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 6 .</head><label>6</label><figDesc>Inferring bound loops and resumable loops</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>RelatedKeys(keyVar, keyVar', 32), [sizeVar := SLOAD(keyVar', *)], HasConstantValue(keyVar, arrayId). VarIndexesStorage(stmt, var) ← stmt: [SSTORE(var, *)]. VarIndexesStorage(stmt, var) ← stmt: [* := SLOAD(var, *)].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 8 .</head><label>8</label><figDesc>Datalog rules for recursively identifying dynamic data structures.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 10 .</head><label>10</label><figDesc>Top level query for unbounded mass operations, wallet griefing and overflow vulnerabilities.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>if ( balanceOf [ _to ] + stake &lt; balanceOf [ _to ]) throw ; // Check for overflows</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>(a) Prevalence of loops as a way to access arrays. Contracts that have arrays on storage tend to iterate on them, usually in explicit loops.(b) Prevalence of maps, arrays and nested data structures.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 12 .</head><label>12</label><figDesc>Classification of data structure use.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Is MadMax an effective static analysis? RQ1.A. Is the analysis relevant? What percentage of contracts are vulnerable and how much currency do these hold? RQ1.B. Is the overall analysis precise, i.e., does it have a low false positive rate? RQ2. Is MadMax an efficient analysis? RQ3. Are the individual MadMax components and design decisions justified? RQ3.A. Is the Vandal decompilation approach effective (in terms not captured by the earlier overall effectiveness of MadMax)? RQ3.B. Do the insights from actual contracts vindicate the design choices for the analysis and the patterns it captures?</figDesc><table><row><cell>6.1 RQ1: Effectiveness of MadMax</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>limitations, making the graceful handling of timeout not always possible. We believe that this restriction can be addressed in future work.6.3 RQ3: Analysis of Components and Design DecisionsRQ3 is evaluated quantitatively by interpreting metrics derived from all Ethereum contracts.6.3.1 RQ3.A. Vandal Decompiler Effectiveness. Vandal decompilation captures most program behav-iors. This is certainly suggested by the earlier effectiveness results of the overall MadMax pipeline. However, we have also empirically established that in 75% of programs, all jump targets, under all call-site contexts are resolved. Note that if a single jump in the program is missing one of its two targetsÐe.g., because of behavior too complex for the analysis to resolve, the entire smart contract is considered unresolved. The contract becomes part of the 25%. 6.3.2 RQ3.B. Analysis Design Decisions vs. Contract Metrics.</figDesc><table><row><cell>(a) Prevalence of dynamically bound loops (catego-</cell><cell>(b) Prevalence of loops bound by gas, resumable</cell></row><row><cell>rized further into storage and other) and contracts</cell><cell>loops and loops dynamically bound by storage</cell></row><row><cell>that have array iterators. Most dynamically bound</cell><cell>state.</cell></row><row><cell>loops are actually iterating on arrays.</cell><cell></cell></row><row><cell cols="2">Fig. 11. Classification of loops.</cell></row><row><cell>contract Contract {</cell><cell></cell></row><row><cell>XYZ [] public xyzs ; ...</cell><cell></cell></row><row><cell>struct XYZ {</cell><cell></cell></row><row><cell>uint256 value ;</cell><cell></cell></row><row><cell>address owner ;</cell><cell></cell></row><row><cell>} ...</cell><cell></cell></row><row><cell>uint256 public index ;</cell><cell></cell></row><row><cell>function work () public payable { ...</cell><cell></cell></row><row><cell>while ( index &lt; xyzs . length &amp;&amp; ...) {</cell><cell></cell></row><row><cell>XYZ storage xyz = xyzs [ index ];</cell><cell></cell></row><row><cell>...</cell><cell></cell></row><row><cell>xyz . owner . transfer (...) ;</cell><cell></cell></row></table><note>engineering</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Available on GitHub: https://github.com/nevillegrech/MadMax Proc. ACM Program. Lang., Vol. 2, No. OOPSLA, Article 116. Publication date: November 2018.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proc. ACM Program. Lang., Vol. 2, No. OOPSLA, Article 116. Publication date: November 2018.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">The price of ETH/USD and contract balances are both volatile quantities. To fix a reference point, all numbers given are as of Apr. 9th, 2018 (with ETH/USD at $400.72). 5 To avoid misuse we will not publish exact details on these contracts until we have in place a responsible disclosure protocol.Proc. ACM Program. Lang., Vol. 2, No. OOPSLA, Article 116. Publication date: November 2018.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This research was supported partially by the Australian Government through the Australian Research Council's Discovery Projects funding scheme (project ARC DP180104030). We gratefully acknowledge funding by the European Research Council, grants 307334 and 790340. In addition, the research work disclosed is partially funded by the REACH HIGH Scholars Program ś Post-Doctoral Grants. The grant is part-financed by the European Union, Operational Program II, Cohesion Policy 2014-2020 (Investing in human capital to create more opportunities and promote the wellbeing of society -European Social Fund).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>... if (...) { ... index ++; ... } } ... xyzs . push ( XYZ ({ value : ... , owner : msg . sender }) ); } }</p><p>We can see that the wallet griefing attack for this contract is simple to execute and involves calling the work function with the right amount of ether, i.e., generally a small sum that satisfies some of the requirements for the while loop to start. The attacker has to construct a fall-back function that throws an error. After the loop ends, the attacker's address is stored and the next time work is called, the contract would throw exceptions in the loop once it iterates over the attacker's details. This will happen every single time.</p><p>Contract #4 increases the size of the data structure m_pendingIndex by directly manipulating the length field of the array. Our bytecode-level analysis has no problem capturing this behavior: For lack of space, we summarize the findings of the contracts. Contract #5 uses a multidimensional (stacked) data structure (i.e., map of structs that contain arrays), which increases in size. The analysis identifies this behavior correctly. Contract #7 is falsely flagged for unbounded iteration. Contract #9 is flagged for loop overflows, and despite having the implementation of operations specifically designed to not overflow, the implementer overlooks one of the loops. Similarly, Contract #11 uses a library called Safemath, but it is not used everywhere, resulting in a true warning. Contract #12 tries to use assertions to avoid overflows but some corner cases are missed. Contract #13 uses a while loop on a decreasing quantity, subtracting a dynamically-determined value. This contract is vulnerable to underflows for some inputs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">RQ2: Efficiency of MadMax</head><p>MadMax is able to analyze (modulo timeouts) the 91.8k contracts on the blockchain in around hours on our hardware configuration, running 45 concurrent processes. Each contract takes an average of 5.6s for decompilation and 0.3s for the client analyses, making this a very scalable analysis.</p><p>The Vandal decompiler timed out in 8.2% of the contracts (with a 20s timeout). By inspection, we see that these contracts are of larger-than-average size, but they are not the largest nor exhibit consistent patterns different from the rest of the contracts. In principle, timing out should not prevent getting partial decompilation results for these programs: Vandal could report results produced for up to the previous inlining depth explored. However, the current Vandal implementation has</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Loopboundby</surname></persName>
		</author>
		<title level="m">loop, var) ← InductionVar(i, loop), !InductionVar(var, loop), Flows(var, condVar), Flows(i, condVar)</title>
		<imprint/>
	</monogr>
	<note>LoopExitCond(condVar, loop</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dynamicallybound</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>dynVar := SLOAD(*)], LoopBoundBy(loop, dynVar</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dynamicallybound</surname></persName>
		</author>
		<idno>loop) ← [dynVar := RUNTIMEKNOWABLE(</idno>
		<imprint/>
	</monogr>
	<note>LoopBoundBy(loop, dynVar</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Possiblyresumableloop</surname></persName>
		</author>
		<idno>loop) ← [gas := GAS(</idno>
		<imprint>
			<pubPlace>LoopBoundBy(loop, gas</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Flows(loaded, i)</title>
		<editor>18 N.Grech, M.Kong, A.Jurisevic, L.Brent, B.Scholz, Y.Smaragdakis IncreasedStorageOnPublicFunction</editor>
		<imprint>
			<biblScope unit="volume">116</biblScope>
		</imprint>
	</monogr>
	<note>Flows(i, stored). SSTORE(*, stored)</note>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">InPublicFunction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">(</forename><surname>Arraysizevariable</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>sizeVar&apos; := ADD(sizeVar, *)], f), InPublicFunction([SSTORE(keyVar, sizeVar&apos;)], f)</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">ArrayIterator(loop, arrayId) ← LoopBoundBy(loop, sizeVar), ArraySizeVariable(sizeVar, arrayId, *)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Datalog rules for identifying storage requirements increase in public functions</title>
		<imprint>
			<pubPlace>UnboundedMassOp(loop</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m">IncreasedStorageOnPublicFunction(arrayId), ArrayIdToStorageIndex(arrayId, storeOffsetVar), Flows(storeOffsetVar, index), VarIndexesStorage(storeOrLoadStmt, index), InLoop(storeOrLoadStmt, loop), ArrayIterator(loop, arrayId)</title>
		<meeting><address><addrLine>InductionVar(i, loop), Flows(i, index</addrLine></address></meeting>
		<imprint/>
	</monogr>
	<note>PossiblyResumableLoop(loop</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Flows(storeOffsetVar, index)</title>
	</analytic>
	<monogr>
		<title level="m">WalletGriefing(loop) ← IncreasedStorageOnPublicFunction(arrayId), ArrayIdToStorageIndex(arrayId, storeOffsetVar)</title>
		<imprint/>
	</monogr>
	<note>Flows(loadVar, target), InLoop. resVar := CALL(target, **)], loop), InLoop([THROWI(condVar)], loop), Flows(resVar, condVar), InductionVar(i, loop), Flows(i, index</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">; ←</forename><surname>Loopoverflow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dynamicallyboundloop</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to := CASTN(from, n). n ≤ 16, InductionVar(to, loop), InductionVar(from, loop), Flows(to, condVar), LoopExitCond(condVar, loop</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Towards Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sidney</forename><surname>Amani</surname></persName>
			<affiliation>
				<orgName type="collaboration">CPP</orgName>
			</affiliation>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Myriam</forename><surname>Bégel</surname></persName>
			<affiliation>
				<orgName type="collaboration">CPP</orgName>
			</affiliation>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maksym</forename><surname>Bortin</surname></persName>
			<affiliation>
				<orgName type="collaboration">CPP</orgName>
			</affiliation>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Staples</surname></persName>
			<affiliation>
				<orgName type="collaboration">CPP</orgName>
			</affiliation>
		</author>
		<idno type="DOI">10.1145/3167084</idno>
		<ptr target="https://doi.org/10.1145/3167084" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs</title>
		<meeting>the 7th ACM SIGPLAN International Conference on Certified Programs and Proofs<address><addrLine>New York, NY, USA, 66ś77</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">A survey of attacks on Ethereum smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicola</forename><surname>Atzei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Massimo</forename><surname>Bartoletti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tiziana</forename><surname>Cimoli</surname></persName>
		</author>
		<ptr target="https://eprint.iacr.org/2016/1007" />
		<imprint>
			<date type="published" when="1007" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Dissecting Ponzi schemes on Ethereum: identification, analysis, and impact</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Massimo</forename><surname>Bartoletti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salvatore</forename><surname>Carta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tiziana</forename><surname>Cimoli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><surname>Saia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Smaragdakis Verification of Smart Contracts: Short Paper</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthikeyan</forename><surname>Bhargavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Delignat-Lavaud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cédric</forename><surname>Fournet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anitha</forename><surname>Gollamudi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Georges</forename><surname>Gonthier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadim</forename><surname>Kobeissi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natalia</forename><surname>Kulatova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aseem</forename><surname>Rastogi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Sibut-Pinote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikhil</forename><surname>Swamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Santiago</forename><surname>Zanella-Béguelin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">;</forename><forename type="middle">N</forename><surname>Grech</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jurisevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Brent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Scholz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename></persName>
		</author>
		<idno type="DOI">10.1145/2993600.2993611</idno>
		<ptr target="https://doi.org/10.1145/2993600.2993611" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM Workshop on Programming Languages and Analysis for Security (PLAS &apos;16)</title>
		<meeting>the 2016 ACM Workshop on Programming Languages and Analysis for Security (PLAS &apos;16)<address><addrLine>New York, NY, USA, 91ś96</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016-11" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
	<note>OOPSLA, Article 116</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Strictly Declarative Specification of Sophisticated Points-to Analyses</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Bravenboer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yannis</forename><surname>Smaragdakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 24th Annual ACM SIGPLAN Conf. on Object Oriented Programming, Systems, Languages, and Applications (OOPSLA &apos;09)</title>
		<meeting>of the 24th Annual ACM SIGPLAN Conf. on Object Oriented Programming, Systems, Languages, and Applications (OOPSLA &apos;09)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Vandal: A Scalable Security Analysis Framework for Smart Contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lexi</forename><surname>Brent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anton</forename><surname>Jurisevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francois</forename><surname>Gauthier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent</forename><surname>Gramoli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ralph</forename><surname>Holz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernhard</forename><surname>Scholz</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1809.03981</idno>
		<ptr target="https://arxiv.org/abs/1809.03981" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A Next-Generation Smart Contract and Decentralized Application Platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vitalik Buterin</surname></persName>
		</author>
		<ptr target="https://github.com/ethereum/wiki/wiki/White-Paper." />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Under-optimized smart contracts devour your money</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<idno type="DOI">10.1109/SANER.2017.7884650</idno>
		<ptr target="https://doi.org/10.1109/SANER.2017.7884650" />
	</analytic>
	<monogr>
		<title level="m">2017 IEEE 24th International Conference on Software Analysis, Evolution and Reengineering (SANER). 442ś446</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Consensys</surname></persName>
		</author>
		<ptr target="https://new.consensys.net/Accessed" />
	</analytic>
	<monogr>
		<title level="j">Consensys logo</title>
		<imprint>
			<biblScope unit="page" from="2018" to="2022" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Consensys</surname></persName>
		</author>
		<ptr target="https://consensys.github.io/smart-contract-best-practices/Accessed" />
	</analytic>
	<monogr>
		<title level="j">Ethereum Smart Contract Best Practices</title>
		<imprint>
			<biblScope unit="page" from="2018" to="2022" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Delmolino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><surname>Arnett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><forename type="middle">E</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<title level="m">Step by Step Towards Creating a Safe Smart Contract: Lessons and Insights from a Cryptocurrency Lab. IACR Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note>460. etherscan.io. [n. d.</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Ethereum Contracts with Verified Source Codes</title>
		<ptr target="https://etherscan.io/contractsVerifiedAccessed" />
		<imprint>
			<biblScope unit="page" from="2018" to="2021" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Extended static checking for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymie</forename><surname>Stata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGPLAN 2002 Conf. on Programming Language Design and Implementation</title>
		<meeting>of the ACM SIGPLAN 2002 Conf. on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="234" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">F*: A Higher-Order Effectful Language Designed for Program Verification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Fstarlang</surname></persName>
		</author>
		<ptr target="https://www.fstar-lang.org/Accessed" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2018" to="2022" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">A Semantic Framework for the Security Analysis of Ethereum smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Grishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matteo</forename><surname>Maffei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clara</forename><surname>Schneidewind</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.08660</idno>
		<ptr target="http://arxiv.org/abs/1802.08660" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Online Detection of Effectively Callback Free Objects with Applications to Smart Contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shelly</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ittai</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guy</forename><surname>Golan-Gueta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Michalevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noam</forename><surname>Rinetzky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mooly</forename><surname>Sagiv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoni</forename><surname>Zohar</surname></persName>
		</author>
		<idno type="DOI">10.1145/3158136</idno>
		<ptr target="https://doi.org/10.1145/3158136" />
	</analytic>
	<monogr>
		<title level="m">Proc. ACM Program. Lang. 2, POPL</title>
		<meeting>ACM Program. Lang. 2, POPL</meeting>
		<imprint>
			<date type="published" when="2017-12" />
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page">48</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">KEVM: A Complete Semantics of the Ethereum Virtual Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Everett</forename><surname>Hildenbrandt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoran</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nishant</forename><surname>Rodrigues</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Defining the Ethereum Virtual Machine for Interactive Theorem Provers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoichi</forename><surname>Hirai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography and Data Security</title>
		<editor>Michael Brenner, Kurt Rohloff, Joseph Bonneau, Andrew Miller, Peter Y.A. Ryan, Vanessa Teague, Andrea Bracciali, Massimiliano Sala, Federico Pintore, and Markus Jakobsson</editor>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="520" to="535" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The Truth about Blockchain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Iansiti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karim</forename><forename type="middle">R</forename><surname>Lakhani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Harvard Business Review</title>
		<imprint>
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="118" to="127" />
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
	<note>Issue 1</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Descriptive Complexity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neil</forename><surname>Immerman</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-1-4612-0539-5</idno>
		<ptr target="https://doi.org/10.1007/978-1-4612-0539-5" />
		<imprint>
			<date type="published" when="1999" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isabelle</forename></persName>
		</author>
		<ptr target="https://isabelle.in.tum.de/Accessed" />
	</analytic>
	<monogr>
		<title level="j">Isabelle</title>
		<imprint>
			<biblScope unit="page" from="2018" to="2022" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Soufflé: On Synthesis of Program Analyzers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernhard</forename><surname>Scholz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pavle</forename><surname>Subotić</surname></persName>
		</author>
		<ptr target="http://www.kframework.org/index.php/Main_PageAccessed" />
	</analytic>
	<monogr>
		<title level="m">Computer Aided Verification</title>
		<editor>Swarat Chaudhuri and Azadeh Farzan</editor>
		<meeting><address><addrLine>Cham</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="2018" to="2022" />
		</imprint>
	</monogr>
	<note>422ś430. K Framework. 2018. K Framework.</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">ZEUS: Analyzing Safety of Smart Contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sukrit</forename><surname>Kalra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seep</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seep</forename><surname>Goel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subodh</forename><surname>Sharma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">25th Annual Network and Distributed System Security Symposium (NDSS&apos;18)</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">A Scalable Method to Analyze Gas Costs, Loops and Related Security Vulnerabilities on the Ethereum Virtual Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Kong</surname></persName>
		</author>
		<ptr target="https://github.com/usyd-blockchain/vandal/wiki/pubs/MKong17.pdf" />
		<imprint>
			<date type="published" when="2017-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Uday Khedker, Anders Mùller, and Dimitrios Vardoulakis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Livshits</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manu</forename><surname>Sridharan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yannis</forename><surname>Smaragdakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ondřej</forename><surname>Lhoták</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">Nelson</forename><surname>Amaral</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bor-Yuh Evan</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Guyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Defense of Soundiness: A Manifesto</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Llvm</surname></persName>
		</author>
		<ptr target="https://llvm.org/Accessed" />
	</analytic>
	<monogr>
		<title level="j">The LLVM Compiler Infrastructure Project</title>
		<imprint>
			<biblScope unit="page" from="2018" to="2022" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Making Smart Contracts Smarter</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loi</forename><surname>Luu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duc-Hiep</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hrishi</forename><surname>Olickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aquinas</forename><surname>Hobor</surname></persName>
		</author>
		<idno type="DOI">10.1145/2976749.2978309</idno>
		<ptr target="https://doi.org/10.1145/2976749.2978309" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security (CCS &apos;16)</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security (CCS &apos;16)<address><addrLine>New York, NY, USA, 254ś269</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Making Smart Contracts Smarter</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loi</forename><surname>Luu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duc-Hiep</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hrishi</forename><surname>Olickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aquinas</forename><surname>Hobor</surname></persName>
		</author>
		<idno type="DOI">10.1145/2976749.2978309</idno>
		<ptr target="https://doi.org/10.1145/2976749.2978309" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security (CCS &apos;16)</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security (CCS &apos;16)<address><addrLine>New York, NY, USA, 254ś269</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Designing Secure Ethereum Smart Contracts: A Finite State Machine Based Approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anastasia</forename><surname>Mavridou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aron</forename><surname>Laszka</surname></persName>
		</author>
		<ptr target="http://aronlaszka.com/papers/mavridou2018designing.pdf" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Chord: A Versatile Platform for Program Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Conf. on Programming Language Design and Implementation. Tutorial</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Effective static deadlock detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang-Seo</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Gay</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICSE.2009.5070538</idno>
		<ptr target="https://doi.org/10.1109/ICSE.2009.5070538" />
	</analytic>
	<monogr>
		<title level="m">Proc. of the 31st International Conf. on Software Engineering (ICSE &apos;09)</title>
		<meeting>of the 31st International Conf. on Software Engineering (ICSE &apos;09)<address><addrLine>New York, NY, USA, 386ś396</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Bitcoin: A Peer-to-Peer Electronic Cash System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satoshi</forename><surname>Nakamoto</surname></persName>
		</author>
		<ptr target="https://www.bitcoin.org/bitcoin.pdf." />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">Finding The Greedy, Prodigal, and Suicidal Contracts at Scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivica</forename><surname>Nikolic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aashish</forename><surname>Kolluri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sergey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aquinas</forename><surname>Hobor</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.06038</idno>
		<ptr target="http://arxiv.org/abs/1802.06038" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">SeaHorn | A Verification Framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Seahorn</surname></persName>
		</author>
		<ptr target="http://seahorn.github.io/Accessed" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2018" to="2022" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">A Concurrent Perspective on Smart Contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sergey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aquinas</forename><surname>Hobor</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1702.05511</idno>
		<ptr target="http://arxiv.org/abs/1702.05511" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<monogr>
		<title level="m" type="main">Control-Flow Analysis of Higher-Order Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olin</forename><surname>Shivers</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Dissertation</note>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Higher-order control-flow analysis in retrospect: lessons learned, lessons abandoned</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olin</forename><surname>Shivers</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Best of PLDI 1988</title>
		<editor>Kathryn S. McKinley</editor>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="257" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Continuations, functions and jumps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Thielecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGACT News</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="33" to="42" />
			<date type="published" when="1999-01" />
		</imprint>
	</monogr>
	<note>Issue 2</note>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Soot -a Java bytecode optimization framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raja</forename><surname>Vallée-Rai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phong</forename><surname>Co</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Etienne</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurie</forename><forename type="middle">J</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><surname>Sundaresan</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=781995.782008" />
	</analytic>
	<monogr>
		<title level="m">Proc. of the 1999 Conf. of the Centre for Advanced Studies on Collaborative research (CASCON &apos;99). IBM Press, 125ś135</title>
		<meeting>of the 1999 Conf. of the Centre for Advanced Studies on Collaborative research (CASCON &apos;99). IBM Press, 125ś135</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Optimizing Java Bytecode Using the Soot Framework: Is It Feasible</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raja</forename><surname>Vallée-Rai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Etienne</forename><surname>Gagnon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurie</forename><forename type="middle">J</forename><surname>Hendren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrice</forename><surname>Pominville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><surname>Sundaresan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 9th International Conf. on Compiler Construction (CC &apos;00)</title>
		<meeting>of the 9th International Conf. on Compiler Construction (CC &apos;00)</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="18" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Various</surname></persName>
		</author>
		<idno>2018-04-14. Various</idno>
		<ptr target="https://github.com/ethereum/wiki/wiki/Safety." />
		<imprint>
			<biblScope unit="page" from="2018" to="2022" />
		</imprint>
	</monogr>
	<note>n. d.]a. GovernMental page.. n. d.]b. Safety -Ethereum Wiki. n. d.]). Accessed</note>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m" type="main">Documentation for the LLL compiler ś LLL Compiler Documentation 0</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Various</surname></persName>
		</author>
		<ptr target="http://lll-docs.readthedocs.io/en/latest/index.htmlAccessed" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="2018" to="2022" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">GitHub -ethereum/solidity: The Solidity Contract-Oriented Programming Language</title>
		<ptr target="https://github.com/ethereum/solidityAccessed" />
		<editor>Various. 2018b. GitHub -ethereum/serpent.</editor>
		<imprint>
			<date type="published" when="2018-04-17" />
			<biblScope unit="page" from="2018" to="2022" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">GitHub -ethereum/vyper: New experimental programming language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Various</surname></persName>
		</author>
		<ptr target="https://github.com/ethereum/vyperAccessed" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2018" to="2022" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title level="m" type="main">Vandal ś A Static Analysis Framework for Ethereum Bytecode</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Various</surname></persName>
		</author>
		<ptr target="https://github.com/usyd-blockchain/vandal/Accessed" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="2018" to="2025" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Ethereum Griefing Wallets: Send w/Throw Is Dangerous</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Vessenes</surname></persName>
		</author>
		<ptr target="http://why3.lri.fr/Accessed" />
	</analytic>
	<monogr>
		<title level="j">Why3</title>
		<imprint>
			<biblScope unit="page" from="2018" to="2022" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Ethereum: A Secure Decentralised Generalised Transaction Ledger</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gavin</forename><surname>Wood</surname></persName>
		</author>
		<ptr target="http://gavwood.com/Paper.pdf." />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
