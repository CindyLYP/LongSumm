<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Keeping Master Green at Scale</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Masoud</roleName><forename type="first">Sundaram</forename><surname>Ananthanarayanan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saeida</forename><surname>Masoud</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ardekani</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denis</forename><surname>Haenikel</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Balaji</forename><surname>Varadarajan</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Soriano</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dhaval</forename><surname>Patel</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali-Reza</forename><surname>Adl-Tabatabai</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saeida</forename><surname>Ardekani</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Uber Technologies</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Uber Technologies</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Uber Technologies</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Uber Technologies</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Uber Technologies</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff5">
								<orgName type="institution">Uber Technologies</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff6">
								<orgName type="institution">Uber Technologies</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Keeping Master Green at Scale</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3302424.3303970</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Giant monolithic source-code repositories are one of the fundamental pillars of the back end infrastructure in large and fast-paced software companies. The sheer volume of everyday code changes demands a reliable and efficient change management system with three uncompromisable key requirements-always green master, high throughput, and low commit turnaround time. Green refers to a master branch that always successfully compiles and passes all build steps, the opposite being red. A broken master (red) leads to delayed feature rollouts because a faulty code commit needs to be detected and rolled backed. Additionally, a red master has a cascading effect that hampers developer productivitydevelopers might face local test/build failures, or might end up working on a codebase that will eventually be rolled back. This paper presents the design and implementation of SubmitQueue. It guarantees an always green master branch at scale: all build steps (e.g., compilation, unit tests, UI tests) successfully execute for every commit point. SubmitQueue has been in production for over a year, and can scale to thousands of daily commits to giant monolithic repositories.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Giant monolithic source-code repositories (monorepos hereafter) form one of the fundamental pillars of backend infrastructure in many large, fast-paced software companies.</p><p>Recent studies <ref type="bibr" target="#b14">[27,</ref><ref type="bibr" target="#b25">38]</ref> have shown that the monolithic model of source code management results in simplified dependency management, unified versioning, ease of collaboration, improved code visibility, and development velocity.</p><p>As shown by Perry et al. <ref type="bibr" target="#b24">[37]</ref>, concurrently committing code changes by thousands of engineers to a big repository, with millions of lines of code, may lead to a master breakage (e.g., compilation error, unit test failure, integration test failure, and unsignable artifact). Tracking down and rolling back the faulty change is a tedious and error-prone task, which very often needs human intervention. Since developers may potentially develop over a faulty master (mainline hereafter), their productivity may get hampered substantially. Additionally, a breakage in the master can cause delays in rolling out new features.</p><p>For example, prior to the launch of a new version of our mobile application for riders, hundreds of changes were committed in a matter of minutes after passing tests individually. Collectively though, they resulted in substantial performance regression, which considerably delayed shipping the application. Engineers had to spend several hours bisecting the mainline in order to identify a small list of changes that caused performance regressions. New changes further aggravated the problem such that the mainline required blocking while the investigation continued.</p><p>To prevent the above issues, the monorepo mainline needs to remain green at all times. A mainline is called green if all build steps (e.g., compilation, unit tests, UI tests) can successfully execute for every commit point in the history. Keeping the mainline green allows developers to (i) instantly release new features from any commit point in the mainline, (ii) roll back to any previously committed change, and not necessarily to the last working version, and (iii) always develop against the most recent and healthy version of the monorepo.</p><p>To guarantee an always green mainline, we need to guarantee serializability among developers' requests called changes. Conceptually, a change comprises of a developer's code patch padded with some build steps that need to succeed before the patch can be merged into the mainline. Therefore, committing a change means applying its patch to the mainline HEAD only if all of its build steps succeed. Observe that totally ordering changes is different from totally ordering code patches, which a conventional code management system (e.g., git server) does. While the latter can still lead to a mainline breakage, totally ordering changes guarantees a green mainline since it ensures that all build steps succeed before committing the patch to the mainline.</p><p>In addition to ensuring serializability, the system also needs to provide SLAs on how long a developer would need to wait before her changes are merged into the mainline, called turn-around time. Ideally, this has to be small enough that engineers are willing to trade speed for correctness (i.e., always green mainline).</p><p>Ensuring the above two properties at scale is challenging. The system needs to scale to thousands of commits per day while it may take hours to perform all build steps. For example, performing UI tests of an iOS application requires compiling millions of lines of code on Mac Minis, uploading artifacts to different iPhones, and running UI tests on them. Additionally, the emergence of bots that continuously generate code (e.g., Facebook's Configurator <ref type="bibr" target="#b29">[42]</ref>), further highlights the need for a highly scalable system that can process thousands of changes per day. Thus many existing solutions try to only alleviate, rather than eliminate, the aforementioned issues by building tools <ref type="bibr" target="#b25">[38,</ref><ref type="bibr" target="#b34">47]</ref> for rapid detection and removal of faulty commits.</p><p>This paper introduces a change management system called SubmitQueue that is responsible for continuous integration of changes into the mainline at scale while always keeping the mainline green. Based on all possible outcomes of pending changes, SubmitQueue constructs, and continuously updates a speculation graph that uses a probabilistic model, powered by logistic regression. The speculation graph allows SubmitQueue to select builds that are most likely to succeed, and speculatively execute them in parallel. Our system also uses a scalable conflict analyzer that constructs a conflict graph among pending changes. The conflict graph is then used to (1) trim the speculation space to further improve the likelihood of using remaining speculations, and (2) determine independent changes that can commit in parallel. In summary, this paper makes the following contributions:</p><p>• Based on our experience, we describe the problem space and real challenges of maintaining large monorepos, and why it is crucial to keep the mainline green all the time. • We introduce our change management system called SubmitQueue, and detail its core components. The main novelty of SubmitQueue lies in picking the right set of techniques, and applying them together for building a highly scalable change management system. • We evaluate SubmitQueue, compare it against similar approaches, and report how SubmitQueue performs and scales in production.</p><p>The outline of this paper is as follows: we first review background work in the next section. Section 3 explains the development life cycle, and gives a high level overview of SubmitQueue. We explain our speculation model and conflict analyzer in Section 4 and Section 5, respectively. Section 6 explains how SubmitQueue performs build steps. SubmitQueue implementation and evaluation are discussed in Section 7 and Section 8. We review additional related work in Section 9. We discuss limitations and future work in Section 10, and conclude the paper in Section 11.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Intermittently Green Mainline</head><p>The trunk-based development approach typically commits a code patch into the mainline as soon as it gets approved, and passes pre-submission tests. A change management system then launches an exhaustive set of tests to make sure that no breakage exists, and all artifacts can be generated. In case an error is detected (e.g., due to a conflict or a failing test case), the system needs to roll back the committed change. However, since several patches could have been committed in the meantime, detecting and reverting the faulty patch is tedious and error-prone. In many cases, build sheriffs and engineers need to get involved in order to cherry-pick a set of patches for roll backs. Besides, a red mainline has the following substantial drawbacks:</p><p>• Cost of delayed rollout: for many companies, the cost of delaying rollouts of new features or security patches, even for a day, can result in substantial monetary loss. • Cost of rollbacks: in case an issue arises with a release, engineers can only roll back to the last working version, and not any arbitrary version. • Cost of hampered productivity: a red mainline can significantly affect productivity of engineers. At the very least, engineers might face local test and build failures. Even worse, they can end up working on a codebase that will eventually be rolled back. To alleviate the above issues, software companies try to minimize post-submit failures by building pre-submit infrastructures (e.g., Google's presubmit infrastructure <ref type="bibr" target="#b25">[38]</ref>), which tests patches before committing them to the mainline. Pre-submit testing approach solely focuses on individual changes, and does not consider concurrent changes. Therefore, testing infrastructures still need to (1) perform tests (e.g., integration tests) on all affected dependencies upon every commit, (2) quickly identify patches introducing regressions <ref type="bibr" target="#b34">[47]</ref>, and (3) ultimately roll back the faulty patch in case of a breakage. These steps are commonly referred to as post-submit testing. <ref type="figure" target="#fig_0">Figure 1</ref> shows the probability of real conflicts as the number of concurrent (i.e., pending) and potentially conflicting changes increases for our Android and iOS monorepos over the course of nine months. Roughly speaking, n concurrent changes are considered potentially conflicting if they touch the same logical parts of a repository. On the other hand, n concurrent changes have real conflicts if all the following conditions hold: (1) applying changes 1 to n − 1 do not lead to a mainline breakage, (2) applying the n t h change individually does not break the mainline, and (3) applying all the changes together results in a master breakage. Consequently, the n th change must have a real conflict with one or more of 1 to n − 1 changes. Therefore, pre-submit tests cannot detect these real conflicts, and they can only be captured post-submit. Observe that with even two concurrent and potentially conflicting changes, there is a 5% chance of a real conflict. This number grows to 40% with only 16 concurrent and potentially conflicting changes. This shows that, despite all the efforts to minimize mainline breakages, it is very likely that the mainline experiences daily breakages due to the sheer volume of everyday code changes committed to a big monorepo.</p><p>Using data collected over one year, <ref type="figure" target="#fig_1">Figure 2</ref> plots probability of a mainline breakage as change staleness increases. Change staleness is measured as how old a submitted change is with respect to the mainline HEAD at the time of submission. As expected, the probability of a mainline breakage increases as change staleness increases. However, observe that even changes with one to ten hour staleness have between 10% to 20% chance of making the mainline red. Thus, while frequent synchronization with the mainline may help avoid some conflicts, there is still a high chance of a breakage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Always Green Mainline</head><p>The simplest solution to keep the mainline green is to enqueue every change that gets submitted to the system. A change at the head of the queue gets committed into the mainline if its build steps succeed. For instance, the rustproject [9] uses this technique to ensure that the mainline remains healthy all the time[2]. This approach does not scale as the number of changes grows. For instance, with a thousand changes per day, where each change takes 30 minutes to pass all build steps, the turnaround time of the last enqueued change will be over 20 days.</p><p>An obvious solution for scalability limitations of a single queue is to batch changes together, and commit the whole batch if all build steps for every change in the batch succeed. Otherwise, the batch needs to get divided into smaller batches, and get retried. As the batch size grows, which is the case when there are thousands of commits every day, the probability of failure (e.g., due to a conflict) increases significantly. This leads to batches getting divided and retried frequently. Therefore, SLAs cannot be guaranteed as they would vary widely based on how successful changes are as well as the incoming rate of changes. In addition, this approach also suffers from scalability issues since we still need to test and build one unit of batch at a time.</p><p>Chromium uses a variant of this approach called Commit Queue [4] to ensure an always green mainline. In Commit Queue, all pending changes go through two steps before getting merged into the mainline. The first step is called precommit queue where the system tries to compile a change. Changes passing the first step are picked every few hours by the second step to undergo a large suite of tests which typically take around four hours. If the build breaks at this stage, the entire batch gets rejected. Build sheriffs and their deputies spring into action at this point to attribute failures to particular faulty changes. Non-faulty changes, though, need to undergo another round of batching, and can only get accepted if no faulty change exists in a round. This approach does not scale for fast-paced developments as batches often fail, and developers have to keep resubmitting their changes. Additionally, as mentioned earlier, finding faulty changes manually in large monorepos with thousands of commits is a tedious and error-prone process, which results in long turnaround times. Finally, observe that this approach leads to shippable batches, and not shippable commits. Thus, a second change that fixes an issue of the first change must be included in the same batch in order for the first change to pass all its tests. Otherwise, the first patch will never succeed.</p><p>Optimistic execution of changes is another technique being used by production systems (e.g., <ref type="bibr">Zuul [12]</ref>). Similar to optimistic concurrency control mechanisms in transactional systems, this approach assumes that every pending change in the system can succeed. Therefore, a pending change starts performing its build steps assuming that all the pending changes that were submitted before it will succeed. If a  change fails, then the builds that speculated on the success of the failed change needs to be aborted, and start again with new optimistic speculation. Similar to the previous solutions, this approach does not scale and results in high turnaround time since failure of a change can abort many optimistically executing builds. Moreover, abort rate increases as the probability of conflicting changes increase ( <ref type="figure" target="#fig_0">Figure 1</ref>). In Section 8, we will empirically evaluate the performance of the solutions explained in this section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Dev Life Cycle &amp; System Overview</head><p>In this section, we first briefly introduce the development life cycle, and define the terms that will be used throughout the paper. We then give a high level overview of SubmitQueue, and present its architecture. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Development Life Cycle</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">SubmitQueue Overview</head><p>SubmitQueue guarantees an always green mainline by providing the illusion of a single queue where every change gets enqueued, performs all its build steps, and ultimately  Upon submitting a change to SubmitQueue through the API service (i.e., step 5 in <ref type="figure" target="#fig_3">Figure 3</ref>), SubmitQueue enqueues the change in a distributed queue. The core service then needs to perform all necessary build steps for every enqueued (i.e., pending) change, and either lands the change, or aborts it along with a reason.</p><p>The core service uses a planner engine to orchestrate executions of pending changes. In order to scale to thousands of changes per day while ensuring serializability, the planner engine speculates on outcomes of pending changes using a speculation engine, and executes their corresponding builds in parallel by using a build controller.</p><p>The planner engine periodically contacts the speculation engine, and selects speculation builds that are most likely to succeed. In turn, the speculation engine uses a probabilistic model, powered by logistic regression, to compute likelihoods of speculations succeeding.</p><p>The core service also contains a scalable conflict analyzer that constructs a conflict graph among pending changes. The conflict graph helps the speculation engine to (1) trim the speculation space to further improve the likelihood of using remaining speculations, and (2) determine independent changes that can commit in parallel.</p><p>Based on the selected builds, the planner engine then performs the following actions: (1) schedules executions of selected builds, returned by the speculation engine, through the build controller, (2) aborts builds that do not exist in the latest set of selected builds, but were scheduled previously, and (3) commits a change's patch into the monorepo (i.e., step 6 in <ref type="figure" target="#fig_3">Figure 3</ref>) once it is safe.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Probabilistic Speculation</head><p>Every change submitted to SubmitQueue has two possible outcomes: (i) All build steps for the change succeed, and it gets committed (i.e., its patch gets merged into the mainline). (ii) Some build step fails, and the change is rejected. Therefore, if we can predict the outcome of a change, then we can  <ref type="figure">Figure 5</ref>. Speculation tree of builds and their outcomes for</p><formula xml:id="formula_0">changes C 1 , C 2 , C 3</formula><p>precompute the result of committing concurrent changes under this speculation.</p><p>Let H denote the current HEAD, and C 1 , C 2 represent the changes that need to be committed into the mainline branch. In order to land C 1 , we need to merge C 1 into H , denoted as H ⊕ C 1 , and make sure that all build steps succeed. Let B 1 denote the build steps for H ⊕ C 1 , and</p><formula xml:id="formula_1">B 1.2 represents build steps for H ⊕ C 1 ⊕ C 2 .</formula><p>By assuming that B 1 has a high probability to succeed, we can proactively start executing B 1.2 in parallel with B 1 . If B 1 succeeds, we can use the precomputed result of B 1.2 to determine if C 2 can commit or not. If the prediction does not hold (i.e., B 1 fails), then we need to build C 2 alone by running B 2 . Therefore, the key challenge is to determine which set of builds we need to run in parallel, in order to improve turnaround time and throughput, while ensuring an always green mainline. To this end, the speculation engine builds a binary decision tree, called speculation tree, annotated with prediction probabilities for each edge. The speculation tree allows the planner engine to select the builds that are more likely to succeed, and speculatively execute them in parallel. <ref type="figure">Figure 5</ref> shows the speculation tree for changes C 1 , C 2 , and C 3 where C 1 is the first submitted change to SubmitQueue, and C 3 is the last submitted change. We note that in this section, and for simplicity, we assume that all pending changes conflict with each other. In the next section, we explain how we detect independent changes, and change the speculation tree to a speculation graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Speculate Them All</head><p>The fastest and most expensive approach is to speculate on all possible outcomes for every pending change by assuming that the probability of committing a change is equal to the probability of rejecting a change. For instance, we need to execute all the seven builds shown in <ref type="figure">Figure 5</ref> in order to commit C 1 , C 2 , C 3 . Therefore, we would need to perform n − 1 builds for n pending changes.</p><p>However, we do not need to speculate on all the possible builds. For example, consider the example in <ref type="figure">Figure 5</ref>. If B 1 succeeds, and C 1 can be committed, the result of B 2 (i.e., build steps for H ⊕C 2 ) becomes irrelevant since now we can either commit C 1 or C 1 ⊕ C 2 . Thus B 2 can be stopped. Similarly, if B 1 fails, and C 1 gets rejected, then B 1.2 containing both C 1 and C 2 can never be successful, and should be stopped. Thus, depending on the outcome of B 1 , either B 2 or B 1.2 becomes irrelevant, and its computation is wasted. Likewise, for C 3 , only one of {B 3 , B 1.3 , B 2.3 , B 1.2.3 } is needed to commit C 3 when result of B 1 , B 2 or B 1.2 becomes known.</p><p>To generalize, only n out of 2 n − 1 builds will ever be needed to commit n pending changes. Considering that the system receives hundreds of changes an hour, this approach leads to substantial waste of resources since the results of most speculations will not be used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Probabilistic Modeling</head><p>Instead of executing on all possible builds, SubmitQueue uses a probabilistic model, powered by logistic regression, to select and execute builds that are more likely to succeed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Value of Build</head><p>Considering a set of changes C, the value of building these changes can be measured as</p><formula xml:id="formula_2">V B C = B B C . P needed B C where P needed B C</formula><p>is the probability that the result of build B C will be used to make decision to commit or reject a set of changes C. B B C is the benefit (e.g., monetary benefit) obtained by performing the build on the set of changes C. In this paper, and for the sake of simplicity, we assume the same benefit for all builds. In practice, we can assign different values to different builds. For instance, builds for certain projects or with certain priority (e.g., security patches) can have higher values, which in turn will be favored by Sub-mitQueue. Alternatively, we may assign different quotas to different teams, and let each team manages the benefits of its changes. In our current implementation, we consider the benefit of all builds to be one.</p><p>Consider the speculation tree shown in <ref type="figure">Figure 5</ref>. In this example, there are three pending changes, named C 1 , C 2 and C 3 . The root of the tree, B 1 , is always needed as it is used to determine if C 1 can be committed safely. Thus, P needed B 1 = 1. B 1.2 is only needed when B 1 succeeds. If B 1 fails, B 1.2 is not needed, but B 2 is needed. Thus,</p><formula xml:id="formula_3">P needed B 1.2 = P succ B 1 P needed B 2 = 1 − P succ B 1 (1)</formula><p>The probability that an individual change, C i , succeeds (denoted as P succ C i ) is equal to the probability that its build independently succeeds:</p><formula xml:id="formula_4">P succ B 1 = P succ C 1 .</formula><p>By substituting the probability of successful builds in Equation 1, we get:</p><formula xml:id="formula_5">P needed B 1.2 = P succ C 1 P needed B 2 = 1 − P succ C 1 (2)</formula><p>The above equations can be extended to builds in the next level: B 1.2.3 is only needed under the condition that both B 1 and B 1.2 succeed. This can be written as</p><formula xml:id="formula_6">P needed B 1.2.3 = P succ B 1 . P succ B 1.2 |B 1<label>(3)</label></formula><p>where P succ B 1.2 |B 1 denotes the probability that B 1.2 succeeds given the success of B 1 . Let's consider the inverse. There are two conditions in which B 1.2 will fail given B 1 succeeds.</p><p>1. C 2 fails individually when tested against the current HEAD. For instance, it can fail because of a compilation error, a unit test failure, or a UI test failure. 2. C 2 conflicts with C 1 , denoted as P conf C 1 ,C 2 . A conflict implies that C 2 succeeds individually against the current HEAD but fails when combined with C 1 . Examples of conflicts are merge conflicts, or unit tests failures when both changes are applied. Based on the above conditions, we can derive</p><formula xml:id="formula_7">P succ B 1.2 |B 1 = P succ C 2 − P conf C 1 ,C 2<label>(4)</label></formula><p>By substituting P succ B 1.2 |B 1 in Equation 3 with Equation 4, we get:</p><formula xml:id="formula_8">P needed B 1.2.3 = P succ C 1 . (P succ C 2 − P conf C 1 ,C 2 )<label>(5)</label></formula><p>Consequently, by determining the probability that a change succeeds, and the probability that some changes conflict, we can compute the value of builds. This allows SubmitQueue to schedule builds with the highest value in order to commit pending changes. We observed that statically assigning P succ</p><formula xml:id="formula_9">C i and P conf C 1 ,C 2</formula><p>based on heuristics results in sub-optimal selection of builds, and high turnaround time. This is because the penalty of mis-speculation, with hundreds of commits every hour and long build times, is huge. Additionally, by statically assigning probabilities, the system is not able to react to build successes or failures. SubmitQueue uses the conventional regression model for predicting probabilities of a change success or a change failure. As we will show in Section 8, we observed that by correctly estimating P succ C i and P conf C i ,C j , SubmitQueue's performance becomes close to the performance of a system with an oracle that can accurately foresee the success/failure of a build. Section 7 explains how the regression model is trained, and used by SubmitQueue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Speculating Independent Changes</head><p>In the previous section, we considered cases where changes can potentially conflict with each other. However, in many cases, changes do not conflict with each other. For instance, let's consider C 1 , C 2 where C 1 changes a README file in a  <ref type="figure">Figure 6</ref>. Conflict graph and speculation graph for independent C 1 and C 2 changes both conflicting with C 3 service while C 2 introduces a feature in a mobile app. If we were to use the previous approach and speculate on C 1 's success while testing C 2 , then probability of success of B 1.2 , given that P conf C 1 ,C 2 =0 is:</p><formula xml:id="formula_10">P succ B 1.2 = P succ C 1 . P succ C 2</formula><p>This implies that if two changes are completely independent, then building them individually and committing them in parallel has a higher probability to succeed than building them together. In the next section, we explain how the speculation engine uses the conflict analyzer to determine whether two changes conflict or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conflict Analyzer</head><p>In the previous section, we assumed that all changes conflict with each other. Therefore, the result of our speculation model is always a tree (e.g., <ref type="figure">Figure 5)</ref> where the tree root is the first enqueued pending change.</p><p>By determining independent changes, the speculation engine can (1) change the speculation tree into a speculation graph where independent changes can get committed in parallel, and (2) trim unnecessary builds from the graph.</p><p>First consider the scenario depicted in <ref type="figure">Figure 6</ref>. In this example, C 1 and C 2 do not conflict with each other while both of them conflict with C 3 . As explained in Section 4.2.2, since C 1 and C 2 are independent, B 1 and B 2 can execute in parallel to determine the outcome of the two changes. On the other hand, since C 3 potentially conflicts with both C 1 and C 2 , C 3 needs to speculate on both C 1 and C 2 which results in four builds as shown in <ref type="figure">Figure 6</ref>. Observe that this is equal to the number of speculation builds for C 3 depicted in <ref type="figure">Figure 5</ref>. Therefore, taking the conflict graph into account in this example solely helps C 2 as it only requires one build, and can commit independently. <ref type="figure">Figure 7</ref> depicts a second example where C 1 conflicts with both C 2 and C 3 while C 2 and C 3 are independent. As a result, unlike the example shown in <ref type="figure">Figure 5</ref>, there are only two</p><formula xml:id="formula_11">B 1 B 2 B 1.2 B 3 B 1.3 B 1 succeeds B 1 fails B 1 succeeds B 1 fails Revision Conflict Graph Speculation Graph C 1 C 2 C 3</formula><p>Figure 7. Conflict graph and speculation graph for C 1 conflicting with both C 2 and C 3 builds to consider for C 3 and the choice is solely based on C 1 . Therefore, the total number of possible builds decreases from seven to five.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Build Systems &amp; Targets</head><p>In order to build a conflict graph among pending changes, the conflict analyzer relies on on the build system. A build system (e.g., Bazel [1], Buck [3]) partitions the code into smaller entities called targets. Roughly speaking, a target is a list of source files, their dependencies along with a specification on how these entities can be translated into one or more output files. The directed acyclic graph of targets are then executed in a topological order such that the executed build actions are hermetic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Conflict Detection</head><p>Every change modifies a set of build targets, which is a transitive closure of targets whose source files are modified by the change along with the set of targets that depend on them. Roughly speaking, two changes conflict if they both affect a common set of build targets.</p><p>To this end, we associate every build target with a unique target hash that represents its current state. We then use target hashes to detect which build targets are affected by a change. Algorithm 1 demonstrates how a target hash is computed for a given target. First, we find all the dependencies of a target, recursively compute their target hashes, and update a message digest with these hashes (lines 3 to 5). Second, we find all the source files that the target depends on, and update the message digest with their contents (lines 6 to 8). Third, we convert the message digest to a target hash -a fixed length hash value.</p><p>Formally, let δ H ⊕C i denote a set of targets affected by C i against HEAD. An affected target is defined as a 2-tuple (name, hash) where name represents the target's name, and hash represents the target's hash value after applying C i . Also, let ∩ name denote intersection on target names. Thus, δ H ⊕C i ∩ name δ H ⊕C j ∅ implies that C i and C j conflict since there are some common targets affected by both changes.</p><p>Two changes might still conflict even if they do not affect a common set of targets. For example, consider the case shown in <ref type="figure">Figure 8</ref>. The original build graph for the HEAD contains three targets where target Y depends on target X while target Z is independent. Numbers inside circles denote target hash values. Applying C 1 to the HEAD leads to targets X and Y being affected. Thus, they have different target hashes compared to target X and Y in the original build graph. More precisely, δ H ⊕C 1 = {(X , 4), (Y , 5)}. After applying C 2 to the HEAD, target Z along with its dependencies change: δ H ⊕C 2 = {(Z , 6)}. Observe that while these two changes conflict with each other, simply computing the intersection of affected targets does not yield any conflict.</p><p>Consequently, to accurately determine two independent changes, we also need to make sure that every hash of an affected target after applying both changes to the HEAD is either observed after applying the first change to the HEAD, or observed after applying the second change to the HEAD. If neither holds, it implies that the composition of both changes results in a new affected target, and two changes conflict. Formally, C i conflicts with C j if the following equation holds.</p><p>δ</p><formula xml:id="formula_12">H ⊕C i ∪ δ H ⊕C j δ H ⊕C i ⊕C j<label>(6)</label></formula><p>For instance, in <ref type="figure">Figure 8</ref>, δ H ⊕C 1 ∪δ H ⊕C 2 = {(X , 4), (Y , 5), (Z , 6)} while δ H ⊕C 1 ⊕C 2 = {(X , 4), (Y , 5), (Z , 7)} . Determining whether two changes conflict based on the above approach requires building the target graphs four times using H , H ⊕ C i , H ⊕ C j , and H ⊕ C i ⊕ C j . Therefore, for committing n changes, we need to compute the build graphs approximately n 2 times. Since it may take several minutes to compute the build graph for a change on a big monorepo with millions of lines of code, the above solution cannot scale to thousands of commits per day.</p><p>Observe that Equation 6 is only needed if a build graph changes as a result of applying a change. We observed that only 7.9% (resp. 1.6%) of changes actually cause a change to the build graph for iOS (resp. Backend) monorepos over a span of five months. Therefore, if the build graph remains unchanged, we just need to use the intersection of changed targets to decide whether the two changes conflict. This leads to substantial elimination of needed build graphs. Alternatively, we can also determine if C i and C j conflict by solely computing a union of build graphs for H , H ⊕C i , and H ⊕C j instead of also computing a build graph for H ⊕C i ⊕C j . This approach requires n build graphs for detecting conflicts among n changes.</p><p>Let G H denote a build graph at HEAD where a node is a target, and an edge is a dependency between two nodes. The following algorithm determines if two changes conflict:</p><p>• Step 1: we first build a union graph among G H , G H ⊕C i , and G H ⊕C j as follows: for every node in any of these build graphs, we create a corresponding node in the union graph. Every node in the union graph contains all the target hashes of its corresponding nodes in the individual build graphs. Precisely, a node in the union graph is a 4-tuple of target name and all of its corresponding hashes in G H , G H ⊕C i , and G H ⊕C j . For example, considering <ref type="figure">Figure 8</ref>, we will have the following nodes: (A, 2, 5, 2), (B, 1, 4, 1), and (C, 3, 3, 6). Lastly, we will add an edge between two nodes in the union graph if there exists an edge between its corresponding two nodes in any of the build graphs. • Step 2: a node is tagged as affected by C i (resp. C j ) if its target hash in G H is different from its target hash in G H ⊕C i (resp. G H ⊕C j ). Considering the example shown in <ref type="figure">Figure 8</ref>, targets X and Y are tagged affected by C 1 , and target Z is tagged affected by C 2 in the union graph. • Step 3: we then traverse the union graph in a topological order, and mark a visiting node as affected by C i (resp. C j ) if any of its dependent nodes is affected by C i (resp. C j ). Therefore, in our example, target Z is tagged affected by both C 1 and C 2 . • Step 4: C i and C j conflict if there exists a node that is affected by both C i and C j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Planner Engine &amp; Build Controller</head><p>Based on the number of available resources, the planner engine contacts the speculation engine on every epoch, and receives a prioritized list of builds needed. The planner engine then terminates builds that are currently running, but are not part of the received list. It then schedules new builds according to their priorities in the list using the build controller. In turn, the build controller employs the following techniques to efficiently schedule builds.</p><p>Minimal Set of Build Steps. Instead of performing all build steps, the build controller eliminates build steps that are being executed by prior builds. For instance, when scheduling B 1.2.3 (build steps for H ⊕ C 1 ⊕ C 2 ⊕ C 3 ), the build controller can eliminate the build steps that are already performed by prior builds (i.e., B 1 or B 1.2 ). Therefore, the build controller only needs to perform build steps for targets affected by C 3 (i.e., δ</p><formula xml:id="formula_13">H ⊕C 1 ⊕C 2 ⊕C 3 − δ H ⊕C 1 ⊕C 2 ).</formula><p>Load Balancing. Once the list of affected targets is determined, the build controller uniformly distributes the work among the available worker nodes. Accordingly, it maintains the history of build steps that were performed, along with their average build durations. Based on this data, the build controller assigns build steps to workers such that every worker has an even amount of work.</p><p>Caching Artifacts. In order to further improve the turnaround times, the build controller also leverages caching mechanisms that exist in build systems to reuse generated artifacts, instead of building them from scratch. One challenge in dealing with a speculation graph is the number of builds that need to be considered to find the most valuable builds. More precisely, for n pending changes in the system, the speculation engine needs to consider and sort 2 n builds in the worst case. In order to scale to hundreds of concurrent pending changes, SubmitQueue uses a greedy best-first algorithm that visits nodes having the highest probability first. Because edges in the speculation graph represent the probability a path is needed, the value of a node always goes down as the path length increases. Hence, greedy best first helps SubmitQueue to navigate the speculation graph optimally in memory while scaling to hundreds of pending changes per hour. Observe that the required space complexity of this approach is O(n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Model Training</head><p>We trained our success prediction models predictSuccess(C i ) and predictConflict(C i ,C j ) that estimate P succ C i and P conf C i ,C j in a supervised manner using logistic regression. We selected historical changes that went through SubmitQueue along with their final results for this purpose. We then extracted around 100 handpicked features. Our feature set is almost identical for training both of the above models, and can be categorized as follows:</p><p>Change. Clearly changes play the most important role in predicting the likelihoods of a change succeeding, or conflicting with another change. Thus, we considered several features of a change, including (i) number of affected targets, (ii) number of git commits inside a change, (iii) number of binaries added/removed, (iv) number of files changed along with number of lines/hunks added or removed, and (v) status of initial tests/checks run before submitting a change.</p><p>Revision. As explained in Section 3, a revision is a container for storing changes. We observed that revisions with multiple submitted changes tend to succeed more often than newer revisions. Additionally, we noticed that the nature of a revision has an impact on its success. Therefore, we included features such as (i) number of times changes are submitted to a revision, and (ii) revert and test plan suggested as part of the revision.</p><p>Developer. Developers also play a major role in determining whether a change may succeed or not. For instance, experienced developers do due diligence before landing their changes while inexperienced developers tend to land buggy changes more often. Some developers may also work on more fragile code-paths (e.g., core libraries). Thus their initial land attempts fail more often. Additionally, we observed that developer data helped us tremendously in detecting chances of conflicts among changes. This is due to the fact that developers working on the same set of features (or code path) conflict with each other more often. Consequently, we selected several developer features such as their name, employment length, and levels.</p><p>Speculation. The above identified features, associated with revisions/changes, are static: they do not change over time for a given land request. Therefore, while they can initially help to determine likelihoods of a change succeeding or conflicting with another change, they cannot help as Sub-mitQueue performs different speculations. This leads to high mis-speculation penalties when initial speculations are not accurate. To side step this issue, the number of speculations that succeeded or failed were also included for training.</p><p>The dataset was then divided into two sets: 70% for training the model and 30% for validating the model. The model was trained using scikit <ref type="bibr">[10]</ref> in Python, and has an accuracy of 97%. To avoid overfitting the models and keeping the computation during actual prediction fast, we also ran our model against recursive feature elimination (RFE) <ref type="bibr" target="#b12">[25]</ref>. This helped us reduce the set of features to just the bare minimum.</p><p>In our best performing model, the following features had the highest positive correlation scores: (1) number of succeeded speculations, (2) revision revert and test plans, and (3) number of initial tests that succeeded before submitting a change. In contrast, number of failed speculations, and number of times that changes are submitted to a revision had the most negative weights. We also note that while developer features such as the developer name had high predictive power, the correlation varied based on different developers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Evaluation</head><p>We evaluated SubmitQueue by comparing it against the following approaches:</p><p>• Speculate-all: as discussed in Section 4.1, this approach tries all possible combinations that exist in the speculation graph. Therefore, it assumes that the probability of a build to succeed is 50%. • Single-Queue: where all non-independent changes are enqueued, and processed one by one, à la Bors [2]. Independent changes, on the other hand, are processed in parallel. • Optimistic speculation: similar to Zuul [12], this approach selects a path in the speculation graph by assuming that all concurrent changes will succeed. Therefore, a pending change starts performing its build steps assuming that all the pending changes that were submitted before it will succeed. If a change fails, all the builds that speculated on the success of the failed change need to get aborted, and a new path in the speculation graph is selected. To compare these approaches in a more meaningful way, we also implemented an Oracle, and normalized turnaround time and throughput of the above approaches against it. Our Oracle implementation can perfectly predict the outcome of a change. Since Oracle always makes the right decision in In this section, we first study how the above approaches impact turnaround time (Section 8.2) and throughput (Section 8.3) as number of changes per hour and number of workers increase. We then take a more microscopic look at SubmitQueue, and investigate benefits of conflict analyzer, and how it helps different approaches (Section 8.4). We present the state of our monorepo and its breakages before SubmitQueue was launched in Section 8.5. We conclude our evaluation section by reporting the results of our survey on SubmitQueue in Section 8.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Setup</head><p>We ran all the iOS build steps in our datacenter with Mac Minis, each equipped with 2 cores (Intel Core i7 processors, 3.3 GHz), 16 GB memory and 512 GB of SSD storage. Our API and core servies run on Linux machines equipped with 32 cores (Intel Core i7 processors, 3 Ghz), with 128 GB memory and 2 TB of SSD storage. <ref type="figure">Figure 9</ref> plots the cumulative distribution function (CDF) of build durations for changes submitted to our iOS and Android monorepos in the first 9 months of 2018. Since they have similar CDFs, we only report our evaluation results for the iOS monorepo.</p><p>To evaluate the performance of SubmitQueue in a controlled way, we selected the above changes, and ingested them into our system at different rates (i.e., 100, 200, 300, 400 and 500 changes per hour). Thus, the only difference with the real data is the inter-arrival time between two changes in order to maintain a fixed incoming rate. <ref type="figure" target="#fig_0">Figure 10</ref> shows the CDF of turnaround time for different rates with Oracle running under no contention (with 2000 workers). Observe that the difference between <ref type="figure">Figure 9</ref> and <ref type="figure" target="#fig_0">Figure 10</ref> is in fact the cost of serializing conflicting changes. <ref type="figure" target="#fig_0">Figure 11</ref> plots P50, P95 and P99 turnaround times normalized against Oracle. As illustrated by <ref type="figure" target="#fig_0">Figure 11a</ref>, Sub-mitQueue's logistic regression model for probabilistic speculation along with conflict analyzer leads to maximum of 2.98x slower 50-percentile turnaround time, compared to the optimal Oracle solution. Similarly, SubmitQueue's 95percentile turnaround latency increases by 4x under high contention in which not enough resources are available for handling incoming changes (see <ref type="figure" target="#fig_0">Figure 11b</ref>). Yet, by properly provisioning the number of worker nodes, the turnaround time can substantially be reduced. For instance, if the maximum number of incoming changes per hour is 500, and with 500 workers, 50-percentile, 95-percentile and 99-percentile turnaround time gets reduced to 1.2x of the Oracle's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Turnaround Time</head><p>On the other hand, as shown in <ref type="figure" target="#fig_0">Figure 11</ref>, the P50 turnaround time of the Speculate-all approach suffers up to 15x, while its P99 turnaround time increases up to 24x. Interestingly though, the Optimistic approach results in better turnaround times compared to Speculate-all. This is due to the fact that a significant proportion of changes are expected to succeed even under high load. Thus, speculating deep instead of going wide helps. We observed that Single-Queue yields the worst turnaround times. With 500 changes per hour, P50, P95, P99 turnaround times grow 80x, 129x and 132x respectively compared to the turnaround times of the Oracle. Due to its poor performance, we omitted the results of Single-Queue.</p><p>Observe that as expected, turnaround time decreases as we increase the number of workers in all the cases. However, normalized (P50, P95 and P99) turnaround times for 200 changes per hour is higher than normalized turnaround times for 300/400/500 changes per hour with the same number of machines. Unlike normalized turnaround time, we observed that actual turnaround time consistently increases as the number of changes per hour increases. Yet, depending on production data, in certain hours, Oracle can perform substantially better than other approaches which results in larger gaps. <ref type="figure" target="#fig_0">Figure 12</ref> illustrates average throughput of different approaches normalized against Oracle. SubmitQueue's approach has the least throughput slowdown compared with other approaches. While under high contention, SubmitQueue experiences up to 60% slowdown compared to Oracle, the slowdown reduces to around 20% with 500 workers. We observed similar  Among the studied solutions, Single-Queue has the worst throughput (i.e., 95% slowdown). Surprisingly, we also observed that not only does the Optimistic approach do worse than Speculate-all, it remains unchanged as we increase the number of workers. This is due to the fact that with the Optimistic approach, the system assumes that all changes will  <ref type="figure" target="#fig_0">Figure 13</ref>. P95 turnaround time improvement when using conflict analyzer succeed. Therefore, its throughput is limited by the number of contiguous changes that succeed. However, since this is always less than 100 in our workload, the throughput remains the same as we increase the number of machines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.3">Throughput</head><p>Finally, observe that adding more workers does not have any effect on the Speculate-all approach. Since our speculation graph is deep, adding a few hundred workers does not have any effect on throughput. However, for wide speculation graphs (i.e., more independent changes), we expect much better performance. <ref type="figure" target="#fig_0">Figure 13</ref> shows how the conflict analyzer improves 95percentile turnaround time of different approaches. The turnaround time of Oracle improves by up to 60% with the conflict analyzer. Likewise, both SubmitQueue and Speculate-all also substantially benefit from the conflict analyzer as it helps them to perform more parallel builds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.4">Benefits of Conflict Analyzer</head><p>Surprisingly though, the effect of the conflict analyzer on the Optimistic approach is only 20%. Moreover, observe that for both the Optimistic and Single-Queue approaches, the turnaround time improvement remains constant as we increase the number of workers. This is due to the fact that the build graph on the iOS monorepo is very deep (i.e., only 8/31 9/1 9/2 9/3 9/4 9/5 9/6 0 25 50 75 100 Success Rate / Hour <ref type="figure" target="#fig_0">Figure 14</ref>. State of the mainline for iOS monorepo prior to SubmitQueue launch a handful of leaf-level nodes) resulting in a large number of conflicts among changes. Consequently, the speculation graph has few independent changes that can execute and commit in parallel. Therefore, we expect substantially better improvements when using the conflict analyzer for repositories that have a wider build graph. <ref type="figure" target="#fig_0">Figure 14</ref> shows the state of iOS mainline prior to Sub-mitQueue. Over a span of one week, the mainline was green only 52% of the time affecting both development and rollouts. This clearly exhibits the need for a change management system that guarantees an always green mainline on fastmoving projects involving thousands of developers. Since its launch, our mainlines have remained green at all times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Mainline State Prior to SubmitQueue</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.6">Survey on Benefits of SubmitQueue</head><p>We conducted an internal survey, and asked for feedback from developers, release engineers, and release managers. Specifically, we sought answers to the following two questions:</p><p>(1) what is the perceived impact of an always green master on personal productivity and getting code to production, and (2) how good is the performance of SubmitQueue in production. Out of 40 people who answered the survey, close to 70% had some previous experience committing to monorepos, and 60% of responders had experience with an always green mainline.</p><p>92% of survey takers believed that enforcing an always green mainline positively impacts their personal productivity while 8% saw no impact. Interestingly though, none of the responders claimed that an always green master negatively impacts their productivity. Similarly, 88% of responders believed that an always green master positively impacts deploying code to production, while only one responder thought it imposes a negative impact.</p><p>As for the performance of SubmitQueue on the scale of 1 to 5 (where 5 is the best performance), 94% of responders felt that it was either on par or significantly better than prior experiences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Related Work</head><p>In Section 2, we reviewed various solutions for preventing master breakages, and different techniques for recovering from master breakages. In this section, we focus on other research works that are relevant to SubmitQueue, but are not directly comparable to it.</p><p>Proactive Conflict Detection. An alternative approach to reduce the number of regressions in a monorepo is a proactive detection of potential conflicts among developers working on the same project. These solutions provide awareness to developers, and notify them that parallel changes are taking place. The granularity of these solutions can be filelevel <ref type="bibr" target="#b2">[15]</ref>, method-level using static-analysis <ref type="bibr" target="#b8">[21,</ref><ref type="bibr" target="#b11">24,</ref><ref type="bibr" target="#b28">41]</ref>, and repository-level <ref type="bibr" target="#b3">[16]</ref>. Yet, these solutions do not prevent mainline breakages, and solely notify developers of potential breakages. It is up to developers to further investigate, and prevent a breakage. Unlike SubmitQueue, these solutions do not scale because the number of commits that need to be considered is extremely high in large monorepos. Additionally, these approaches encourage developers to rush committing their changes in order to avoid merging with conflicting changes <ref type="bibr" target="#b7">[20]</ref>.</p><p>Transactional Systems. Transactional systems, including distributed data stores, software transactional memories and databases, use concurrency control schemes to ensure that committing a transaction does not break their consistency model (e.g., Serializability). To guarantee consistency, they employ different concurrency control mechanisms such as pessimistic 2PL mechanism (e.g., Spanner <ref type="bibr" target="#b6">[19]</ref> and Calvin <ref type="bibr" target="#b30">[43]</ref>), an optimistic concurrency control mechanism (e.g., Percolator <ref type="bibr" target="#b23">[36]</ref> and CLOCC <ref type="bibr" target="#b0">[13]</ref>), or conflict reordering mechanism (e.g., Rococo <ref type="bibr" target="#b21">[34]</ref>). These schemes are tailored for relatively short running transactions. Sub-mitQueue on the other hand aims at ensuring serializability for transactions (i.e., changes) that may need hours to finish. Therefore, the penalty of both optimistic and pessimistic execution is extremely high as shown in Section 8. Additionally, conventional transactional systems can easily validate a transaction to make sure that it does not conflict with another transaction before committing it. SubmitQueue, on the other hand, needs to ensure the integrity of the mainline by performing several build steps before being able to commit a change.</p><p>Bug &amp; Regression Detections. Bug &amp; regression detections have been studied extensively by PL, software engineering, and systems communities. These works can be classified in the following categories: (i) techniques <ref type="bibr" target="#b15">[28,</ref><ref type="bibr" target="#b32">45]</ref> to identify bugs prior to submitting changes to repositories, (ii) tools [7, <ref type="bibr" target="#b16">29,</ref><ref type="bibr" target="#b17">30</ref>] to find bugs after a change is submitted, and (iii) solutions <ref type="bibr" target="#b1">[14,</ref><ref type="bibr" target="#b5">18,</ref><ref type="bibr" target="#b18">31,</ref><ref type="bibr" target="#b31">44]</ref> that help online engineers and developers to detect and localize bugs post deployment.</p><p>Kamei et al. <ref type="bibr" target="#b15">[28]</ref> and Yang et al. <ref type="bibr" target="#b32">[45]</ref> introduce different ML techniques to detect if a change is risky and might cause regressions before it is submitted to a repository. To this end, they use information such as reviews, authors, and modified files. Similarly, SubmitQueue uses a ML model to determine the likelihood of a change's build succeeding or not. However, unlike these techniques, SubmitQueue also considers concurrent pending changes. Additionally, instead of rejecting a change, SubmitQueue uses the outcome of its model to determine builds that are more likely to succeed.</p><p>Developers can easily leverage many of the above tools to detect bugs prior to deploying their code by introducing new build steps, and let SubmitQueue runs those build steps before committing the code into a repository. For instance, one can use different tools <ref type="bibr">[8,</ref><ref type="bibr">11,</ref><ref type="bibr" target="#b9">22,</ref><ref type="bibr" target="#b13">26,</ref><ref type="bibr" target="#b22">35]</ref> to eliminate NullPointerException, or detect data races by simply adding extra build steps that need to run upon submitting new changes.</p><p>Test Selection. As a number of changes along with a number of tests grow in many giant repositories, it may not be feasible to perform all tests during builds. To address this issue, several solutions have been proposed based on static analysis <ref type="bibr" target="#b4">[17,</ref><ref type="bibr" target="#b20">33,</ref><ref type="bibr" target="#b27">40,</ref><ref type="bibr" target="#b33">46]</ref>, dynamic analysis <ref type="bibr" target="#b10">[23,</ref><ref type="bibr" target="#b26">39]</ref>, and datadriven <ref type="bibr" target="#b19">[32]</ref> using a ML model. Therefore, upon committing a change, and instead of conducting all test cases, only a subset of test cases are required to run.</p><p>Our build controller currently does not leverage any of these techniques, and performs all required build steps (including test cases) for every build. Applying the above techniques is an interesting future work that can lead to substantial performance improvements.</p><p>Speculative Execution. Speculative execution has been used in almost every field in computer science, including processors, operating systems, programming languages, and distributed systems to name a few. SubmitQueue applies a similar technique in order to keep the mainline green at scale when thousands of developers commit their changes to a mono repository every day.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Discussion</head><p>While SubmitQueue addresses many challenges of a change management system, it still has some limitations. In this section, we discuss its limitations, and future works.</p><p>Change Reordering. The current version of SubmitQueue respects the order in which changes are submitted to the system. Therefore, small changes that are submitted to the system after a large change with long turnaround time (e.g., refactoring of a library API) need to wait for the large change to commit/abort before committing or aborting. As future work, we plan to reorder non-independent changes in order to improve throughput, and provide a better balance between starvation and fairness.</p><p>Other ML Techniques. Our current logistic regression model has an accuracy of 97%, and performs well in production as we showed in Section 8. Yet, exploring other ML techniques such as Gradient Boosting for our prediction model remains an interesting future work.</p><p>Build Preemption. As explained in Section 6, the planner engine aborts ongoing builds if the likelihood of their success drops, and the speculation engine returns a new set of builds that are more likely to succeed. However, if a build is near its completion, it might be beneficial to continue running its build steps, instead of preemptively aborting the build. As future work, we plan to further investigate this issue, and only abort builds that are very unlikely to be needed.</p><p>Batching Independent Changes. SubmitQueue performs all build steps of independent changes separately. A better approach is to batch independent changes expected to succeed together before running their build steps. While this approach can lead to better hardware utilization and lower cost, false prediction can result in higher turnaround time. Finding a balance between cost and turnaround time still needs to be explored.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Conclusion</head><p>This paper introduces a change management system called SubmitQueue that is responsible for continuous integration of changes into the mainline at scale while keeping the mainline green by ensuring serializability among changes. Based on possible outcomes of pending changes, SubmitQueue constructs, and continuously updates a speculation graph that uses a probabilistic model, powered by logistic regression. The speculation graph allows SubmitQueue to select builds that are most likely to succeed, and speculatively execute them in parallel. It also uses a conflict analyzer that constructs a conflict graph among pending changes in order to (1) trim the speculation space to further improve the likelihood of using remaining speculations, and (2) determine independent changes that can commit in parallel. SubmitQueue has been in production for over a year, and can scale to thousands of daily commits to giant monolithic repositories.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Probability of real conflicts as the number of concurrent and potentially conflicting changes increases.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 .</head><label>2</label><figDesc>Probability of a mainline breakage for iOS/Android monorepos as change staleness increases.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 .</head><label>3</label><figDesc>Development Life Cycle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>SubmitQueue Architecture merged with the mainline branch if all build steps succeed.Figure 4shows the high level architecture of SubmitQueue.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 9 .Figure 10 .</head><label>910</label><figDesc>CDF of build duration for iOS/Android monorepos CDF of Oracle turnaround time for 100, 200, 300, 400, and 500 changes per hour the speculation graph, it has the shortest turnaround time, lowest overhead, and the best throughput.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 11 .</head><label>11</label><figDesc>Turnaround Time Normalized Against Oracle behavior with 200 changes per hour. Additionally, for 100 changes per hour, we noticed that SubmitQueue's throughput matches Oracle's. Throughput results for 100 and 200 changes per hour are not included.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 12. Average throughput normalized against Oracle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Algorithm 1 Calculating Target Hash Algorithm 1: function thash(tarдet)</figDesc><table><row><cell>2:</cell><cell>md ← ∅</cell></row><row><cell>3:</cell><cell>deps ← dependentTargetsOf(tarдet)</cell></row><row><cell>4:</cell><cell>for dep ∈ deps do</cell></row><row><cell>5:</cell><cell>md ← md ⊕ thash(dep)</cell></row><row><cell>6:</cell><cell>srcs ← sourceFilesOf(tarдet)</cell></row><row><cell>7:</cell><cell>for src ∈ srcs do</cell></row><row><cell>8:</cell><cell>md = md ⊕ contentsOf(src))</cell></row><row><cell>9:</cell><cell>return hash(md)</cell></row><row><cell>10:</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Original Build Graph for HBuild Graph for H ⊕ C 1Build Graph for H ⊕ C 2 Changes in target graph with different changes. Circle denotes a target hash value. Arrow from target X to target Y implies output of target X is required for building target Y. Shaded target node means the target is affected by the corresponding change.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Build Graph for H ⊕ C 1 ⊕ C 2</cell></row><row><cell>Target Y</cell><cell>3</cell><cell>Target Z</cell><cell>5</cell><cell>Target Y</cell><cell>Target Z</cell><cell>Target Y</cell><cell>Target Z</cell><cell>Target Y</cell><cell>Target Z</cell></row><row><cell>Target X</cell><cell></cell><cell></cell><cell></cell><cell>Target X</cell><cell></cell><cell>Target X</cell><cell></cell><cell>Target X</cell><cell></cell></row><row><cell>Figure 8.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>It uses Buck [3] as the underlying build system for constructing conflict graphs, MySQL as the backend storage system, Apache Helix for sharding queues across machines, and RxJava for communicating events within a process.</figDesc><table><row><cell>7 Implementation</cell></row><row><cell>7.1 API &amp; Core Services</cell></row><row><cell>SubmitQueue's API Service is a stateless backend service</cell></row><row><cell>that provides the following functions: landing a change, and</cell></row><row><cell>getting the state of a change. The service is implemented in</cell></row><row><cell>5k lines of Java using Dropwizard [6] -a popular Java frame-</cell></row><row><cell>work for developing RESTful web services. It also features a</cell></row><row><cell>web UI using cycle.js [5] to help developers track the state</cell></row><row><cell>of their changes.</cell></row><row><cell>The core service is implemented with 40k lines of Java</cell></row><row><cell>code.</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank Raj Barik, Milind Chabbi, Kamal Chaya, Prateek Gupta, Manu Sridharan, and Matthew Williams for their valuable suggestions on early versions of this paper. We also would like to thank our Shepherd, Steven Hand, and our anonymous reviewers for their insightful feedback and suggestions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient Optimistic Concurrency Control Using Loosely Synchronized Clocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Atul</forename><surname>Adya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Gruber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barbara</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Umesh</forename><surname>Maheshwari</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Management of Data (SIGMOD</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Orca: Differential Bug Localization in Large-Scale Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ranjita</forename><surname>Bhagwan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rahul</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chandra</forename><surname>Sekhar Maddila</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adithya Abraham</forename><surname>Philip</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Design and Implementation (OSDI</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="493" to="509" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">FASTDash: A Visual Dashboard for Fostering Awareness in Software Teams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><forename type="middle">T</forename><surname>Biehl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><surname>Czerwinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><surname>Czerwinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><forename type="middle">G</forename><surname>Robertson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Human Factors in Computing Systems (CHI)</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="1313" to="1322" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Proactive Detection of Collaboration Conflicts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuriy</forename><surname>Brun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reid</forename><surname>Holmes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Notkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on the Foundations of Software Engineering (FSE) and European Software Engineering Conference (ESEC</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="168" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Regression Test Selection Across JVM Boundaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmet</forename><surname>Celik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marko</forename><surname>Vasic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aleksandar</forename><surname>Milicevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milos</forename><surname>Gligoric</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Joint Meeting on Foundations of Software Engineering</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="809" to="820" />
		</imprint>
		<respStmt>
			<orgName>ESEC/FSE</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">HOLMES: Effective Statistical Debugging via Efficient Path Profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Trishul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Chilimbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krishna</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><forename type="middle">V</forename><surname>Mehra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kapil</forename><surname>Nori</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vaswani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="34" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Spanner: Google&apos;s Globally-Distributed Database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J J</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrey</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wilson</forename><surname>Hochschild</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eugene</forename><surname>Kanthak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongyi</forename><surname>Kogan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Design and Implementation</title>
		<meeting><address><addrLine>Alexander Lloyd, Sergey Melnik, David Mwaura, David Nagle, Sean Quinlan, Rajesh Rao, Lindsay Rolig, Yasushi Saito, Michal Szymaniak, Christopher Taylor, Ruth Wang, and Dale Woodford</addrLine></address></meeting>
		<imprint>
			<publisher>OSDI</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="251" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Breaking the code&quot;, moving between private and public work in collaborative software development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Cleidson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">F</forename><surname>Souza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Redmiles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dourish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Supporting Group Work (GROUP)</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="105" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prasun</forename><surname>Dewan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajesh</forename><surname>Hegde</surname></persName>
		</author>
		<title level="m">European Conference on Computer Supported Cooperative Work</title>
		<imprint>
			<publisher>ECSCW</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="159" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">RacerX: Effective, Static Detection of Race Conditions and Deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawson</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Ashcraft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Principles (SOSP)</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="237" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Practical Regression Test Selection with Dynamic File Dependencies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milos</forename><surname>Gligoric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lamyaa</forename><surname>Eloussi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Software Testing and Analysis (ISSTA)</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="211" to="222" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Improving Early Detection of Software Merge Conflicts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">António Rito</forename><surname>Mário Luís Guimarães</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Silva</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="342" to="352" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Gene Selection for Cancer Classification using Support Vector Machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isabelle</forename><surname>Guyon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Weston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Barnhill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vladimir</forename><surname>Vapnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="389" to="422" />
			<date type="published" when="2002-01-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Maximal Sound Predictive Race Detection with Control Flow Abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O'neil</forename><surname>Patrick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grigore</forename><surname>Meredith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rosu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Programming Languages Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="337" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Advantages and Disadvantages of a Monolithic Repository: A Case Study at Google</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ciera</forename><surname>Jaspan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Jorde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caitlin</forename><surname>Sadowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">K</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Collin</forename><surname>Winter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emerson</forename><surname>Murphy-Hill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="225" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A large-scale empirical study of just-in-time quality assurance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Kamei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shihab</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Hassan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mockus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sinha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ubayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="757" to="773" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sunghun</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">James</forename><surname>Whitehead</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jr</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename><surname>Zhang</surname></persName>
		</author>
		<title level="m">Classifying Software Changes: Clean or Buggy? IEEE Transactions on Software Engineering</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="181" to="196" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Automatic Identification of Bug-Introducing Changes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Zimmermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Whitehead</surname><genName>Jr</genName></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Automated Software Engineering (ASE</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="81" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Scalable Statistical Bug Isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alice</forename><forename type="middle">X</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Programming Languages Design and Implementation (PLDI</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="15" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mateusz</forename><surname>Machalica</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Samylkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meredith</forename><surname>Porth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satish</forename><surname>Chandra</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1810.05286</idno>
		<ptr target="http://arxiv.org/abs/1810.05286" />
	</analytic>
	<monogr>
		<title level="j">Predictive Test Selection. Computing Research</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Taming Google-scale Continuous Testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Atif</forename><surname>Memon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zebao</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bao</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjeev</forename><surname>Dhanda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Nickell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Siemborski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Micco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP)</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="233" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Extracting More Concurrency from Distributed Transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuai</forename><surname>Mu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Cui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wyatt</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinyang</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="479" to="494" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Effective Static Race Detection for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Whaley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Programming Languages Design and Implementation (PLDI)</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="308" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Large-scale incremental processing using distributed transactions and notifications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Dabek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Design and Implementation (OSDI)</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="251" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Parallel Changes in Large-scale Software Development: An Observational Case Study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dewayne</forename><forename type="middle">E</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">P</forename><surname>Siy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><forename type="middle">G</forename><surname>Votta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="308" to="337" />
			<date type="published" when="2001-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Why Google Stores Billions of Lines of Code in a Single Repository</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rachel</forename><surname>Potvin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josh</forename><surname>Levenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="78" to="87" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Safe, Efficient Regression Test Selection Technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregg</forename><surname>Rothermel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><forename type="middle">Jean</forename><surname>Harrold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Software Engineering and Methodology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="173" to="210" />
			<date type="published" when="1997-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Change Impact Analysis for Object-oriented Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barbara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Ryder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tip</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Program Analysis for Software Tools and Engineering (PASTE)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="46" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Towards Supporting Awareness of Indirect Conflicts Across Software Configuration Management Workspaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anita</forename><surname>Sarma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerald</forename><surname>Bortis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andre</forename><surname>Van Der Hoek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Automated Software Engineering (ASE</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="94" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Holistic Configuration Management at Facebook</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chunqiang</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thawan</forename><surname>Kooburat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pradeep</forename><surname>Venkatachalam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akshay</forename><surname>Chander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhe</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Dowell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Karl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Principles (SOSP</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="328" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Calvin : Fast Distributed Transactions for Partitioned Database Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thaddeus</forename><surname>Diamond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on the Management of Data (SIGMOD</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Triage: Diagnosing Production Run Failures at the User&apos;s Site</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengdu</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Spiros</forename><surname>Xanthos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Operating Systems Principles (SOSP)</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="131" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Deep Learning for Just-in-Time Defect Prediction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Lo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Quality, Reliability and Security</title>
		<imprint>
			<publisher>QRS</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="17" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Hybrid Regression Test Selection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lingming</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="199" to="209" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Who Broke the Build?: Automatically Identifying Changes That Induce Test Failures in Continuous Integration at Google Scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Celal</forename><surname>Ziftci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Reardon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="113" to="122" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
