<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Design and Implementation of the Wave Transactional Filesystem</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2015-09-25">25 Sep 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Emin</roleName><forename type="first">Robert</forename><surname>Escriva</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">GÃ¼n</forename><surname>Sirer</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
								<orgName type="institution">Cornell University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">The Design and Implementation of the Wave Transactional Filesystem</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-09-25">25 Sep 2015</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1509.07821v1[cs.DC]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>This paper introduces the Wave Transactional Filesystem (WTF), a novel, transactional, POSIX-compatible filesystem based on a new file slicing API that enables efficient file transformations. WTF provides transactional access to a distributed filesystem, eliminating the possibility of inconsistencies across multiple files. Further, the file slicing API enables applications to construct files from the contents of other files without having to rewrite or relocate data. Combined, these enable a new class of high-performance applications. Experiments show that WTF can qualitatively outperform the industry-standard HDFS distributed filesystem, up to a factor of four in a sorting benchmark, by reducing I/O costs. Microbenchmarks indicate that the new features of WTF impose only a modest overhead on top of the POSIX-compatible API.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Distributed filesystems are a cornerstone of modern data processing applications. Key-value stores such as Google's BigTable <ref type="bibr" target="#b9">[10]</ref> and Spanner <ref type="bibr" target="#b11">[12]</ref>, and Apache's HBase <ref type="bibr" target="#b6">[7]</ref> use distributed filesystems for their underlying storage. MapReduce <ref type="bibr" target="#b12">[13]</ref> uses a distributed filesystem to store the inputs, outputs, and intermediary processing steps for offline processing applications. Infrastructure such as Amazon's EBS <ref type="bibr" target="#b0">[1]</ref> and Microsoft's Blizzard <ref type="bibr" target="#b27">[28]</ref> use distributed filesystems to provide storage for virtual machines and cloud-oblivious applications.</p><p>Yet, current distributed filesystems exhibit a tension between retaining the familiar semantics of local filesystems and achieving high performance in the distributed setting. Often, designs will compromise consistency for performance, require special hardware, or artificially restrict the filesystem interface. For example, in GFS, operations can be inconsistent or, "consistent, but undefined," even in the absence of failures <ref type="bibr" target="#b16">[17]</ref>. GFSbacked applications must account for these anomalies, leading to additional work for application programmers. HDFS <ref type="bibr" target="#b3">[4]</ref> side-steps this complexity by prohibiting con-current or non-sequential modifications to files. This obviates the need to worry about nuances in filesystem behavior, but fails to support use cases requiring concurrency or random-access writes. Flat Datacenter Storage <ref type="bibr" target="#b28">[29]</ref> is only eventually consistent and requires a network with full-bisection bandwidth, which can be cost prohibitive and is not possible in all environments.</p><p>This paper introduces the Wave Transactional Filesystem (WTF), a new distributed filesystem that contains a transactional model with a new API that provides file slicing operations. A WTF transaction may span multiple files and is fully general; applications can include calls such as read, write, and seek within their transaction. This file slicing API enables applications to efficiently read, write, and rearrange files without rewriting the underlying data. For example, applications may concatenate multiple files without reading them; garbage collect and compress a database without writing the data; and even sort the contents of record-oriented files without rewriting the files' contents.</p><p>The key design decision that enables WTF's advanced feature set is an architecture that represents filesystem data and metadata to ensure that filesystem-level transactions may be performed using, solely, transactional operations on metadata. Custom storage servers hold filesystem data and handle the bulk of I/O requests. These servers retain no information about the structure of the filesystem; instead, they treat all data as opaque, immutable, variable-length arrays of bytes, called slices. WTF stores references to these slices in HyperDex <ref type="bibr" target="#b14">[15]</ref> alongside metadata that describes how to combine the slices to reconstruct files' contents. This structure enables most bookkeeping to be done at the metadata level, within the scope of HyperDex transactions.</p><p>Supporting this architecture is a custom concurrency control layer that decouples WTF transactions from the underlying HyperDex transactions. This layer ensures that applications only abort when a concurrentlyexecuting transaction changes the filesystem in a way that generates an unresolvable, application-visible conflict. This seemingly minor functionality enables WTF to support many concurrent operations with minimal abortinduced overheads.</p><p>Overall, this paper makes three contributions. First, it describes a new API for filesystems called file slicing that enables efficient file transformations. Second, it describes an implementation of a transactional filesystem with minimal overhead. Finally, it evaluates WTF and the file slicing interfaces, and compares them to the nontransactional HDFS filesystem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design</head><p>WTF's distributed architecture consists of four components: the metadata storage, the storage servers, the replicated coordinator, and the client library. <ref type="figure" target="#fig_0">Figure 1</ref> summarizes this architecture. The metadata storage builds on top of HyperDex and its expansive API. The storage servers hold filesystem data, and are provisioned for high I/O workloads. A replicated coordinator service serves as a rendezvous point for all components of the system, and maintains the list of storage servers. The client library contains the majority of the functionality of the system, and is where WTF combines the metadata and data into a coherent filesystem.</p><p>In this section, we first explore the file slicing abstraction to understand how the different components contribute to the overall design. We will then look at the design of the storage servers to understand how the system stores the majority of the filesystem information. Finally, we discuss performance optimizations and additional functionality that make WTF practical, but are not essential to the core design, such as replication, fault tolerance, and garbage collection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The File Slicing Abstraction</head><p>WTF represents a file as a sequence of byte arrays that, when overlaid, comprise the file's contents. The central abstraction is a slice, an immutable, byte-addressable, arbitrarily sized sequence of bytes. A file in WTF, then is a sequence of slices and their associated offsets. This representation has some inherent advantages over block-based designs. Specifically, the abstraction provides a separation between metadata and data that enables filesystem-level transactions to be implemented using, solely, transactions over the metadata. Data is stored in the slices, while the metadata is a sequence of slices. WTF can transactionally change these sequences to change the files they represent, without having to rewrite the data.</p><p>Concretely, file metadata consists of a list of slice pointers that indicate the exact location on the storage servers of each slice. A slice pointer is a tuple consisting of the unique identifier for the storage server holding </p><formula xml:id="formula_0">A=(s 0 , f 1 , ...) B=(s 1 , f 2 , ...) C=(s 2 , f 3 , ...) D=(s 0 , f 4 , ...) E=(s 1 , f 5 , ...) File 0 1 2 3 4 MB A C E B</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Slices</head><p>Metadata: A@[0,2], B@ <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4]</ref>, C@ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, D@ <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, E@ <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref> Compacted: A@[0,1], C@ <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>, E@ <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, B@ <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4]</ref> Figure 2: A 4 MB file with five writes that write or overwrite different portions of the file. This figure shows the slices that were written, the resulting file's content, and the metadata in HyperDex.</p><p>the slice, the local filename containing the slice on that storage server, the offset of the slice within the file, and the length of the slice. Associated with each slice pointer is an integer offset that indicates where the slice should be overlaid when reconstructing the file. Crucially, this representation is self-contained: everything necessary to retrieve the slice from the storage server is present in the slice pointer, with no need for extra bookkeeping elsewhere in the system. As we will discuss later, the metadata also contains standard info found in an inode, such as modification time, and file length. This slice pointer representation enables WTF to easily generate new slice pointers that refer to subsequences of existing slices. Because the representation transparently reflects the global location of a slice on disk, WTF may use simple arithmetic to create new slice pointers. This representation also enables applications to modify a file with only localized modifications to the metadata. <ref type="figure">Figure 2</ref> shows an example file consisting of five different slices. Each slice is overlaid on top of previous slices. Where slices overlap, the latest additions to the metadata take precedence. For example, slice C takes precedence over slices A and B; similarly, slice E completely obscures slice D and part of C. The file, then, consists of the corresponding slices of A, C, E, and B. The figure also shows the compacted metadata for the same file. This compacted form contains the minimal slice pointers necessary to reconstruct the file without reading data that is overwritten by another slice. Crucially, file modifications can be performed without having to rearrange the entire metadata.</p><p>The procedures for reading and writing follow directly from the abstraction. A writer creates one or more slices on the storage servers, and overlays them at the appropriate positions within the file by appending their slice pointers to the metadata list. Readers retrieve the metadata list, compact it, and determine which slices must be retrieved from the storage servers to fulfill the read.</p><p>The correctness of this design relies upon the metadata storage providing primitives to atomically read and append to the list. HyperDex natively supports both of these operations. Because each writer writes slices before appending to the metadata list, it is guaranteed that any transaction that can see these immutable slices is serialized after the writing transaction commits. It can then retrieve the slices directly. The transactional guarantees of WTF extend directly from this design as well: a WTF transaction will execute a single HyperDex transaction consisting of multiple append and retrieve operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Storage Server Interface</head><p>The file slicing abstraction greatly simplifies the design of the storage servers. Storage servers deal exclusively with slices, and are oblivious to files, offsets, or concurrent writes. Instead, the complete storage server API consists of just two calls that create and retrieve slices.</p><p>A storage server processes a request to create a slice by writing the data to disk and returning a slice pointer to the caller. The structure of this request intentionally grants the storage server complete flexibility to store the slice anywhere it chooses because the slice pointer containing the slice's location is returned to the client only after the slice is written to disk. A storage server can retrieve slices by following the information in the slice pointer to open the named file, read the requisite number of bytes, and return them to the caller.</p><p>The transparency of the slice pointer minimizes the bookkeeping of the storage server implementation, while also permitting a wide variety of implementation strategies. Currently, each WTF storage server maintains a di- As an optimization, the storage servers maintain multiple backing files to which slices are written. This serves three purposes: First, it allows servers to avoid contention when writing to the same file; second, it allows the storage server to explicitly spread data across multiple filesystems if configured to do so; and, finally, it allows the storage server to use hints provided by writers to improve locality within backing files, as described in Section 2.7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">File Partitioning</head><p>Practically, it is desirable to keep the list of slice pointers small so that they can be stored, retrieved, and transmitted with low overhead; however, it would be impractical to achieve this by limiting the number of writes to a file. In order to achieve support for both arbitrarily large files and efficient operations on the list of slice pointers, WTF partitions a file into fixed size regions, each with its own list. Each region is stored as its own object in HyperDex under a deterministically derived key.</p><p>Operations on these partitioned metadata lists behave the same as operations on a single list. When operations span multiple regions, they are separated into their respective operations on each region, and performed within the context of a single multi-key HyperDex transaction. This guarantees that multiple regions may be modified simultaneously in one atomic action. <ref type="figure">Figure 3</ref> shows a series of writes that span different metadata regions, and their resulting metadata lists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Filesystem Hierarchy</head><p>The WTF filesystem hierarchy is modeled after the traditional Unix filesystem, with directories and files. Each Write slice to fd and increment the offset punch(fd, amount)</p><p>Zero-out amount bytes at the fd offset, freeing the underlying storage append(fd, slice)</p><p>Append slice to the end of file fd concat(sources, dest) Concatenate the listed files to create dest copy(source, dest)</p><p>Copy source to dest using only the metadata directory contains entries that are named links to other directories or files, and WTF enables files to be hard linked to multiple places in the filesystem hierarchy. WTF implements a few changes to the traditional filesystem behavior to reduce false dependencies when opening a file. If one were to implement path traversal as it is traditionally implemented, an open operation would require a traversal from the root, putting every directory along the path within the scope of a transaction, and require several round trips to both HyperDex and the storage servers to open a file.</p><p>WTF avoids traversing the filesystem on open by maintaining a pathname to inode mapping. This enables a client to map a pathname to the corresponding inode with just one HyperDex lookup, no matter how deeply nested the pathname. To enable applications to enumerate the contents of a single directory, WTF maintains traditional-style directories, implemented as special files, alongside the one-lookup mapping. The two data structures are atomically updated using HyperDex transactions. This optimization simplifies the process of opening files, without a loss of functionality.</p><p>Inodes are also stored in HyperDex, and contain standard information, such as link count and modification time. The inode also maintains ownership, group, and permissions information, though WTF differs from POSIX in that permissions are not checked on the full pathname from the root. Each inode also stores a reference to the highest-offset region written within the file, enabling applications to find the end of the file.</p><p>Because HyperDex permits transactions to span multiple keys across independent schemas, updates to the filesystem hierarchy remain consistent. For example, to create a hardlink for a file, WTF atomically creates a new pathname to inode mapping for the file, increments the inode's link count, and inserts the pathname and inode pair into the destination directory, which requires a write to the file holding the directory entries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">File Slicing Interface</head><p>The file slicing interface enables new applications to make more efficient use of the filesystem. Instead of operating on bytes and offsets as traditional POSIX systems do, this new API allows applications to manipulate subsequences of files at the structural level, without copying or reading the data itself. <ref type="table" target="#tab_1">Table 1</ref> summarizes the new APIs that WTF provides to applications. The yank, paste, and append calls are analogous to read, write, and append, but operate on slices instead of sequences of bytes. The yank call retrieves slice pointers for a range of the file. An application may provide these slice pointers to a subsequent call to paste or append to write the data back to the filesystem, reusing the existing slices. These write operations bypass the storage servers and only incur costs at the metadata storage component.</p><p>The append call is internally optimized to improve throughput. A naive append call could be implemented as a transaction that seeks to the end of the file, and performs a paste. While not incorrect, it would allow only one append call to proceed at a time, because only one append can commit for each value for the end of file; the others will spuriously fail and retry. Instead, WTF stores, alongside the metadata list, an offset representing the end of the region. An append call will conditionally append to the list, making sure that the offset, plus the length of the slice to be appended, does not exceed the bounds of the metadata region. The entry in the metadata list for an append is marked as relative to the end of the file, rather than a specific offset. When an append is too large to fit within a single region, WTF will fall back on reading the offset of the end of file, and performing a write at that offset. This enables multiple append operations to proceed in parallel in the common case.</p><p>Other calls that are new to the file slicing API have no counter-part in traditional APIs. The concat call concatenates multiple files to create one unified output file. The copy call creates a copy of a file by copying the file's compacted metadata. Both of these calls may be implemented by yank and paste and are provided for convenience.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Transaction Retry</head><p>To ensure that transactions abort only when they encounter application-visible conflicts, WTF implements its own concurrency control on top of HyperDex that re-tries aborted transactions. To see why this may be necessary, consider an application that seeks to the end of a file, and writes the string "Hello World" within a single transaction. Barring any permanent failures, such a transaction should always succeed because this transaction can serialize between any other pair of transactions as it does not impose any requirements on the filesystem state. If, however, a write were to change the length of the file between the end-of-file lookup and the transaction commit, the transaction encompassing the original seek-and-write operation will abort within HyperDex because the observed value of the file length has changed. Passing this failure up to the application, which never saw the offset of the end of file, would complicate the guarantees made by the WTF interface. Instead, WTF internally retries the transaction by repeating the seek and then pasting the previously written slice that contains "Hello World" at the new end of file. This ensures that transactions only abort in response to an unresolvable, application-visible conflict.</p><p>The mechanism that retries transactions is a thin layer that sits at the boundary of the WTF client library and the user's application. Each call the application makes is logged, along with the arguments provided to the call, and its return value. If the transaction aborts within Hy-perDex, the state of the system remains unchanged by the WTF transaction, so it is safe to retry it in its entirety. WTF will then replay all of the user's operations in sequence using the same arguments originally supplied. If at any point a re-executed call completes with an outcome different from the original execution, the transaction will signal an abort to the application. Similarly, if the WTF transaction re-executes all operations successfully, and the HyperDex transaction commits, the commit status is passed back to the application. WTF will retry transactions as necessary to ensure that they only abort when operations on the filesystem generate unresolvable, application-visible conflicts.</p><p>To reduce the overhead for maintaining the log of individual operations, the client library uses slice pointers to refer to bytes of data that pass through the interface. For example, a write of 100 MB will not be copied and maintained in the log; instead, the log maintains the slice pointers that refer to the 100 MB on the storage servers. Similarly, reads are maintained using the retrieved slice pointers, and not the data itself or checksums thereof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Locality-Aware Slice Placement</head><p>As an optimization, WTF employs a locality-aware slice placement algorithm to improve the locality on disk of writes to nearby ranges of a file. Writes to the same metadata region reside on the same servers, and are located near each other on those servers' disks. Files that are written to WTF sequentially will, with high probability, be written sequentially to disk.</p><p>WTF chooses which server to write a slice to using consistent hashing <ref type="bibr" target="#b20">[21]</ref> across the servers to ensure that writes to the same region reside on the same storage server. The writer provides the slice and the identity of the metadata region the write affects to the storage server, which then uses consistent hashing to map each slice to a file on its local disk. The hashing function used at the storage server level is different from the hashing function used across storage servers, so writes which map to the same server will be unlikely to map to the same backing file, unless they are for the same metadata region.</p><p>Overall, this ensures that a writer that writes sequentially to a file will write contiguous sequences of bytes on the storage servers with high probability. During compaction, these independent slices may be combined into a single slice spanning the maximum contiguous range on the disk. For example, a sequential writer writing fixed size 1 MB blocks to a metadata region will sequentially send each of these blocks to the same storage server, which will append them to the same file on disk. These adjacent slices may be compactly represented by a single slice pointer that references the contiguous region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.8">Garbage Collection</head><p>WTF prevents unbounded growth of data and metadata through a three-tiered garbage collection mechanism.</p><p>First, the most prevalent form of garbage in WTF comes from the metadata lists growing when many independent append operations force it to grow. This predominant case is easily handled by compacting the metadata list, and storing the compacted list in place of the original list. This eliminates the garbage generated from overlaid slices, such as those in <ref type="figure">Figure 2</ref>, and will typically combine multiple slices into one because of locality-aware slice placement. WTF retrieves the current metadata list, compacts it, and stores the result using a single HyperDex transaction. The resulting file contents are equivalent to those from before the compaction, and the compaction incurs no I/O on the storage servers.</p><p>Metadata compaction is not always sufficient. In particular, random writes reduce the effect that localityaware slice placement has on compaction, leading to fragmented metadata lists. In this case, WTF writes a new slice with contents identical to the compacted form of the current metadata list, and swaps a pointer to this slice with the originally observed list.</p><p>Finally, as an application overwrites or deletes files, slices become unused by the filesystem and turn into garbage on the storage servers. Because the storage servers outsource all bookkeeping to the metadata storage, storage servers do not directly know which portions of its local data are garbage. WTF periodically scans the entire filesystem metadata and constructs a list of in-use slice pointers for each storage server. For simplicity of implementation, these lists are stored in a reserved directory within the WTF filesystem so that they need not be maintained in memory or communicated out of band to the storage servers. Storage servers link the WTF client library and read their respective files to discover unused regions in their local storage space. To prevent the race condition where a slice is created and garbage collected before being referenced by the metadata, the periodic garbage collection is run infrequently-on the order of hours or days-and servers do not collect an unused region until it appears in two consecutive scans.</p><p>Storage servers implement garbage collection by creating sparse files on the local disk. To compress a file containing garbage slices, a storage server rewrites the file, seeking past each unused slice. On inode-based Linux filesystems this creates a sparse file that occupies disk space proportional to the in-use slices it contains. Counter-intuitively, files with the most garbage are the most efficient to collect, because the garbage collection thread seeks past large regions of garbage and only writes the small number of remaining slices. Backing files with little garbage incur much more I/O, because there are more in-use slices to rewrite. WTF chooses the file with the most garbage to compact first, because it will simultaneously compact the most garbage and incur the least I/O.</p><p>The storage servers derive benefit from the kernel buffer cache by relying upon writing to a local filesystem rather than direct disk access. When writing a file, Linux will not start to flush the data to disk immediately, but will instead flush data in batched writes. The filesystem coalesces many writes and reduces the number of seeks used by garbage collection <ref type="bibr" target="#b24">[25]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.9">Fault Tolerance</head><p>WTF uses replication to add a configurable degree of fault tolerance to the system. To accomplish this, it augments the metadata list such that each entry references multiple slice pointers that are replicas of the data. On the write path, writers create multiple replica slices and append their pointers atomically. Readers may read from any of the replicas, as they hold identical data.</p><p>The metadata storage derives its fault tolerance from the strong guarantees offered by HyperDex. Specifically, HyperDex guarantees that it can tolerate f failures for a user-configurable value of f . HyperDex uses valuedependent chaining to coordinate between the replicas and manage recovery from failures <ref type="bibr" target="#b13">[14]</ref>.</p><p>The data storage derives its durability guarantees from the backing file system. While replication protects WTF against uncorrelated failures, WTF is not designed to withstand correlated failures such as cluster-wide power outages.</p><p>The file slicing abstraction is easier to make fault tolerant and consistent than existing block-based solutions. In a block-based design a write is often constrained to reuse existing replicas for the block it is writing. Further, block designs often employ some mechanism on top of the block servers to consistently update all replicas, or at least ensure they eventually converge to the same value. This added mechanism introduces overheads that are absent in WTF's slice-based design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Implementation</head><p>Everything described in this paper is available in our WTF implementation. Currently, the implementation is approximately 30 k lines of code written exclusively for WTF. It relies upon HyperDex with transactions, which is approximately 85 k lines of code, with an additional 37 k lines of code of supporting libraries written for both projects. The replicated coordinator for both HyperDex and WTF is an additional 19 k lines of code. Altogether, WTF constitutes 171 k lines of code that were written for WTF and HyperDex.</p><p>WTF's fault tolerant coordinator is implemented as a replicated object on top of the Replicant replicated state machine service. The coordinator consists of just 960 lines of code that are compiled into a dynamically linked library that is passed to Replicant. Replicant deploys multiple copies of the library, and uses Paxos <ref type="bibr" target="#b21">[22]</ref> to sequence the function calls into the library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation</head><p>To evaluate WTF, we will look at a series of both end-toend and micro benchmarks that demonstrate our working implementation under a variety of conditions. The first part of this section looks at the how the file slicing interface improves an end-to-end sorting benchmark written in the style of a map reduce application. We will then look at a series of microbenchmarks that characterize the performance of WTF's conventional filesystem interface.</p><p>All benchmarks execute on a cluster of fifteen servers dedicated to the experiment. Each server is equipped with two Intel Xeon 2.5 GHz L5420 processors, 16 GB of DDR2 memory with error correction, and between 500 GB and 1 TB SATA spinning-disks from the same era as the CPUs. The servers are connected with gigabit ethernet via a single top of rack switch. Installed on each server is 64-bit Ubuntu 14.04, HDFS from Apache Hadoop 2.7, and WTF with HyperDex 1.8.1.</p><p>For all benchmarks, HDFS and WTF are configured to provide an apples-to-apples comparison. Both systems are deployed with three nodes reserved for the metadata-the HDFS name node, or the HyperDex clusterand the remaining twelve servers are allocated as storage nodes for the data. Except for changes necessary to achieve feature parity, both systems were deployed</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Stage</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conventional File Slicing</head><p>Bucketing R = 100 GB R = 100 GB W = 100 GB W = 0 GB Sorting R = 100 GB R = 100 GB W = 100 GB W = 0 GB Merging R = 100 GB R = 0 GB W = 100 GB W = 0 GB Total R = 300 GB R = 200 GB W = 300 GB W = 0 GB <ref type="table">Table 2</ref>: File slicing enables the WTF-based sort application to sort a 100 GB file with one third the I/O required by conventional distributed filesystems.</p><p>in their default configuration. To bring the semantics of HDFS up to par with WTF, each write is followed by an hflush call to ensure that the write is flushed from the client-side buffer and is visible to readers. The hflush primitive solely makes sure that writes are visible to all readers, and does not trigger an fsync on the written data; the resulting guarantee is the same guarantee provided by a WTF write, and no stronger.</p><p>Additionally, in order to work around a long-standing bug with append operations <ref type="bibr" target="#b4">[5]</ref>, the HDFS block size was reduced from 128 MB to 64 MB. Without this change to the configuration, the HDFS node can report an outof-disk-space condition when only 3% of the disk space is in use. Instead of gracefully handling the condition and falling back to other replicas as is done in WTF, the failure cascades and causes multiple writes to fail, making it impossible to complete the benchmark. Decreasing the block size does increase the amount of metadata held on the name node, but because all data is held within main memory, and our workloads do not generate more metadata than the HDFS name node's memory capacity, the increase is irrelevant to our benchmarks. The change is unlikely to impact the performance of data nodes because the increase from 64 MB to 128 MB was not motivated by performance <ref type="bibr" target="#b5">[6]</ref>. WTF is also configured to use 64 MB regions.</p><p>Except where otherwise noted, both systems replicate all files such that two copies of the file exist. This allows the filesystem to tolerate the failure of any one storage server throughout the experiment without loss of data or availability. It is possible to tolerate more failures so long as all the replicas for a file do not fail simultaneously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Map Reduce: Sorting</head><p>MapReduce <ref type="bibr" target="#b12">[13]</ref> is a processing technique that forms the basis of many modern analytic applications. Because filesystems like HDFS and GFS are the basis of modern mapreduce frameworks, mapreduce applications provide a useful means of evaluating new distributed filesystems.</p><p>Sorting a file with mapreduce is a three-step process  <ref type="figure">Figure 4</ref>: Total execution time for sorting a 100 GB file using a map-reduce application. HDFS takes more than one hour and seven minutes to sort the file, while WTF completes the same task in under fifteen minutes. that breaks the sort into two map jobs followed by a reduce job. The first map task partitions the input file into buckets, each of which holds a disjoint, contiguous section of the keyspace. These buckets are sorted in parallel by the second map task. Finally, the reduce phase concatenates the sorted buckets to produce the sorted output.</p><p>Each intermediate step of this application is written to disk, implying that the entire data set will be read or written several times over. Here, WTF's file slicing interface can reduce this excessive I/O and improve the efficiency of the application. Instead of reading and writing whole records during the first two stages, WTF can use yank and paste to rearrange the records. File slicing also eliminates almost all I/O of the reduce phase using a concat operation. <ref type="table">Table 2</ref> summarizes the number of bytes of data we can expect to be read or written while sorting a 100 GB file. We can see that a conventional API will perform 600 GB of total I/O while a file-slicing filesystem can do the same task with only 200 GB of I/O. Empirically, the file slicing operations do improve the running time of a WTF-based sort. <ref type="figure">Figure 4</ref> shows the total running time of both systems to sort a 100 GB file consisting of 500 kB records indexed by 10 B keys that were generated uniformly at random. In this benchmark, the intermediate files are written without replication because they may easily be recomputed from the input. We can see that WTF sorts the entire file in one fourth the time taken to perform the same task on HDFS.</p><p>The speedup is attributable to the efficient primitives that WTF exposes to applications. From <ref type="figure" target="#fig_3">Figure 5</ref>, we can see that the WTF-based sorting application spends less time in the partitioning and merging steps than the conventional HDFS-based application. For HDFS, the majority of execution time is spent in merging and bucketing of the input data. Just 8.5% of execution time is spent in the CPU-intensive sorting task. The rest is spent shuffling data on either side of this task. In contrast, WTF spends 74.1% of its time in the CPU intensive task, whereas the first map phase accounts for 25.3% of the execution time. The concatenation operation at the end occupies less than 1% of the overall running time. From this, we can conclude that the efficiency of WTF's I/O operations contribute to reducing the overall runtime of the sort operation.</p><p>Overall this sorting benchmark shows that file slicing operations can improve map reduce performance. In general, applications that process data by partitioning, shuffling, or combining records will benefit from a reduction in I/O and decrease in running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Micro Benchmarks</head><p>In this section we examine a series of microbenchmarks that quantify the performance of the POSIX API for both HDFS and WTF. Here HDFS serves as a gold-standard. With ten years of active development, and deployment across hundreds of nodes, including large deployments at both Facebook and LinkedIn <ref type="bibr" target="#b10">[11]</ref>, HDFS provides a reasonable estimate of distributed filesystem performance. Although we cannot expect WTF to grossly outperform HDFS-both systems are limited by the speed of the hard disks in our cluster-we can use the degree to which WTF and HDFS differ in performance to estimate the overheads present in WTF's design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Setup</head><p>The workload for these benchmarks is generated by twelve distinct clients, one per storage server in the cluster, that all work in parallel. This configuration was chosen after experimentation because additional clients do not significantly increase the throughput, but do increase the latency significantly.</p><p>All benchmarks operate on 100 GB of data, or over 16 GB per machine once replication is accounted for. This workload is small enough that we can run the experiments several times each, but is big enough to be blocked by disk on modern Linux kernels. The Linux virtual memory subsystem will not allow a writing process to populate the entirety of RAM with dirty buffers; instead, only a fraction of memory may be used for dirty pages before the kernel forces writing processes to yield time for writing back I/O <ref type="bibr" target="#b23">[24]</ref>. Consequently, although our test data is not multiple times the memory available in our cluster, it is more than five times the space available for storing dirty buffers. To mitigate any confounding effects of the kernel's buffer cache on read-oriented experiments, the buffer cache was completely cleared before each such experiment. Single server performance This first benchmark executes on a single server to establish the baseline performance of a one node cluster. Here, we'll not only compare the two systems to each other, but to the same workload implemented on a local ext4 filesystem. Our expectation here is that the POSIX API will provide an upper bound on performance. To reduce the extent to which round trip time dominates the calls in each distributed system the client and storage server are collocated. <ref type="figure" target="#fig_4">Figure 6</ref> shows the throughput of write and read operations in the one-node cluster. From this we can see that the maximum measured throughput of a single node in our cluster is 87 MB/s, which means the total throughput of the cluster, assuming optimal usage, will peak at 1044 MB/s. Sequential Writes WTF guarantees that all readers in the filesystem see a write upon its completion; however, this guarantee is only useful to applications when throughput remains high for smaller writes. This benchmark examines the impact that write size has on the aggregate throughput achievable for filesystem-based applications by varying the block size and measuring the aggregate throughput across all twelve writers. <ref type="figure">Figure 7</ref> shows the results for block sizes between 256 kB and 64 MB. For writes greater than 1 MB, WTF achieves 97% the throughput of HDFS. For 256 kB writes, WTF achieves 84% of the throughput of HDFS.  <ref type="figure">Figure 7</ref>: Aggregate throughput of a sequential write workload where writers make fixed size calls to "write". HDFS and WTF both provide applications with approximately 400 MB/s of goodput. Error bars report the standard error of the mean across seven trials. The latency for the two systems is similar, and directly correlated with the block size. <ref type="figure" target="#fig_6">Figure 8</ref> shows the latency of writes across a variety of block sizes. We can see that WTF's median latency is very close to HDFS's median latency for larger writes, and that the 95th percentile latency for WTF is often lower than on HDFS operations. Latency of WTF write operations diverges from HDFS for 256 kB writes. Each HyperDex transaction in WTF imposes an approximately 3 ms lower bound on the total write completion time. For the 256 kB test case, this is 50% of the median latency. Even so, WTF's median and 95th percentile latency measurements for this block size are only 2 ms higher than the corresponding measurements for HDFS. Random Writes WTF enables applications to write at random offsets in a file without restriction. Because HDFS cannot support applications that write at random offsets within a file, we cannot use it as a baseline for these experiments; instead, the sequential write performance of WTF will serve as a baseline to compare against the random write performance. This this bench-  <ref type="figure">Figure 9</ref>: Aggregate throughput of concurrent writers making fixed size calls to "write" at random offsets within a file. Error bars report the standard error of the mean across seven trials. mark issues writes at uniformly random offsets instead of sequentially increasing offsets. <ref type="figure">Figure 9</ref> shows the aggregate throughput achieved by clients randomly writing to WTF. We can see that the random write throughput is always within a factor of two of the sequential throughput, and that this difference diminishes as the size of the writes approaches 8 MB.</p><p>Because the common case for a sequential write and a random write in WTF differ only at the stage where metadata is written to HyperDex, we expect that such a difference in throughput is directly attributable to the metadata stage. HyperDex provides lower latency variance to applications with a small working set than applications with a large working set with no locality of access. We can see the difference this makes in the tail latency of WTF writes in <ref type="figure" target="#fig_0">Figure 10</ref>, which shows the median and 99th percentile latencies for both the sequential and random workloads. The median latency for both workloads is the same for all block sizes. For block sizes MB and larger, the 99th percentile latencies are approximately the same as well. Writes less than 4 MB in size exhibit a significant difference in 99th percentile latency between the sequential and random workloads. These smaller writes spend more time updating HyperDex than writing to storage servers. We expect that further optimization of HyperDex would close the gap between sequential and random write performance.</p><p>Although the difference between sequential and random performance is significant, it is important to remember that HDFS applications cannot perform random writes at all. With HDFS, applications that need to change a file must rewrite the file in its entirety, which is a costly and slow process. Sequential Reads Batch processing applications often read large input files sequentially during both the map and reduce phases. Although a properly-written application will double-buffer to avoid small reads, the filesystem should not rely on such behavior to enable high throughput. This experiment shows the extent to which WTF can be used by batch applications by reading through a file sequentially using a fixed-size buffer. <ref type="figure" target="#fig_0">Figure 11</ref> shows the aggregate throughput of concurrent readers reading through a file written by the previously described sequential write benchmark. We can see that for all read sizes, WTF's throughput is at least 80% the throughput of HDFS. The throughput reported here is not comparable to the throughput reported in the write benchmark because only one of the two active replicas is consulted on each read, thus doubling the number of disks available for independent operations. For smaller reads, WTF's throughput matches that of HDFS. The difference at larger sizes is largely an artifact of the implementations. HDFS uses readahead on both the clients and storage servers in order to improve throughput for streaming workloads. By default and in the experiment, the HDFS readahead is configured to be 4 MB, which is the point at which the systems start to exhibit different characteristics. Our preliminary WTF implementation does not have any readahead mechanism, and exhibits  <ref type="figure" target="#fig_0">Figure 12</ref>: Aggregate throughput of random reads of varying size in a two-replicated deployment. We can see that WTFbacked applications achieve higher throughput than HDFS applications for a variety of small read sizes. Error bars indicate the standard error of the mean across seven trials.</p><p>higher latency. A more mature implementation could take advantage of readahead to reduce this difference. Random Reads Applications built on a distributed filesystem, such as key-value stores or record-oriented applications often require random access to the files. This experiment shows the performance of applications reading constant-sized pieces from a file at offsets that are chosen uniformly at random. <ref type="figure" target="#fig_0">Figure 12</ref> shows the aggregate throughput of twelve concurrent random readers. We can see that for reads of less than 16 MB, WTF achieves significantly higher throughput-at its peak, WTF's throughput is 2.4Ã the throughput of HDFS. Here, the readahead and clientside caching that helps HDFS with larger sequential read workloads adds overhead to HDFS that WTF does not incur. The 95th percentile latency of a WTF read is less than the median latency of a HDFS read for block sizes less than 4 MB. Scaling the Workload This experiment varies the number of clients writing to the filesystem to explore how concurrency affects both latency and throughput. This benchmark employs the workload from the sequential-write benchmark with a 4 MB write size and a variable number of workload-generating clients. <ref type="figure" target="#fig_0">Figure 13</ref> shows the resulting throughput for between one and twelve clients. We can see that the single client performance is approximately 60 MB/s, while twelve clients sustain an aggregate throughput of approximately 380 MB/s. WTF's throughput is approximately the same as the throughput of HDFS for each data point. Running the same workload with forty-eight clients did not increase the throughput beyond the throughput achieved with twelve clients. We can see the corresponding latency change in <ref type="figure" target="#fig_0">Figure 14</ref>. mentioned in Section 2.8, it is more efficient to collect files with more garbage than files with less garbage, and WTF preferentially garbage collects these larger files. <ref type="figure" target="#fig_0">Figure 15</ref> shows the rate at which the cluster can collect garbage, for varying amounts of randomly located garbage, when all resources are dedicated to the task. We can see that when the cluster consists of 90% garbage, the cluster can reclaim this garbage at a rate of over 9 GB of garbage per second, because it need only write 1 GB/s to reclaim the garbage. It is, however, impractical to dedicate all resources to garbage collection; instead, WTF dedicates only a fraction of I/O to the task. Storage servers initiate garbage collection when disk usage exceeds a configurable threshold, and ceases when the amount of garbage drops below 20%. <ref type="figure" target="#fig_0">Figure 15</ref> shows that the maximum overhead required to maintain the system below this threshold is 4%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>Filesystems have been an active research topic since the earliest days of systems research. Existing approaches related to WTF can be broadly classified into two categories based upon their design. Distributed filesystems Distributed filesystems expose one or more units of storage over a network to clients. AFS <ref type="bibr" target="#b19">[20]</ref> exports a uniform namespace to workstations, and stores all data on centralized servers. Other systems <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b32">33]</ref>, most notably xFS <ref type="bibr" target="#b2">[3]</ref> and Swift <ref type="bibr" target="#b8">[9]</ref> stripe data across multiple servers for higher performance than can be achieved with a single disk. Petal <ref type="bibr" target="#b22">[23]</ref> provides a virtual disk abstraction that clients may use as a traditional block device. Frangipani <ref type="bibr" target="#b37">[38]</ref> builds a filesystem abstraction on top of Petal. NASD <ref type="bibr" target="#b17">[18]</ref> and Panasas <ref type="bibr" target="#b42">[43]</ref> employ customized storage devices that attach to the network to store the bulk of the metadata. In contrast to these systems, WTF provides transactional guarantees that can span hundreds or thousands of disks because its metadata storage scales independently of the number of storage servers.</p><p>Recent work has focused on building large-scale datacenter-centric filesystems. GFS <ref type="bibr" target="#b16">[17]</ref> and HDFS <ref type="bibr" target="#b3">[4]</ref> employ a centralized master server that maintains the metadata, mediates client access, and coordinates the storage servers. Salus <ref type="bibr" target="#b41">[42]</ref> improves HDFS to support storage and computation failures without loss of data, but retains the central metadata server. This centralized master approach, however, suffers from scalability bottlenecks inherent to the limits of a single server <ref type="bibr" target="#b26">[27]</ref>. WTF overcomes the metadata scalability bottleneck using the scalable HyperDex key-value store <ref type="bibr" target="#b14">[15]</ref>.</p><p>CalvinFS <ref type="bibr" target="#b39">[40]</ref> focuses on fast metadata management using distributed transactions in the Calvin <ref type="bibr" target="#b40">[41]</ref> transaction processing system. Transactions in CalvinFS are limited, and cannot do read-modify-write operations on the filesystem without additional mechanism. Further, CalvinFS addresses file fragmentation using a heavy-weight garbage collection mechanism that entirely rewrites fragmented files; in the worst case, a sequential writer could incur I/O that scales quadratically in the size of the file. In contrast, WTF provides fully general transactions and carefully arranges data to improve sequential write performance.</p><p>Another approach to scalability is demonstrated by Flat Datacenter Storage <ref type="bibr" target="#b28">[29]</ref>, which enables applications to access any disk in a cluster via a CLOS network with full bisection bandwidth. To eliminate the scalability bottlenecks inherent to a single master design, FDS stores metadata on its tract servers and uses a centralized master solely to maintain the list of servers in the system. Blizzard <ref type="bibr" target="#b27">[28]</ref> builds block storage, visible to applications as a standard block device, on top of FDS, using nested striping and eventual durability to service the smaller writes typical of POSIX applications. These systems are complementary to WTF, and could implement the storage servers abstraction.</p><p>Power-proportional filesystems are elastic, in that they dynamically change the power consumption of a cluster to scale resource usage with demand and decrease power consumption in the cluster <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b38">39,</ref><ref type="bibr" target="#b44">45]</ref>. WTF's design does not consider power-proportionality, but could possibly incorporate allocation techniques from other systems to make it more elastic.</p><p>Other "blob" storage systems behave similarly to file systems, but with a restricted interface that permits creating, retrieving, and deleting blobs, without efficient support for arbitrarily changing or resizing blobs. Facebook's f4 <ref type="bibr" target="#b36">[37]</ref> ensures infrequently accessed files are readily available for access. Pelican <ref type="bibr" target="#b7">[8]</ref> enables powerefficient cold storage by over provisioning storage space, and selectively turning on subsets of the disks to service requests. The design goals of these systems are different from the interactive, online applications that WTF enables; WTF could be used in front of these systems to generate, maintain, and modify data before placing it in warm or cold storage. Transactional filesystems Transactional filesystems enable applications to offload much of the hard work relating to update consistency and durability to the filesystem. The QuickSilver operating system shows that transactions across the filesystem simplify application development <ref type="bibr" target="#b31">[32]</ref>. Further work showed that transactions could be easily added to LFS, exploiting properties of the already-log-structured data to simplify the design <ref type="bibr" target="#b34">[35]</ref>. Valor <ref type="bibr" target="#b35">[36]</ref> builds transaction support into the Linux kernel by interposing a lock manager between the kernel's VFS calls and existing VFS implementations. In contrast to the transactions provided by WTF, and the underlying HyperDex transactions, these systems adopt traditional pessimistic locking techniques that hinder concurrency.</p><p>Optimistic concurrency control schemes often enable more concurrency for lightly-contended workloads. PerDiS FS adopts an optimistic concurrency control scheme that relies upon external components to reconcile concurrent changes to a file <ref type="bibr" target="#b15">[16]</ref>. This allows users and applications to concurrently work on the same file; according to the authors, the most commonly adopted technique is selecting one version and throwing the rest away. Liskov and Rodrigues show that much of the overhead of a serializable filesystem can be avoided by running readonly transactions in the recent past, and employing an optimistic protocol for read-write transactions <ref type="bibr" target="#b25">[26]</ref>. WTF builds on top of HyperDex's optimistic concurrency and supports operations such as append that avoid creating conflicts between concurrent transactions.</p><p>WTF is not the first system to choose to employ a transactional database as part of its design. Inversion <ref type="bibr" target="#b29">[30]</ref> builds on PostgreSQL to maintain a complete filesystem. KBDBFS <ref type="bibr" target="#b35">[36]</ref> and Amino <ref type="bibr" target="#b43">[44]</ref> both build on top of BerkeleyDB; the former is an in-kernel implementation of BerkeleyDB, while the latter eschews the complexity and takes a performance hit with a userspace implementation. WTF differs from these designs in that it stores solely the metadata in the transactional data store; data is stored elsewhere and not managed by the transactional component. Further, its design ensures that transactions on metadata are sufficient to provide filesystemlevel transactions.</p><p>Stasis <ref type="bibr" target="#b33">[34]</ref> makes the argument that no one design support all use cases, and that transactional components should be building blocks for applications. WTF's approach is similar: HyperDex's transactions are used as a base primitive for managing WTF's state, and WTF supports a transactional API. Applications built on WTF can use this API to achieve their own transactional behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>This paper described the Wave Transactional Filesystem (WTF), a new distributed filesystem that enables applications to operate on multiple files transactionally without requiring complex application logic. A new filesystem abstraction called file slicing further boosts performance by modifying files more efficiently than traditional primitives permit. The main insight behind file slicing is that it enables applications to read and write using references to data that is stored elsewhere in the filesystem.</p><p>A broad evaluation shows that WTF achieves throughput and latency similar to industry-standard HDFS, while simultaneously offering stronger guarantees and a richer API. A sample application built with file slicing outperforms traditional approaches by a factor of four by reducing the overall I/O cost.</p><p>The ability to make transactional changes to multiple files at scale is novel in the distributed systems space, and the file slicing APIs enable a new class of applications that are difficult to implement efficiently with current APIs. Together, these features are a potent combination that enables a new class of high performance applications.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>WTF employs a distributed architecture consisting of metadata storage, data storage, a replicated coordinator, and the client library.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>,sz):slice,[data] Copy sz bytes from fd; return slice pointers and optionally the data paste(fd, slice)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Execution time of the sort broken down by stage of the map-reduce application. HDFS spends 91.5% of its time partitioning and reassembling the data, compared to WTF, which spends 25.9% of its time on the same task.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Performance of a one-server deployment of HDFS and WTF compared with the ext4 filesystem. Error bars indicate the standard error of the mean across seven trials.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 :</head><label>8</label><figDesc>Median latency of write operations across a variety of write sizes. Error bars report the 5th and 95th percentile latencies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>Median and 99th percentile latencies for sequential and random WTF writes. The median latency does not change between sequential and random write patterns. Aggregate throughput of concurrent readers reading fixed size blocks. HDFS and WTF both achieve approximately 900 MB/s of read throughput. Error bars report the standard error of the mean across seven trials.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :Figure 14 :</head><label>1314</label><figDesc>Garbage Collection This benchmark measures the overhead of garbage collection on a storage server. Aggregate throughput as the number of writers increases. Error bars show the standard error of the mean across seven trials. Median write latency as the number of writers increases. Error bars show the 5th and 95th percentile latencies.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 15 :</head><label>15</label><figDesc>The maximum rate of garbage collection is positively correlated with the amount of garbage to be collected. Consequently, WTF dedicates a small fraction of its overall I/O to garbage collection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>WTF's new file slicing API. Note that these supplement the POSIX API, which includes calls for moving a file descriptor's offset via seek. concat and copy are provided for convenience and may be implemented with yank and paste.</figDesc><table /><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Amazon Web Services. Elastic Block Store</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Robust And Flexible Power-Proportional Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hrishikesh</forename><surname>Amur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Cipar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Varun</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karsten</forename><surname>Schwan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Cloud Computing</title>
		<meeting>the Symposium on Cloud Computing<address><addrLine>Indianapolis, Indiana</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-06" />
			<biblScope unit="page" from="217" to="228" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Serverless Network File Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><forename type="middle">E</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeanna</forename><forename type="middle">M</forename><surname>Neefe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Drew</forename><forename type="middle">S</forename><surname>Roselli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randolph</forename><forename type="middle">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating Systems Principles</title>
		<meeting>the Symposium on Operating Systems Principles<address><addrLine>Copper Mountain, Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1995-12" />
			<biblScope unit="page" from="109" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Hadoop</surname></persName>
		</author>
		<ptr target="http://hadoop.apache.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">DFS Used Space Is Not Correct Computed On Frequent Append Operations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Hadoop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jira</forename></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HDFS-6489" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Hadoop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jira</forename></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HDFS-4053" />
		<title level="m">crease The Default Block Size</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Apache</forename><surname>Hbase</surname></persName>
		</author>
		<ptr target="http://hbase.apache.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Pelican: A Building Block For Exascale Cold Data Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shobana</forename><surname>Balakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename><surname>Donnelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>England</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Glass</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Legtchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Ogus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Peterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antony</forename><forename type="middle">I T</forename><surname>Rowstron</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating System Design and Implementation</title>
		<meeting>the Symposium on Operating System Design and Implementation<address><addrLine>Broomfield, Colorado</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
			<biblScope unit="page" from="351" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Swift: Using Distributed Disk Striping To Provide High I/O Data Rates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luis-Felipe</forename><surname>Cabrera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darrell</forename><forename type="middle">D E</forename><surname>Long</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computing Systems</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="405" to="436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Bigtable: A Distributed Storage System For Structured Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fay</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wilson</forename><forename type="middle">C</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deborah</forename><forename type="middle">A</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tushar</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Gruber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating System Design and Implementation</title>
		<meeting>the Symposium on Operating System Design and Implementation<address><addrLine>Seattle, Washington</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11" />
			<biblScope unit="page" from="205" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Copysets: Reducing The Frequency Of Data Loss In Cloud Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asaf</forename><surname>Cidon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><forename type="middle">M</forename><surname>Rumble</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Stutsman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sachin</forename><surname>Katti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">K</forename><surname>Ousterhout</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mendel</forename><surname>Rosenblum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Annual Technical Conference</title>
		<meeting>the USENIX Annual Technical Conference<address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Spanner: Google&apos;s Globally-Distributed Database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrey</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Hochschild</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wilson</forename><forename type="middle">C</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Kanthak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eugene</forename><surname>Kogan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongyi</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Mwaura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Nagle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajesh</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lindsay</forename><surname>Rolig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yasushi</forename><surname>Saito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michal</forename><surname>Szymaniak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruth</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dale</forename><surname>Woodford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating System Design and Implementation</title>
		<meeting>the Symposium on Operating System Design and Implementation<address><addrLine>California</addrLine></address></meeting>
		<imprint>
			<publisher>Hollywood</publisher>
			<date type="published" when="2012-10" />
			<biblScope unit="page" from="261" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">MapReduce: A Flexible Data Processing Tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Communications of the ACM</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="72" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">HyperDex: A Distributed, Searchable Key-Value Store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Escriva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernard</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emin GÃ¼n</forename><surname>Sirer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGCOMM Conference</title>
		<meeting>the SIGCOMM Conference<address><addrLine>Helsinki, Finland, Au</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
	<note>gust</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Warp: Lightweight Multi-Key Transactions For Key-Value Stores</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Escriva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernard</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emin GÃ¼n</forename><surname>Sirer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<pubPlace>Ithaca</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The PerDiS FS: A Transactional File System For A Distributed Persistent Store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">JoÃ£o</forename><surname>Garcia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paulo</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paulo</forename><surname>Guedes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European SIGOPS Workshop</title>
		<meeting>the European SIGOPS Workshop<address><addrLine>Sintra, Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-09" />
			<biblScope unit="page" from="189" to="194" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The Google File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Howard</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shun-Tak</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating Systems Principles</title>
		<meeting>the Symposium on Operating Systems Principles<address><addrLine>Bolton Landing, New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10" />
			<biblScope unit="page" from="29" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Cost-Effective, High-Bandwidth Storage Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Garth</forename><forename type="middle">A</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Nagle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khalil</forename><surname>Amiri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Butler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fay</forename><forename type="middle">W</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Howard</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Hardin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erik</forename><surname>Riedel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Rochberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Zelenka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the Architectural Support for Programming Languages and Operating Systems<address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998-10" />
			<biblScope unit="page" from="92" to="103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The Zebra Striped Network File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">K</forename><surname>Hartman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ousterhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="274" to="310" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Scale And Performance In A Distributed File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">H</forename><surname>Howard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">L</forename><surname>Kazar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sherri</forename><forename type="middle">G</forename><surname>Menees</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">A</forename><surname>Nichols</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mahadev</forename><surname>Satyanarayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">N</forename><surname>Sidebotham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>West</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="51" to="81" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Consistent Hashing And Random Trees: Distributed Caching Protocols For Relieving Hot Spots On The World Wide Web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">R</forename><surname>Karger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Lehman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rina</forename><surname>Frank Thomson Leighton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><forename type="middle">S</forename><surname>Panigrahy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lewin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Theory of Computing</title>
		<meeting>the ACM Symposium on Theory of Computing<address><addrLine>El Paso, Texas</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-05" />
			<biblScope unit="page" from="654" to="663" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The Part-Time Parliament</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="169" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Petal: Distributed Virtual Disks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chandramohan</forename><forename type="middle">A</forename><surname>Thekkath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Architectural Support for Programming Languages and Operating Systems</title>
		<meeting>the Architectural Support for Programming Languages and Operating Systems<address><addrLine>Cambridge, Massachusetts</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="84" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Linux Kernel Developers. Documentation For /proc/sys/vm/*</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m">Linux Kernel Developers. ext4 Filesystem</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Transactional File Systems Can Be Fast</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Barbara</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rodrigo</forename><surname>Rodrigues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European SIGOPS Workshop</title>
		<meeting>the European SIGOPS Workshop<address><addrLine>Leuven, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">GFS: Evolution On Fast-Forward</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kirk</forename><surname>Mckusick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Quinlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="42" to="49" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Blizzard: Fast, Cloud-Scale Block Storage For Cloud-Oblivious Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">W</forename><surname>Mickens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edmund</forename><forename type="middle">B</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darren</forename><surname>Gehring</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bin</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Asim</forename><surname>Kadav</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><surname>Chidambaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Osama</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krishna</forename><surname>Nareddy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Networked System Design and Implementation</title>
		<meeting>the Symposium on Networked System Design and Implementation<address><addrLine>Washington</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-04" />
			<biblScope unit="page" from="257" to="273" />
		</imprint>
	</monogr>
	<note>Seattle</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Flat Datacenter Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edmund</forename><forename type="middle">B</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Elson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jinliang</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Owen</forename><forename type="middle">S</forename><surname>Hofmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yutaka</forename><surname>Suzue</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating System Design and Implementation</title>
		<meeting>the Symposium on Operating System Design and Implementation<address><addrLine>Hollywood, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-10" />
			<biblScope unit="page" from="1" to="15" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The Design And Implementation Of The Inversion File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Olson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the USENIX Winter Technical Conference</title>
		<meeting>the USENIX Winter Technical Conference<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-01" />
			<biblScope unit="page" from="205" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">GPFS: A Shared-Disk File System For Large Computing Clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><forename type="middle">L</forename><surname>Schmuck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Haskin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on File and Storage Technologies</title>
		<meeting>the Conference on File and Storage Technologies<address><addrLine>Monterey, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002-01" />
			<biblScope unit="page" from="231" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Experience With Transactions In QuickSilver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">C</forename><surname>Schmuck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wyllie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating Systems Principles</title>
		<meeting>the Symposium on Operating Systems Principles<address><addrLine>Pacific Grove, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="239" to="253" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title/>
		<ptr target="http://lustre.org/" />
	</analytic>
	<monogr>
		<title level="j">Seagate Technology LLC. Lustre Filesystem</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Stasis: Flexible Transactional Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Russell</forename><surname>Sears</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating System Design and Implementation</title>
		<meeting>the Symposium on Operating System Design and Implementation<address><addrLine>Seattle, Washington</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-11" />
			<biblScope unit="page" from="29" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Transaction Support In A Log-Structured File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Margo</forename><forename type="middle">I</forename><surname>Seltzer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Data Engineering</title>
		<meeting>the IEEE International Conference on Data Engineering<address><addrLine>Vienna, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-04" />
			<biblScope unit="page" from="503" to="510" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Enabling Transactional File Access Via Lightweight Kernel Extensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">P</forename><surname>Spillane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sachin</forename><surname>Gaikwad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manjunath</forename><surname>Chinni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erez</forename><surname>Zadok</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">P</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on File and Storage Technologies</title>
		<meeting>the Conference on File and Storage Technologies<address><addrLine>San Francisco, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-02" />
			<biblScope unit="page" from="29" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">F4: Facebook&apos;s Warm BLOB Storage System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Muralidhar</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wyatt</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sabyasachi</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cory</forename><surname>Hill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ernest</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwen</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satadru</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shiva</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sivakumar</forename><surname>Viswanathan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linpeng</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjeev</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating System Design and Implementation</title>
		<meeting>the Symposium on Operating System Design and Implementation<address><addrLine>Broomfield</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
			<biblScope unit="page" from="383" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Frangipani: A Scalable Distributed File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chandramohan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Thekkath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">K</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Operating Systems Principles</title>
		<meeting>the Symposium on Operating Systems Principles<address><addrLine>Saint Malo, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997-10" />
			<biblScope unit="page" from="224" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Sierra: Practical Power-Proportionality For Data Center Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eno</forename><surname>Thereska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Austin</forename><surname>Donnelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dushyanth</forename><surname>Narayanan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the European Conference on Computer Systems</title>
		<meeting>the European Conference on Computer Systems<address><addrLine>Salzburg, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-04" />
			<biblScope unit="page" from="169" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Calv-inFS: Consistent WAN Replication And Scalable Metadata Management For Distributed File Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on File and Storage Technologies</title>
		<meeting>the Conference on File and Storage Technologies<address><addrLine>Santa Clara, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-02" />
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Calvin: Fast Distributed Transactions For Partitioned Database Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thaddeus</forename><surname>Diamond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shu-Chun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kun</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">J</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Abadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the SIGMOD International Conference on Management of Data</title>
		<meeting>the SIGMOD International Conference on Management of Data<address><addrLine>Scottsdale, Arizona</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-05" />
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Robustness In The Salus Scalable Block Store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manos</forename><surname>Kapritsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuocheng</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prince</forename><surname>Mahajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeevitha</forename><surname>Kirubanandam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lorenzo</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Dahlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Symposium on Networked System Design and Implementation</title>
		<meeting>the Symposium on Networked System Design and Implementation<address><addrLine>Lombard, Illinois</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-04" />
			<biblScope unit="page" from="357" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Scalable Performance Of The Panasas Parallel File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brent</forename><surname>Welch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Unangst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zainul</forename><surname>Abbasi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Garth</forename><forename type="middle">A</forename><surname>Gibson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Mueller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Small</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Zelenka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bin</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on File and Storage Technologies</title>
		<meeting>the Conference on File and Storage Technologies<address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-02" />
			<biblScope unit="page" from="17" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Extending ACID Semantics To The File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">P</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">P</forename><surname>Spillane</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gopalan</forename><surname>Sivathanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erez</forename><surname>Zadok</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Transactions on Storage</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">SpringFS: Bridging Agility And Performance In Elastic Distributed Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lianghong</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Cipar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elie</forename><surname>Krevat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexey</forename><surname>Tumanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitin</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">A</forename><surname>Kozuch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on File and Storage Technologies</title>
		<meeting>the Conference on File and Storage Technologies<address><addrLine>Santa Clara</addrLine></address></meeting>
		<imprint>
			<publisher>California</publisher>
			<date type="published" when="2014-02" />
			<biblScope unit="page" from="243" to="255" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
