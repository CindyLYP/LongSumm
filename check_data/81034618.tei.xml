<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Generalized Data Structure Synthesis</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calvin</forename><surname>Loncaric</surname></persName>
							<email>loncaric@cs.washington.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">G</forename><surname>Allen</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
							<email>mernst@cs.washington.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emina</forename><surname>Torlak</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">University of Washington Seattle</orgName>
								<address>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">University of Washington Seattle</orgName>
								<address>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="department">School of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">University of Washington Seattle</orgName>
								<address>
									<region>WA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Generalized Data Structure Synthesis</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/nnnnnnn.nnnnnnn</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Program synthesis</term>
					<term>automatic programming</term>
					<term>data structures</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Data structure synthesis is the task of generating data structure implementations from high-level specifications. Recent work in this area has shown potential to save programmer time and reduce the risk of defects. Existing techniques focus on data structures for manipulating subsets of a single collection, but real-world programs often track multiple related collections and aggregate properties such as sums, counts, minimums, and maximums. This paper shows how to synthesize data structures that track subsets and aggregations of multiple related collections. Our technique decomposes the synthesis task into alternating steps of query synthesis and incrementalization. The query synthesis step implements pure operations over the data structure state by leveraging existing enumerative synthesis techniques, specialized to the data structures domain. The incrementalization step implements imperative state modifications by re-framing them as fresh queries that determine what to change, coupled with a small amount of code to apply the change. As an added benefit of this approach over previous work, the synthesized data structure is optimized for not only the queries in the specification but also the required update operations. We have evaluated our approach in four large case studies, demonstrating that these extensions are broadly applicable. CCS CONCEPTS • Theory of computation → Data structures design and analysis; • Software and its engineering → Source code generation;</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Many programming tasks can be framed as data structure problems, especially in domains like user interfaces or web services where software must manage some internal state and also handle asynchronous events. Manually implementing complex applicationspecific data structures can be time-consuming and error-prone. Recent research seeks to automatically synthesize data structure implementations from high-level specifications, thus ensuring correctness and run-time efficiency with minimum programmer effort <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b15">16]</ref>. Existing techniques can synthesize only a narrow range of data structures-those that retrieve a subset of a single collection. Such a simple API limits their applicability, as real-world software often has more complex requirements.</p><p>For example, the chat server Openfire <ref type="bibr" target="#b12">[13]</ref> uses a custom inmemory data structure to represent a many-to-many relationship between users and groups. This data structure needs to answer many different kinds of queries efficiently, such as which users belong to a given group or whether any two users share a group. It also needs to keep itself up-to-date as users and groups are added, removed, and renamed. Despite its complex implementation, Openfire's user management code has a simple specification. In general, data structure specifications are much smaller than their implementations because they do not need to manage memory or be algorithmically efficient.</p><p>This paper presents a new technique for data structure synthesis that overcomes many of the limitations of previous work. Our tool Cozy can synthesize implementations for complex multi-collection data structures-including those found in Openfire-from high-level specifications. Like previous work, a Cozy specification declares the abstract state (what information the data structure stores), queries (methods that perform pure computations on the state), and updates (methods that modify the state) that the data structure must support. Cozy then produces source code that developers can use right away.</p><p>In previous work, implementations for update methods were hard-coded <ref type="bibr" target="#b15">[16]</ref> or derived using a set of hand-written rules <ref type="bibr" target="#b10">[11]</ref>. In Cozy, update methods are synthesized rather than hardcoded. This enables Cozy to discover more specialized data representations than previous work, since Cozy can choose different representations depending on what kinds of updates appear in the specification.</p><p>Our technique iteratively improves the data structure specification using two cooperating components: a query synthesizer that selects a better representation and implementation for each query method and an incrementalization step that ensures the new representation is kept up-to-date when an update method is called. Crucially, the incrementalization step can produce specifications for new query operations to help implement the update procedure. Cozy thus uses the query synthesizer to implement both pure query operations and imperative updates. Our technique is agnostic to the exact implementations of the query synthesizer and incrementalization step; Section 3 gives a detailed explanation of the concrete choices we made for Cozy. The query synthesizer and incrementalization step interact using concretization functions. A concretization function expresses a data structure's representation-its concrete state-as a function of its abstract state. For example, the following concretization function represents the count of elements in an abstract set S: C(S) = x ∈S 1 . Concretization functions allow Cozy to reason about the effects of updates in pure mathematical terms. The imperative operation S .remove(e )-which removes an instance of e from S if any is present-causes a change to the data representation. The new value of the count thus becomes C(S ′ ) = C(S − {e}) = x ∈(S −{e }) 1 .</p><p>Cozy's query synthesis step outputs both an efficient implementation for each query and a set of concretization functions indicating how the data should be represented. The incrementalization step then uses the concretization functions to produce a specification of the change to the concrete state as a result of each update. For the case of S .remove(e ), the change specification is the amount by which the count changes: C(S ′ ) − C(S). These change specifications are queries over the abstract state of the data structure, and to implement them Cozy repeats the query synthesis step. The tool proceeds in this loop until exhausting its time budget-three hours for our evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Contributions</head><p>• A high-level data structure synthesis algorithm with alternating steps of query synthesis and incrementalization ( §2). • Query synthesis and incrementalization algorithms ( §3).</p><p>• An implementation, called Cozy (https://cozy.uwplse.org).</p><p>• Four real-world case studies that evaluated Cozy's effect on development time, correctness, and efficiency ( §4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>OVERVIEW</head><p>This section illustrates Cozy's high-level algorithm using a simplified example of a real-world data structure from Openfire. The data structure that manages users' contacts has been a frequent source of bugs (Section 4.4). Cozy can synthesize a complete implementation for Openfire's data structure given its specification. Cozy uses the algorithm shown in <ref type="figure" target="#fig_0">Figure 1</ref>. It takes as input an executable specification of the data structure (Section 2.1), constructs an initial implementation (Section 2.2), and then iteratively improves its implementation using alternating steps of query synthesis (Section 2.3) and incrementalization (Section 2.4). A dead code elimination step (Section 2.5) prunes dead code as synthesis progresses. <ref type="figure" target="#fig_1">Figure 2a</ref> shows a complete Cozy specification for part of the Openfire contact management data structure. It would be used as the input to <ref type="figure" target="#fig_0">Figure 1</ref>. In the specification, state declarations describe the abstract state of the data structure, query declarations specify methods that compute values using the abstract state, and op declarations specify methods that alter the abstract state. Methods may also include assumptions (preconditions) about their inputs. In some cases, Cozy can produce better implementations by leveraging these assumptions, but they are optional for specification writers. Callers must ensure that the assumptions hold at each call site.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Specification</head><p>In Openfire, users' contact lists are implicit and are computed based on the groups that each user belongs to. The data structure must be able to efficiently answer the question "should user u 1 appear in the contacts of user u 2 ?" for any u 1 and u 2 . The query method visible in Figure 2a defines this relationship: u 1 is visible to (i.e. appears in the contacts of) u 2 if there exists a group д of which u 1 is a member and either д has been made visible to everyone (д.visibility == Everyone) or u 2 is also a member of д.    This example has been simplified; our experiments (Section 4) use a full specification of the data structure that also includes explicit contacts and additional visibility modes for groups. As specified, visible runs in O(|groups| × |members|) time. Cozy creates a more efficient implementation for visible ( <ref type="figure" target="#fig_1">Figure 2b</ref>) that runs in O(д) time, where д is the maximum number of groups that any one user is a member of.</p><formula xml:id="formula_0">f = λu . exists Filter p(u) members p(u) = λ(v, д) . u == v</formula><formula xml:id="formula_1">д = λu . Filter q(u) members q(u) = λ(v, д) . u == v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Initial Implementation</head><p>Whenever Cozy chooses a data representation, it also creates, for each field in the representation, a concretization function that computes the field's representation from the abstract state. Since Cozy specifications are executable, they can be converted to implementations whose concrete state is the same as the abstract state. For the specification in <ref type="figure" target="#fig_1">Figure 2a</ref>, Cozy's initial implementation has the variables v 1 , v 2 , and v 3 and trivial concretization functions: C v1 (users, groups, members) = users C v2 (users, groups, members) = groups C v3 (users, groups, members) = members Each query and update operation can be rewritten in terms of v 1 , v 2 , and v 3 by simple substitution. The visible method becomes query visible(u 1 , u 2 : User):</p><formula xml:id="formula_2">assume u 1 ∈ v1 assume u 2 ∈ v1 return (exists [ д | д ← v2, (u 1 , д) ∈ v3 and ( д.visibility == Everyone or (u 2 , д) ∈ v3) ])</formula><p>While renaming the abstract members to v 1 , v 2 , v 3 does not functionally change the specification, it creates initial concretization functions for later steps to consume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Query Synthesis</head><p>Cozy synthesizes an implementation by iteratively finding improvements to the data structure. The query synthesis step in <ref type="figure" target="#fig_0">Figure 1</ref> makes an improvement to some non-deterministically chosen query operation on the data structure. Section 3.2 discusses how Cozy makes the choice and the improvement. <ref type="figure" target="#fig_1">Figure 2</ref> shows output from one of the query synthesis steps, i.e., an improvement to the query visible that uses a new representation and has associated concretization functions.</p><p>The query synthesis step may introduce new state variables, but it does not drop unused ones. In <ref type="figure" target="#fig_1">Figure 2</ref>, the red state variables s 1 , s 2 , and s 3 are new; v 1 , v 2 , and v 3 are now unused. The dead code elimination pass will eliminate the unused variables later.</p><p>The new variables' concretization functions are more complex than the trivial ones introduced for the initial implementation. The state variable s 1 , for instance, has the concretization function C s1 , which uses the MakeMap primitive to construct a new map from users to Booleans. The MakeMap primitive takes a collection of keys (users) and a value function (f ) and builds a map where each key u ∈ users is associated with value f (u). For s 1 , the value is true if the user is a member of a group with visibility set to "Everyone". In Cozy, maps are total. Lookups on missing keys return a default value: false for booleans, the empty set for sets, and so on. Thus, op join(u : User, д : Group): // Find keys of map s1 whose values // change when user u joins group g.</p><formula xml:id="formula_3">join _ s1(u, д) join _ s2(u, д) join _ s3(u, д) join _ v1(u, д) join _ v2(u, д) join _ v3(u, д</formula><p>private query altered _ keys _ s1(u : User, д : Group):</p><formula xml:id="formula_4">assume u ∈ users assume д ∈ groups assume (u, д) members return [ k | k ← MapKeys(s1) ∪ MapKeys(s1 ′ ), s1[k ] s1 ′ [k ] ]</formula><p>// Compute a new value at key k ∈ s1 when user u joins group g. private query new _ value _ for _ key _ s1(k , u : User, д : Group): assume u ∈ users assume д ∈ groups assume (u, д)</p><formula xml:id="formula_5">members assume s1[k ] s1 ′ [k ] return s1 ′ [k ]</formula><p>// Sub-queries for s2 and s3 have been omitted for brevity.</p><p>(b) <ref type="figure">Figure 3</ref>: (a) Implementation of the join update operation and (b) new sub-queries that need to be synthesized. The variable s1 ′ is defined as the new value of s1 after join is called: C s1 (users ′ , groups ′ , members ′ ).</p><p>the expression s1[u 1 ] efficiently determines whether user u 1 is a member of a group with visibility set to "Everyone".</p><p>The concretization functions shown in <ref type="figure" target="#fig_1">Figure 2c</ref> will become the implementation of the constructor for the data structure. The constructor takes the abstract state as input and initializes the concrete state. Furthermore, the concretization functions enable incrementalization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Incrementalization</head><p>The query synthesis step creates an incorrect data structure: the new state variables s 1 , s 2 , and s 3 are not kept up-to-date when join is called. The incrementalization step restores correct functioning by adding code to join that updates the new state variables. The new code must preserve the concretization functions in <ref type="figure" target="#fig_1">Figure 2c</ref>.</p><p>A simple but inefficient solution would be to recompute the value of each concrete state variable from scratch. Because an update usually makes a small change to the abstract state, Cozy produces an incremental update that makes small changes to the concrete state in response to a small change to the abstract state.</p><p>To incrementally update the concrete state, Cozy rephrases the update procedure as a set of queries that compute what changes should take place, plus a simple hardcoded snippet that applies those computed changes. A previous approach applied this same idea to synthesize remove operations <ref type="bibr" target="#b10">[11]</ref>, but with concretization functions it can be generalized to insertions and other updates as well. Our approach also allows for more complex update procedures like those that apply multiple changes at once or only make a change under certain conditions. <ref type="figure">Figure 3a</ref> shows the code that Cozy produces to update the concrete state as a result of a user joining a group. Each concrete state variable gets its own update procedure (e.g. join _ s1 for s1). The code for join _ s1 is not synthesized; it comes from a lookup table (Section 3.3). However, the new code uses two fresh query operations altered _ keys _ s1 and new _ value _ for _ key _ s1 <ref type="figure">(Figure 3b</ref>) that determine what changes to apply. The former computes the set of map keys whose values change, and the latter computes the new value for each key. These two queries are added to the data structure specification, and thus they will be optimized by the query synthesizer on subsequent iterations.</p><p>The definitions of the fresh queries make use of both the old value of s1 and the new value s1 ′ . The new value is computed using the specification of join and the concretization functions. Mathematically, join sets the abstract state to users ′ = users; groups ′ = groups; members ′ = members ∪ {(u, д)} and thus the new value s1 ′ must be  <ref type="figure">Figure 3b</ref> shows the specifications for altered _ keys _ s1 and new _value _ for _ key _ s1, which are inefficient. On later iterations, Cozy's query synthesizer discovers efficient implementations for both. Specifically, Cozy implements altered _ keys _ s1 to return the singleton set {u} if д has visibility Everyone and u is not already in such a group, or ∅ otherwise. Cozy implements new _ value _ for _ key _ s1 to simply return true.</p><formula xml:id="formula_6">s1 ′ = C s1 (users ′ , groups ′ , members ′ ) = MakeMap f users where f = λu . exists Filter p(u) (members ∪ {(u, д)}) p(u) = λ(v, д) . u == v</formula><p>The implementations of altered _ keys _ s1 and new _ value _ for _key _ s1 do not require additional concrete state. In general, however, new concrete state might be generated for the fresh queries in later iterations, requiring another phase of incrementalization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Dead Code Elimination</head><p>At each iteration, Cozy cleans up unused state variables and operations. For instance, the state variable v 2 can be eliminated since it is never read. All code that keeps v 2 up-to-date can be eliminated as well. Cozy also deduplicates state variables and fresh queries. Duplicates happen in cases where the same concrete state is useful to multiple different query operations.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DETAILS</head><p>Cozy iteratively improves a specification (Section 3.1) to produce an implementation. At each iteration Cozy attempts to find an improvement to some query (Section 3.2). The improvement may require new concrete state, which must be properly maintained in each update method (Section 3.3). Finally, unused state and code are removed (Section 3.4).  Maps could be included in the input language, but they are not needed: a comprehension can group and look up values in a declarative rather than procedural manner. This clarifies what each expression computes and reduces the number of invariants that programmers need to maintain. In the output language, the MakeMap primitive takes an expression e representing the keys of the map and a projection f that gives the value at each key. MapKeys returns the keys of a map. The map index operator e[e] returns the value of a given key in the given map. If the key is not in the map, this operator returns a default value; e.g. false for booleans and the empty set for bags.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Specification and Output Languages</head><formula xml:id="formula_7">len(X ) → Σ Map λx .1 X empty(X ) → len(X ) = 0 areUnique(X ) → X = Distinct X ∀x ∈ X , p(x) → empty(Filter ¬p X ) ∃x ∈ X , p(x) → ¬empty(Filter p X ) x ∈ X → ∃y ∈ X , y = x [f (x) | x ∈ X , p(x)] → Map f Filter p X [f (x, y) | x ∈ X , y ∈ Y ] → FlatMap λx .Map λy .f (x,y) Y X</formula><p>We plan to extend Cozy with additional primitives for heaps, trees, and other efficient data structures in the future. For the case studies we examined, maps alone are sufficient to discover efficient implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Synthesis</head><p>Cozy attempts to synthesize a better implementation for each query method in the specification, in parallel, with one thread per query. A static cost model ( <ref type="figure" target="#fig_5">Figure 6</ref>) defines "better. " Whenever a thread discovers a better implementation: (1) That implementation is immediately passed through the incrementalization step, and new queries it produces get new threads. (2) The whole specification undergoes dead code elimination, and any old queries that were eliminated have their threads terminated.</p><p>Each thread synthesizes improvements for its query using enumerative synthesis, an optimized form of brute-force search. The core algorithm described here was pioneered by previous work <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b30">31]</ref>, but Cozy employs several novel improvements. We describe the core algorithm first, followed by our extensions.</p><p>Enumerative synthesis explores every possible expression in Cozy's output grammar, in order of size from smallest to largest. For each expression, a verifier (e.g. Z3 <ref type="bibr" target="#b5">[6]</ref>) checks whether the expression satisfies the specification-that is, they always produce the same result. If so, the expression is emitted. Then the search continues to look for an even better solution. Since Cozy employs bounded verification (described below), the verifier always produces a result and never times out or returns unknown.</p><p>To make the search feasible, Cozy employs equivalence class deduplication <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b30">31]</ref>, an optimization that skips most expressions in the search space. The skipping is done safely so that Cozy never State Expressions cost S (e) = number of AST nodes in e Query Expressions cost Q (e) | e is a state expression = 1 cost Q (x) = 1 cost Q (e 1 op e 2 ) = 1 + cost Q (e 1 ) + cost Q (e ) cost Q (Filter p e) = 1 + cost Q (e) + card(e) × cost Q (p(x)) (x is a fresh variable) cost Q (Σ e) = 1 + cost Q (e) + card(e) ... misses a solution, if one exists. Equivalence class deduplication requires a list of example inputs. In Cozy, an example input consists of values for both the abstract state of the data structure and the query arguments. The example inputs are produced by the verifier: every time an expression fails verification, the verifier yields a new example input. Cozy caches built expressions. Whenever two expressions produce the same output on every example, Cozy consults a static cost model (described below) to decide which to keep. In this way, an expression's set of outputs on the examples puts it in an equivalence class, and only one representative of each equivalence class is cached at any given time. Larger expressions are only built out of those that survive this deduplication. Furthermore, Cozy only tries to verify expressions that produce correct output on every example, reducing the number of calls to the verifier. Since the skipping is so aggressive, the search must restart every time a new example is discovered to ensure that no solutions are missed. Cozy includes three novel additions to the core enumerative synthesis algorithm: query-time distinction, a symbolic cost model, and diversity injection. Additionally, since verification is undecidable for our specification language, Cozy uses bounded verification instead of full functional verification. This technique was also employed by previous work <ref type="bibr" target="#b25">[26]</ref>.</p><p>Query-Time Distinction. Cozy's query synthesis algorithm must solve two intertwined problems: choosing a good representation for the data and choosing a good algorithm that exploits that representation. Our solution is to tag each node in a synthesized expression as either a state expression or a query expression. The data structure stores each state expression as a member and incrementally maintains it at each update operation. A query expression is evaluated each time the query is called.</p><p>For instance, an expression to compute the length of a list could be implemented in several different ways, depending on which parts are tagged as state expressions:</p><formula xml:id="formula_8">Σ Map λx .1 S state or Σ Map λx .1 S state .</formula><p>The first case indicates that the data structure stores the length of S as a member and returns the stored value when the query is called. The second case indicates that the data structure stores S as a member and computes the length on-demand. Since these two expressions are equivalent, only the lower-cost one-in this case, the first-is kept during deduplication. Cozy's cost model does not account for the cost of maintaining the state; instead, that job is delegated to the sub-queries generated during incrementalization. Expressions that contain query arguments may not be tagged as state expressions, since those values will not be available until the query is executed.</p><p>Symbolic Cost Model. <ref type="figure" target="#fig_5">Figure 6</ref> shows Cozy's novel static cost model. The cost model compares state expressions based on their complexity in terms of the number of AST nodes (cost S ). It compares query-time expressions based on their expected run time (cost Q ).</p><p>Cozy represents costs as symbolic formulas involving the cardinalities of various collections. For example, the cost of performing a filter includes the cost of evaluating the predicate on every element of the collection being filtered.</p><p>To determine the ordering between two costs c 1 and c 2 , Cozy first makes solver calls to establish as many facts as possible about all the cardinalities (i.e., calls to card) in each expression. Each call to card can then be replaced by a fresh real-type variable. Using these assumptions, Cozy then makes more solver calls. If there are cases where c 1 is less than c 2 (sat(c 1 &lt; c 2 )) and no cases where c 1 is more than c 2 (¬sat(c 2 &lt; c 1 )), then the expression having cost c 1 should always be preferred over the expression having cost c 2 .</p><p>Diversity Injection. In practice, the enumerative synthesis algorithm may take a long time to discover good solutions, especially for languages like ours where expression size is not strongly correlated with cost (that is, larger expressions may have lower cost). When the syntax tree for the best solution is of size fifteen or twenty, standard enumerative synthesis may take many centuries to discover it! For comparison, the syntax tree for the efficient implementation of visible in <ref type="figure" target="#fig_1">Figure 2</ref> requires 45 nodes.</p><p>To bias the search toward useful expressions, Cozy employs a small number of handwritten diversity rules that inject new expressions into the search procedure. Whenever Cozy considers a new candidate expression, it also applies these rules and considers the resulting expressions. The diversity rules do not need to be universally correct or efficient: incorrect expressions will be rejected by the verifier, and inefficient expressions will be rejected by the cost model. However, incorrect expressions are still cached to help Map Introduction  build larger expressions, as they might appear as subexpressions of correct solutions later on. Cozy uses the five diversity rules shown in <ref type="figure" target="#fig_6">Figure 7</ref>. These diversity rules are specialized to Cozy's domain and are intended to capture some intuitions human programmers might apply. "Map introduction" converts some linear-time filter operations into efficient map lookups. "Cleaners" put expressions into normal form, which helps Cozy identify potential map lookups on later iterations. The "relevant subset" rule converts a collection into the subset that is already stored on the data structure. Finally, the "instantiation" rule helps transfer insights about a variable to insights about other expressions. For example, if Cozy has discovered the expressions x ∈ S and y, then y ∈ S might also be important.</p><formula xml:id="formula_9">Filter λx .f (x )=y X → (MakeMap (λk .Filter λx .f (x )=k X ) Map λx .f (x ) X )[y] Cleaners Filter λx .P 1 (x )∧P 2 (x ) X → Filter λx .P 1 (x ) Filter λx .P 2 (x ) X Filter λx .a(x )?b(x ):c (x ) X → Filter λx .a(x )∧b(x ) X + Filter λx .¬a(x )∧c (x ) X Relevant Subset X, v | v</formula><p>In practice, Cozy's enumerative search machinery does not function well without the diversity rules and vice-versa. If the diversity rules are disabled, Cozy does not find a good solution to any specification for any of our subject programs within a three hour timeout. Similarly if the diversity rules are applied without the rest of Cozy's enumerative search machinery, the search quickly runs out of new expressions and stalls without ever finding a good solution.</p><p>Bounded Verification. It is undecidable to determine whether an expression in Cozy's language satisfies a specification. Thus, Cozy employs bounded verification: collection-type variables are limited to a fixed number of elements. In our experiments, we found a limit of four to be sufficient to ensure correct solutions. This may be thanks to the small-scope hypothesis <ref type="bibr" target="#b13">[14]</ref>, which proposes that most program bugs can be exhibited with small inputs. There is some evidence that the small scope hypothesis is true for simple programs <ref type="bibr" target="#b3">[4]</ref>, and we found it to be true in our domain as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Incrementalization</head><p>After query synthesis picks a new representation for the data, the incrementalization step restores proper functioning by adding code to keep that representation up-to-date as the data structure changes. Cozy's incrementalize procedure accomplishes that goal by leveraging the existing query synthesis procedure.</p><p>In join from Section 2.4, Cozy updated s1 using the code for k ∈ altered _ keys _ s1(u, д): s1[k ] = new _ value _ for _ key _ s1(k , u, д) <ref type="figure">Figure 8</ref> shows the rules for Cozy's incrementalize procedure. Since s1 has a map type, Cozy uses the update sketch shown in the figure for maps. </p><formula xml:id="formula_10">Int x ← x + q(...) q(...) = C x (σ ′ ) − C x (σ ) Bag for elem ∈ q 1 (...) :</formula><p>x.del(elem) for elem ∈ q 2 (...) :</p><p>x.add(elem) to compute which keys have changed.</p><formula xml:id="formula_11">q 1 (...) = C x (σ ) − C x (σ ′ ) q 2 (...) = C x (σ ′ ) − C x (σ ) Map for k ∈ q(...) : incrementalize( x[k], λσ .C x (σ )[k]) q(...) = {k | k ∈ MapKeys(C x (σ )) ∪ MapKeys(C x (σ ′ )), C x (σ )[k] C x (σ ′ )[k]} other x ← q(...) q(...) = C x (σ ′ )</formula><p>Since the values in s1 are booleans, Cozy uses the fallback sketch for "other" types to update each value. This rule uses a new query new _ value _ for _ key _ s1 to compute-from scratch-a new value for s1 <ref type="bibr">[k]</ref>. As discussed in Section 2.4, the new value for s1[k] is simply true. In practice, new queries generated by incrementalize often have short and efficient implementations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Dead Code Elimination</head><p>When a better query implementation is found, some state variables may go unused. The imperative operations that keep these variables up-to-date are unnecessary, as are any queries required only by those imperative operations, and so forth. The dead code elimination procedure is important; it frequently eliminates variables in this manner as better query solutions are found.</p><p>To clean up unused state and operations, Cozy uses mark-andsweep. User-specified query operations start as roots. Any state that they use is marked as relevant, and code to update that state is also marked. Queries used by the update code are then marked, and so on until fixed point. Finally any unmarked state, queries, or update code can be safely removed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Termination</head><p>The query synthesis procedure (Section 3.2) has no formal termination guarantees, and as a result, neither does Cozy itself. But since the input specification is executable, Cozy always has a correct solution and the synthesis process can be stopped at any time. Our experiments used a fixed timeout of three hours for synthesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EVALUATION</head><p>Cozy has three goals: to reduce programmer effort, to produce bugfree code, and to match the performance of handwritten code. We found that using Cozy requires an order of magnitude fewer lines of code than manual implementation (Section 4.3), makes no mistakes even when human programmers do (Section 4.4), and often matches the performance of handwritten code (Section 4.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Methodology</head><p>For each of four real-world programs (Section 4.2), we</p><p>(1) identified an important, complex, handwritten data structure, (2) manually wrote a Cozy specification, (3) allowed Cozy a three-hour timeout to synthesize a new implementation, and (4) replaced the original data structure by the synthesized one. Replacing handwritten code with Cozy-synthesized code required some light refactoring in each program. For example, some programmers intertwine data structure code with I/O code. We disentangled these, because Cozy does not synthesize I/O code. This refactoring was only necessary because these projects did not use Cozy from day one. Furthermore, we believe it results in better code style and easier-to-understand abstractions.</p><p>We ran our experiments on a machine with 96 cores and 512 Gb of memory. Cozy spawns one thread for each query in the specification and runs fastest on a machine with at least that many cores, but does not require it. The Openfire specification, our largest, has 12 query operations, thus requiring 12 cores for fastest operation. Memory usage steadily climbs the longer Cozy runs; we have observed it reach 32 Gb in the worst case.</p><p>The three hour synthesis time does not slow down the editcompile-test cycle. Since Cozy specifications are executable, they can be immediately translated into usable but inefficient code. Developers can code and test against the slow version to gain confidence in their specification before running the full synthesizer. We made use of this feature while writing specifications in our evaluation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Subject Programs</head><p>ZTopo <ref type="bibr" target="#b31">[32]</ref> is a topological map viewer implemented in C++. Its cache of map tiles asynchronously loads map tiles over the network and caches them on disk or in memory. The cache enables any other part of the program to query for information about a given map tile. ZTopo was also a target for previous data structure synthesis work <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b15">16]</ref>. Cozy is also able to synthesize two parts of the cache that previous work could not. First, Cozy can synthesize the code that accounts for the total disk and memory usage of cached map tiles. Second, Cozy synthesizes a key operation to look up a single element by its unique identifier. Previous tools implemented this operation inefficiently by checking whether a computed collection of results contained a single element or not.</p><p>Sat4j <ref type="bibr" target="#b16">[17]</ref> is a Boolean satisfiability solver implemented in Java. Its variable store tracks, among other things, when a guess was last made about a variable's value and whether any listeners are watching that variable's state. Sat4j was also a target for previous data structure synthesis work <ref type="bibr" target="#b15">[16]</ref>. As with ZTopo, Cozy's synthesized implementation of the Sat4j data structure is a closer match to the original than previous tools, requiring less wrapper code. Openfire <ref type="bibr" target="#b12">[13]</ref> is a large, scalable IRC server implemented in Java. Its in-memory contact manager is extremely complex. Users' contacts can be either explicit (added by users manually) or implicit (present due to users' group memberships). Furthermore, the contact manager must keep its state in sync with the underlying database as users and groups are created, modified, and deleted. This logic has been a frequent source of bugs <ref type="bibr" target="#b29">[30]</ref>. Openfire's implicit contacts require computing information about two distinct collections (users and groups), and thus cannot be handled by any previous tool.</p><p>Lucene <ref type="bibr" target="#b28">[29]</ref> is a search engine back end implemented in Java. Lucene uses a custom data structure that consumes a stream of words and aggregates key statistics about them. The data structure has an add method that is called once for each token instead of getting the tokens as one big list. The logic for handling each token is tricky since the data structure needs to to be queryable between calls to its add method. Cozy helps avoid the logic in the add method by having a clean specification that describes the abstract state as a bag of tokens and descriptions of the queries that matter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Programmer Effort</head><p>We do not know how much time programmers spent implementing and debugging the hand-written data structures, but it was significant. <ref type="table" target="#tab_9">Table 1</ref> shows the size of each implementation, in noncomment non-blank lines of code. It also reports how many commits contributed to the current version of the data structure implementation, and across how much time those commits were made. The long time periods are because Sat4j, Openfire, and Lucene are established projects and still undergoing active maintenance. In all three, however, bug fixes have been made to the data structure in the last five commits, indicating that full functional correctness has been difficult to achieve.</p><p>The Cozy specifications are an order of magnitude shorter than the manual implementations. Most of our time was spent reverseengineering to understand the undocumented existing implementation; once we understood it, writing the specification was quick. For example, writing, integrating, and testing the ZTopo and Sat4j specifications took less than a day each. The Openfire roster manager was more challenging because we had to first formalize the implicit contacts function, a task the developers never carried out. We already understood the Cozy specification language (Section 3.1), but we believe that a programmer could learn it more quickly than it took us to reverse-engineer any one of the programs.</p><p>Because the specifications are shorter, simpler, and more abstract, they are much easier to understand. Programmers writing specifications are therefore less likely to make mistakes, and mistakes </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Correctness</head><p>Cozy might produce an incorrect data structure because of its use of bounded verification. We also might have made an error when writing the specification. To check the correctness of the Cozy-synthesized data structures, we ensured that all tests in each project still pass. ZTopo, Openfire, and Lucene have no tests that cover the data structure we replaced. For these projects we verified that our synthesized data structure behaves identically to the original implementation during execution of the benchmarks we used in Section 4.5. <ref type="table" target="#tab_10">Table 2</ref> lists how many data-structure-related issues in each project's respective issue tracker might have been prevented by Cozy. Most issues relate to defective update code putting the data structure in a bad state. Cozy is perfectly positioned to prevent those defects: changes to a data structure's abstract state are much easier to specify than the code that updates an optimized representation. We now discuss some of these issues.</p><p>Sat4j's variable metadata storage has suffered both performance and functional correctness issues in the past that Cozy avoids. Today Sat4j has a test suite that achieves 89% statement coverage on the data structure we replaced, and Cozy's synthesized implementation passes all tests.</p><p>Of Sat4j's seven reported issues, five relate to update code. Sat4j's data structure includes several arrays of data that grow exponentially as entries are added, and the logic to grow them and keep the capacity information up-to-date proved tricky to get right. The data structure also supports a reset() method to clear all of its internal state, but developers did not properly revise its implementation when they introduced new state variables. Cozy can prevent these kinds of problems since the programmer does not need to maintain the concrete representation.</p><p>Openfire, having a more complex data structure, has been even more difficult to get right. Section 2 presented only a simplified portion of the Openfire roster manager specification. The full specification has additional rules and visibility modes for groups. In particular, a user u 1 is visible to a user u 2 if any one of four different conditions are met: (1) the users have added each other as explicit contacts, (2) u 1 is in a group with visibility set to Everyone, (3) both users share a group with visibility set to OnlyGroup, or (4) u 1 is in a group д A with visibility set to OnlyGroup and u 2 is a member of a group д B configured to have visibility onto д A .</p><p>This definition gives rise to two kinds of roster items: explicit items due to condition 1 and implicit items due to conditions 2-4. The manually written implementation makes a trade-off: all explicit items plus implicit items due to conditions 2 and 3 are held as Additionally, we discovered multiple new failures while replacing the original implementation. <ref type="bibr" target="#b1">2</ref> For example, the original implementation makes it possible to create a situation in which two users see different views of the roster: according to one user, both are visible to each other, while according to another, there is only a one-way visibility. The synthesized implementation does not suffer from these problems. We do not know how many source code defects contribute to the observed failures.</p><p>Even Lucene's small data structure has been a source of defects. Overlapping words caused some of its internal statistics to become corrupted because the original developers did not foresee this possibility. Our Cozy implementation handles this case gracefully; the natural way to specify Lucene's operations does not have the defect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Performance</head><p>We measured the performance of the handwritten and synthesized implementations on realistic workloads. <ref type="table" target="#tab_11">Table 3</ref> reports the wallclock time required to run each benchmark to completion. The benchmarks are end-to-end, and include application behavior in addition to the data structure itself; the resulting time, therefore, represents the overall effect on each program from using the synthesized data structure.</p><p>Our benchmarks for ZTopo and Sat4j are the same ones used to evaluate an earlier iteration of Cozy <ref type="bibr" target="#b15">[16]</ref>. The ZTopo benchmark is a log of recorded application usage that we replay. The Cozysynthesized implementation of the ZTopo tile cache matches the performance of the existing implementation almost exactly. The handwritten and synthesized implementations are conceptually identical: both store map tiles in linked lists grouped by tile type. The dominant factor affecting performance is the speed of finding tiles by unique ID, which both implementations do using a hash table.</p><p>Sat4j's benchmark suite consists of eleven randomly-selected input files from the 2002 boolean satisfiability solver competition <ref type="bibr" target="#b17">[18,</ref><ref type="bibr" target="#b21">22]</ref>. The synthesized data structure for Sat4j under-performs the existing implementation. The handwritten code exploits some facts about the data that Cozy does not know: in Sat4j, variable IDs can be used as indexes into an array since they always fall between zero and a known maximum bound. This interacts poorly with Cozy's total semantics for map lookups. At code generation time, Cozy must insert safety checks at every map lookup. In Sat4j those safety checks are unnecessary and harm performance substantially.</p><p>Our benchmark for Openfire is a replayed sequence of actions against its admin panel that offers direct access to the internal roster data structure, where users, groups, and explicit contacts can be modified. The synthesized structure improves performance slightly. There are several contributing factors, but the dominant one is that the synthesized data structure can avoid a number of expensive internal representation checks. To improve correctness, the handwritten implementation will often clean up its own state, which imposes some overhead. By generating correct code, Cozy avoids these internal checks.</p><p>Our benchmark for Lucene is a series of operations on artificial data. Cozy's synthesized data structure for Lucene is very similar to the manually written one, leading to identical performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>The data structure synthesis problem dates to the 1970s and iterator inversion, a technique for constructing data structures to accelerate iterative operations <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b9">10]</ref>. Our syntax for queries is similar to that found in Earley's work, although our techniques are substantially more powerful. Iterator inversion required handwritten rewrite rules, while Cozy's exhaustive search discovers complex transformations unaided.</p><p>The developers of the SETL language took a different approach by splitting it into a pure language and a representation sub-language. The sub-language specifies what structures to use when running pure code <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b19">20]</ref>. More recently, researchers have investigated dynamic techniques to achieve the same effect <ref type="bibr" target="#b20">[21]</ref>. Beyond simply choosing better existing implementations of an interface, Cozy can implement more complex interfaces that require composing data structure representations.</p><p>Modern program synthesis techniques have been applied to lowlevel data structure code <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b26">27]</ref>. These techniques can help to write pointer and array manipulations but, unlike our work, require the programmer to choose a data representation in advance.</p><p>More recently, researchers have made headway on synthesizing complete data structures. RelC <ref type="bibr" target="#b10">[11]</ref> constructs data structure implementations that track subsets of a collection. It was later extended to produce safe concurrent data structures <ref type="bibr" target="#b11">[12]</ref>. An earlier version of Cozy <ref type="bibr" target="#b15">[16]</ref> used a custom "outline language" to describe data structure implementations and was able to synthesize data structures with richer specifications than RelC. By generalizing to arbitrary expressions and concretization functions, Cozy can now synthesize a far wider class of data structures, including the data structures for Openfire and Lucene that require multiple related collections and aggregation operators. To gain this expressiveness we have given up decidability, relying instead on bounded verification.</p><p>RelC and earlier versions of Cozy had a tuning step that used a user-supplied benchmark to make low-level optimizations. Cozy no longer has this step. Its effectiveness was never fully evaluated and our powerful symbolic cost model now fills the role. Some data structures that Cozy originally supported have also been dropped. These were not necessary for the case studies we explored, but we plan to reimplement them to extend Cozy's applicability.</p><p>Cozy's high-level algorithm resembles programming by refinement (PBR), in which programs are produced by manual iterative modifications to an initial specification. Unlike PBR tools such as KIDS <ref type="bibr" target="#b23">[24]</ref>, Designware <ref type="bibr" target="#b24">[25]</ref>, and Fiat <ref type="bibr" target="#b6">[7]</ref>, each refinement iteration that Cozy makes may bear little resemblance to the implementation before it. This is because Cozy enumerates possible solutions in a fixed order rather than transforming the input specification. Furthermore, Cozy requires no manual effort beyond writing a specification. The cost of this simplicity is that Cozy cannot produce many of the more complicated algorithms derived by PBR systems. However, Cozy can automate parts of the job, specifically the "finite differencing" and "data type refinement" tasks <ref type="bibr" target="#b23">[24]</ref>.</p><p>The transformations that Cozy performs are akin to the index selection and view maintenance problems in database systems. Index selection is the task of choosing useful indexes to speed up desired queries. AutoAdmin <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b4">5]</ref> solves the problem by enumerating many possible indexes and using a query planner to decide which work best. As a result, AutoAdmin is limited by the set of optimization rules available to the query planner.</p><p>View maintenance is the problem of keeping an index or materialized view up-to-date as the data changes. Materialized views are similar to Cozy's concretization functions: they can be computed from the original state of the database. DBToaster <ref type="bibr" target="#b1">[2]</ref> implements a very efficient view maintenance system. More recently, the same team has worked on generalizing these ideas to collections, including nested collections <ref type="bibr" target="#b14">[15]</ref>. While it is possible to augment Cozy with these techniques, Cozy's enumerative synthesizer generally discovers those same solutions without the need for manual rewrite rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSION</head><p>Cozy is effective because incrementalization allows it to implement both pure and imperative operations using only a query synthesizer. A high-quality cost function and diversity injection make the query synthesizer powerful and practical. As a result, Cozy does not need clever analyses or transformation rules. Our case studies demonstrate that data structure synthesis can improve software development time, correctness, and efficiency.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Architecture of Cozy. Each iteration through the loop performs query synthesis, incrementalization, and dead code elimination.Figure 2ashows example input, andFigures 2b and 3show the corresponding output.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>(a) An example input to Figure 1 that specifies the Openfire user and group management data structure. (b) New implementation of visible after several query synthesis steps. Cozy does not produce the comments, which we added for clarity. Since incrementalization and dead code elimination have not yet run, the implementation does not properly update the new state variables s 1 , s 2 , and s 3 and still contains some unused state variables. (c) Concretization functions for the new implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Core specification language spec.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4</head><label>4</label><figDesc>shows the core specification language. All input specifications are desugared to this core language (Figure 5). Cozy's output language is a superset of its input language that includes additional constructs for maps:τ ::= Map⟨τ , τ ⟩ e ::= MakeMap f e | MapKeys e | e[e]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Expressions that Cozy accepts in input specifications but desugars into simpler forms. Cozy supports arbitrary list comprehensions, though only two examples of desugaring list comprehensions are shown.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Facts About Cardinalities ∀e, card(e) ≥ 0 ∀x, card(x) ≥ 1000 (if x is an abstract state variable) card(∅) = 0 card({e}) = 1 card(e 1 + e 2 ) = card(e 1 ) + card(e 2 ) unsat(|e 1 | &gt; |e 2 |) → card(e 1 ) ≤ card(e 2 ) Partial Order on Costs sat(c 1 &lt; c ) ∧ ¬sat(c 2 &lt; c 1 ) → c 1 ≺ c 2 (subject to the provable facts about all cardinalities in formulas c 1 and c 2 ) Static cost model. In Cozy, costs are represented as symbolic formulas over the cardinalities of various collections. Cozy uses a solver (sat and unsat functions) to order costs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Cozy's diversity rules.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>specname :specifications s 1 , s 2 , ... invariant e m 1 , m 2 , ... Enum {case 1 , case 2 , ...} enumerations | ⟨τ 1 , τ 2 , ...⟩ tuples | { f 1 : τ 1 , f 1 : τ 2 , ...} records == e | e &lt;e | ... comparisons | e ∧ e | e ∨ e | ¬e bool operations | e ? e : e conditionals | e + e | e − e arithmetic | (e, e, ...) | e.n tuples | { f : e, f : e, ...} | e.f records | ∅ | {e} | e ∪ e | e − e bag operations | Map f e | Filter f e</figDesc><table><row><cell>s</cell><cell>x : τ</cell><cell>abstract state</cell></row><row><cell>τ</cell><cell>Int | Bool | String</cell><cell>basic types</cell></row><row><cell></cell><cell>| | Bag⟨τ ⟩</cell><cell>bags (multisets)</cell></row><row><cell>m</cell><cell>query q(args...) :</cell><cell>queries</cell></row><row><cell></cell><cell>assume e;</cell><cell></cell></row><row><cell></cell><cell>return e;</cell><cell></cell></row><row><cell></cell><cell>| op u(args...) :</cell><cell>updates</cell></row><row><cell></cell><cell>assume e;</cell><cell></cell></row><row><cell></cell><cell>stmt;</cell><cell></cell></row><row><cell>stmt</cell><cell>x ← e</cell><cell>assignment</cell></row><row><cell></cell><cell>| x .add(e)</cell><cell>insertion</cell></row><row><cell></cell><cell>| x .rm(e)</cell><cell>deletion</cell></row><row><cell></cell><cell>| if e : stmt</cell><cell>conditional</cell></row><row><cell></cell><cell>| stmt; stmt</cell><cell>sequencing</cell></row><row><cell>e</cell><cell>x</cell><cell>variables</cell></row><row><cell></cell><cell cols="2">| e map and filter</cell></row><row><cell></cell><cell>| FlatMap f e</cell><cell>map union</cell></row><row><cell></cell><cell>| Σ e</cell><cell>sum</cell></row><row><cell></cell><cell>| Distinct e</cell><cell>remove duplicates</cell></row><row><cell></cell><cell>| ArgMin f e | ArgMax f e</cell><cell>min and max</cell></row><row><cell>f</cell><cell>λx .e</cell><cell>lambda abstraction</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>is a state variable → Filter λx .x ∈v X</figDesc><table /><note>Instantiation e 1 , e 2 | v is free in e 1 → e 1 [v → e 2 ]</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>An update sketch is a small snippet of imperative code that updates the variable. An update sketch may require new query incrementalize(x, C x ): Input: old abstract state σ and new abstract state σ ′ Output: code to update concrete state x</figDesc><table><row><cell>Type</cell><cell>Update Sketch</cell><cell>New Queries</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 1 :</head><label>1</label><figDesc>Programmer effort. LoC measurements do not include comments or whitespace.</figDesc><table><row><cell></cell><cell cols="2">Hand-written</cell><cell>Cozy</cell></row><row><cell>Project</cell><cell>Span</cell><cell cols="2">Commits LoC LoC</cell></row><row><cell>ZTopo</cell><cell>week</cell><cell>15</cell><cell>1024</cell></row><row><cell>Sat4j</cell><cell>8 years</cell><cell>22</cell><cell>195</cell></row><row><cell cols="2">Openfire 10 years</cell><cell>47</cell><cell>1992</cell></row><row><cell>Lucene</cell><cell>13 years</cell><cell>20</cell><cell>68</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 2 :</head><label>2</label><figDesc>Correctness results. ZTopo has no dedicated issue tracker.</figDesc><table><row><cell cols="3">Project Issues New defects found</cell></row><row><cell>ZTopo</cell><cell>n/a</cell><cell>No</cell></row><row><cell>Sat4j</cell><cell>7</cell><cell>No</cell></row><row><cell>Openfire</cell><cell>25</cell><cell>Yes</cell></row><row><cell>Lucene</cell><cell>1</cell><cell>No</cell></row><row><cell cols="3">will be easier to discover, diagnose, and correct. The specifications</cell></row><row><cell cols="3">also serve as concise, unambiguous documentation.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 3 :</head><label>3</label><figDesc>Performance results. All times are in seconds.</figDesc><table><row><cell cols="3">Project Time (orig.) Time (Cozy)</cell></row><row><cell>ZTopo</cell><cell>5</cell><cell>5</cell></row><row><cell>Sat4j</cell><cell>53</cell><cell>61</cell></row><row><cell>Openfire</cell><cell>16</cell><cell>15</cell></row><row><cell>Lucene</cell><cell>9</cell><cell>9</cell></row><row><cell cols="3">concrete objects in memory, but implicit items due to condition 4 are</cell></row><row><cell cols="3">constructed on-demand to save memory. Developers had to write</cell></row><row><cell cols="3">a large amount of code to keep the implicit contacts correct when</cell></row><row><cell cols="3">groups change visibility or when group membership changes. That</cell></row><row><cell cols="3">code has been a frequent source of defects, and still has open issues.</cell></row><row><cell cols="3">For example, one issue still open at time of writing reports that</cell></row><row><cell cols="3">when administrators delete a user without first manually removing</cell></row><row><cell cols="3">her from all of her groups, she remains in other users' contact lists.</cell></row><row><cell cols="3">Other issues were caused by the stored state of the roster getting</cell></row><row><cell cols="3">out-of-sync with the abstract state of the roster. By contrast, a Cozy</cell></row><row><cell cols="3">programmer does not need to write the update code; Cozy discovers</cell></row><row><cell cols="3">its own data representation and determines how to update it in</cell></row><row><cell>response to changes.</cell><cell></cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">https://issues.igniterealtime.org/browse/OF-1121 2 https://community.igniterealtime.org/thread/60317</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>David Grant assisted with the Cozy implementation and the Lucene case study. This material is based upon work supported by the United States Air Force under Contract No. FA8750-15-C-0010, and on research sponsored by Air Force Research Laboratory and DARPA under agreement number FA8750-16-2-0032. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. This work is supported in part by NSF grant CCF-1651225, and the Intel and NSF joint research center for Computer Assisted Programming for Heterogeneous Architectures (CAPA).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Automated Selection of Materialized Views and Indexes in SQL Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Vivek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Narasayya</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=645926.671701" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Conference on Very Large Data Bases (VLDB &apos;00)</title>
		<meeting>the 26th International Conference on Very Large Data Bases (VLDB &apos;00)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="496" to="505" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">DBToaster: Higher-order Delta Processing for Dynamic, Frequently Fresh Views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yanif</forename><surname>Ahmad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oliver</forename><surname>Kennedy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milos</forename><surname>Nikolic</surname></persName>
		</author>
		<idno type="DOI">10.14778/2336664.2336670</idno>
		<ptr target="http://dx.doi.org/10.14778/2336664.2336670" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2012-06" />
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="968" to="979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Syntax-Guided Synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rastislav</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Garvit</forename><surname>Juniwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Milo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mukund</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Raghothaman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sanjit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Seshia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Singh</surname></persName>
		</author>
		<ptr target="http://ieeexplore.ieee.org/document/6679385/" />
	</analytic>
	<monogr>
		<title level="m">Formal Methods in Computer-Aided Design (FMCAD &apos;13)</title>
		<meeting><address><addrLine>Emina Torlak, and Abhishek Udupa</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Evaluating the &quot;Small Scope Hypothesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandr</forename><surname>Andoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dumitru</forename><surname>Daniliuc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sarfraz</forename><surname>Khurshid</surname></persName>
		</author>
		<idno>. MIT</idno>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">An Efficient Cost-Driven Index Selection Tool for Microsoft SQL Server</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Surajit</forename><surname>Chaudhuri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Vivek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Narasayya</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=645923.673646" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Very Large Data Bases (VLDB &apos;97)</title>
		<meeting>the 23rd International Conference on Very Large Data Bases (VLDB &apos;97)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="146" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Z3: An Efficient SMT Solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonardo</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolaj</forename><surname>Bjørner</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-78800-3_24</idno>
		<ptr target="http://dx.doi.org/10.1007/978-3-540-78800-3_24" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS/ETAPS &apos;08)</title>
		<meeting>the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS/ETAPS &apos;08)<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Fiat: Deductive Synthesis of Abstract Data Types in a Proof Assistant</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Delaware</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clément</forename><surname>Pit-Claudel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Chlipala</surname></persName>
		</author>
		<idno type="DOI">10.1145/2676726.2677006</idno>
		<ptr target="http://dx.doi.org/10.1145/2676726.2677006" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL &apos;15)</title>
		<meeting>the 42nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL &apos;15)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="689" to="700" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Programming by Refinement, As Exemplified by the SETL Representation Sublanguage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">K</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arthur</forename><surname>Dewar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ssu-Cheng</forename><surname>Grand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><forename type="middle">T</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edmond</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schonberg</surname></persName>
		</author>
		<idno type="DOI">10.1145/357062.357064</idno>
		<ptr target="http://dx.doi.org/10.1145/357062.357064" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="27" to="49" />
			<date type="published" when="1979-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Relational Level Data Structures for Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jay</forename><surname>Earley</surname></persName>
		</author>
		<idno type="DOI">10.1007/BF00289502</idno>
		<ptr target="http://dx.doi.org/10.1007/BF00289502" />
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="293" to="309" />
			<date type="published" when="1973-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">High Level Iterators and a Method for Automatically Designing Data Structure Representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jay</forename><surname>Earley</surname></persName>
		</author>
		<idno type="DOI">10.1016/0096-0551(75)90019-3</idno>
		<ptr target="http://dx.doi.org/10.1016/0096-0551(75" />
	</analytic>
	<monogr>
		<title level="j">Computer Languages</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="90019" to="90022" />
			<date type="published" when="1975-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Data Representation Synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Hawkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kathleen</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mooly</forename><surname>Sagiv</surname></persName>
		</author>
		<idno type="DOI">10.1145/1993498.1993504</idno>
		<ptr target="http://dx.doi.org/10.1145/1993498.1993504" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;11)</title>
		<meeting>the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;11)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="38" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Concurrent Data Representation Synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Hawkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kathleen</forename><surname>Fisher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rinard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mooly</forename><surname>Sagiv</surname></persName>
		</author>
		<idno type="DOI">10.1145/2254064.2254114</idno>
		<ptr target="http://dx.doi.org/10.1145/2254064.2254114" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;12)</title>
		<meeting>the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;12)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="417" to="428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Openfire real time collaboration server</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ignite</forename><surname>Realtime</surname></persName>
		</author>
		<ptr target="https://www.igniterealtime.org/projects/openfire/" />
		<imprint>
			<date type="published" when="2016-03-28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Elements of Style: Analyzing a Software Design Feature with a Counterexample Detector</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Jackson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Damon</surname></persName>
		</author>
		<idno type="DOI">10.1145/229000.226322</idno>
		<idno>ISSTA. 239-249. DOI</idno>
		<ptr target="http://dx.doi.org/10.1145/229000.226322" />
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Incremental View Maintenance For Collection Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christoph</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Lupei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Val</forename><surname>Tannen</surname></persName>
		</author>
		<idno type="DOI">10.1145/2902251.2902286</idno>
		<ptr target="http://dx.doi.org/10.1145/2902251.2902286" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems (PODS &apos;16)</title>
		<meeting>the 35th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems (PODS &apos;16)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="75" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast Synthesis of Fast Collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calvin</forename><surname>Loncaric</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emina</forename><surname>Torlak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<idno type="DOI">10.1145/2908080.2908122</idno>
		<ptr target="http://dx.doi.org/10.1145/2908080.2908122" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;16)</title>
		<meeting>the 37th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;16)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="355" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Sat4j Boolean Reasoning Library</title>
		<ptr target="https://www.sat4j.org" />
		<imprint>
			<date type="published" when="2016-02-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="http://www.satcompetition.org/" />
		<title level="m">SAT Competition</title>
		<imprint>
			<date type="published" when="2002-02-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An Automatic Technique for Selection of Data Representations in SETL Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edmond</forename><surname>Schonberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><forename type="middle">T</forename><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Micha</forename><surname>Sharir</surname></persName>
		</author>
		<idno type="DOI">10.1145/357133.357135</idno>
		<ptr target="http://dx.doi.org/10.1145/357133.357135" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="126" to="143" />
			<date type="published" when="1981-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Automatic Data Structure Choice in a Language of Very High Level</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schwartz</surname></persName>
		</author>
		<idno type="DOI">10.1145/512976.512981</idno>
		<ptr target="http://dx.doi.org/10.1145/512976.512981" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;75)</title>
		<meeting>the 2nd ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;75)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1975" />
			<biblScope unit="page" from="36" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Chameleon: Adaptive Selection of Collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ohad</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eran</forename><surname>Yahav</surname></persName>
		</author>
		<idno type="DOI">10.1145/1542476.1542522</idno>
		<ptr target="http://dx.doi.org/10.1145/1542476.1542522" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09)</title>
		<meeting>the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="408" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laure</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">Le</forename><surname>Berre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">A</forename><surname>Hirsch</surname></persName>
		</author>
		<idno type="DOI">10.1007/s10472-005-0424-6</idno>
		<ptr target="http://dx.doi.org/10.1007/s10472-005-0424-6" />
	</analytic>
	<monogr>
		<title level="m">The SAT2002 Competition</title>
		<imprint>
			<date type="published" when="2005-01-01" />
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="307" to="342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Synthesizing Data Structure Manipulations from Storyboards</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<idno type="DOI">10.1145/2025113.2025153</idno>
		<ptr target="http://dx.doi.org/10.1145/2025113.2025153" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on The Foundations of Software Engineering (ESEC/FSE &apos;11)</title>
		<meeting>the 19th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on The Foundations of Software Engineering (ESEC/FSE &apos;11)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="289" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">KIDS: A Semiautomatic Program Development System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Douglas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smith</surname></persName>
		</author>
		<idno type="DOI">10.1109/32.58788</idno>
		<ptr target="http://dx.doi.org/10.1109/32.58788" />
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1024" to="1043" />
			<date type="published" when="1990-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Designware: Software Development by Refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Douglas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Smith</surname></persName>
		</author>
		<idno type="DOI">10.1016/S1571-0661(05)80320-2</idno>
		<ptr target="http://dx.doi.org/10.1016/S1571-0661(05)80320-2" />
	</analytic>
	<monogr>
		<title level="j">Electronic Notes in Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="275" to="287" />
			<date type="published" when="1999-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Program Synthesis by Sketching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<idno>Rastislav. AAI3353225</idno>
		<imprint>
			<date type="published" when="2008" />
			<pubPlace>Berkeley, CA, USA</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of CA at Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Dissertation</note>
	<note>Advisor(s) Bodík</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Sketching Concurrent Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">Grant</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rastislav</forename><surname>Bodík</surname></persName>
		</author>
		<idno type="DOI">10.1145/1375581.1375599</idno>
		<ptr target="http://dx.doi.org/10.1145/1375581.1375599" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;08)</title>
		<meeting>the 29th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;08)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="136" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Combinatorial Sketching for Finite Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Armando</forename><surname>Solar-Lezama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liviu</forename><surname>Tancau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rastislav</forename><surname>Bodík</surname></persName>
		</author>
		<idno type="DOI">10.1145/1168917.1168907</idno>
		<ptr target="http://dx.doi.org/10.1145/1168917.1168907" />
	</analytic>
	<monogr>
		<title level="j">Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="404" to="415" />
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
	<note>Sanjit Seshia, and Vijay Saraswat</note>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">The Apache Software Foundation</title>
		<ptr target="https://lucene.apache.org" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note>Apache Lucene</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Staccato: A Bug Finder for Dynamic Configuration Updates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Grossman</surname></persName>
		</author>
		<idno type="DOI">10.4230/LIPIcs.ECOOP.2016.24</idno>
		<idno>1-24:25. DOI</idno>
		<ptr target="http://dx.doi.org/10.4230/LIPIcs.ECOOP.2016.24" />
	</analytic>
	<monogr>
		<title level="m">30th European Conference on Object-Oriented Programming (ECOOP &apos;16). Schloss Dagstuhl, Dagstuhl</title>
		<meeting><address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">24</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">TRANSIT: Specifying Protocols with Concolic Snippets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhishek</forename><surname>Udupa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arun</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jyotirmoy</forename><forename type="middle">V</forename><surname>Deshmukh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sela</forename><surname>Mador-Haim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milo</forename><forename type="middle">M K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Alur</surname></persName>
		</author>
		<idno type="DOI">10.1145/2491956.2462174</idno>
		<ptr target="http://dx.doi.org/10.1145/2491956.2462174" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;13)</title>
		<meeting>the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;13)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="287" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">ZTopo Topographic Map Viewer</title>
		<ptr target="https://hawkinsp.github.io/ZTopo/" />
		<imprint>
			<date type="published" when="2015-05-08" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
