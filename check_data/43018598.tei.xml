<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Understanding Real-World Concurrency Bugs in Go</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tengfei</forename><surname>Tu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoyu</forename><surname>Liu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linhai</forename><surname>Song</surname></persName>
							<email>songlh@ist.psu.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yiying</forename><surname>Zhang</surname></persName>
							<email>yiying@purdue.edu</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">BUPT</orgName>
								<orgName type="institution" key="instit2">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Purdue University</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution">Pennsylvania State University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Understanding Real-World Concurrency Bugs in Go</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3297858.3304069</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Go</term>
					<term>Concurrency Bug</term>
					<term>Bug Study</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Go is a statically-typed programming language that aims to provide a simple, efficient, and safe way to build multithreaded software. Since its creation in 2009, Go has matured and gained significant adoption in production and open-source software. Go advocates for the usage of message passing as the means of inter-thread communication and provides several new concurrency mechanisms and libraries to ease multi-threading programming. It is important to understand the implication of these new proposals and the comparison of message passing and shared memory synchronization in terms of program errors, or bugs. Unfortunately, as far as we know, there has been no study on Go&apos;s concurrency bugs. In this paper, we perform the first systematic study on concurrency bugs in real Go programs. We studied six popular Go software including Docker, Kubernetes, and gRPC. We analyzed 171 concurrency bugs in total, with more than half of them caused by non-traditional, Go-specific problems. Apart from root causes of these bugs, we also studied their fixes, performed experiments to reproduce them, and evaluated them with two publicly-available Go bug detectors. Overall, our study provides a better understanding on Go&apos;s concurrency models and can guide future researchers and practitioners in writing better, more reliable Go software and in developing debugging and diagnosis tools for Go. CCS Concepts • Computing methodologies → Concurrent programming languages; • Software and its engineering → Software testing and debugging.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Go <ref type="bibr" target="#b19">[20]</ref> is a statically typed language originally developed by <ref type="bibr">Google in 2009</ref>. Over the past few years, it has quickly gained attraction and is now adopted by many types of software in real production. These Go applications range from libraries <ref type="bibr" target="#b18">[19]</ref> and high-level software <ref type="bibr" target="#b24">[26]</ref> to cloud infrastructure software like container systems <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b34">36]</ref> and key-value databases <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b14">15]</ref>.</p><p>A major design goal of Go is to improve traditional multithreaded programming languages and make concurrent programming easier and less error-prone. For this purpose, Go centers its multi-threading design around two principles: 1) making threads (called goroutines) lightweight and easy to create and 2) using explicit messaging (called channel) to communicate across threads. With these design principles, Go proposes not only a set of new primitives and new libraries but also new implementation of existing semantics.</p><p>It is crucial to understand how Go's new concurrency primitives and mechanisms impact concurrency bugs, the type of bugs that is the most difficult to debug and the most widely studied <ref type="bibr" target="#b38">[40,</ref><ref type="bibr" target="#b41">43,</ref><ref type="bibr" target="#b43">45,</ref><ref type="bibr" target="#b55">57,</ref><ref type="bibr" target="#b59">61]</ref> in traditional multi-threaded programming languages. Unfortunately, there has been no prior work in studying Go concurrency bugs. As a result, to date, it is still unclear if these concurrency mechanisms actually make Go easier to program and less error-prone to concurrency bugs than traditional languages.</p><p>In this paper, we conduct the first empirical study on Go concurrency bugs using six open-source, productiongrade Go applications: Docker <ref type="bibr" target="#b12">[13]</ref> and Kubernetes <ref type="bibr" target="#b34">[36]</ref>, two datacenter container systems, etcd <ref type="bibr" target="#b14">[15]</ref>, a distributed key-value store system, gRPC <ref type="bibr" target="#b18">[19]</ref>, an RPC library, and Cock-roachDB <ref type="bibr" target="#b9">[10]</ref> and BoltDB <ref type="bibr" target="#b5">[6]</ref>, two database systems.</p><p>In total, we have studied 171 concurrency bugs in these applications. We analyzed the root causes of them, performed experiments to reproduce them, and examined their fixing patches. Finally, we tested them with two existing Go concurrency bug detectors (the only publicly available ones).</p><p>Our study focuses on a long-standing and fundamental question in concurrent programming: between message passing <ref type="bibr" target="#b25">[27,</ref><ref type="bibr" target="#b35">37]</ref> and shared memory, which of these inter-thread communication mechanisms is less error-prone <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b46">48]</ref>. Go is a perfect language to study this question, since it provides frameworks for both shared memory and message passing. However, it encourages the use of channels over shared memory with the belief that explicit message passing is less error-prone <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr">21]</ref>.</p><p>To understand Go concurrency bugs and the comparison between message passing and shared memory, we propose to categorize concurrency bugs along two orthogonal dimensions: the cause of bugs and their behavior. Along the cause dimension, we categorize bugs into those that are caused by misuse of shared memory and those caused by misuse of message passing. Along the second dimension, we separate bugs into those that involve (any number of) goroutines that cannot proceed (we call them blocking bugs) and those that do not involve any blocking (non-blocking bugs)</p><p>.</p><p>Surprisingly, our study shows that it is as easy to make concurrency bugs with message passing as with shared memory, sometimes even more. For example, around 58% of blocking bugs are caused by message passing. In addition to the violation of Go's channel usage rules (e.g., waiting on a channel that no one sends data to or close), many concurrency bugs are caused by the mixed usage of message passing and other new semantics and new libraries in Go, which can easily be overlooked but hard to detect.</p><p>To demonstrate errors in message passing, we use a blocking bug from Kubernetes in <ref type="figure">Figure 1</ref>. The finishReq function creates a child goroutine using an anonymous function at line 4 to handle a request-a common practice in Go server programs. The child goroutine executes fn() and sends result back to the parent goroutine through channel ch at line 6. The child will block at line 6 until the parent pulls result from ch at line 9. Meanwhile, the parent will block at select until either when the child sends result to ch (line 9) or when a timeout happens (line 11). If timeout happens earlier or if Go runtime (non-deterministically) chooses the case at line 11 when both cases are valid, the parent will return from requestReq() at line 12, and no one else can pull result from ch any more, resulting in the child being blocked forever. The fix is to change ch from an unbuffered channel to a buffered one, so that the child goroutine can always send the result even when the parent has exit. This bug demonstrates the complexity of using new features in Go and the difficulty in writing correct Go programs like this. Programmers have to have a clear understanding of goroutine creation with anonymous function, a feature Go proposes to ease the creation of goroutines, the usage of buffered vs. unbuffered channels, the non-determinism of waiting for multiple channel operations using select, and the special library time. Although each of these features were designed to ease multi-threaded programming, in reality, it is difficult to write correct Go programs with them.</p><p>Overall, our study reveals new practices and new issues of Go concurrent programming, and it sheds light on an answer to the debate of message passing vs. shared memory accesses. Our findings improve the understanding of Go concurrency and can provide valuable guidance for future tool design. This paper makes the following key contributions.</p><p>• We performed the first empirical study of Go concurrency bugs with six real-world, production-grade Go applications. • We made nine high-level key observations of Go concurrency bug causes, fixes, and detection. They can be useful for Go programmers' references. We further make eight insights into the implications of our study results to guide future research in the development, testing, and bug detection of Go. • We proposed new methods to categorize concurrency bugs along two dimensions of bug causes and behaviors. This taxonomy methodology helped us to better compare different concurrency mechanisms and correlations of bug causes and fixes. We believe other bug studies can utilize similar taxonomy methods as well.</p><p>All our study results and studied commit logs can be found at https://github.com/system-pclub/go-concurrency-bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background and Applications</head><p>Go is a statically-typed programming language that is designed for concurrent programming from day one <ref type="bibr" target="#b58">[60]</ref>. Almost all major Go revisions include improvements in its concurrency packages <ref type="bibr" target="#b21">[23]</ref>. This section gives a brief background on Go's concurrency mechanisms, including its thread model, inter-thread communication methods, and thread synchronization mechanisms. We also introduce the six Go applications we chose for this study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Goroutine</head><p>Go uses a concept called goroutine as its concurrency unit. Goroutines are lightweight user-level threads that the Go runtime library manages and maps to kernel-level threads in an M-to-N way. A goroutine can be created by simply adding the keyword go before a function call.</p><p>To make goroutines easy to create, Go also supports creating a new goroutine using an anonymous function, a function definition that has no identifier, or "name". All local variables declared before an anonymous function are accessible to the anonymous function, and are potentially shared between a parent goroutine and a child goroutine created using the anonymous function, causing data race (Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Synchronization with Shared Memory</head><p>Go supports traditional shared memory accesses across goroutines. It supports various traditional synchronization primitives like lock/unlock (Mutex), read/write lock (RWMutex), condition variable (Cond), and atomic read/write (atomic). Go's implementation of RWMutex is different from pthread_rwlock_t in C. Write lock requests in Go have a higher privilege than read lock requests.</p><p>As a new primitive introduced by Go, Once is designed to guarantee a function is only executed once. It has a Do method, with a function f as argument. When Once.Do(f) is invoked many times, only for the first time, f is executed.</p><p>Once is widely used to ensure a shared variable only be initialized once by multiple goroutines.</p><p>Similar to pthread_join in C, Go uses WaitGroup to allow multiple goroutines to finish their shared variable accesses before a waiting goroutine. Goroutines are added to a WaitGroup by calling Add. Goroutines in a WaitGroup use Done to notify their completion, and a goroutine calls Wait to wait for the completion notification of all goroutines in a WaitGroup. Misusing WaitGroup can cause both blocking bugs (Section 5) and non-blocking bugs (Section 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Synchronization with Message Passing</head><p>Channel (chan) is a new concurrency primitive introduced by Go to send data and states across goroutines and to build more complex functionalities <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b48">50]</ref>. Go supports two types of channels: buffered and unbuffered. Sending data to (or receiving data from) an unbuffered channel will block a goroutine, until another goroutine receives data from (or sends data to) the channel. Sending to a buffered channel will only block, when the buffer is full. There are several underlying rules in using channels and the violation of them can create concurrency bugs. For example, channel can only be used after initialization, and sending data to (or receiving data from) a nil channel will block a goroutine forever. Sending data to a closed channel or close an already closed channel can trigger a runtime panic.</p><p>The select statement allows a goroutine to wait on multiple channel operations. A select will block until one of its cases can make progress or when it can execute a default branch. When more than one cases in a select are valid, Go will randomly choose one to execute. This randomness can cause concurrency bugs as will be discussed in Section 6.</p><p>Go introduces several new semantics to ease the interaction across multiple goroutines. For example, to assist the programming model of serving a user request by spawning a set of goroutines that work together, <ref type="bibr">Go</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Go Applications</head><p>Recent years have seen a quick increase in popularity and adoption of the Go language. Go was the 9th most popular language on GitHub in 2017 <ref type="bibr" target="#b17">[18]</ref>. As of the time of writing, there are 187K GitHub repositories written in Go.</p><p>In this study, we selected six representative, real-world software written in Go, including two container systems (Docker and Kubernetes), one key-value store system (etcd), two databases (CockroachDB and BoltDB), and one RPC library (gRPC-go 1 ) ( <ref type="table">Table 1</ref>). These applications are opensource projects that have gained wide usages in datacenter environments. For example, Docker and Kubernetes are the top 2 most popular applications written in Go on GitHub, with 48.9K and 36.5K stars (etcd is the 10th, and the rest are ranked in top 100). Our selected applications all have at least three years of development history and are actively maintained by developers currently. All our selected applications are of middle to large sizes, with lines of code ranging from 9 thousand to more than 2 million. Among the six applications, Kubernetes and gRPC are projects originally developed by Google.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Go Concurrency Usage Patterns</head><p>Before studying Go concurrency bugs, it is important to first understand how real-world Go concurrent programs are like. This section presents our static and dynamic analysis results of goroutine usages and Go concurrency primitive usages in our selected six applications.</p><p>We will use gRPC to represent the gRPC version that is written Go in the following paper, unless otherwise specified.  <ref type="table">Table 3</ref>. Dynamic information when executing RPC benchmarks. The ratio of goroutine number divided by thread number and the average goroutine execution time normalized by the whole application's execution time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Goroutine Usages</head><p>To understand concurrency in Go, we should first understand how goroutines are used in real-world Go programs. One of the design philoshopies in Go is to make goroutines lightweight and easy to use. Thus, we ask "do real Go programmers tend to write their code with many goroutines (static)?" and "do real Go applications create a lot of goroutines during runtime (dynamic)?" To answer the first question, we collected the amount of goroutine creation sites (i.e., the source lines that create goroutines). <ref type="table">Table 2</ref> summarizes the results. Overall, the six applications use a large amount of goroutines. The average creation sites per thousand source lines range from 0.18 to 0.83. We further separate creation sites to those that use normal functions to create goroutines and those that use anonymous functions. All the applications except for Kubernetes and BoltDB use more anonymous functions.</p><p>To understand the difference between Go and traditional languages, we also analyzed another implementation of gRPC, gRPC-C, which is implemented in C/C++. gRPC-C contains 140K lines of code and is also maintained by Google's gRPC team. Compared to gRPC-Go, gRPC-C has surprisingly very few threads creation (only five creation sites and 0.03 sites per KLOC).</p><p>We further study the runtime creation of goroutines. We ran gRPC-Go and gRPC-C to process three performance benchmarks that were designed to compare the performance of multiple gRPC versions written in different programming languages <ref type="bibr" target="#b20">[22]</ref>. These benchmarks configure gRPC with different message formats, different numbers of connections, and synchronous vs. asynchronous RPC requests. Since gRPC-C is faster than gRPC-Go <ref type="bibr" target="#b20">[22]</ref>, we ran gRPC-C and gRPC-Go to process the same amount of RPC requests, instead of the same amount of total time.  <ref type="table">Table 3</ref> shows the ratio of the number of goroutines created in gRPC-Go over the number of threads created in gRPC-C when running the three workloads. More goroutines are created across different workloads for both the client side and the server side. <ref type="table">Table 3</ref> also presents our study results of goroutine runtime durations and compare them to gRPC-C's thread runtime durations. Since gRPC-Go and gRPC-C's total execution time is different and it is meaningless to compare absolute goroutine/thread duration, we report and compare the goroutine/thread duration relative to the total runtime of gRPC-Go and gRPC-C. Specifically, we calculate average execution time of all goroutines/threads and normalize it using the total execution time of the programs. We found all threads in gRPC-C execute from the beginning to the end of the whole program (i.e., 100%) and thus only included the results of gRPC-Go in <ref type="table">Table 3</ref>. For all workloads, the normalized execution time of goroutines is shorter than threads. Observation 1: Goroutines are shorter but created more frequently than C (both statically and at runtime).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Concurrency Primitive Usages</head><p>After a basic understanding of goroutine usages in real-world Go programs, we next study how goroutines communicate and synchronize in these programs. Specifically, we calculate the usages of different types of concurrency primitives in the six applications. <ref type="table">Table 4</ref> presents the total (absolute amount of primitive usages) and the proportion of each type of primitive over the total primitives. Shared memory synchronization operations are used more often than message passing, and Mutex is the most widely-used primitive across all applications. For message-passing primitives, chan is the one used most frequently, ranging from 18.48% to 42.99%.</p><p>We further compare the usages of concurrency primitives in gRPC-C and in gRPC-Go. gRPC-C only uses lock, and it is used in 746 places (5.3 primitive usages per KLOC). gRPC-Go uses eight different types of primitives in 786 places (14.8 primitive usages per KLOC). Clearly, gRPC-Go uses a larger amount of and a larger variety of concurrency primitives than gRPC-C.</p><p>Next, we study how the usages of concurrency primitives change over time. <ref type="figure" target="#fig_1">Figures 2 and 3</ref> present the shared-memory and message-passing primitive usages in the six applications from Feb 2015 to May 2018. Overall, the usages tend to be stable over time, which also implies that our study results will be valuable for future <ref type="bibr">Go</ref>    </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Bug Study Methodology</head><p>This section discusses how we collected, categorized, and reproduced concurrency bugs in this study.</p><p>Collecting concurrency bugs. To collect concurrency bugs, we first filtered GitHub commit histories of the six applications by searching their commit logs for concurrencyrelated keywords, including "race", "deadlock", "synchronization", "concurrency", "lock", "mutex", "atomic", "compete", "context", "once", and "goroutine leak". Some of these keywords are used in previous works to collect concurrency bugs in other languages <ref type="bibr" target="#b38">[40,</ref><ref type="bibr" target="#b40">42,</ref><ref type="bibr" target="#b43">45]</ref>. Some of them are related to new concurrency primitives or libraries introduced by Go, such as "once" and "context". One of them, "goroutine leak", is related to a special problem in Go. In total, we found 3211 distinct commits that match our search criteria. We then randomly sampled the filtered commits, identified commits that fix concurrency bugs, and manually studied them. Many bug-related commit logs also mention the corresponding bug reports, and we also study these reports for our bug analysis. We studied 171 concurrency bugs in total. Bug taxonomy. We propose a new method to categorize Go concurrency bugs according to two orthogonal dimensions.</p><p>The first dimension is based on the behavior of bugs. If one or more goroutines are unintentionally stuck in their execution and cannot move forward, we call such concurrency issues blocking bugs. If instead all goroutines can finish their tasks but their behaviors are not desired, we call them non-blocking ones. Most previous concurrency bug studies <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b41">43,</ref><ref type="bibr" target="#b43">45]</ref> categorize bugs into deadlock bugs and non-deadlock bugs, where deadlocks include situations where there is a circular wait across multiple threads. Our definition of blocking is broader than deadlocks and include situations where there is no circular wait but one (or more) goroutines wait for resources that no other goroutines supply. As we will show in Section 5, quite a few Go concurrency bugs are of this kind. We believe that with new programming habits and semantics with new languages like Go, we should pay more attention to these non-deadlock blocking bugs and extend the traditional concurrency bug categorization mechanism.</p><p>The second dimension is along the cause of concurrency bugs. Concurrency bugs happen when multiple threads try to communicate and errors happen during such communication. Our idea is thus to categorize causes of concurrency bugs by how different goroutines communicate: by accessing shared memory or by passing messages. This categorization can help programmers and researchers choose better ways to perform inter-thread communication and to detect and avoid potential errors when performing such communication.</p><p>According to our categorization method, there are a total of 85 blocking bugs and 86 non-blocking bugs, and there are a total of 105 bugs caused by wrong shared memory protection and 66 bugs caused by wrong message passing. <ref type="table" target="#tab_4">Table 5</ref> shows the detailed breakdown of bug categories across each application.</p><p>We further analyzed the life time of our studied bugs, i.e., the time from when the buggy code was added (committed) to the software to when it is being fixed in the software (a bugfixing patch is committed). As shown in <ref type="figure">Figure 4</ref>, most bugs we study (both shared memory and message passing) have long life time. We also found the time when these bugs were report to be close to when they were fixed. These results show that most of the bugs we study are not easy to be  <ref type="table" target="#tab_4">Docker  9  0  3  5  2  2  Kubernetes   2  0  3  6  0  etcd   0  0  10  5  1  CockroachDB   3  0  5  0  0  gRPC   0  0  6  2  1  BoltDB   0  0  0  1</ref>  triggered or detected, but once they are, they got fixed very soon. Thus, we believe these bugs are non-trivial and worth close examination.</p><formula xml:id="formula_0">0 Total 3</formula><p>Reproducing concurrency bugs. In order to evaluate the built-in deadlock and data-race detection techniques, we reproduced 21 blocking bugs and 20 non-blocking bugs. To reproduce a bug, we rolled the application back to the buggy version, built the buggy version, and ran the built program using the bug-triggering input described in the bug report. We leveraged the symptom mentioned in the bug report to decide whether we have successfully reproduced a bug. Due to their non-deterministic nature, concurrency bugs are difficult to reproduce. Sometimes, we needed to run a buggy program a lot of times or manually add sleep to a buggy program. For a bug that is not reproduced, it is either because we do not find some dependent libraries, or because we fail to observe the described symptom. Threats to validity. Threats to the validity of our study could come from many aspects. We selected six representative Go applications. There are many other applications implemented in Go and they may not share the same concurrency problems. We only studied concurrency bugs that have been fixed. There could be other concurrency bugs that are rarely reproduced and are never fixed by developers. For some fixed concurrency bugs, there is too little information provided, making them hard to understand. We do not include these bugs in our study. Despite these limitations, we have made our best efforts in collecting real-world Go concurrency bugs and in conducting a comprehensive and unbiased study. We believe that our findings are general enough to motivate and guide future research on fighting Go concurrency bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Blocking Bugs</head><p>This section presents our study results on blocking bugs, including their root causes, fixes, and the effectiveness of the built-in runtime Go deadlock detector on detecting blocking situations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Root Causes of Blocking Bugs</head><p>Blocking bugs manifest when one or more goroutines conduct operations that wait for resources, and these resources are never available. To detect and avoid blocking bugs, it is important to understand their root causes. We study blocking bugs' root causes by examining which operation blocks a goroutine and why the operation is not unblocked by other goroutines. Using our second dimension of bug categorization, we separate blocking bugs into those that are caused by stuck operations that are intended to protect shared memory accesses and those that are caused by message passing operations. <ref type="table" target="#tab_6">Table 6</ref> summarizes the root causes of all the blocking bugs. Overall, we found that there are around 42% blocking bugs caused by errors in protecting shared memory, and 58% are caused by errors in message passing. Considering that shared memory primitives are used more frequently than message passing ones (Section 3.2), message passing operations are even more likely to cause blocking bugs. Observation 3: Contrary to the common belief that message passing is less error-prone, more blocking bugs in our studied Go applications are caused by wrong message passing than by wrong shared memory protection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">(mis)Protection of Shared Memory</head><p>Shared memory accesses are notoriously hard to program correctly and have always been one of the major focuses on deadlock research <ref type="bibr" target="#b33">[35,</ref><ref type="bibr" target="#b49">51,</ref><ref type="bibr" target="#b52">54]</ref>. They continue to cause blocking bugs in Go, both with traditional patterns and new, Go-specific reasons. Mutex 28 blocking bugs are caused by misusing locks (Mutex), including double locking, acquiring locks in conflicting orders, and forgetting to unlock. All bugs in this category are traditional bugs, and we believe traditional deadlock detection algorithms should be able to detect these bugs with static program analysis. RWMutex As explained in Section 2.2, Go's write lock requests have a higher privilege than read lock requests. This unique lock implementation can lead to a blocking bug when a goroutine (th-A) acquires one RWMutex twice with read locking, and these two read lock operations are interleaved by a write lock operation from another goroutine (th-B). When th-A's first read lock operation succeeds, it will block th-B's write lock operation, since write locking is exclusive. However, th-B's write lock operation will also block th-A's second read lock operation, since the write lock request has a higher privilege in Go's implementation. Neither th-A nor th-B will be able to proceed.</p><p>Five blocking bugs are caused by this reason. Note that the same interleaving locking pattern will not cause blocking bugs for pthread_rwlock_t in C, since pthread_rwlock_t prioritize read lock requests under the default setting. The RWMutex blocking bug type implies that even when Go uses the same concurrency semantics as traditional languages, there can still be new types of bugs because of Go's new implementation of the semantics. Wait Three blocking bugs are due to wait operations that cannot proceed. Unlike Mutex and RWMutex related bugs, they do not involve circular wait. Two of these bugs happen when Cond is used to protect shared memory accesses and one goroutine calls Cond.Wait(), but no other goroutines call Cond.Signal() (or Cond.Broadcast()) after that.</p><p>The third bug, Docker#25384, happens with the use of a shared variable of type WaitGroup, as shown in <ref type="figure">Figure 5</ref>. The Wait() at line 7 can only be unblocked, when Done() at line 5 is invoked len(pm.plugins) times, since len(pm.plugins) is used as parameter to call Add() at line 2. However, the Wait() is called inside the loop, so that it blocks goroutine creation at line 4 in later iterations and it blocks the invocation of Done() inside each created goroutine. The fix of this bug is to move the invocation of Wait() out from the loop.</p><p>Although conditional variable and thread group wait are both traditional concurrency techniques, we suspect Go's new programming model to be one of the reasons why programmers made these concurrency bugs. For example, unlike pthread_join which is a function call that explicitly waits on the completion of (named) threads, WaitGroup is a variable that can be shared across goroutines and its Wait function implicitly waits for the Done function. Observation 4: Most blocking bugs that are caused by shared memory synchronization have the same causes and same fixes as traditional languages. However, a few of them are different from traditional languages either because of Go's new implementation of existing primitives or its new programming semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Misuse of Message Passing</head><p>We now discuss blocking bugs caused by errors in message passing, which in the contrary of common belief are the main type of blocking bugs in our studied applications. Channel Mistakes in using channel to pass messages across goroutines cause 29 blocking bugs. Many of the channelrelated blocking bugs are caused by the missing of a send to (or receive from) a channel or closing a channel, which will result in the blocking of a goroutine that waits to receive from (or send to) the channel. One such example is <ref type="figure">Figure 1</ref>.</p><p>When combining with the usage of Go special libraries, the channel creation and goroutine blocking may be buried inside library calls. As shown in <ref type="figure">Figure 6, a</ref>   <ref type="figure">Figure 6</ref>. A blocking bug caused by context. object, hcancel, is created at line 1. A new goroutine is created at the same time, and messages can be sent to the new goroutine through the channel field of hcancel. If timeout is larger than 0 at line 4, another context object is created at line 5, and hcancel is pointing to the new object. After that, there is no way to send messages to or close the goroutine attached to the old object. The patch is to avoid creating the extra context object when timeout is larger than 0.  Channel and other blocking primitives For 16 blocking bugs, one goroutine is blocked at a channel operation, and another goroutine is blocked at lock or wait. For example, as shown in <ref type="figure" target="#fig_5">Figure 7</ref>, goroutine1 is blocked at sending request to channel ch, while goroutine2 is blocked at m.Lock(). The fix is to add a select with default branch for goroutine1 to make ch not blocking any more. Messaging libraries Go provides several libraries to pass data or messages, like Pipe. These special library calls can also cause blocking bugs when not used correctly. For example, similar to channel, if a Pipe is not closed, a goroutine can be blocked when it tries to send data to or pull data from the unclosed Pipe. There are 4 collected blocking bugs caused by special Go message-passing library calls.  <ref type="table">Table 7</ref>. Fix strategies for blocking bugs. The subscript s stands for synchronization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Fixes of Blocking Bugs</head><p>After understanding the causes of blocking bugs in Go, we now analyze how Go programmers fixed these bugs in the real world.</p><p>Eliminating the blocking cause of a hanging goroutine will unblock it and this is the general approach to fix blocking bugs. To achieve this goal, Go developers often adjust synchronization operations, including adding missing ones, moving or changing misplaced/misused ones, and removing extra ones. <ref type="table">Table 7</ref> summarizes these fixes.</p><p>Most blocking bugs caused by mistakenly protecting shared memory accesses were fixed by methods similar to traditional deadlock fixes. For example, among the 33 Mutexor RWMutex-related bugs, 8 were fixed by adding a missing unlock; 9 were fixed by moving lock or unlock operations to proper locations; and 11 were fixed by removing an extra lock operation.</p><p>11 blocking bugs caused by wrong message passing were fixed by adding a missing message or closing operation to a channel (and on two occasions, to a pipe) on a goroutine different from the blocking one. 8 blocking bugs were fixed by adding a select with a default option (e.g., <ref type="figure" target="#fig_5">Figure 7</ref>) or a case with operation on a different channel. Another common fix of channel-related blocking bugs is to replace an unbuffered channel with a buffered channel (e.g., <ref type="figure">Figure 1</ref>). Other channel-related blocking bugs can be fixed by strategies such as moving a channel operation out of a critical section and replacing channel with shared variables.</p><p>To understand the relationship between the cause of a blocking bug and its fix, we apply a statistical metric called lift, following previous empirical studies on real-world bugs <ref type="bibr" target="#b27">[29,</ref><ref type="bibr" target="#b39">41]</ref>. lift is calculated as lift(A, B) = P (AB) P (A)P (B) , where A denotes a root cause category, B denotes a fix strategy category, P (AB) denotes the probability that a blocking is caused by A and fixed by B. When lift value is equal to 1, A root cause is independent with B fix strategy. When lift value is larger than 1, A and B are positively correlated, which means if a blocking is caused by A, it is more likely to be fixed by B. When lift is smaller than 1, A and B are negatively correlated.</p><p>Among all the bug categories that have more than 10 blocking bugs (we omit categories that have less than 10 bugs because of their statistical insignificance), Mutex is the category that has the strongest correlation to a type of fix-it correlates with Move s with lift value 1. <ref type="bibr" target="#b50">52</ref> We also analyzed the fixes of blocking bugs according to the type of concurrency primitives used in the patches. As expected, most bugs whose causes are related to a certain type of primitive were also fixed by adjusting that primitive. For example, all Mutex-related bugs were fixed by adjusting Mutex primitives.</p><p>The high correlation of bug causes and the primitives and strategies used to fix them, plus the limited types of synchronization primitives in Go, suggests fruitful revenue in investigating automatic correction of blocking bugs in Go. We further find that the patch size of our studied blocking bugs is small, with an average of 6.8 lines of code. Around 90% of studied blocking bugs are fixed by adjusting synchronization primitives. Observation 6: Most blocking bugs in our study (both traditional shared-memory ones and message passing ones) can be fixed with simple solutions and many fixes are correlated with bug causes. Implication 3: High correlation between causes and fixes in Go blocking bugs and the simplicity in their fixes suggest that it is promising to develop fully automated or semi-automated tools to fix blocking bugs in Go.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Detection of Blocking Bugs</head><p>Go provides a built-in deadlock detector that is implemented in the goroutine scheduler. The detector is always enabled during Go runtime and it reports deadlock when no goroutines in a running process can make progress. We tested all our reproduced blocking bugs with Go's built-in deadlock detector to evaluate what bugs it can find. For every tested bug, the blocking can be triggered deterministically in every run. Therefore, for each bug, we only ran it once in this experiment. <ref type="table" target="#tab_9">Table 8</ref> summarizes our test results.</p><p>The built-in deadlock detector can only detect two blocking bugs, BoltDB#392 and BoltDB#240, and fail in all other cases (although the detector does not report any false positives <ref type="bibr" target="#b36">[38,</ref><ref type="bibr" target="#b37">39]</ref>). There are two reasons why the built-in detector failed to detect other blocking bugs. First, it does not consider the monitored system as blocking when there are still some running goroutines. Second, it only examines whether or not goroutines are blocked at Go concurrency primitives but does not consider goroutines that wait for other systems  <ref type="table" target="#tab_6">Docker  9  6  0  1  6  1  Kubernetes  8      0  etcd   0  2  2  3  0  CockroachDB  10  1  3  2  0  0  gRPC  8  1  0  1  2  0  BoltDB  2</ref>   resources. These two limitations were largely due to the design goal of the built-in detector-minimal runtime overhead. When implemented in the runtime scheduler, it is very hard for a detector to effectively identify complex blocking bugs without sacrificing performance. Implication 4: Simple runtime deadlock detector is not effective in detecting Go blocking bugs. Future research should focus on building novel blocking bug detection techniques, for example, with a combination of static and dynamic blocking pattern detection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Non-Blocking Bugs</head><p>This section presents our study on non-blocking bugs. Similar to what we did in Section 5, we studied the root causes and fixes of non-blocking bugs and evaluated a built-in race detector of Go.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Root Causes of Non-blocking Bugs</head><p>Similar to blocking bugs, we also categorize our collected non-blocking bugs into those that were caused by failing to protect shared memory and those that have errors with message passing <ref type="table" target="#tab_10">(Table 9</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Failing to Protect Shared Memory</head><p>Previous work <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b44">46,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b50">52,</ref><ref type="bibr" target="#b60">[62]</ref><ref type="bibr" target="#b61">[63]</ref><ref type="bibr" target="#b62">[64]</ref> found that not protecting shared memory accesses or errors in such protection are the main causes of data race and other non-deadlock bugs. Similarly, we found around 80% of our collected nonblocking bugs are due to un-protected or wrongly protected shared memory accesses. However, not all of them share the same causes as non-blocking bugs in traditional languages. Traditional bugs More than half of our collected nonblocking bugs are caused by traditional problems that also happen in classic languages like C and Java, such as atomicity violation <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b44">46]</ref>, order violation <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b45">47,</ref><ref type="bibr" target="#b60">62,</ref><ref type="bibr" target="#b62">64]</ref>, and data race <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b50">52,</ref><ref type="bibr" target="#b61">63]</ref>. This result shows that same mistakes are made by developers across different languages. It also indicates that it is promising to apply existing concurrency bug detection algorithms to look for new bugs in Go. Interestingly, we found seven non-blocking bugs whose root causes are traditional but are largely caused by the lack of a clear understanding in new Go features. For example,   Unfortunately, this ease of programming can increase the chance of data-race bugs when goroutines are created with anonymous functions, since developers may not pay enough attention to protect such shared local variables. We found 11 bugs of this type, 9 of which are caused by a data race between a parent goroutine and a child goroutine created using an anonymous function. The other two are caused by a data race between two child goroutines. One example from Docker is shown in <ref type="figure">Figure 8</ref>. Local variable i is shared between the parent goroutine and the goroutines it creates at line 2. The developer intends each child goroutine uses a distinct i value to initialize string apiVersion at line 4. However, values of apiVersion are non-deterministic in the buggy program. For example, if the child goroutines begin after the whole loop of the parent goroutine finishes, value of apiVersion are all equal to 'v1.21'. The buggy program only produces desired result when each child goroutine initializes string apiVersion immediately after its creation and before i is assigned to a new value. Docker developers fixed this bug by making a copy of the shared variable i at every iteration and pass the copied value to the new goroutines. Misusing WaitGroup There is an underlying rule when using WaitGroup, which is that Add has to be invoked before Wait. The violation of this rule causes 6 non-blocking bugs. <ref type="figure" target="#fig_10">Figure 9</ref> shows one such bug in etcd, where there is no guarantee that Add at line 8 of func1 happens before Wait at line 5 of func2. The fix is to move Add into a critical section, which ensures that Add will either be executed before Wait or it will not be executed. Special libraries Go provides many new libraries, some of which use objects that are implicitly shared by multiple goroutines. If they are not used correctly, data race may happen. For example, the context object type is designed to be accessed by multiple goroutines that are attached to the context. etcd#7816 is a data-race bug caused by multiple goroutines accessing the string field of a context object.</p><p>Another example is the testing package which is designed to support automated testing. A testing function (identified by beginning the function name with "Test") takes only one parameter of type testing.T, which is used to pass testing states such as error and log. Three data-race bugs are caused by accesses to a testing.T variable from the goroutine running the testing function and other goroutines created inside the testing function. Observation 7: About two-thirds of shared-memory nonblocking bugs are caused by traditional causes. Go's new multithread semantics and new libraries contribute to the rest onethird. Implication 5: New programming models and new libraries that Go introduced to ease multi-thread programming can themselves be the reasons of more concurrency bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Errors during Message Passing</head><p>Errors during message passing can also cause non-blocking bugs and they comprise around 20% of our collected nonblocking bugs.</p><p>Misusing channel As what we discussed in Section 2, there are several rules when using channel, and violating them can lead to non-blocking bugs in addition to blocking ones. There are 16 non-blocking bugs caused by misuse of channel. As an example, Docker#24007 in <ref type="figure">Figure 10</ref> is caused by the violation of the rule that a channel can only be closed once. When multiple goroutines execute the piece of code, more than one of them can execute the default clause and try to close the channel at line 5, causing a runtime panic in Go. The fix is to use Once package to enforce that the channel is only closed once.</p><p>Another type of concurrency bugs happen when using channel and select together. In Go, when multiple messages received by a select, there is no guarantee which one will be processed first. This non-determinism implementation of select caused 3 bugs. <ref type="figure">Figure 11</ref> shows one such example. The loop at line 2 executes a heavy function f() at line 8 whenever a ticker ticks at line 12 (case 2) and stops its execution when receiving a message from channel stopCh at line 10 (case 1). If receiving a message from stopCh and the ticker ticks at the same time, there is no guarantee which one will be chosen by select. If select chooses case 2, f() will be executed unnecessarily one more time. The fix is to add another select at the beginning of the loop to handle the unprocessed signal from stopCh. Special libraries Some of Go's special libraries use channels in a subtle way, which can also cause non-blocking bugs. <ref type="figure">Figure 12</ref> shows one such bug related to the time package which is designed for measuring time. Here, a timer is created with timeout duration 0 at line 1. At the creation time of a Timer object, Go runtime (implicitly) starts a libraryinternal goroutine which starts timer countdown. The timer is set with a timeout value dur at line 4. Developers here intended to return from the current function only when dur is larger than 0 or when ctx.Done(). However, when dur is not greater than 0, the library-internal goroutine will signal the timer.C channel as soon as the creation of the timer, causing the function to return prematurely (line 8). The fix is to avoid the Timer creation at line 1. Observation 8: There are much fewer non-blocking bugs caused by message passing than by shared memory accesses.   <ref type="table">Table 11</ref>. Synchronization primitives in patches of non-blocking bugs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Rules of channel and complexity of using channel with other</head><p>Go-specific semantics and libraries are the reasons why these non-blocking bugs happen. Implication 6: When used correctly, message passing can be less prone to non-blocking bugs than shared memory accesses. However, the intricate design of message passing in a language can cause these bugs to be especially hard to find when combining with other language-specific features.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Fixes of Non-Blocking Bugs</head><p>Similar to our analysis of blocking bug fixes, we first analyze fixes of non-blocking bugs by their strategies. <ref type="table" target="#tab_12">Table 10</ref> categorizes the fix strategies of our studied Go non-blocking bugs, in a similar way as a previous categorization of nonblocking bug fixes in C/C++ <ref type="bibr" target="#b41">[43]</ref>. Around 69% of the non-blocking bugs were fixed by restricting timing, either through adding synchronization primitives like Mutex, or through moving existing primitives like moving Add in <ref type="figure" target="#fig_10">Figure 9</ref>. 10 non-blocking bugs were fixed by eliminating instructions accessing shared variables or by bypassing the instructions (e.g., <ref type="figure">Figure 10</ref>). 14 bugs were fixed by making a private copy of the shared variable (e.g., <ref type="figure">Figure 8</ref>) and these bugs are all shared-memory ones.</p><p>To have a better understanding of non-blocking bug fixes and their relationship to bug causes, we further check what primitives are leveraged inside patches. <ref type="table">Table 11</ref> lists the fixes according to the type of primitives used in the patches.</p><p>Similar to the results of a previous study on patches of concurrency bugs in C/C++ <ref type="bibr" target="#b41">[43]</ref>, mutex is the most widely used primitive to enforce mutual exclusion and fix non-blocking bugs. Besides traditional bugs, mutex was also used to fix races caused by anonymous function and by WaitGroup and to replace misused channel.</p><p>As a new primitive, channel is the second most widelyused. Channel was leveraged to pass value between two  <ref type="table">Table 12</ref>. Benchmarks and evaluation results of the data race detector. We consider a bug detected within runs as a detected bug.</p><p>goroutines and to replace shared variable to fix data race. It was also used to enforce the order between two operations in different goroutines. There are also bugs where channel is not properly used and is fixed in the patch (e.g., <ref type="figure">Figure 10</ref>).</p><p>Interestingly, channels were not only used to fix messagepassing bugs but also bugs caused by traditional shared memory synchronization. We suspect this is because some Go programmers view message passing as a more reliable way or easier-to-program way of performing inter-thread communication than shared memory synchronization.</p><p>Finally, 24 bugs were fixed by other concurrency primitives and 19 bugs were fixed without using any concurrency primitives (e.g., <ref type="figure">Figure 8</ref>).</p><p>Similar to our lift analysis in Section 5.2, we calculate lift between causes and fix strategies and between causes and fix primitives for non-blocking bugs. Among bug categories with more than 10 bugs, the strongest correlation is between the cause misusing channel and fix primitive channel, with a lift value of 2.7. The cause anonymous function and the fix strategy data private has the second highest lift value of 2.23. Next, Misusing channel is strongly correlated with Move s with lift value 2.21. Observation 9: Traditional shared memory synchronization techniques remain to be the main fixes for non-blocking bugs in Go, while channel is used widely to fix not only channel-related bugs but also shared-memory bugs. Implication 7: While Go programmers continue to use traditional shared memory protection mechanisms to fix nonblocking bugs, they prefer the use of message passing as a fix in certain cases possibly because they view message passing as a safer way to communicate across threads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Detection of Non-Blocking Bugs</head><p>Go provides a data race detector which uses the same happenbefore algorithm as ThreadSanitizer <ref type="bibr" target="#b51">[53]</ref>. It can be enabled by building a program using the '-race' flag. During program execution, the race detector creates up to four shadow words for every memory object to store historical accesses of the object. It compares every new access with the stored shadow word values to detect possible races.</p><p>We use our 20 reproduced non-blocking bugs to evaluate how many bugs the detector can detect. We ran each buggy program 100 times with the race detector turned on. <ref type="table">Table 12</ref> summarizes the number of bugs detected under each root cause category. The detector reports no false positives.</p><p>The data race detector successfully detected 7/13 traditional bugs and 3/4 bugs caused by anonymous functions. For six of these successes, the data race detector reported bugs on every run, while for the rest four, around 100 runs were needed before the detector reported a bug.</p><p>There are three possible reasons why the data race detector failed to report many non-blocking bugs. First, not all non-blocking bugs are data races; the race detector was not designed to detect these other types. Second, the effectiveness of the underlying happen-before algorithm depends on the interleaving of concurrent goroutines. Finally, with only four shadow words for each memory object, the detector cannot keep a long history and may miss data races. Implication 8: Simple traditional data race detector cannot effectively detect all types of Go non-blocking bugs. Future research can leverage our bug analysis to develop more informative, Go-specific non-blocking bug detectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Discussion and Future Work</head><p>Go advocates for making thread creation easy and lightweight and for using message passing over shared memory for inter-thread communication. Indeed, we saw more goroutines created in Go programs than traditional threads and there are significant usages of Go channel and other message passing mechanisms. However, our study show that if not used correctly, these two programming practices can potentially cause concurrency bugs. Shared memory vs. message passing. Our study found that message passing does not necessarily make multithreaded programs less error-prone than shared memory. In fact, message passing is the main cause of blocking bugs. To make it worse, when combined with traditional synchronization primitives or with other new language features and libraries, message passing can cause blocking bugs that are very hard to detect. Message passing causes less nonblocking bugs than shared memory synchronization and surprisingly, was even used to fix bugs that are caused by wrong shared memory synchronization. We believe that message passing offers a clean form of inter-thread communication and can be useful in passing data and signals. But they are only useful if used correctly, which requires programmers to not only understand message passing mechanisms well but also other synchronization mechanisms of Go. Implication on bug detection. Our study reveals many buggy code patterns that can be leveraged to conduct concurrency bug detection. As a preliminary effort, we built a detector targeting the non-blocking bugs caused by anonymous functions (e.g. <ref type="figure">Figure 8</ref>). Our detector has already discovered a few new bugs, one of which has been confirmed by real application developers <ref type="bibr" target="#b11">[12]</ref>.</p><p>More generally, we believe that static analysis plus previous deadlock detection algorithms will still be useful in detecting most Go blocking bugs caused by errors in shared memory synchornization. Static technologies can also help in detecting bugs that are caused by the combination of channel and locks, such as the one in <ref type="figure" target="#fig_5">Figure 7</ref>.</p><p>Misusing Go libraries can cause both blocking and nonblocking bugs. We summarized several patterns about misusing Go libraries in our study. Detectors can leverage the patterns we learned to reveal previously unknown bugs.</p><p>Our study also found the violation of rules Go enforces with its concurrency primitives is one major reason for concurrency bugs. A novel dynamic technique can try to enforce such rules and detect violation at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Related Works</head><p>Studying Real-World Bugs. There are many empirical studies on real-world bugs <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b27">29,</ref><ref type="bibr" target="#b38">40,</ref><ref type="bibr" target="#b42">44,</ref><ref type="bibr" target="#b43">45]</ref>. These studies have successfully guided the design of various bugcombating techniques. To the best of our knowledge, our work is the first study focusing on concurrency bugs in Go and the first to compare bugs caused by errors when accessing shared memory and errors when passing messages. Combating Blocking Bugs. As a traditional problem, there are many research works fighting deadlocks in C and Java <ref type="bibr">[7, 28, 33-35, 51, 54, 55, 58, 59]</ref>. Although useful, our study shows that there are many non-deadlock blocking bugs in Go, which are not the goal of these techniques. Some techniques are proposed to detect blocking bugs caused by misusing channel <ref type="bibr" target="#b36">[38,</ref><ref type="bibr" target="#b37">39,</ref><ref type="bibr" target="#b47">49,</ref><ref type="bibr" target="#b54">56]</ref>. However, blocking bugs can be caused by other primitives. Our study reveals many code patterns for blocking bugs that can serve the basis for future blocking bug detection techniques. Combating Non-Blocking Bugs. Many previous research works are conducted to detect, diagnose and fix non-deadlock bugs, caused by failing to synchronize shared memory accesses <ref type="bibr">[4, 5, 8, 14, 16, 17, 30-32, 43, 46, 47, 52, 62-64]</ref>. They are promising to be applied to Go concurrency bugs. However, our study finds that there is a non-negligible portion of non-blocking bugs caused by errors during message passing, and these bugs are not covered by previous works. Our study emphasizes the need of new techniques to fight errors during message passing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>As a programming language designed for concurrency, Go provides lightweight goroutines and channel-based message passing between goroutines. Facing the increasing usage of Go in various types of applications, this paper conducts the first comprehensive, empirical study on 171 real-world Go concurrency bugs from two orthogonal dimensions. Many interesting findings and implications are provided in our study. We expect our study to deepen the understanding of Go concurrency bugs and bring more attention to Go concurrency bugs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>1 func 14 }Figure 1 .</head><label>1141</label><figDesc>finishReq(timeout time.Duration) r ob { 2 -ch := make(chan ob) 3 + ch := make(chan ob, 1) A blocking bug caused by channel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Usages of Message-Passing Primitives over Time. For each application, we calculate the proportion of message-passing primitives over all primitives.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .Observation 2 :</head><label>42</label><figDesc>Bug Life Time. The CDF of the life time of all shared-memory bugs and all message-passing bugs. Although traditional shared memory thread communication and synchronization remains to be heavily used, Go programmers also use significant amount of messagepassing primitives. Implication 1: With heavier usages of goroutines and new types of concurrency primitives, Go programs may potentially introduce more concurrency bugs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>var 6 } 7 - 8 } 9 +Figure 5 .</head><label>67895</label><figDesc>group sync.WaitGroup 2 group.Add(len(pm.plugins)) 3 for _, p := range pm.plugins { 4 go func(p *plugin) { 5 defer group.Done() group.Wait() group.Wait() A blocking bug caused by WaitGroup.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>A blocking bug caused by wrong usage of channel with lock.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>1 8 }Figure 8 . 2 p</head><label>882</label><figDesc>for i := 17; i &lt;= 21; i++ { // write 2 -go func() { /* Create a new goroutine */ 3 + go func(i int) { 4 apiVersion := fmt.Sprintf("v1.%d", i) // read 5 A data race caused by anonymous function. 1 func (p *peer) send() {</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 .</head><label>9</label><figDesc>A non-blocking bug caused by misusing WaitGroup. Docker#22985 and CockroachDB#6111 are caused by data race on a shared variable whose reference is passed across goroutines through a channel. Anonymous function Go designers make goroutine declaration similar to a regular function call (which does not even need to have a "function name") so as to ease the creation of goroutines. All local variables declared before a Go anonymous function are accessible by the anonymous function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>1 -select { 2 -Figure 10 .</head><label>210</label><figDesc>case &lt;-c.closed: 3 -A bug caused by closing a channel twice.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>1 ticker 14 }Figure 11 . 6 } 7 select { 8 - 11 return nil 12 }Figure 12 .</head><label>11411678111212</label><figDesc>A non-blocking bug caused by select and channel. 1 -timer := time.NewTimer(0) 2 + var timeout &lt;-chan time.Time 3 if dur &gt; 0 { 4 -timer = time.NewTimer(dur) 5 + timeout = time.NewTimer(dur).C case &lt;-timer.C: 9 + case &lt;-timeout: 10 case &lt;-ctx.Done(): A non-blocking bug caused by Timer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Reader and a Writer. Both context and Pipe are new forms of passing messages and misusing them can create new types of concurrency bugs (Section 5).</figDesc><table><row><cell></cell><cell></cell><cell>introduces</cell></row><row><cell cols="3">context to carry request-specific data or metadata across</cell></row><row><cell cols="3">goroutines. As another example, Pipe is designed to stream</cell></row><row><cell>data between a Application Stars Commits Contributors</cell><cell>LOC</cell><cell>Dev History</cell></row><row><cell>Docker</cell><cell>786K</cell><cell>4.2 Years</cell></row><row><cell>Kubernetes</cell><cell>2297K</cell><cell>3.9 Years</cell></row><row><cell>etcd</cell><cell>441K</cell><cell>4.9 Years</cell></row><row><cell>CockroachDB</cell><cell>520k</cell><cell>4.2 Years</cell></row><row><cell>gRPC*</cell><cell>53K</cell><cell>3.3 Years</cell></row><row><cell>BoltDB</cell><cell>9K</cell><cell>4.4 Years</cell></row><row><cell cols="3">Table 1. Information of selected applications. The num-</cell></row><row><cell cols="3">ber of stars, commits, contributors on GitHub, total source lines of</cell></row><row><cell cols="3">code, and development history on GitHub. *: the gRPC version that is</cell></row><row><cell>written in Go.</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Once WaitGroup Cond chan Misc.</figDesc><table><row><cell cols="3">Application Mutex atomic Docker Shared Memory 62.62% 1.06% 4.75% 1.70%</cell><cell cols="2">Message Total 0.99% 27.87% 0.99%</cell></row><row><cell>Kubernetes</cell><cell>70.34% 1.21% 6.13%</cell><cell>2.68%</cell><cell>0.96% 18.48% 0.20%</cell><cell></cell></row><row><cell>etcd</cell><cell>45.01% 0.63% 7.18%</cell><cell>3.95%</cell><cell>0.24% 42.99%</cell><cell>2075</cell></row><row><cell cols="2">CockroachDB 55.90% 0.49% 3.76%</cell><cell>8.57%</cell><cell>1.48% 28.23% 1.57%</cell><cell></cell></row><row><cell>gRPC-Go</cell><cell>61.20% 1.15% 4.20%</cell><cell>7.00%</cell><cell>1.65% 23.03% 1.78%</cell><cell></cell></row><row><cell>BoltDB</cell><cell>70.21% 2.13%</cell><cell>0</cell><cell>0 23.40% 4.</cell><cell></cell></row></table><note>26% Table 4. Concurrency Primitive Usage. The Mutex column includes both Mutex and RWMutex.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>programmers.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>1</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Usage Proportion</cell><cell>0 0.2 0.4 0.6 0.8 1</cell><cell>.15−02</cell><cell>15−05 docker 15−08 15−11 cockroachdb 16−02 16−05 kubernetes 16−08 16−11 17−02 grpc−go</cell><cell>17−05</cell><cell>17−08 etcd 17−11 boltdb 18−02</cell><cell>18−05</cell><cell>Usage Proportion</cell><cell>0 0.2 0.4 0.6 0.8</cell><cell>.15−02</cell><cell>15−05 docker 15−08 15−11 cockroachdb 16−02 16−05 kubernetes 16−08 16−11 17−02 grpc−go</cell><cell>17−05</cell><cell>17−08 etcd 17−11 boltdb 18−02</cell><cell>18−05</cell></row><row><cell cols="7">Figure 2. Usages of Shared-Memory</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">Primitives over Time. For each appli-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">cation, we calculate the proportion of shared-</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="6">memory primitives over all primitives.</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 .</head><label>5</label><figDesc>Taxonomy. This table shows how our studied bugs distribute across different categories and applications.</figDesc><table><row><cell>Application</cell><cell cols="3">Behavior blocking non-blocking shared memory message passing Cause</cell></row><row><cell>Docker</cell><cell></cell><cell></cell><cell></cell></row><row><cell>Kubernetes</cell><cell></cell><cell></cell><cell></cell></row><row><cell>etcd</cell><cell></cell><cell></cell><cell></cell></row><row><cell>CockroachDB</cell><cell>16</cell><cell>23</cell><cell>5</cell></row><row><cell>gRPC</cell><cell>12</cell><cell>12</cell><cell>11</cell></row><row><cell>BoltDB</cell><cell>2</cell><cell>4</cell><cell>1</cell></row><row><cell>Total</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 6 .</head><label>6</label><figDesc>Blocking Bug Causes. Wait includes both the Wait function in Cond and in WaitGroup. Chan indicates channel operations and Chan w/ means channel operations with other operations. Lib stands for Go libraries related to message passing.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>new context 1 -hctx, hcancel := context.WithCancel(ctx) 2 + var hctx context.Context + var hcancel context.CancelFunc</figDesc><table><row><cell>4</cell><cell>if timeout &gt; 0 {</cell></row><row><cell>5</cell><cell>hctx, hcancel = context.WithTimeout(ctx, timeout)</cell></row><row><cell cols="2">6 + } else {</cell></row><row><cell cols="2">7 + hctx, hcancel = context.WithCancel(ctx)</cell></row></table><note>8 }</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 8 .</head><label>8</label><figDesc>. The correlation Benchmarks and evaluation results of the deadlock detector.between Chan and Add s is the second highest, with lift value 1.42. All other categories that have more than 10 blocking bugs have lift values below 1.16, showing no strong correlation.</figDesc><table><row><cell>Root Cause</cell><cell># of Used Bugs # of Detected Bugs</cell></row><row><cell>Mutex</cell><cell>1</cell></row><row><cell>Chan</cell><cell>0</cell></row><row><cell>Chan w/</cell><cell>1</cell></row><row><cell>Messaging Libraries</cell><cell>0</cell></row><row><cell>Total</cell><cell>2</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 9 .</head><label>9</label><figDesc>Root causes of non-blocking bugs.</figDesc><table><row><cell>traditional:</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12"><head>Table 10 .</head><label>10</label><figDesc>Fix strategies for non-blocking bugs. The subscript s stands for synchronization.</figDesc><table><row><cell></cell><cell cols="7">Mutex Channel Atomic WaitGroup Cond Misc. None</cell></row><row><cell>Shared Memory</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>traditional</cell><cell>24</cell><cell>3</cell><cell>6</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>13</cell></row><row><cell>waitgroup</cell><cell>2</cell><cell>0</cell><cell>0</cell><cell>4</cell><cell>3</cell><cell>0</cell><cell>0</cell></row><row><cell>anonymous</cell><cell>3</cell><cell>2</cell><cell>3</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>3</cell></row><row><cell>lib</cell><cell>0</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell>0</cell><cell>1</cell><cell>2</cell></row><row><cell>Message Passing</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>chan</cell><cell>3</cell><cell>11</cell><cell>0</cell><cell>2</cell><cell>1</cell><cell>2</cell><cell>1</cell></row><row><cell>lib</cell><cell>0</cell><cell>1</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell>Total</cell><cell>32</cell><cell>19</cell><cell>10</cell><cell>7</cell><cell>4</cell><cell>3</cell><cell>19</cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Principles of designing Go APIs with channels</title>
		<ptr target="https://inconshreveable.com/07-08-2014/principles-of-designing-go-apis-with-channels/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">The Go Blog: Share Memory By Communicating</title>
		<ptr target="https://blog.golang.org/share-memory-by-communicating" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Advanced Go Concurrency Patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sameer</forename><surname>Ajmani</surname></persName>
		</author>
		<ptr target="https://talks.golang.org/2013/advconc.slide" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Productionrun software failure diagnosis via hardware performance counters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joy</forename><surname>Arulraj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Po-Chun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;13)</title>
		<meeting>the 18th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;13)<address><addrLine>Houston, Texas, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Leveraging the short-term memory of hardware to diagnose production-run software failures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joy</forename><surname>Arulraj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;14)</title>
		<meeting>the 19th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;14)<address><addrLine>Salt Lake City, Utah, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">An embedded key/value database for Go</title>
		<ptr target="https://github.com/boltdb/bolt" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Magiclock: Scalable detection of potential deadlocks in large-scale multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">K</forename><surname>Chan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="266" to="281" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Kivati: Fast detection and prevention of atomicity violations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename><surname>Chew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th European Conference on Computer systems (EuroSys &apos;10)</title>
		<meeting>the 5th European Conference on Computer systems (EuroSys &apos;10)<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">An empirical study of operating systems errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junfeng</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Chelf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Hallem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawson</forename><surname>Engler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM symposium on Operating Systems Principles (SOSP &apos;01)</title>
		<meeting>the 18th ACM symposium on Operating Systems Principles (SOSP &apos;01)<address><addrLine>Banff, Alberta, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">CockroachDB is a cloud-native SQL database for building global, scalable cloud services that survive disasters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Cockroach</surname></persName>
		</author>
		<ptr target="https://github.com/cockroachdb/cockroach" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Bell Labs and CSP Threads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Russ</forename><surname>Cox</surname></persName>
		</author>
		<ptr target="http://swtch.com/rsc/thread/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A thread-safe way of appending errors into Result</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graphql</forename><surname>Developers</surname></persName>
		</author>
		<ptr target="https://github.com/graphql-go/graphql/pull/434" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<ptr target="https://www.docker.com/" />
		<title level="m">Ship, and Run Any App</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Effective data-race detection for the kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kirk</forename><surname>Olynyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;10)</title>
		<meeting>the 9th USENIX Conference on Operating Systems Design and Implementation (OSDI &apos;10)<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">A distributed, reliable key-value store for the most critical data of a distributed system</title>
		<ptr target="https://github.com/coreos/etcd" />
		<imprint/>
		<respStmt>
			<orgName>ETCD</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Atomizer: A dynamic atomicity checker for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Freund</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL &apos;04)</title>
		<meeting>the 31st ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL &apos;04)<address><addrLine>Venice, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">2nd-strike: Toward manifesting hidden concurrency typestate bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qi</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenbin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhezhe</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mai</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feng</forename><surname>Qin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;11)</title>
		<meeting>the 16th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;11)<address><addrLine>Newport Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">The fifteen most popular languages on GitHub</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Github</surname></persName>
		</author>
		<ptr target="https://octoverse.github.com/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">A high performance, open source, general RPC framework that puts mobile and HTTP/2 first</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://github.com/grpc/grpc-go" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><forename type="middle">Effective</forename><surname>Go</surname></persName>
		</author>
		<ptr target="https://golang.org/doc/effective_go.html#concurrency" />
		<imprint/>
	</monogr>
	<note>21] Google. Effective Go: Concurrency</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Google</forename><surname>Benchmarking</surname></persName>
		</author>
		<ptr target="https://grpc.io/docs/guides/benchmarking.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">The Go Programming Language -Release History</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Google</surname></persName>
		</author>
		<ptr target="https://golang.org/doc/devel/release.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">What change history tells us about thread synchronization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linhai</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linjie</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</title>
		<meeting>the 2015 10th Joint Meeting on Foundations of Software Engineering<address><addrLine>Bergamo, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">What bugs live in the cloud? a study of 3000+ issues in cloud systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Haryadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mingzhe</forename><surname>Gunawi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tanakorn</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tiratat</forename><surname>Leesatapornwongsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thanh</forename><surname>Patana-Anake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffry</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Adityatama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kurnia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Agung</forename><surname>Eliazar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">F</forename><surname>Laksono</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincentius</forename><surname>Lukman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anang</forename><forename type="middle">D</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Satria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Cloud Computing (SOCC&apos; 14)</title>
		<meeting>the ACM Symposium on Cloud Computing (SOCC&apos; 14)<address><addrLine>Seattle, Washington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Lightweight SMTP client written in Go</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hectane</surname></persName>
		</author>
		<ptr target="https://github.com/hectane" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Communicating Sequential Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A R</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="666" to="677" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Lazy-cseq: A context-bounded model checking tool for multi-threaded c-programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Omar</forename><surname>Inverso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Truc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salvatore</forename><forename type="middle">La</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gennaro</forename><surname>Torre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Parlato</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th IEEE/ACM International Conference on Automated Software Engineering (ASE &apos;15)</title>
		<meeting><address><addrLine>Lincoln, Nebraska, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Understanding and detecting real-world performance bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linhai</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoming</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Scherpelz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos; 12)</title>
		<meeting>the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos; 12)<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Automated atomicity-violation fixing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linhai</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Liblit</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos; 11)</title>
		<meeting>the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos; 11)<address><addrLine>San Jose, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Instrumentation and sampling strategies for cooperative concurrency bug isolation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><forename type="middle">V</forename><surname>Thakur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM International Conference on Object oriented programming systems languages and applications (OOPSLA &apos;10)</title>
		<meeting>the ACM International Conference on Object oriented programming systems languages and applications (OOPSLA &apos;10)<address><addrLine>Reno/-Tahoe, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Automated concurrency-bug fixing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongdong</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Liblit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12)</title>
		<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12)<address><addrLine>Hollywood, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A randomized dynamic program analysis technique for detecting real deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pallavi</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang-Seo</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mayur</forename><surname>Naik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09)</title>
		<meeting>the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;09)<address><addrLine>Dublin, Ireland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Deadlock immunity: Enabling systems to defend against deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Horatiu</forename><surname>Jula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Tralamazza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cristian</forename><surname>Zamfir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th USENIX Conference on Operating systems design and implementation (OSDI &apos;08)</title>
		<meeting>the 8th USENIX Conference on Operating systems design and implementation (OSDI &apos;08)<address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Sound static deadlock analysis for c/pthreads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Poetzl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Schrammel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Björn</forename><surname>Wachter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">31st IEEE/ACM International Conference on Automated Software Engineering (ASE &apos;16)</title>
		<meeting><address><addrLine>Singapore, Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Production-Grade Container Orchestration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kubernetes</surname></persName>
		</author>
		<ptr target="https://kubernetes.io/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Concurrent Reading and Writing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="806" to="811" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Fencing off go: Liveness and safety for channel-based programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernardo</forename><surname>Toninho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;17)</title>
		<meeting>the 44th ACM SIGPLAN Symposium on Principles of Programming Languages (POPL &apos;17)<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A static verification framework for message passing in go using behavioural types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernardo</forename><surname>Toninho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM 40th International Conference on Software Engineering (ICSE &apos;18)</title>
		<meeting><address><addrLine>Gothenburg, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Taxdc: A taxonomy of non-deterministic concurrency bugs in datacenter distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tanakorn</forename><surname>Leesatapornwongsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">F</forename><surname>Lukman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haryadi</forename><forename type="middle">S</forename><surname>Gunawi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;16)</title>
		<meeting>the 21th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;16)<address><addrLine>Atlanta, Georgia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Have things changed now?: An empirical study of bug characteristics in modern open source software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhenmin</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lin</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuanhui</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chengxiang</forename><surname>Zhai</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st workshop on Architectural and system support for improving software dependability (ASID &apos;06)</title>
		<meeting>the 1st workshop on Architectural and system support for improving software dependability (ASID &apos;06)<address><addrLine>San Jose, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Jacontebe: A benchmark suite of real-world java concurrency bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ziyi</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuting</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianjun</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th IEEE/ACM International Conference on Automated Software Engineering (ASE &apos;15)</title>
		<meeting><address><addrLine>Lincoln, Nebraska, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Understanding and generating high quality patches for concurrency bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haopeng</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuxi</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE &apos;16)</title>
		<meeting>the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE &apos;16)<address><addrLine>Seattle, Washington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A study of linux file system evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lanyue</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">C</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Remzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Arpaci-Dusseau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Conference on File and Storage Technologies (FAST &apos;13)</title>
		<meeting>the 11th USENIX Conference on File and Storage Technologies (FAST &apos;13)<address><addrLine>San Jose, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Learning from mistakes -a comprehensive study of real world concurrency bug characteristics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eunsoo</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;08)</title>
		<meeting>the 13th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;08)<address><addrLine>Seattle, Washington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Avio: Detecting atomicity violations via access interleaving invariants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Tucek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feng</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;06)</title>
		<meeting>the 12th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;06)<address><addrLine>San Jose, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Finding concurrency bugs with contextaware communication graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brandon</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luis</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO &apos;09)</title>
		<meeting>the 42nd Annual IEEE/ACM International Symposium on Microarchitecture (MICRO &apos;09)<address><addrLine>New York, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Are concurrent programs that are easier to write also easier to check?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kedar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Namjoshi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Exploiting Concurrency Efficiently and Correctly</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Static deadlock detection for concurrent go by global session graph synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Compiler Construction (CC &apos;16)</title>
		<meeting>the 25th International Conference on Compiler Construction (CC &apos;16)<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Go Concurrency Patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rob</forename><surname>Pike</surname></persName>
		</author>
		<ptr target="https://talks.golang.org/2012/concurrency.slide" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Racerx: Effective, static detection of race conditions and deadlocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Dawson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Engler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ashcraft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM symposium on Operating systems principles (SOSP &apos;03)</title>
		<meeting>the 19th ACM symposium on Operating systems principles (SOSP &apos;03)<address><addrLine>Bolton Landing, New York, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Eraser: A dynamic data race detector for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Savage</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Sobalvarro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="391" to="411" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Threadsanitizer: Data race detection in practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Konstantin</forename><surname>Serebryany</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timur</forename><surname>Iskhodzhanov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Binary Instrumentation and Applications (WBIA &apos;09)</title>
		<meeting>the Workshop on Binary Instrumentation and Applications (WBIA &apos;09)<address><addrLine>New York, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Deadlock-detection in java-library using staticanalysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Vivek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shanbhag</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">15th Asia-Pacific Software Engineering Conference (APSEC &apos;08)</title>
		<meeting><address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Picklock: A deadlock prediction approach under nested locking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francesco</forename><surname>Sorrentino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd International Symposium on Model Checking Software (SPIN &apos;15)</title>
		<meeting>the 22nd International Symposium on Model Checking Software (SPIN &apos;15)<address><addrLine>Stellenbosch, South Africa</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Static tracebased deadlock analysis for synchronous mini-go</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Stadtmüller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Sulzmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Peter" Thiemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th Asian Symposium on Programming Languages and Systems (APLAS &apos;16)</title>
		<meeting><address><addrLine>Hanoi, Vietnam</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">A comprehensive study on real world concurrency bugs in node.js</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wensheng</forename><surname>Dou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chushu</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feng</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kang</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun</forename><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE &apos;17)</title>
		<meeting>the 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE &apos;17)<address><addrLine>Urbana-Champaign, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2017-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Gadara: Dynamic deadlock avoidance for multithreaded programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terence</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manjunath</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stéphane</forename><surname>Lafortune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><forename type="middle">A</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th USENIX Conference on Operating systems design and implementation (OSDI &apos;08)</title>
		<meeting>the 8th USENIX Conference on Operating systems design and implementation (OSDI &apos;08)<address><addrLine>San Diego, California, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">The theory of deadlock avoidance via discrete control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stéphane</forename><surname>Lafortune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terence</forename><surname>Kelly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manjunath</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><forename type="middle">A</forename><surname>Mahlke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL &apos;09)</title>
		<meeting>the 36th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages (POPL &apos;09)<address><addrLine>Savannah, Georgia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wikipedia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Go</surname></persName>
		</author>
		<ptr target="https://en.wikipedia.org/wiki/Go_(programming_language" />
		<imprint/>
	</monogr>
	<note>programming language</note>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Ad hoc synchronization considered harmful</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwei</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soyeon</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaqi</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiqiang</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on Operating systems design and implementation (OSDI &apos;10)</title>
		<meeting>the 9th USENIX Conference on Operating systems design and implementation (OSDI &apos;10)<address><addrLine>Vancouver, British Columbia, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">A case for an interleaving constrained shared-memory multi-processor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jie</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satish</forename><surname>Narayanasamy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th annual International symposium on Computer architecture (ISCA &apos;09)</title>
		<meeting>the 36th annual International symposium on Computer architecture (ISCA &apos;09)<address><addrLine>Austin, Texas, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Racetrack: Efficient detection of data race conditions via adaptive tracking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuan</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Rodeheffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM symposium on Operating systems principles (SOSP &apos;05)</title>
		<meeting>the 20th ACM symposium on Operating systems principles (SOSP &apos;05)<address><addrLine>Brighton, United Kingdom</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Conmem: detecting severe concurrency bugs through an effect-oriented approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chong</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;10)</title>
		<meeting>the 15th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;10)<address><addrLine>Pittsburgh, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-03" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
