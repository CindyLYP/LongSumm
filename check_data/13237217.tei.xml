<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">GraphIt: A High-Performance Graph DSL</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2018-10-22">22 Oct 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunming</forename><surname>Zhang</surname></persName>
							<email>yunming@mit.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">RIYADH BAGHDADI</orgName>
								<address>
									<region>MIT CSAIL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">Julian Shun</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>USA</roleName><forename type="first">Mit</forename><surname>Csail</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">RIYADH BAGHDADI</orgName>
								<address>
									<region>MIT CSAIL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution">RIYADH BAGHDADI</orgName>
								<address>
									<region>MIT CSAIL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mengjiao</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">RIYADH BAGHDADI</orgName>
								<address>
									<region>MIT CSAIL</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">Julian Shun</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Baghdadi</surname></persName>
							<email>baghdadi@mit.edu</email>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">Julian Shun</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kamil</surname></persName>
							<email>kamil@adobe.com</email>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">Julian Shun</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shun</surname></persName>
							<email>jshun@mit.edu</email>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">Julian Shun</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">MIT CSAIL</orgName>
								<orgName type="institution">Julian Shun</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">GraphIt: A High-Performance Graph DSL</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2018-10-22">22 Oct 2018</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3276491</idno>
					<idno type="arXiv">arXiv:1805.00923v2[cs.PL]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Compiler Optimizations</term>
					<term>Code Generation</term>
					<term>Big Data</term>
				</keywords>
			</textClass>
			<abstract>
				<p>The performance bottlenecks of graph applications depend not only on the algorithm and the underlying hardware, but also on the size and structure of the input graph. As a result, programmers must try different combinations of a large set of techniques, which make tradeoffs among locality, work-efficiency, and parallelism, to develop the best implementation for a specific algorithm and type of graph. Existing graph frameworks and domain specific languages (DSLs) lack flexibility, supporting only a limited set of optimizations. This paper introduces GraphIt, a new DSL for graph computations that generates fast implementations for algorithms with different performance characteristics running on graphs with different sizes and structures. GraphIt separates what is computed (algorithm) from how it is computed (schedule). Programmers specify the algorithm using an algorithm language, and performance optimizations are specified using a separate scheduling language. The algorithm language simplifies expressing the algorithms, while exposing opportunities for optimizations. We formulate graph optimizations, including edge traversal direction, data layout, parallelization, cache, NUMA, and kernel fusion optimizations, as tradeoffs among locality, parallelism, and work-efficiency. The scheduling language enables programmers to easily search through this complicated tradeoff space by composing together a large set of edge traversal, vertex data layout, and program structure optimizations. The separation of algorithm and schedule also enables us to build an autotuner on top of GraphIt to automatically find high-performance schedules. The compiler uses a new scheduling representation, the graph iteration space, to model, compose, and ensure the validity of the large number of optimizations. We evaluate GraphIt&apos;s performance with seven algorithms on graphs with different structures and sizes. GraphIt outperforms the next fastest of six state-of-the-art shared-memory frameworks (Ligra, Green-Marl, GraphMat, Galois, Gemini, and Grazelle) on 24 out of 32 experiments by up to 4.8×, and is never more than 43% slower than the fastest framework on the other experiments. GraphIt also reduces the lines of code by up to an order of magnitude compared to the next fastest framework. CCS Concepts: • Mathematics of computing → Graph algorithms; • Software and its engineering → Parallel programming languages; Domain specific languages;</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>In recent years, large graphs with billions of vertices and trillions of edges have emerged in many domains, such as social network analytics, machine learning, and biology. Extracting information from these graphs often involves running algorithms for identifying important vertices, finding connections among vertices, and detecting communities of interest. Speeding up these algorithms can enhance the efficiency of data analytics applications and improve the quality of web services <ref type="bibr" target="#b15">[Eksombatchai et al. 2018;</ref><ref type="bibr" target="#b16">Fu et al. 2017;</ref><ref type="bibr" target="#b52">Sharma et al. 2016]</ref>.</p><p>It is difficult to implement high-performance graph algorithms. The performance bottlenecks of these algorithms depend not only on the algorithm and the underlying hardware, but also on the size and structure of the graph <ref type="bibr" target="#b5">[Beamer et al. 2015]</ref>. As a result, different algorithms running on the same machine, or even the same algorithm running with different types of graphs on the same machine, can exhibit different performance bottlenecks. For example, some algorithms, such as PageRank, spend most of the time working on the entire graph, while traversal algorithms, such as Breadth-First Search (BFS), work on a smaller subgraph at a time. In addition, running the same algorithm on a social network with small diameter and power-law degree distribution exposes different performance bottlenecks compared to running on a road network with large diameter and uniform degree distribution.</p><p>Graph optimizations make tradeoffs among locality, parallelism and work-efficiency <ref type="bibr" target="#b4">[Beamer et al. 2012</ref><ref type="bibr" target="#b6">[Beamer et al. , 2017</ref><ref type="bibr" target="#b23">Kiriansky et al. 2016;</ref><ref type="bibr" target="#b54">Shun and Blelloch 2013;</ref><ref type="bibr" target="#b64">Zhang et al. 2017</ref>] to improve performance. Since many graph algorithms have very different performance bottlenecks, and optimizations make different tradeoffs, one optimization can significantly boost the performance for some graph algorithms on certain types of graphs, while hurting the performance of other algorithms or the same algorithm running on other types of graphs <ref type="bibr" target="#b34">[Malicevic et al. 2017]</ref>. Programmers must iterate over multiple implementations of the same algorithm to identify the best combination of optimizations for a specific algorithm and input data.</p><p>Existing graph frameworks perform well for a subset of algorithms for specific types of input, but have suboptimal performance on algorithms with different bottlenecks and graphs of different sizes and structures <ref type="bibr" target="#b5">[Beamer et al. 2015;</ref><ref type="bibr" target="#b51">Satish et al. 2014]</ref>. Developers writing performance-critical applications cannot afford such a level of slowdown. This performance inconsistency exists because each framework was designed to support only a limited set of optimization techniques, and does not allow for easy exploration of the large space of optimizations. It is infeasible to write handoptimized code for every combination of algorithm and input type. A compiler approach that generates efficient implementations from high-level specifications is therefore a good fit. However, existing graph domain specific languages (DSLs) <ref type="bibr" target="#b2">[Aberger et al. 2016;</ref><ref type="bibr" target="#b20">Hong et al. 2012;</ref><ref type="bibr" target="#b27">Lam et al. 2013]</ref> do not support composition of optimizations or expose comprehensive performance tuning capabilities to programmers.</p><p>We introduce GraphIt, 1 a new graph DSL that produces efficient implementations with performance competitive with or faster than state-of-the-art frameworks for a diverse set of algorithms running on graphs with different sizes and structures. GraphIt achieves good performance by enabling programmers to easily find the best combination of optimizations for their specific algorithm and input graph. In this paper, we focus on providing mechanisms that make it possible to easily and productively explore the space of optimizations.</p><p>GraphIt separates algorithm specifications from the choice of performance optimizations. Programmers specify the algorithm using an algorithm language based on high-level operators on sets of vertices and edges. Performance optimizations are specified using a separate scheduling language. The algorithm language simplifies expressing algorithms and exposes opportunities for 121:4 Y. <ref type="bibr">Zhang</ref>  <ref type="figure">Fig. 1</ref>. A heat map of slowdowns of various frameworks compared to the fastest of all frameworks for PageRank (PR), Breadth-First Search (BFS), Connected Components (CC) using label propagation, and Single Source Shortest Paths (SSSP) using Bellman-Ford, on five graphs with varying sizes and structures (LiveJournal (LJ), Twitter (TW), WebGraph (WB), USAroad (RD), and Friendster (FT)). Lower numbers (green) are better, with one being the fastest for the specific algorithm running on the specific graph. Gray means that either an algorithm or a graph is not supported by the framework. We try to use the same algorithms across different frameworks. For Galois, we used the asynchronous algorithm for BFS, and the Ligra algorithm for SSSP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">TRADEOFF SPACE AND OPTIMIZATIONS</head><p>Rank = {0, . . . , 0}  While the effects of various optimizations are well-known to expert programmers, we believe that we are the first to characterize the optimization tradeoff space for graph optimizations. Our tradeoff space includes three properties of graph programs-locality, work-efficiency, and parallelism. Locality refers to the amount of spatial and temporal reuse in a program. Increasing the amount of reuse improves locality due to increasing the number of cache hits. In a NUMA system, locality also refers to the memory location relative to the processor. Increasing the ratio of local memory accesses to remote memory accesses improves locality. Workefficiency is the inverse of the number of instructions, where each instruction is weighted according to the number of cycles that it takes to execute assuming a cold cache. Reducing the number of instructions improves work-efficiency. Parallelism refers to the relative amount of work that can be executed independently by different processing units, which is often affected by the load balance and synchronization among processing units. Increasing parallelism improves performance by taking advantage of more processing units, and helping to hide the latency of DRAM requests. We use PageRankDelta (described in Section 2.1 and shown in <ref type="figure" target="#fig_0">Fig. 2</ref>) as an example to illustrate the effects of various optimizations on these three metrics. Each optimization can affect multiple properties in the tradeoff space, either positively or negatively. The complex tradeoff space motivates the design of GraphIt's scheduling language and compiler, which can be used to easily search for points in the tradeoff space that achieve high performance.</p><formula xml:id="formula_0">▷ Length V</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">PageRankDelta</head><p>PageRankDelta <ref type="bibr" target="#b54">[Shun and Blelloch 2013]</ref> is a variant of the standard PageRank algorithm <ref type="bibr" target="#b41">[Page et al. 1999</ref>] that computes the importance of vertices in a graph. It maintains an array of ranks, and on each iteration, updates the ranks of all vertices based on the ranks of their neighbors weighted by their neighbors' out-degrees. PageRankDelta speeds up the computation by updating only the ranks of vertices whose ranks have changed significantly from the previous iteration. The pseudocode for PageRankDelta is shown in <ref type="figure" target="#fig_0">Fig. 2</ref>, where V is the number of vertices in the graph, 0 ≤ α ≤ 1 is the damping factor that determines how heavily to weight the neighbors' ranks during the update, and ϵ ≥ 0 is a constant that determines whether a vertex's rank has changed sufficiently. For simplicity, we update the ranks of vertices for MaxIter number of iterations, although the code can easily be modified to terminate based on a convergence criterion. The algorithm maintains the set of vertices whose ranks (stored in the Rank array) have changed significantly from the previous iteration in the variable Frontier (represented as a sparse array). We will refer to this as the active set of vertices, or the frontier. Initially all vertices are in the active set (Line 5). On each iteration, each vertex in the active set sends its Delta (change in Rank value) from the previous iteration to its out-neighbors by incrementing the DeltaSum values of its neighbors (Lines 8-10). Since vertices are processed in parallel, the updates to DeltaSum must be atomic. Then in parallel, all vertices compute their own Delta and Rank values based on their DeltaSum value and α (Lines 11-18). Delta is computed differently for the first iteration. If the Delta of the vertex is larger than ϵ times its Rank, then the vertex is active for the next iteration and is added to the next frontier (Lines 20-21).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Graph Optimizations</head><p>We describe the tradeoffs of the optimizations listed in <ref type="table">Table with PageRankDelta (Table 11</ref> describes which optimizations are supported by which frameworks and DSLs). <ref type="table">Table contains</ref> the effect of optimizations relative to the baseline in <ref type="figure" target="#fig_0">Fig. 2</ref>, which we refer to as SparsePush. <ref type="table">Table 1</ref>. Effect of optimizations on the different properties of the tradeoff space relative to the baseline SparsePush. For each property, ↑ means positive impact on performance, ↓ means negative impact on performance, ↕ means it could increase or decrease depending on various factors (described in the text), and no entry means no effect on performance. not be updated in parallel, and this reduces synchronization overhead. Instead of doing random writes as in SparsePush, DensePull does random reads and mostly sequential writes, which are cheaper. For some algorithms (e.g., breadth-first search), the inner loop over the in-neighbors in DensePull can exit early to reduce overall work. Therefore, the overall number of edges traversed could increase or decrease. A detailed performance study of the two traversal methods can be found in <ref type="bibr" target="#b4">Beamer et al. [2012]</ref> and <ref type="bibr" target="#b8">Besta et al. [2017]</ref>. We can further use bitvectors instead of boolean arrays to keep track of vertices on the frontier for the DensePull direction. A dense frontier implemented using a bitvector improves spatial locality, but requires extra work to compress the boolean array.</p><p>DensePush <ref type="figure">(Fig. 3 (right)</ref>) loops through all vertices and checks if each one is on the frontier instead of only looping over frontier vertices as in SparsePush. While iterating over all vertices reduces work-efficiency, this could be offset by not having to maintain the frontier in a sparse format. Parallelism increases as there is more parallel work when looping over all vertices.</p><p>Hybrid traversal modes (DensePull-SparsePush and DensePush-SparsePush) use different directions (SparsePush, DensePull, and DensePush) in different iterations based on the size of the active set to improve work-efficiency <ref type="bibr" target="#b4">[Beamer et al. 2012;</ref><ref type="bibr" target="#b54">Shun and Blelloch 2013]</ref>. In PageRankDelta, the number of vertices in the frontier gradually decreases as the ranks of vertices converge. In the early iterations, DensePull is preferred due to lower synchronization overheads and avoiding random writes. As the frontier shrinks, SparsePush is preferred due to the fewer number of vertices that need to be traversed. DensePull-SparsePush computes the sum of out-degrees of the frontier vertices and uses DensePull if the sum is above some threshold, and SparsePush otherwise. However, computing the sum of out-degrees of the vertices in the active set in every iteration incurs significant overhead if one direction is always better than the other.</p><p>GraphIt is able to support all of these traversal directions whereas existing frameworks only support a subset of them. GraphIt also supports both bitvectors and boolean arrays for the frontier representation in dense traversals, as well as the sparse array representation for sparse traversals. Parallelization. For each traversal mode, there are different methods for parallelization. The parallelization shown in <ref type="figure" target="#fig_0">Fig. 2</ref> and 3 processes the vertices in parallel. This approach (vertex-parallel) works well on algorithms and inputs where the workload of each vertex is similar. However, if the degree distribution is skewed and the workload of each vertex is proportional to the number of incident edges, this approach can lead to significant load imbalance. For these workloads, an edge-aware vertex-parallel scheme (edge-aware-vertex-parallel) can be more effective. This approach breaks up the vertices into a number of vertex chunks, where each chunk has approximately the same number of edges. However, this scheme reduces work-efficiency due to having to compute the sum of degrees of vertices in each chunk. Finally, we can parallelize across all edges, instead of just vertices, by parallelizing the inner loop of the edge-traversal code computing DeltaSum in <ref type="figure" target="#fig_0">Fig. 2 and 3</ref>. This method (edge-parallel) improves parallelism but reduces work-efficiency due to the overhead of work-stealing in the inner loop and atomic updates needed for synchronization. For graphs with a regular degree distribution, using static parallelism instead of work-stealing parallelism can sometimes reduce runtime overhead and improve performance. GraphIt supports all three modes of parallelism while existing frameworks only support one or two. Cache Partitioning. Cache partitioning tries to keep random accesses within the last level cache (LLC) to improve locality. This optimization first partitions the vertices into p segments</p><formula xml:id="formula_1">(V 0 , V 1 , . . . , V p−1 )</formula><p>, which correspond to the range of source vertexsets in the pull mode or the destination vertexsets in the push mode for each Segmented Subgraph (SSG). For the pull mode, incoming edges (src, dst) are assigned to SSG i if src ∈ V i , and sorted by dst. For the push mode, outgoing edges (src, dst) are assigned to SSG i if dst ∈ V i , and sorted by src. Each SSG is processed before moving on to the next. V i controls the range of random memory accesses through segmenting the original graph. If we fit V i into LLC, we can significantly reduce the number of random DRAM accesses when processing each SSG. Cache partitioning improves locality but sacrifices work-efficiency due to vertex data replication from graph partitioning and merging partial results <ref type="bibr" target="#b6">[Beamer et al. 2017;</ref><ref type="bibr" target="#b39">Nishtala et al. 2007;</ref><ref type="bibr" target="#b64">Zhang et al. 2017]</ref>. Fine-tuning the number of SSGs can reduce this overhead. Most existing frameworks do not support cache partitioning. NUMA Optimizations. NUMA partitioning improves locality by minimizing slow inter-socket memory accesses <ref type="bibr" target="#b55">[Sun et al. 2017;</ref><ref type="bibr" target="#b63">Zhang et al. 2015;</ref><ref type="bibr" target="#b66">Zhu et al. 2016]</ref>. This optimization partitions the graph into a set of Segmented Subgraphs (SSGs) in the same way as cache partitioning in order to limit the range of random memory access. While the cache partitioning optimization processes one SSG at a time across all sockets, NUMA partitioning executes multiple SSGs in parallel on different sockets. Each SSG and the threads responsible for processing the subgraph are bound to the same NUMA socket. The intermediate results collected on each socket are merged at the end of each iteration. As with cache partitioning, NUMA partitioning improves locality but reduces work-efficiency due to vertex data replication from graph partitioning and the additional merge phase. Parallelism might also decrease for highly skewed graphs due to workload imbalance among SSGs <ref type="bibr" target="#b55">[Sun et al. 2017]</ref>. For algorithms with performance bottlenecked on load imbalance instead of inter-socket memory accesses, simply using an interleaved allocation across sockets can result in better performance. GraphIt and a subset of existing frameworks support NUMA optimizations. Vertex Data Layout Optimizations. The layout of vertex data can significantly affect the locality of memory accesses. Random accesses to the same index of two separate arrays (e.g., the Delta and OutDegree arrays in PageRankDelta) can be changed into a single random access to an array of structs to improve spatial locality. However, grouping together fields that are not always accessed together expands the working set and hurts the locality of the data structures. Vertex data layout optimizations reduce work-efficiency due to the extra overhead for reorganizing the data. GraphIt supports both arrays of structs and structs of arrays. Program Structure Optimizations. When two graph kernels have the same traversal pattern (they process the same vertices/edges on each iteration), we can fuse together the edge traversals and transform their data structures into an array of structs. We refer to this optimization as kernel fusion. This improves spatial locality by enabling the program to access the fields of the two kernels together when traversing the edges. Additional work is incurred for performing the AoS-SoA optimization, but this is usually small compared to the rest of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ALGORITHM LANGUAGE</head><p>GraphIt leverages an algorithm and a scheduling language to compose graph optimizations, enabling programmers to easily navigate the complex performance tradeoff space described in Section 2. The algorithm language can express a variety of algorithms, while exposing opportunities for optimizations. We use PageRankDelta (GraphIt code shown in <ref type="figure" target="#fig_1">Fig. 4</ref>) to showcase the language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data Model</head><p>GraphIt's data model consists of elements, vertexsets and edgesets, and vertex and edge data. The programmer first defines vertex and edge element types (Vertex and Edge on Lines 1-2 of <ref type="figure" target="#fig_1">Fig. 4</ref>  for algorithms that work on multiple graphs. After defining element types, the programmer can construct vertexsets and edgesets. Lines 3-4 of <ref type="figure" target="#fig_1">Fig. 4</ref> show the definitions of an edgeset, edges, and vertexset, vertices. Each element of the edgeset is of Edge type (specified between "{ }"), and the source and destination of the edge is of Vertex type (specified between "( )"). The edgeset declaration supports edges with different types of source and destination vertices (e.g., in a bipartite graph). vertices uses the getVertices method on the edgeset to obtain the union of source and destination vertices of edges. Data for vertices and edges are defined as vectors associated with an element type denoted using the { } syntax (Lines 8-11).</p><formula xml:id="formula_2">Delta[v] = damp * (DeltaSum[v]) + base_score; Rank[v] += Delta[v]; Delta[v] = Delta[v] -1.0/vertices.size(); output = fabs(Delta[v] &gt; epsilon*Rank[v]); DeltaSum[v] = 0; end func updateVertex(v : Vertex) -&gt; output : bool Delta[v] = DeltaSum[v] * damp; Rank[v] += Delta[v]; DeltaSum[v] = 0; output = fabs(Delta[v]) &gt; epsilon * Rank[v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Language Constructs and Operators</head><p>The language constructs of GraphIt (shown in <ref type="table" target="#tab_4">Table 2</ref>) separate edge processing logic from edge traversal, edge filtering (from, to, srcFilter, and dstFilter), atomic synchronization, and modified vertex deduplication and tracking logic (apply and applyModified). This separation enables the compiler to represent the algorithm at a high level, exposing opportunities for edge traversal and vertex data layout optimizations. Moreover, it frees the programmer from specifying low-level implementation details, such as synchronization and deduplication logic.</p><p>In the GraphIt code for PageRankDelta ( <ref type="figure" target="#fig_1">Fig. 4)</ref>, the from operator (Line 32) ensures that only edges whose source vertex is in the frontier are traversed, and the apply operator uses the updateEdge function on the selected edges to compute DeltaSum, corresponding to Lines 8-10 of Algorithm 2. This separation enables the compiler to generate complex code for different traversal modes Applies f(source, destination) to every edge. Returns a vertexset that contains destination vertices whose entry in the vector vec has been modified in f. The programmer can optionally disable deduplication within modified vertices. Deduplication is enabled by default.</p><p>and parallelization optimizations, while inserting appropriate data access and synchronization instructions for the updateEdge function. #s1# is a label used in the scheduling language (explained in Section 4). Lines 34 and 36 of <ref type="figure" target="#fig_1">Fig. 4</ref> compute the updated Delta and Rank values by applying updateVertexFirstRound and updateVertex functions on every vertex. Vertices with Delta greater than epsilon of their Rank are returned as the next frontier, corresponding to Lines 11-21 of Algorithm 2. As shown in <ref type="table" target="#tab_4">Table 2</ref>, GraphIt provides various operators on vertexsets and edgesets to express graph algorithms with different traversal and update logic. The applyModified operator tracks which vertices have been updated during the edge traversal and outputs a vertexset containing just those vertices. By default, applyModified ensures that each vertex is added only once to the output vertexset. However, the programmer can optionally disable deduplication for algorithms that are guaranteed to insert each vertex only once (e.g., BFS) for better performance.  We demonstrate how GraphIt simplifies the expression of the algorithm by showing Ligra's implementation of the edge update function in <ref type="figure" target="#fig_2">Fig. 5</ref> (note that the 16 lines of Ligra code shown correspond to only 3 lines in GraphIt's implementation in <ref type="figure" target="#fig_1">Fig. 4</ref>). Ligra requires the programmer to specify edge processing (Lines 8-9, 12-14), edge filtering (Line 16), deduplication and modification tracking (Lines 10 and 15), and synchronization logic (Lines 12-14). GraphIt only requires the programmer to specify the edge processing logic in this case.</p><p>GraphIt also supports traditional control flow constructs such as for, while, and if for expressing fixed iteration loops, loops until convergence, and conditional control flow. After setting up a new vertexset called Frontier, Line 31 in <ref type="figure" target="#fig_1">Fig. 4</ref> uses a for loop to iterate maxIters times. An alternative implementation could use a while loop that iterates until the ranks of all vertices stabilize.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>121:10</head><p>Y. Zhang, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe <ref type="table">Table 3</ref>. GraphIt Scheduling Language functions. The default option for an operator is shown in bold. Optional arguments are shown in [ ]. If the optional direction argument is not specified, the configuration is applied to all relevant directions. We use a default grain size of 256 for parallelization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Apply Scheduling Functions</head><p>Descriptions program-&gt;configApplyDirection(label, config); Config options:</p><formula xml:id="formula_3">SparsePush, DensePush, DensePull, DensePull-SparsePush, DensePush-SparsePush program-&gt;configApplyParallelization(label, config, [grainSize], [direction]); Config options: serial, dynamic-vertex-parallel, static-vertex- parallel, edge-aware-dynamic-vertex-parallel, edge-parallel program-&gt;configApplyDenseVertexSet(label, config, [vertexset], [direction])</formula><p>Vertexset options: both, src-vertexset, dst-vertexset Config Options: bool-array, bitvector program-&gt;configApplyNumSSG(label, config, numSegments, [direction]);</p><p>Config options: fixed-vertex-count or edge-aware-vertexcount program-&gt;configApplyNUMA(label, config, [direction]);</p><formula xml:id="formula_4">Config options: serial, static-parallel, dynamic-parallel program-&gt;fuseFields({vect1, vect2, ...})</formula><p>Fuses multiple arrays into a single array of structs. program-&gt;fuseForLoop(label1, la bel2, fused_label)</p><p>Fuses together multiple loops.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>program-&gt;fuseApplyFunctions(label1, label2, fused_func)</head><p>Fuses together two edgeset apply operators. The fused apply operator replaces the first operator.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SCHEDULING LANGUAGE</head><p>After specifying the algorithm using the language described in Section 3, programmers can explore different combinations of optimizations using GraphIt's scheduling language. In this section, we describe the design of the scheduling language functions and demonstrate how they work with PageRankDelta.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Scheduling Language</head><p>We use labels (#label#) in algorithm specifications to identify the statements on which optimizations apply. Programmers can assign a label on the left side of a statement and later reference it in the scheduling language. <ref type="figure" target="#fig_3">Fig. 6</ref> shows a simple schedule for the PageRankDelta implementation in <ref type="figure" target="#fig_1">Fig. 4</ref>. The programmer adds label s1 to the edgeset operation statement. After the schedule keyword, the programmer can make a series of calls to scheduling functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>30</head><p>...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>31</head><p>for i in 1:maxIters 32 #s1# edges.from(frontier).apply(updateEdge); ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>end ... schedule:</head><p>42 program-&gt;configApplyDirection("s1", "DensePull-SparsePush"); We designed GraphIt's scheduling language functions (shown in Table 3) to allow programmers to compose together edge traversal direction, frontier data structure, parallelization, cache, NUMA, vertex data layout, and program structure optimizations discussed in Section 2. The configApplyDirection function allows programmers to configure directions used for traversal. The programmer can use the configDenseVertexSet function to switch between bitvector and boolean array for source and destination vertexsets. The configApplyNumSSG function configures the number of segmented subgraphs and how the subgraphs are partitioned (fixed-vertex-count and edge-aware-vertex-count). Setting the right number of segments and partitioning configuration allows random accesses to be restricted to a NUMA node or last level cache with balanced load as described in Section 2. configApplyNUMA configures the segmented subgraphs to be executed in parallel with static or dynamic NUMA node assignment (static-parallel and dynamic-parallel), ensuring the random memory accesses are restricted to the local NUMA node, while maintaining good parallel scalability. Finally, vertex data vectors can be fused together into an array of structs with fuseFields. (c) Generated Code with Parallelization Configuration program -&gt;configApplyDirection("s1", DensePull-SparsePush") -&gt;configApplyParallel("s1", "dynamic-vertex-parallel");</p><p>(d) Generated Code with Data Layout Configuration program-&gt;fuseVectors({"Delta", "OutDegree"}) -&gt;configApplyDirection("s1", DensePull-SparsePush") -&gt;configApplyParallel("s1", "dynamic-vertex-parallel") -&gt;configApplyDenseVertexSet("s1", "src-vertexset", "bitvector", "DensePull");  <ref type="figure">Fig. 7</ref>. Each subfigure shows pseudocode generated from applying the schedule in the caption to the GraphIt PageRankDelta code with labels from <ref type="figure" target="#fig_1">Fig. 4</ref> and <ref type="figure" target="#fig_3">Fig. 6</ref>. The options in the caption highlighted in blue are newly added scheduling commands relative to the previous subfigure and the code highlighted in purple is pseudocode updated due to the new schedules.</p><p>To compose together different optimizations, the programmer first chooses a direction for traversal. Then the programmer can use the other scheduling functions to pick one option for the parallelization, graph partitioning, NUMA, and dense vertexset optimizations for the current direction. The programmer can configure each direction separately using the optional direction argument for hybrid directions (DensePush-SparsePush or DensePull-SparsePush). If no direction argument is specified, then the configuration applies to both directions. <ref type="figure">Fig. 7</ref> shows different schedules for PageRankDelta. <ref type="figure">Fig. 7</ref>(a) starts with the pseudocode generated from the default schedule that performs a serial SparsePush traversal. <ref type="figure">Fig. 7</ref>(b) adds hybrid traversal code that first computes the sum of out-degrees and uses it to determine whether to do a DensePull or a SparsePush traversal. This allows the implementation to pick the traversal mode that minimizes the number of edges that need to be traversed, improving work-efficiency. <ref type="figure">Fig. 7</ref>(c) adds dynamicvertex-parallelism to both directions in the generated code by parallelizing the loops and inserting synchronization code for SparsePush. Finally, <ref type="figure">Fig. 7(d)</ref> adds vertex data layout and bitvector optimizations. Fusing together the vectors Delta and OutDegree with the fuseFields function improves spatial locality of memory accesses since the two vectors are always accessed together. This optimization changes the declaration and access points for the arrays. Finally, for the DensePull direction, the source vertexset specified in from can be dynamically compressed into a bitvector to reduce the working set size, further improving spatial locality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Scheduling PageRankDelta</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Scheduling Program Structure Optimizations</head><p>To support program structure optimizations, we introduce scoped labels, which allow labels to function even after complex program transformations, and scheduling functions for fusing together loops and edgeset apply operators. <ref type="figure">Fig. 8</ref> shows two iterative edgeset apply operators (Lines 2 and 5) that can be fused together into a single iterative edgeset apply operator. GraphIt first performs loop fusion, creating a new loop (l3), and destroying the two old loops (l1 and l2). Now, it would 121:12 Y. Zhang, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe be difficult if we wanted to schedule the first edgeset apply operator in the l3 loop as the original loops l1 and l2 have been removed from the program. Since both edgeset apply operators have s1 as their label, it is hard to identify them individually. To address this, we introduce scoping to labels. The two apply operators will obtain labels l1:s1 and l2:s1, respectively. 1 #l1# for i in 1:10 2 #s1# edges.apply(func1); 3 end 4 #l2# for i in 1:10 5 #s1# edges.apply(func2); 6 end 7 schedule: 8 program-&gt;fuseForLoop("l1", "l2", "l3") 9 -&gt;fuseApplyFunctions("l3:l1:s1", "l3:l2:s1", "fusedFunc") 10 -&gt;configApplyDirection("l3:l1:s1", "DensePull");</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 8. GraphIt loop and function fusion</head><p>We also need a name node, which enforces a named scope for the label. Loops l1 and l2 are replaced with name nodes with labels l1 and l2, respectively. The resulting pseudocode is shown in <ref type="figure" target="#fig_4">Fig. 9</ref>. This enables the user to reference the first edgeset apply as l3:l1:s1 and the second edgeset apply as l3:l2:s1. After the loops are fused together, we can use fuseApplyFunctions to create a new edgeset apply to replace the l3:l1:s1 statement, which can be further configured <ref type="figure">(Fig. 10)</ref>. The new edgeset apply function, fusedFunc, concatenates the statements in the original functions, func1 and func2. In Section 7, we show that fusion of multiple iterative kernels with similar traversal patterns (Eigenvector Centrality and PageRank), and the vertex data vectors they access boosts the performance of the application by up to 60%. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">SCHEDULING REPRESENTATION</head><p>The schedules for an optimized PageRankDelta implementation become even more complex than those shown in <ref type="figure">Fig. 7(d)</ref> as we further combine NUMA and cache optimizations. It is challenging to reason about the validity of, and to generate code for, combinations of optimizations. GraphIt relies on multiple scheduling representations, specifically the graph iteration space, the vertex data vector tags, and the scoped labels, to model combinations of edge traversal, vertex data layout, and program structure optimizations. <ref type="figure">Fig. 11</ref> shows the full space of optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Graph Iteration Space</head><p>Motivation. The graph iteration space is an abstract model for edge traversals that represents the edge traversal optimizations specified by the scheduling commands in <ref type="table">Table 3</ref>. The model simplifies the design of the compiler by representing different combinations of optimizations as multi-dimensional vectors. This representation enables the compiler to easily compose together different optimizations, reason about validity through dependence analysis, and generate nested loop traversal code. The graph iteration space also defines the space of edge traversal optimizations supported by GraphIt, revealing new combinations of optimizations not explored by prior work. Definition. Let us assume that we have an operation that traverses edges and applies a user-defined function F on an edgeset Edges as shown in <ref type="figure" target="#fig_0">Fig. 12(a)</ref>. A graph iteration space defines the set of directed edges on which F is applied and the strategy of traversing the edges. The concept of graph iteration space is inspired by the traditional iteration spaces in dense nested loops <ref type="bibr" target="#b40">[Padua and Wolfe 1986;</ref><ref type="bibr" target="#b61">Wolf and Lam 1991]</ref>. First, we represent the graph as an adjacency matrix, where a column in a row has a value of one if the column represents a neighbor of the current row (the top part of <ref type="figure" target="#fig_0">Fig. 12(b)</ref>  <ref type="figure">Fig. 11</ref>. GraphIt's scheduling representation for edge traversal, vertex data layout, and program structure optimizations. The tags of the graph iteration space represent the direction and performance optimization choices for each vertex data vector and each dimension of the graph iteration space. <ref type="figure" target="#fig_0">Fig. 12</ref>. Representing an edge traversal as nested loops and corresponding graph iteration spaces. Subfigure (c) shows the four dimensions for the graph iteration space, assuming using pull direction and the fixed vertex count partitioning strategy for both SSG and BSG dimensions.  <ref type="figure">Fig. 13</ref>. Definition of the graph iteration space with four dimensions. S, B, O, and I are abbreviations for SSG_ID, BSG_ID, OuterIter, and InnerIter.</p><formula xml:id="formula_5">                   src_set = filtered sr c vertexset of F, dst_set = filtered dst vertexset of F O ∈ src_set ∧ I ∈ dst_set or O ∈ dst_set ∧ I ∈ src_set ssg_set =</formula><formula xml:id="formula_6">S (Segmented Subgraph ID) ∈ ssg_set B (Blocked Subgraph ID) ∈ bsg_set ⟨ O , I ⟩ ∈ edges within the subgraph (B or S )                   </formula><p>two-level nested for loops that iterate through every row and every column. The traversal can be viewed as a traditional 2-D iteration space. Unlike the dense iteration space, the edge traversal only happens when there is an edge from the source to the destination. Thus, we can eliminate unnecessary traversals and make the loops sparse by iterating only through columns with non-zero values in each row (the blue part in <ref type="figure" target="#fig_0">Fig. 12(b)</ref>). We define the row iterator variable as OuterIter, and the column iterator variable as InnerIter. The green part of <ref type="figure" target="#fig_0">Fig. 12(b)</ref> shows that a two dimensional graph iteration space vector is used to represent this two-level nested traversal. The two-level nested for loops can be further blocked and segmented into up to four dimensions as shown in <ref type="figure" target="#fig_0">Fig. 12(c)</ref>. The dimensions of the graph iteration space encode the nesting level of the edge traversal, and the tags for each dimension specify the strategy used to iterate through that dimension. We provide more details of the graph iteration space below.  <ref type="figure">Fig. 11</ref>) specify direction and optimization strategy for each dimension, and are shown in square brackets next to each dimension. Graph Iteration Space Dimensions. The graph iteration space in GraphIt uses four dimensions, defined in <ref type="figure">Fig. 13</ref> and illustrated in <ref type="figure" target="#fig_0">Fig. 12</ref>. The dimensions are ⟨ SSG_ID, BSG_ID, OuterIter, InnerIter ⟩ and are abbreviated as ⟨ S, B, O, I ⟩. Unused dimensions are marked with ⊥.</p><p>OuterIter (O) and InnerIter (I ) in <ref type="figure">Fig. 13</ref> are the vertex IDs of an edge <ref type="figure" target="#fig_0">(Fig. 12(b)</ref>). The ranges of O and I dimensions depend on the direction. For the push direction, O is in the filtered source vertexset (src_set) and I is in the filtered destination vertexset (dst_set). For the pull direction, O is in the dst_set and I is in the src_set. The OuterIter dimension sequentially accesses vertices, while the InnerIter dimension has a random access pattern due to neighbor vertex IDs not being sequential. The edge (O, I ) is in the edgeset of the subgraph identified by BSG_ID and SSG_ID.</p><p>The BSG_ID (Blocked Subgraph ID) dimension identifies a Blocked Subgraph (BSG) in the Blocked Subgraphs Set (bsg_set). The bsg_set is created by partitioning the graph by the OuterIter dimension as illustrated in the top part of <ref type="figure" target="#fig_0">Fig. 12(c)</ref>. This partitioning transforms the loops that traverse the edges without changing the graph data structure. The graph can be partitioned with a grain size on the number of OuterIter vertices or on the total number of edges per BSG, depending on the schedule. This dimension controls the different strategies for parallelization optimizations.</p><p>The SSG_ID (Segmented Subgraph ID) identifies a Segmented Subgraph (SSG) in the Segmented Subgraphs Set (ssg_set). The ssg_set is created by partitioning the graph by the InnerIter dimension as demonstrated in the top part of <ref type="figure" target="#fig_0">Fig. 12(c)</ref>. The partitioning transforms both the graph data structure and the loops that traverse the edges. Details of the partitioning scheme are described in prior work <ref type="bibr" target="#b64">[Zhang et al. 2017]</ref>. This dimension controls the range of random accesses, enabling cache and NUMA optimizations. The ordering of the dimensions ensures that the graph is segmented into SSGs before each SSG is blocked into BSGs. Graph Iteration Space Tags. Each dimension is annotated with tags to specify the direction and optimization strategies <ref type="figure">(Fig. 11</ref> illustrates the tags in GraphIt). There are four types of tags: Direction Tags (DR-Tag), Partitioning Tags (PT-Tag), Parallelization Tags (PR-Tag), and Filtering Tags (FT-Tag). We show tags for each dimension within square brackets in <ref type="figure" target="#fig_1">Fig. 14</ref>. <ref type="table" target="#tab_10">Table 4</ref> shows the mapping between scheduling language commands from Section and the corresponding graph iteration space vector and tags.</p><p>Direction Tags specify whether the traversal is in push or pull direction. In the push direction, the OuterIter is tagged as src and InnerIter tagged as dst; in the pull direction, the tags are reversed. <ref type="table">Table 5</ref>. The schedules applied for PageRankDelta and the generated graph iteration space vectors with tags, following the examples in <ref type="figure">Fig. 7</ref>. Newly added scheduling commands and the affected dimensions and tags in the graph iteration space are highlighted in bold. ⊥ is an unused dimension. The abbreviated dimensions and tags are defined in <ref type="figure">Fig. 13 and Fig. 11</ref>. The keyword 'Program' and the continuation symbol '-&gt;' are omitted. 'ca' is an abbreviation for 'configApply'. "caParallel" is short for configApplyParallelization. Note that configApplyNumSSG uses an integer parameter (X ) which is dependent on the data and hardware system. caDirection("s1","DensePull-SparsePush"); caParallel("s1","dynamic-vertex-parallel"); caDenseVertexSet("s1","src-vertexset", "bitvector","DensePull"); caNumSSG("s1","fixed-vertex-count",X, "DensePull"); Partitioning Tags specify the strategy used for partitioning the SSG_ID or BSG_ID dimensions. For example, the default fixed vertex count (FVC) partitioning strategy will partition the graph based on a fixed number of InnerIter or OuterIter vertices as shown in <ref type="figure" target="#fig_0">Fig. 12(c)</ref>. Depending on the input, this scheme may lead to an unbalanced number of edges in each SSG or BSG. Alternatively, the edge-aware vertex count (EVC) scheme partitions each subgraph with a different number of InnerIter or OuterIter vertices to ensure each subgraph have similar number of edges. The EVC tag is used when the users specify the edge-aware-dynamic-vertex-parallel option with configApplyParalllelization or the edge-aware-vertex-count option with configApplyNumSSG.</p><p>Parallelization Tags control whether to iterate through the dimension using serial (SR), staticpartitioned parallel (SP), or dynamic work-stealing parallel (WSP) execution strategies. The PR-Tag for the BSG_ID dimension controls the parallelization strategy across different Blocked Subgraphs within a Segmented Subgraph. Tagging the SSG_ID dimension to be parallel enables NUMA optimizations by executing multiple SSGs in different sockets in parallel. If work-stealing is enabled, threads on one socket can steal unprocessed SSGs from another socket to improve load balance.</p><p>Filtering Tags on the OuterIter and InnerIter dimensions control the underlying data structure. Filtering is implemented with sparse arrays (SA), dense boolean arrays (BA), or dense bitvectors (BV). The sparse arrays contain all of the vertices that pass the filtering, while the dense boolean arrays or the bitvectors set the value to true or the bit to one for each vertex that passes the filtering. Graph Iteration Spaces for PageRankDelta. <ref type="table">Table 5</ref> continues to use PageRankDelta as an example to illustrate how scheduling language commands generate graph iteration space vectors and tags. The first row shows that the SparsePush schedule maps to a graph iteration space vector with only two dimensions used (⊥ means the dimension is unused). The direction tags for the OuterIter and InnerIter dimensions, src and dst, indicate that this graph iteration space is for the push direction. Going from SparsePush to DensePull-SparsePush creates a new graph iteration space vector for the pull direction. A runtime threshold on the size of the source vertexset is used to decide which vector gets executed. The configApplyParallelization function configures the 121:16 Y. Zhang, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe # generate edgeset traversal code based on # apply_expr: algorithmic operators. such as apply, from, to, src_filter, and dst_filter # gis_vec_list: graph iteration space vectors generated with the scheduling language gen-edgeset-apply (List&lt;GraphIterSpaceVector&gt; gis_vec_list, EdgesetApplyExpr apply_expr){ # two graph iteration space vectors might be supplied # one of the two graph iteration space vectors will be selected at runtime if (gis_vec_list contains two graph iteration space vectors) { # generate a condition to select one of the two graph iteration space vectors print "if"; emit-gis-vector-select-condition (gis_vec_list, apply_expr); print "{"; gen-SSG (gis_vec_list[0], apply_expr); print " } else { "; gen-SSG (gis_vec_list[1], apply_expr); print "}"; } else { gen-SSG (gis_vec_list[0], apply_expr); } } # generate traversal code for the SSG dimension gen-SSG (GraphIterSpaceVector gis_vec, EdgesetApplyExpr apply_expr) { emit-SSG-traversal-loop (gis_vec, apply_expr); # see subsection SSG Code Generation gen-BSG (gis_vec, apply_expr); emit-SSG-post-traversal-code (gis_vec, apply_expr); } # generate traversal code for the BSG dimension gen-BSG (GraphIterSpaceVector gis_vec, EdgesetApplyExpr apply_expr) { emit-BSG-traversal-loop (gis_vec, apply_expr); # see subsection BSG Code Generation gen-OuterIter-InnterIter (gis_vec, apply_expr); emit-BSG-post-traversal-code (gis_vec, apply_expr); } # generate traversal code for the outerIter and innerIter gen-OuterIter-InnterIter (GraphIterSpaceVector gis_vec, EdgesetApplyExpr apply_expr) { # see subsection OuterIter and InnerIter Code Generation emit-OuterIter-InnerIter-Nested-loops (gis_vec, apply_expr); } <ref type="figure" target="#fig_2">Fig. 15</ref>. Code generation algorithm for the graph iteration space.</p><p>BSG_ID dimension with work-stealing parallelism (WSP) and uses the default 1024 grainsize. The fourth row demonstrates that configDenseVertexSet sets the filtering tag for the innerIter dimension to bitvector (BV) in the graph iteration space vector for the pull direction. Finally, configNumSSG sets up the SSG_ID dimension to partition the graph for cache locality. In the fixed-vertex-count configuration (FVC), the InnerIter range for each SSG is computed by dividing the total number of vertices by the number of SSGs specified with X . Generalizing Graph Iteration Spaces. The graph iteration space concept can be generalized to expand the space of supported optimizations. In GraphIt, we restrict the graph iteration space to four dimensions with fixed partitioning schemes. Adding more dimensions and/or removing constraints on how the dimensions are partitioned can potentially represent additional optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Vertex Data Layout and Program Structure Optimizations Representation</head><p>Since the vertex data are stored as abstract vectors, they can be implemented as an array of structs or struct of arrays. We use vector tags to tag each vertex data vector as Array of Structs (AoS) or a separate array in the implicit global struct (SoA). These tags can be configured with the fuseFields scheduling function. Program structure optimizations update the structure of the loops and edgeset apply operators. We use the scoped labels (described in Section 4.3), which are specified in the scheduling language with fuseForLoop and fuseApplyFunctions, to represent the optimizations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">COMPILER IMPLEMENTATION</head><p>This section describes the GraphIt compiler, which generates optimized C++ code from an algorithm and a schedule. We also built an autotuner on top of the compiler to automatically find highperformance schedules.  <ref type="figure">Fig. 18</ref>. Generated DensePull code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Code Generation for Graph Iteration Space</head><p>We first show the high-level code generation algorithm for the graph iteration space in <ref type="figure" target="#fig_2">Fig. 15</ref>. To deal with hybrid traversal modes that have two graph iteration space vectors, such as DensePull-SparsePush, gen-edgeset-apply generates two implementations of edge traversal logic with additional logic to choose an implementation based on the sum of the out-degrees of active vertices (the "if", "else", and emit-gis-vector-select-condition shown in <ref type="figure" target="#fig_2">Fig. 15</ref>) as described in Section 2. The functions gen-SSG, gen-BSG, and gen-OuterIter-InnerIter generate nested traversal loops for the different graph iteration space dimensions. Below, we provide more details on the code generation functions and the mechanisms to ensure the validity of the optimizations. OuterIter and InnerIter Code Generation. We demonstrate how to generate traversal code for the OuterIter and InnerIter dimensions using a simple example with the SparsePush configuration shown in <ref type="figure" target="#fig_3">Fig. 16</ref> (graph iteration space and tags: ⟨ ⊥, ⊥, O [src, SR, SA], I [dst, SR, BA] ⟩; abbreviations and sets are defined in <ref type="figure">Fig. and Fig. 11</ref>).</p><p>#s1# edges.from(Frontier).dstFilter(dstFunc).apply(applyFunc) schedule:</p><p>program-&gt;configApplyDirection("s1","SparsePush"); For the push direction, OuterIter is src and InnerIter is dst. Since the source (OuterIter) filtering is tagged as Sparse Array (SA), the outer loop iterates over the source vertexset (Frontier). The dst (InnerIter) filtering uses the user-defined boolean function dstFunc. The generated code is shown in <ref type="figure">Fig. 17</ref>.</p><p>We show code generated for a DensePull traversal mode (⟨ ⊥, ⊥, O [dst, SR, BA], I [src, SR, BA] ⟩ ) in <ref type="figure">Fig. 18</ref>. The OuterIter is now dst and the InnerIter is src. The user-defined function applyFunc is applied to every edge as before. The vertexsets are automatically converted from the sparse array of vertices (vert_array shown in the SparsePush example above) to a boolean map (bool_map in the DensePull example). Filtering on destination vertices (dstFilter) is attached as an if statement next to the dst iterator (OuterIter). Blocked Subgraph (BSG) Code Generation. The BSG dimension in the graph iteration space is created by partitioning the OuterIter dimension. GraphIt uses the partitioning tag for this dimension to control the granularity and blocking strategy for load balancing, and the parallelization tag to control the mode of parallelization. <ref type="figure">Fig. shows</ref> an example of the generated code, assuming OuterIter represents src. If the edge-aware vertex count (EVC) partitioning tag is used, the compiler generates chunks with approximately the number of edges specified by the schedule. For the fixed vertex count (FVC) partitioning tag, the compiler uses the built-in grain size in OpenMP. For parallelization tags static parallelism (SP) and dynamic work-stealing parallelism (WSP), we simply use the OpenMP pragmas to implement parallel_for (pragma omp for parallel schedule (static) and schedule (dynamic)). Segmented Subgraph (SSG) Code Generation. Using the SSG dimension requires adding a loop outside of the existing traversals and changing the data layout of the graph. GraphIt generates code in the main function to create the SSGs by partitioning the graph by InnerIter. This partitioning The cache optimization processes one SSG at a time (SR), but processes the BSGs within the SSG in parallel. The programmer can enable NUMA optimizations by specifying the parallelization tag for SSG as static parallel (SP); the compiler then assigns different SSGs to be executed on different sockets. GraphIt implements this assignment using numa_alloc in the main function to first allocate SSGs on different sockets, and then uses the proc_bind API in OpenMP to assign threads to process each socket-local subgraph. If work-stealing parallelism (WSP) is enabled for SSGs, then a socket can steal an SSG allocated on another socket if no work remains on the current socket.</p><p>In some cases, we need to use NUMA-local buffers to store intermediate results from each SSG. The compiler generates code for allocating NUMA-local buffers and changes the data references from updating global vertex data vectors to the NUMA-local buffers. The compiler also generates code for a merge phase that merges NUMA-local buffers to update the global data vectors. Validity of Optimizations. GraphIt ensures the validity of single edge traversal optimizations by imposing a set of restrictions on the GraphIt language and using dependence analysis to insert appropriate atomic synchronization instructions.</p><p>We enforce some restrictions on read-write accesses and reduction operators for vertex data vectors across user-defined functions used in srcFilter, dstFilter, and edgeset apply functions for a given edgeset traversal operation. Each vertex data vector must have only one of the following properties: read-only, write-only, or reduction. Additionally, reductions are commutative and associative. With these two restrictions, transformations do not need to preserve read-after-write dependences, and transformations remain valid independent of edge traversal order. Therefore, a transformed program is valid as long as each filtered edge is processed exactly once. GraphIt does provide asyncMax and asyncMin reduction operators for cases where there can be some read and write dependences. The programmer is responsible for ensuring that reordering traversals will not affect the final outcome of the program when using asyncMax and asyncMin. These operators are useful for applications such as connected components and single-source shortest paths as the vertex data values will eventually converge.</p><p>To ensure that each filtered edge is processed exactly once, we insert synchronization code to vertex data vector updates by leveraging dependence analysis theory from dense loop iteration spaces <ref type="bibr" target="#b30">[Li et al. 1989;</ref><ref type="bibr" target="#b35">Maydan et al. 1991]</ref>. Dependence analysis is well-suited for GraphIt because the language prevents aliasing and each vertex data vector represents a separate data structure. Additionally, the goal of the analysis is not to automatically parallelize the loop with a correctness guarantee, but the much easier task of determining whether synchronization code is necessary for a given parallelization scheme. Accomplishing this task does not require a precise distance vector.</p><p>Below we show a code snippet of PageRankDelta with the SparsePush configuration ( ⟨ ⊥, ⊥, O [src, SR, SA], I [dst, SR] ⟩), the distance vector, and read-write properties of the vectors. The compiler builds a dependence vector for the OuterIter and InnerIter dimensions based on their direction tags. We see that DeltaSum has a dependence with the reduction operator (it is both read from and written to). Different source nodes can update the same dst, and so we assign * to the first element of the distance vector to denote that there is a dependence on an unknown iteration of src, which maps to OuterIter based on the direction tags. Given a src, we know that the dst's are all different, and thus, there is no data dependence on the second iterator and we assign the second value of the distance vector as 0. Since Delta and OutDegree are both read-only, they have the distance vector ⟨0, 0⟩ with no dependence across different iterations. Given that DeltaSum's distance vector's first element is * , the compiler knows that synchronization must be provided when parallelizing the OuterIter (outer loop). If only the InnerIter (inner loop) is parallelized, then no synchronization is needed.</p><p>A similar analysis works on a DensePull (⟨ ⊥, ⊥, O [dst, SR, BA], I [src, SR] ⟩) PageRankDelta. The code snippet and distance vectors are shown below. The first element in the distance vector for DeltaSum is 0 given that there is no dependence among different destination vertices and OuterIter represents dst. However, the value is * on the second element because different sources will update the same destination. Parallelizing OuterIter in this case does not require any synchronization. Since BSG is partitioned by OuterIter, parallelizing the BSG_ID dimension would have the same effect as parallelizing OuterIter. Similarly, parallelizing SSG_ID has the same effect as parallelizing InnerIter given SSG is partitioned by InnerIter.</p><p>When applying NUMA optimizations to the second code snippet with the DensePull direction (parallelizing both the SSG and BSG dimensions), we have a dependence vector of ⟨ * , * ⟩ for DeltaSum. In this case, GraphIt writes the updates to DeltaSum[dst] to a socket-local buffer first and later merges buffers from all sockets to provide synchronization.</p><p>For the hybrid traversal configurations, GraphIt generates two versions of the user-defined apply function since the synchronization requirements for the push and pull directions are different. Each version will be used in the corresponding traversal mode.  To generate code with different physical data layouts for the vertex data (array of structs or struct of arrays), GraphIt generates declaration and initialization code in the main function and updates references to vertex data in the other functions. The compiler first transforms assignments on vertex data vectors into vertexset apply operations that set the values of the data vectors. If the programmer specifies the fuseField command, GraphIt generates a new struct type, an array of structs declaration, and changes the references to the vertex data vectors in the functions to access fields of the struct instead of separate arrays. For example, the assignment statement for the parent vector parent : vector {Vertex}(int) = -1; is implemented by first declaring an apply function vertexset_apply_f and another vertices.apply statement in the main 121:20 Y. Zhang, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe function that uses vertexset_apply_f as shown in <ref type="figure" target="#fig_0">Fig. 21</ref>. The vector access expression in the apply function will then be lowered from parent <ref type="bibr">[v]</ref> to fused_struct <ref type="bibr">[v]</ref>.parent (Line 2 of <ref type="figure" target="#fig_0">Fig. 21</ref>). The correctness of the program is not impacted by the vertex data layout optimization as it does not affect the execution ordering of the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Code Generation for Vertex Data Layout Optimizations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Code Generation for Program Structure Optimizations</head><p>Traditional compilers with a fixed number and order of optimization passes are ill-suited for program structure optimizations, such as kernel fusion. The GraphIt compiler introduces a new scheduledriven optimization pass orchestration design that allows users to add more optimization passes and dictate the order of the added optimizations with the label-based scheduling language described in Section 4. Users can perform fine-grained loop fusion, loop splitting, and fusion of apply functions on loops and functions specified with statement labels and scheduling commands. These optimizations are implemented as customized optimization passes on the intermediate representation of the program. GraphIt implements these program structure transformation schedules by adding new optimization passes that transform the intermediate representation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Autotuning GraphIt Schedules</head><p>Finding the right set of schedules can be challenging for non-experts. GraphIt can have up to 10 5 valid schedules with each run taking more than 30 seconds for our set of applications and input graphs. Exhaustive searches would require weeks of time. As a result, we use OpenTuner <ref type="bibr" target="#b3">[Ansel et al. 2014</ref>] to build an autotuner on top of GraphIt that leverages stochastic search techniques (e.g., AUC bandit, greedy mutation, differential mutation, and hill climbing) to find high-performance schedules within a reasonable amount of time. Search space. We limit the tuning to a single edgeset apply operation identified by the user. The autotuner will try different configurations for the direction of the traversal (configApplyDirection), the parallelization scheme (configApplyParallelization), the data layout for the dense vertexset (configApplyDenseVertexSet), the partitioning strategy of the graph (configApplyNumSSG), and the NUMA execution policy (configApplyNUMA).</p><p>Not all generated schedules are valid because schedules have dependencies among them. For example, configApplyNumSSG, which takes a direction parameter, is only valid if the direction specified is also set by configApplyDirection. Instead of reporting an invalid schedule as error, GraphIt's autotuner ignores invalid schedules to smooth the search space. For example, the configApplyNumSSG configuration is ignored if the direction specified is not valid.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EVALUATION</head><p>In this section, we compare GraphIt's performance to state-of-the-art frameworks and DSLs on graphs of various sizes and structures. We also analyze performance tradeoffs among different GraphIt schedules. We use a dual socket system with Intel Xeon E5-2695 v3 CPUs with 12 cores each for a total of 24 cores and 48 hyper-threads. The system has 128GB of DDR3-1600 memory and 30 MB last level cache on each socket, and runs with Transparent Huge Pages (THP) enabled. Data Sets. <ref type="table">Table 6</ref> lists our input datasets and their sizes. LiveJournal, Twitter, and Friendster are three social network graphs. Friendster is special because its number of edges does not fit into a 32-bit signed integer. We use WebGraph from the 2012 common crawl. USAroad is a mesh network with small and undeviating degrees. The Netflix rating dataset and its synthesized expansion (Netflix2x) are used to evaluate Collaborative Filtering. <ref type="table">Table 7</ref> shows the execution time of GraphIt and other systems. The best performing schedules for GraphIt are shown in <ref type="table">Table 8</ref>. <ref type="table">Table 9</ref> shows the line counts of four graph algorithms for each framework. GraphIt often uses significantly fewer lines of code compared to the other frameworks. Unlike GraphIt, other frameworks with direction optimizations require programmers to provide many low-level implementation details as discussed in Section 3. GraphIt outperforms the next fastest of the six state-of-the-art shared-memory frameworks on 24 out of 32 experiments by up to 4.8×, and is never more than 43% slower than the fastest framework on the other experiments. PR. GraphIt has the fastest PR on 4 out of the 5 graphs and is up to 54% faster than the next fastest framework because it enables both cache and NUMA optimizations when necessary. <ref type="table">Table 10</ref> shows that on the Twitter graph, GraphIt has the lowest LLC misses, QPI traffic, and cycles stalled compared to Gemini and Grazelle, which are the second and third fastest. GraphIt also reduces the line count by up to an order of magnitude compared to Grazelle and Gemini as shown in <ref type="table">Table 9</ref>. Grazelle uses the Vector-Sparse edge list to improve vectorization, which works well on graphs with low-degree vertices <ref type="bibr" target="#b19">[Grossman et al. 2018]</ref>, outperforming GraphIt by 23% on USAroad. GraphIt does not yet have this optimization, but we plan to include it in the future. Frameworks other than Gemini and Grazelle do not optimize for cache or NUMA, resulting in much worse running times. BFS. GraphIt has the fastest BFS on 4 out of the 5 graphs (up to 28% faster than the next fastest) because of its ability to generate code with different direction and bitvector optimizations. On LiveJournal, Twitter, WebGraph, and Friendster, GraphIt adopts Ligra's direction optimization. On USAroad, GraphIt always uses SparsePush and omits the check for when to switch traversal direction, reducing runtime overhead. In the pull direction traversals, GraphIt uses bitvectors to represent the frontiers when boolean array representations do not fit in the last level cache, whereas Ligra always uses boolean arrays and Grazelle always uses bitvectors. GraphIt outperforms Galois' BFS, even though Galois is highly-optimized for road graphs. GraphMat and Green-Marl do not <ref type="table">Table 7</ref>. Running time (seconds) of GraphIt and state-of-the-art frameworks. The fastest results are bolded. The missing numbers correspond to a framework not supporting an algorithm and/or not successfully running on an input graph. Galois' Betweenness Centrality (BC) uses an asynchronous algorithm, while other frameworks use a synchronous one. We ran PageRank (PR) for 20 iterations, PageRankDelta (PRDelta) for 10 iterations, and Collaborative Filtering (CF) for 10 iterations. Breadth-First Search (BFS), Single Source Shortest Paths (SSSP), and Betweenness Centrality (BC) times are averaged over 10 starting points. <ref type="table">Table 9</ref>. Line counts of PR, BFS, CC, and SSSP for GraphIt, Ligra, GraphMat, Green-Marl, Galois, Gemini, and Grazelle. Only Green-Marl has fewer lines of code than GraphIt. GraphIt has an order of magnitude fewer lines of code than Grazelle (the second fastest framework on the majority of the algorithms we measured). For Galois, we only included the code for the specific algorithm that we used. Green-Marl has a built-in BFS. <ref type="table" target="#tab_10">Grazelle  PR  34  74  140      BFS      58    CC         SSSP</ref> have the direction optimization so it is much slower. Ligra is slightly faster than GraphIt on the smaller LiveJournal graph due to better memory utilization, but is slower on larger graphs. <ref type="table">Table 10</ref>. LLC miss rate, QPI traffic, cycles with pending memory loads and cache misses, and parallel running time (seconds) of PR, CC, and PRDelta running on Twitter, and CF running on Netflix. CC. GraphIt has the fastest CC on Twitter, WebGraph, and Friendster because of the direction, bitvector, and cache optimizations. <ref type="table">Table 10</ref> shows GraphIt's reduced LLC miss rate and cycles stalled. Interestingly, Gemini has the lowest QPI traffic, but is much slower than GraphIt. With NUMA optimizations, vertices in one socket fail to see the newly propagated labels from vertices in another socket, resulting in slower convergence. Unlike other NUMA-aware graph processing frameworks, GraphIt can easily enable or disable NUMA optimizations depending on the algorithm. We choose the label propagation algorithm option on Galois and use the FRONTIERS_WITHOUT_ASYNC option on Grazelle in order to compare the same algorithm across frameworks. Galois' CC is 35% faster than GraphIt on USAroad because it uses a special asynchronous engine instead of a frontierbased model. We also ran Galois's union-find CC implementation but found it to be slower than GraphIt on all graphs except USAroad. Grazelle's CC using the Vector-Sparse format, implemented with hundreds of lines of assembly code as shown in <ref type="table">Table 9</ref>, is 43% faster than GraphIt on USAroad.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Comparisons with State-of-the-Art Frameworks</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GraphIt Ligra GraphMat Green-Marl Galois Gemini</head><p>The best performing schedule that we found on USAroad without any asynchronous mechanism is DensePush-SparsePush. CF. For CF, GraphIt is faster than Ligra and GraphMat (by 4-4.8×) because the edge-aware-dynamicvertex-parallel schedule achieves good load balance on Netflix. Cache optimization further improves GraphIt's performance and is especially beneficial on Netflix2x. SSSP. GraphIt has the fastest SSSP on 4 out of the 5 graphs because of its ability to enable or disable the direction optimization and the bitvector representation of the frontier. We run Galois with the Bellman-Ford algorithm so that the algorithms are the same across systems. We also tried Galois's asynchronous SSSP but found it to be faster than GraphIt only on WebGraph. Green-Marl's SSSP on USAroad is 328 times slower than GraphIt because it uses the DensePush configuration. On every round, it must iterate through all vertices to check if they are active. This is expensive on USAroad because for over 6000 rounds, the active vertices count is less than 0.4% of all the vertices. PRDelta. GraphIt outperforms Ligra on all graphs by 2-4× due to better locality from using bitvectors as frontiers, fusing the Delta and OutDegree arrays as shown in <ref type="figure" target="#fig_1">Fig. 4</ref>, and applying both the cache and NUMA optimizations in the pull direction. <ref type="table">Table shows</ref> GraphIt's reduced LLC miss rate, QPI traffic, and cycles stalled. BC. GraphIt achieves the fastest BC performance on the USAroad and Friendster graphs and has comparable performance on the other graphs. GraphIt is a bit slower than Gemini on Twitter and WebGraph because it does not support bitvector as a layout option for vertex data vectors layouts. We plan to add this in the future. <ref type="figure" target="#fig_0">Fig. 22</ref> demonstrates the impact of traversal direction, data structures used for keeping track of active vertices, and cache optimizations. For a given algorithm, there is no single schedule that works well on all input graphs. For BFS, DensePullSparsePush with cache optimizations reduces the number of memory accesses on LiveJournal, Twitter, WebGraph, and Friendster, achieving up to 30× speedup. However, using only SparsePush can reduce the runtime overhead on USAroad as described in Section 7.1. For CC, the bitvector and cache optimizations improve locality of 121:24 Y. Zhang, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe <ref type="figure" target="#fig_0">Fig. 22</ref>. Performance of different schedules for BFS, CC, and PRDelta. SparsePush and DensePullSparsePush refer to the traversal directions. BitVec refers to the dense frontier data structure. Cache refers to the cache optimization. The descriptions of these schedules can be found in Section 2.2. The full scheduling commands are shown in <ref type="table">Table 8</ref>. memory accesses for Twitter, WebGraph, and Friendster, but hurt the performance of LiveJournal and USAroad due to lower work-efficiency. For PRDelta, SparsePush sometimes outperforms DensePullSparsePush, but when the cache optimization is applied to the pull direction, hybrid traversal is preferred. <ref type="figure" target="#fig_0">Fig. 23</ref> shows that the parallelization scheme can have a major impact on scalability, and again there is no single scheme that works the best for all algorithms and inputs. For CF, the amount of work per vertex is proportional to the number of edges incident to that vertex. Consequently, the edge-aware-dynamic-vertex-parallel scheme is 2.4× faster than the dynamic-vertex-parallel approach because of better load balance. For PRDelta, the number of active vertices quickly decreases, and many of the edges do not need to be traversed. As a result, the edge-aware-dynamic-vertexparallel scheme has a smaller impact on performance. The dynamic-vertex-parallel approach is a good candidate for BFS because not all edges incident to a vertex are traversed. Using the edgeaware-dynamic-vertex-parallel scheme for BFS ends up hurting the overall load balance. We omit the edge-parallel approach because it is consistently worse than edge-aware-dynamic-vertex-parallel due to the extra synchronization overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Performance of Different Schedules</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Autotuning Performance</head><p>The autotuner found schedules that performed within 5% of the hand-tuned schedules for all of the benchmarks in under 5000 seconds. For three benchmarks, the autotuner found schedules that outperformed hand-tuned schedules by up to 10%. <ref type="figure" target="#fig_0">Fig. 24</ref> demonstrates the performance improvement of kernel fusion with PageRank and Eigenvector Centrality. They have similar memory access patterns. GraphIt significantly improves the spatial locality of the memory accesses by fusing together the two kernels and the vectors they access  <ref type="table">Table 11</ref>. Optimizations adopted by various frameworks (explained in Section 2): WSVP (work-stealing vertex-parallel), WSEVP (work-stealing edge-aware vertex-parallel), SPVP (static-partitioned vertex-parallel with no work-stealing), EP (edge-parallel), BA (dense boolean array), BV (dense bitvector), AoS (Array of Structs), SoA (Struct of Arrays), SPS (SparsePush), DPS (DensePush), SP (SparsePull), DP (DensePull), SPS-DP (hybrid direction with SPS and DP depending on frontier size), DPS-SPS (hybrid with DPS and SPS), DPS-DP (hybrid with DPS and DP). (vertex data layout optimization). <ref type="figure">Fig.</ref> shows significant reduction in cycles stalled on L1 data cache and L2 cache misses, leading to the speedups.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Fusion of Multiple Graph Kernels</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RELATED WORK</head><p>Shared-Memory Graph Processing Libraries and DSLs. Many high-performance graph frameworks and DSLs, including GraphIt, optimize their performance for shared-memory systems. Many of these frameworks support only a limited set of combinations of optimization techniques as shown in <ref type="table">Table 11</ref> (these optimizations are described in Section 2). GraphIt significantly expands the space of optimizations by composing large number of effective optimizations, supporting two orders of magnitude more optimization combinations than existing frameworks. GraphIt achieves high performance by enabling programmers to easily find the best combination of optimizations for their specific algorithm and input graph. GraphIt also finds previously unexplored combinations of optimizations to significantly outperform state-of-the-art frameworks on many algorithms. Many shared-memory graph systems, such as Ligra <ref type="bibr" target="#b54">[Shun and Blelloch 2013]</ref>, Gunrock <ref type="bibr" target="#b60">[Wang et al. 2016]</ref>, GraphGrind <ref type="bibr" target="#b55">[Sun et al. 2017]</ref>, Polymer <ref type="bibr" target="#b63">[Zhang et al. 2015]</ref>, Gemini <ref type="bibr" target="#b66">[Zhu et al. 2016]</ref> and Grazelle <ref type="bibr" target="#b19">[Grossman et al. 2018]</ref>, adopt the frontier-based model. Galois <ref type="bibr" target="#b38">[Nguyen et al. 2013</ref>] also has an implementation of the model and a scheduler that makes it particularly efficient for road graphs. The frontier-based model <ref type="bibr" target="#b54">[Shun and Blelloch 2013]</ref> operates efficiently on subsets of vertices (frontiers) and their outgoing edges using the direction optimization <ref type="bibr" target="#b4">[Beamer et al. 2012]</ref>. Flat data-parallel operators are used to apply functions to the frontier vertices and their neighbors with parallel direction optimizations. Existing frameworks only support up to three of the many possible directions, with little support for different parallelization schemes and frontier and vertex data layout optimizations. GraphIt significantly expands the space of optimizations by enabling combinations of data layout optimization, different direction choices, and various parallelization schemes <ref type="table">(Table 11)</ref>. GraphIt also makes programming easier by freeing the programmer from specifying low-level implementation details, such as updated vertex tracking and atomic synchronizations.</p><p>Many frameworks and techniques have been introduced to improve locality with NUMA and cache optimizations. GraphGrind, Grazelle, Gemini and Polymer all support NUMA optimizations. CSR Segmenting <ref type="bibr" target="#b64">[Zhang et al. 2017]</ref> and cache blocking <ref type="bibr" target="#b6">[Beamer et al. 2017;</ref><ref type="bibr" target="#b39">Nishtala et al. 2007]</ref> have been introduced to improve the cache performance of graph applications through graph partitioning. However, both techniques have not been integrated in a general programming model or combined with direction optimizations. GraphIt supports NUMA optimizations and integrates a simplified variant of CSR segmenting to compose cache optimizations with other optimizations.</p><p>Other shared-memory systems <ref type="bibr" target="#b56">[Sundaram et al. 2015;</ref><ref type="bibr" target="#b62">Yan et al. 2017]</ref> adopt the vertex-centric model to exploit data parallelism across vertices. Programmers specify the logic that each (active) vertex executes iteratively. Frameworks <ref type="bibr" target="#b22">[Kang et al. 2011;</ref><ref type="bibr" target="#b32">Lugowski et al. 2012</ref>] use sparse matrixvector multiplication with semirings to express graph algorithms. However, both programming models cannot easily integrate direction optimization, which requires different synchronization strategies for each vertex in push and pull directions.</p><p>Green-Marl <ref type="bibr" target="#b20">[Hong et al. 2012]</ref>, Socialite <ref type="bibr" target="#b27">[Lam et al. 2013]</ref>, Abelian , and Empty-Headed <ref type="bibr" target="#b2">[Aberger et al. 2016]</ref> are DSLs for shared-memory graph processing. Green-Marl provides a BFS primitive, and so programs that can be expressed with BFS invocations are relatively concise. However, for other graph programs, the programmer needs to write the loops over vertices and edges explicitly, making it hard to integrate direction optimization due to the lower level nature of the language. Socialite and EmptyHeaded provide relational query languages to express graph algorithms. The underlying data representation is in the form of tables, and due to extensive research in join optimizations, these systems perform especially well for graph algorithms that can be expressed efficiently using joins (e.g., subgraph finding). However, since these languages do not allow for explicit representation of active vertex sets, their performance on graph traversal algorithms is worse than the frontier-based frameworks <ref type="bibr" target="#b2">[Aberger et al. 2016;</ref><ref type="bibr" target="#b51">Satish et al. 2014]</ref>. These DSLs also do not support composition of optimizations or expose extensive performance tuning capabilities.</p><p>A number of graph processing frameworks have been developed for GPUs (see <ref type="bibr" target="#b53">[Shi et al. 2018</ref>] for a survey). We did not focus on GPUs in this paper as the current GPU memory capacities do not allow us to process very large graphs in-memory. Out-of-Core Graph Processing Frameworks. There has been a significant amount of work dealing with graphs that cannot fit in memory (e.g., <ref type="bibr" target="#b21">[Jun et al. 2018;</ref><ref type="bibr" target="#b26">Kyrola et al. 2012;</ref><ref type="bibr" target="#b33">Maass et al. 2017;</ref><ref type="bibr" target="#b49">Roy et al. 2013;</ref><ref type="bibr" target="#b57">Vora et al. 2016;</ref><ref type="bibr" target="#b58">Wang et al. 2017</ref><ref type="bibr" target="#b59">Wang et al. , 2015</ref><ref type="bibr" target="#b62">Yan et al. 2017;</ref><ref type="bibr" target="#b65">Zheng et al. 2015;</ref><ref type="bibr" target="#b67">Zhu et al. 2015]</ref>), while GraphIt focuses on in-memory graph processing. Some of the optimizations in out-of-core systems also focus on improving locality of accesses, parallelism, and work-efficiency, but the tradeoff space for these techniques is very different when optimizing for the disk/DRAM boundary, instead of the DRAM/cache boundary. The higher disk access latency, lower memory bandwidth, and larger granularity of access lead to very different techniques <ref type="bibr" target="#b21">[Jun et al. 2018]</ref>. When the graphs do fit in memory, out-of-core systems, such as X-Stream <ref type="bibr" target="#b49">[Roy et al. 2013]</ref>, have shown to be much slower than shared-memory frameworks <ref type="bibr" target="#b19">[Grossman et al. 2018;</ref><ref type="bibr" target="#b64">Zhang et al. 2017]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>121:27</head><p>Distributed Graph Processing Frameworks. Graph analytics has also been studied extensively in distributed memory systems (e.g., <ref type="bibr" target="#b18">Gonzalez et al. 2012;</ref><ref type="bibr" target="#b31">Low et al. 2010;</ref><ref type="bibr" target="#b36">McCune et al. 2015;</ref><ref type="bibr" target="#b42">Prabhakaran et al. 2012;</ref><ref type="bibr" target="#b47">Roy et al. 2015;</ref><ref type="bibr" target="#b50">Sakr et al. 2017;</ref><ref type="bibr" target="#b62">Yan et al. 2017;</ref><ref type="bibr" target="#b66">Zhu et al. 2016]</ref>). The tradeoff space is also different for distributed graph processing systems due to the larger network communication overhead and greater need for load balance. Techniques used by GraphIt, such as direction optimization and locality enhancing graph partitioning can also be applied in the distributed domain <ref type="bibr" target="#b66">[Zhu et al. 2016]</ref>. These systems, when run on a single machine, generally cannot outperform shared-memory frameworks <ref type="bibr" target="#b51">[Satish et al. 2014]</ref>. Scheduling Languages. GraphIt introduces an expressive scheduling language. Examples of existing scheduling languages include Halide <ref type="bibr" target="#b45">[Ragan-Kelley et al. 2017]</ref>, CHiLL <ref type="bibr" target="#b9">[Chen et al. 2008], and</ref><ref type="bibr">HMPP [Romain et al. 2007]</ref>. These languages mainly focus on loop nest optimization in applications that manipulate dense arrays. Unlike these scheduling languages, the GraphIt scheduling language is designed for graph applications. It is the first scheduling language designed to address the challenges of graph applications, graph data structures, and graph optimizations. It allows the programmer to perform data layout transformations (which is not possible in Halide), and allows full separation between the algorithm and the schedule (which is not possible in HMPP). Unlike CHiLL, which was designed mainly for the application of affine transformations on loop nests, the GraphIt scheduling language supports a large set of non-affine transformations, which are the main type of optimizations in the context of graph applications. Program Synthesis. Program synthesis techniques have been explored in the context of graph algorithms <ref type="bibr" target="#b43">[Prountzos et al. 2012</ref><ref type="bibr" target="#b44">[Prountzos et al. , 2015</ref>, which allow many different implementations of an application to be generated. However, little control is provided to compose together different optimizations. GraphIt enables programmers to apply their knowledge to find profitable combinations of optimizations. GraphIt also supports a much wider range of optimizations. Physical Simulation DSLs. GraphIt is heavily influenced by DSLs for physical simulations, including Simit <ref type="bibr" target="#b24">[Kjolstad et al. 2016] and</ref><ref type="bibr">Liszt [DeVito et al. 2011]</ref>. However, Simit and Liszt do not support efficient filtering on vertices and edges, and do not have a scheduling language.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>We have described GraphIt, a novel DSL for graph processing that generates fast implementations for algorithms with different performance characteristics running on graphs with varying sizes and structures. GraphIt separates algorithm specifications from performance optimizations. The algorithm language simplifies expressing the algorithms. We formulate graph optimizations as tradeoffs among locality, parallelism, and work-efficiency. The scheduling language enables programmers to easily search through the complicated tradeoff space. We introduce the graph iteration space to model, compose, and ensure the validity of the edge traversal optimizations. The separation of algorithm and schedule, and the correctness guarantee of edge traversal optimizations enabled us to build an autotuner on top of GraphIt. Our experiments show that GraphIt is up to 4.8× faster than state-of-the-art graph frameworks. Future work includes extending the compiler to support more optimizations and hardware platforms (e.g., GPU and distributed-memory).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>PageRankDelta (SparsePush).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 4 .</head><label>4</label><figDesc>GraphIt code for PageRankDelta.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 5 .</head><label>5</label><figDesc>Ligra's PageRankDelta edge update function, corresponding to Lines 12-14 of Fig. 4 in GraphIt's PageRankDelta example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 6 .</head><label>6</label><figDesc>Scheduling PageRankDelta.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 9 .</head><label>9</label><figDesc>Pseudocode after loop fusion 1 #l3# for i in 1:10 #l1# namenode #s1# edges.apply(fused_func); end end Fig. 10. Pseudocode after function fusion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe &lt; S [PR-tag, (PT-Tag, count)], B [PR-tag, (PT-Tag, count)], O [DR-Tag, PR-Tag, FT-Tag], I [DR-Tag, PR-Tag, FT-Tag] &gt; Fig. 14. Graph Iteration Space Tags: Direction Tags (DR-Tag), Partitioning Tags (PT-Tag), Parallelization Tags (PR-Tag), and Filtering Tags (FT-Tag) (explained in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>⊥, O [sr c, SR, SA], I [dst , SR] ⟩ capDirection("s1","DensePull-SparsePush"); runtime decision between two graph iteration space vectors ⟨ ⊥, ⊥, O [d st , SR], I [sr c , SR, BA] ⟩ and ⟨ ⊥, ⊥, O [sr c, SR, SA], I [dst , SR] ⟩ caDirection("s1","DensePull-SparsePush"); caParallel("s1","dynamic-vertex-parallel"); runtime decision between two graph iteration space vectors ⟨ ⊥, B [WSP, (FVC, 1024)], O [dst , SR], I [sr c, SR, BA] ⟩ and ⟨ ⊥, B [WSP, (FVC, 1024)], O [sr c, SR, SA], I [dst , SR] ⟩ caDirection("s1","DensePull-SparsePush"); caParallel("s1","dynamic-vertex-parallel"); caDenseVertexSet("s1","src-vertexset", "bitvector","DensePull"); runtime decision between two graph iteration space vectors ⟨ ⊥, B [WSP, (FVC, 1024)], O [dst , SR], I [sr c, SR, BV] ⟩ and ⟨ ⊥, B [WSP, (FVC, 1024)], O [sr c, SR, SA], I [dst , SR] ⟩</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>runtime decision between two graph iteration space vectors ⟨ S [SR, (FVC, num_vert / X)], B [WSP, (FVC, 1024)], O [dst , SR], I [sr c, SR, BV] ⟩ and ⟨ ⊥, B [WSP, (FVC, 1024)], O [sr c, SR, SA], I [dst , SR] ⟩</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>i = 0; i &lt; Frontier.size(); i++){ NodeID src = Frontier.vert_array[i]; for (NodeID dst : G.getOutNghs(src)){ if (dstFunc(dst)){ applyFunc(src, dst); }}} Fig. 17. Generated SparsePush code. for (NodeID dst = 0; dst &lt; num_verts; dst++){ if (dstFunc){ for (NodeID src : G.getInNghs(dst)){ if (Frontier.bool_map(src)){ applyFunc(src, dst); }}}}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 16 .</head><label>16</label><figDesc>SparsePush configuration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>1</head><label></label><figDesc>parallel_for (int BSG_ID = 0; BSG_ID &lt; g.num_chunks; BSG_ID++){ 2 for (NodeID src = g.chunk_start[BSG_ID]; src &lt; g.chunk_end[BSG_ID]; src++) 3 for (NodeID dst : G.getOutNghs(src)) 4 applyFunc(src,dst);}Fig. 19. Generated BSG code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe can use a fixed range of vertices (FVC) in the InnerIter or a flexible range of vertices that takes into account the number of edges in each SSG (EVC) with an edge grain size. The random memory access range in each SSG is restricted to improve locality. Fig. 20 shows edge traversal code that uses both SSG and BSG dimensions (⟨ S [SR], B [SR], O [dst, SR], I [src, SR] ⟩). The segmented subgraphs are stored in g.SSG_list. for (int SSG_ID = 0; SSG_ID &lt; num_SSG; SSG_ID++){ 2 sg = g.SSG_list[SSG_ID]; 3 for (int BSG_ID = 0; BSG_ID &lt; sg.num_chunks; BSG_ID++){ for (NodeID dst = sg.chunk_start[BSG_ID]; dst &lt; sg.chunk_end[BSG_ID]; dst++) for (NodeID src : G.getInNghs(dst)) applyFunc(src,dst);}} Fig. 20. Generated SSG and BSG code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 21 .</head><label>21</label><figDesc>Vertexset apply code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 23 .</head><label>23</label><figDesc>Scalability of CF, PRDelta, and BFS with different schedules. Hyper-threading is disabled.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 24 .</head><label>24</label><figDesc>Normalized Execution Time, and L1 and L2 Cache Stall Cycles with Fusion of PageRank and Eigenvector Centrality</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe</figDesc><table><row><cell>LJ</cell><cell>3.48</cell><cell>1</cell><cell>1</cell><cell>1</cell><cell>LJ</cell><cell cols="3">1.64 3.7 5.98 1.86</cell><cell>LJ</cell><cell>1.51 1.83 3.06 1.82</cell></row><row><cell>TW</cell><cell cols="4">5.63 1.13 3.12 1.14</cell><cell>TW</cell><cell cols="2">2.34 9.4</cell><cell>11 1.62</cell><cell>TW</cell><cell>2.42 6.03 5.78 1.41</cell></row><row><cell>WB</cell><cell cols="4">4.15 1.42 2.96 1.13</cell><cell>WB</cell><cell cols="3">2.14 7.44 9.13 2.98</cell><cell>WB</cell><cell>2.59 2.84 5.96 2.54</cell></row><row><cell>RD FT</cell><cell cols="4">PR 2.69 4.81 2.16 4.57 BFS CC SSSP Ligra 6.17 1.38 4.94 2.77</cell><cell>RD FT</cell><cell cols="3">PR 1.61 9.06 7.04 151 BFS CC SSSP GraphMat</cell><cell>RD FT</cell><cell>PR 1.26 2.45 8.99 328 BFS CC SSSP GreenMarl</cell><cell>LJ TW WB</cell><cell>1 1 1</cell><cell>1.3 1.11 1.07 1 1 1 1 1 1</cell></row><row><cell>LJ TW WB</cell><cell cols="4">8.15 1.41 2.05 1.78 3.53 4.49 5.68 1.43 2.82 1.83 8.07 1.36</cell><cell>LJ TW WB</cell><cell cols="3">1.26 2.22 2.46 1.57 1.26 1.64 4.33 1 1 1.52 4.93 1.67</cell><cell>LJ WB TW</cell><cell>1.8 1.17 1.94 1.26 1.28 1.64 1.08 1.93 1.38</cell><cell>RD FT</cell><cell>GraphIt BFS CC SSSP 1.23 1 1.43 1 PR 1 1 1 1</cell></row><row><cell>RD</cell><cell cols="4">13 1.02 1.05 3.25</cell><cell>RD</cell><cell cols="3">1.49 48.8 7.08 26.1</cell><cell>RD</cell><cell>1 8.26</cell><cell>1</cell></row><row><cell>FT</cell><cell cols="4">3.61 7.02 7.05 1.08</cell><cell>FT</cell><cell cols="3">1.37 1.49 5.24 1.43</cell><cell>FT</cell><cell>1.67 1.04 2.24</cell></row><row><cell></cell><cell>PR</cell><cell cols="3">BFS CC SSSP</cell><cell></cell><cell>PR</cell><cell cols="2">BFS CC SSSP</cell><cell>PR</cell><cell>BFS CC SSSP</cell></row><row><cell></cell><cell></cell><cell cols="2">Galois</cell><cell></cell><cell></cell><cell></cell><cell cols="2">Gemini</cell><cell>Grazelle</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>DeltaSum = {0.0, . . . , 0.0}▷ Length V array 3 Delta = {1/V , . . . , 1/V } ▷ Length V array 4 procedure PageRankDelta(Graph G, α , ϵ ) 5 Frontier = { G.vertices } 6 for round ∈ {1, . . . ,MaxIter} do 7 NextFrontier = { } 8 parallel for src : Frontier do 9 for dst : G.getOutNgh[src] do 10 AtomicAdd(DeltaSum[dst], Delta[src]/G.OutDegree[src]) 11 parallel for v : G.vertices do 12 if round == 1 then</figDesc><table><row><cell></cell><cell>BaseScore = (1.0 − α )/V</cell></row><row><cell>14</cell><cell>Delta[v] = α • (DeltaSum[v])+ BaseScore</cell></row><row><cell>15</cell><cell>Delta[v] −= 1/V</cell></row><row><cell>16</cell><cell>else</cell></row><row><cell>17</cell><cell>Delta[v] = α • (DeltaSum[v])</cell></row><row><cell>18</cell><cell>Rank[v] += Delta[v]</cell></row><row><cell>19</cell><cell>DeltaSum[v] = 0</cell></row><row><cell>20</cell><cell>if |Delta[v]|&gt; ϵ •Rank[v] then</cell></row><row><cell>21</cell><cell>NextFrontier.add(v)</cell></row><row><cell>22</cell><cell>Frontier = NextFrontier</cell></row></table><note>array 2</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Zhang, M. Yang, R. Baghdadi, S. Kamil, J. Shun, S. Amarasinghe parallel for dst : G.vertices do 2 for src : G.getInNgh[dst] do 3 if src ∈ Frontier then 4 DeltaSum[dst] += Delta[src] / G.OutDegree[src] 1 parallel for src : G.vertices do 2 if src ∈ Frontier then 3 for dst : G.getOutNgh[src] do 4 AtomicAdd(DeltaSum[dst],Delta[src] / G.OutDegree[src])Fig. 3. DensePull (left) and DensePush (right).</figDesc><table><row><cell>121:6</cell><cell>Y.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">Direction Optimization and Fron-</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">tier Data Structure. Lines 8-10 of</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">SparsePush iterate over the outgoing</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">neighbors of each vertex, and update</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">the DeltaSum value of the neighbor.</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">DensePull (Fig. 3 (left)) is a different</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">traversal mode where each vertex iter-</cell><cell>Optimization</cell><cell cols="3">Locality Work-efficiency Parallelism</cell></row><row><cell cols="2">ates over its incoming neighbors that</cell><cell>DensePull</cell><cell></cell><cell>↕</cell><cell>↕</cell></row><row><cell cols="2">are in the active set, and updates its</cell><cell>DensePush</cell><cell></cell><cell>↕</cell><cell>↑</cell></row><row><cell cols="2">own DeltaSum value. DensePull in-</cell><cell>DensePull-SparsePush DensePush-SparsePush</cell><cell></cell><cell>↕ ↕</cell><cell>↕ ↑</cell></row><row><cell cols="2">creases parallelism relative to Sparse-</cell><cell>edge-aware-vertex-parallel</cell><cell></cell><cell>↓</cell><cell>↑</cell></row><row><cell cols="2">Push since it loops over all vertices in</cell><cell>edge-parallel</cell><cell></cell><cell>↓</cell><cell>↑</cell></row><row><cell cols="2">the graph. This increases work com-</cell><cell>bitvector</cell><cell>↑</cell><cell>↓</cell></row><row><cell cols="2">pared to SparsePush, which only loops</cell><cell>vertex data layout</cell><cell>↕</cell><cell>↓</cell></row><row><cell cols="2">over vertices in the active set. The up-</cell><cell>cache partitioning NUMA partitioning</cell><cell>↑ ↑</cell><cell>↓ ↓</cell><cell>↓</cell></row><row><cell cols="2">date to the DeltaSum array no longer</cell><cell>kernel fusion</cell><cell>↑</cell><cell>↓</cell></row><row><cell cols="2">requires atomics since an entry will</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 .</head><label>2</label><figDesc>Vertexset and Edgeset API. disable_deduplication is an optional parameter.</figDesc><table><row><cell>Set Operators</cell><cell>Return Type</cell><cell>Description</cell></row><row><cell>size()</cell><cell>int</cell><cell>Returns the size of the set.</cell></row><row><cell>Vertexset operators</cell><cell></cell><cell></cell></row><row><cell>filter(func f)</cell><cell>vertexset</cell><cell>Filters out vertices where f(vertex) returns true.</cell></row><row><cell>apply(func f)</cell><cell>none</cell><cell>Applies f(vertex) to every vertex.</cell></row><row><cell>Edgeset operators</cell><cell></cell><cell></cell></row><row><cell>from(vertexset vset)</cell><cell>edgeset</cell><cell>Filters out edges whose source vertex is in the input vertexset.</cell></row><row><cell>to(vertexset vset)</cell><cell>edgeset</cell><cell>Filters out edges whose destination vertex is in the input</cell></row><row><cell></cell><cell></cell><cell>vertexset.</cell></row><row><cell>filter(func f)</cell><cell>edgeset</cell><cell>Filters out edges where f(edge) returns true.</cell></row><row><cell>srcFilter(func f)</cell><cell>edgeset</cell><cell>Filters out edges where f(source) returns true.</cell></row><row><cell>dstFilter(func f)</cell><cell>edgeset</cell><cell>Filters out edges where f(destination) returns true.</cell></row><row><cell>apply(func f)</cell><cell>none</cell><cell>Applies f(source, destination) to every edge.</cell></row><row><cell>applyModified(func f,</cell><cell>vertexset</cell><cell></cell></row><row><cell>vector vec,</cell><cell></cell><cell></cell></row><row><cell>[bool disable_deduplication])</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>). With this representation, we can traverse through all edges using dense</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>121:13</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">GraphIt Scheduling Representation</cell></row><row><cell></cell><cell cols="4">Edge Traversal Optimizations</cell><cell></cell><cell></cell><cell></cell><cell cols="2">Program Structure</cell><cell>Vertex Data Layout</cell></row><row><cell></cell><cell cols="4">( Graph Iteration Space + Tags )</cell><cell></cell><cell cols="4">Optimizations (scoped labels)</cell><cell>Optimizations (vector tags)</cell></row><row><cell></cell><cell cols="6">&lt; SSG_ID, BSG_ID, OuterIter_Vert, InnerIter_Vert &gt;</cell><cell></cell><cell></cell><cell>Array of</cell><cell>Struct of</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Structs</cell><cell>Arrays</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>(AoS)</cell><cell>(SoA)</cell></row><row><cell cols="2">Partitioning tag (PT-Tag)</cell><cell cols="3">Parallelization Tag (PR-Tag)</cell><cell cols="3">Filtering Tag (FT-Tag)</cell><cell cols="2">Direction Tag (DR-Tag)</cell></row><row><cell>Fixed Vertex Count (FVC)</cell><cell>Edge-Aware Vertex Count (EVC)</cell><cell>Serial (SR)</cell><cell>Parallel</cell><cell cols="2">Dense Bitvector (BV)</cell><cell>Sparse Array (SA)</cell><cell cols="2">Dense Bool</cell><cell>src</cell><cell>dst</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="3">Array (BA)</cell></row><row><cell></cell><cell cols="6">Static Parallel (SP) Work-Stealing Parallel (WSP)</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head></head><label></label><figDesc>subgraphs created by segmenting the graph based on InnerIter ⟨ S [tags], B [tags], O [tags], I [tags] ⟩ bsg_set = subgraphs created by blocking the graph based on OuterIter</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10"><head>Table 4 .</head><label>4</label><figDesc>Mapping between GraphIt's scheduling language functions to the relevant dimensions and tags (highlighted in bold) of the graph iteration space.⟨ S [tags], B [tags], O [direction tag, filtering tag], I[direction tag, filtering tag] ⟩. Note, for hybrid directions (e.g.</figDesc><table><row><cell>Apply Scheduling Functions</cell><cell>Graph Iteration Space Dimensions and Tags Configured</cell></row><row><cell>program-&gt;configApplyDirection(label,</cell><cell></cell></row><row><cell>config);</cell><cell></cell></row><row><cell></cell><cell>DensePull-SparsePush), two graph iteration space vectors are</cell></row><row><cell></cell><cell>created, one for each direction.</cell></row><row><cell>program-&gt;configApplyParallelization(label,</cell><cell>⟨ S [tags], B [partitioning tag, parallelization tag], O [tags],</cell></row><row><cell>config, [grainSize], [direction]);</cell><cell>I [tags] ⟩</cell></row><row><cell>program-&gt;configApplyDenseVertexSet(label,</cell><cell>⟨ S [tags], B [tags], O [filtering tag], I [filtering tag] ⟩</cell></row><row><cell>config, [vertexset], [direction])</cell><cell></cell></row><row><cell>program-&gt;configApplyNumSSG(label, config,</cell><cell>⟨ S [partitioning tag], B [tags], O [tags], I [tags] ⟩</cell></row><row><cell>numSegments, [direction]);</cell><cell></cell></row><row><cell>program-&gt;configApplyNUMA(label, config,</cell><cell></cell></row><row><cell>[direction]);</cell><cell></cell></row></table><note>⟨ S [parallelization tag], B [tags], O [tags], I [tags] ⟩</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">Proc. ACM Program. Lang., Vol. 2, No. OOPSLA, Article 121. Publication date: November 2018.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">for (int i = 0; i &lt; Frontier.size(); i++){</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank Tyler Denniston, Vladimir Kiriansky, Jure Leskovec, Michael W. Mahoney, and the reviewers for their helpful feedback and suggestions. This research was supported by Toyota Research Institute, DoE Exascale award #DE-SC0008923, DARPA SDH Award #HR0011-18-3-0007, DARPA D3M Award #FA8750-17-2-0126, Applications Driving Architectures (ADA) Research Center, a JUMP Center co-sponsored by SRC and DARPA, and DOE Early Career Award #DE-SC0018947.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Algorithms. We try to use the same algorithms across different frameworks to study the impact of performance optimizations. Our evaluation is done on seven algorithms: PageRank (PR), Breadth-First Search (BFS), Connected Components (CC) with synchronous label propagation, Single Source Shortest Paths (SSSP) with frontier based Bellman-Ford algorithm, Collaborative Filtering (CF), Betweenness Centrality (BC), and PageRankDelta (PRDelta). For Galois, we used the asynchronous algorithm for BFS, and the Ligra algorithm for SSSP.  <ref type="bibr" target="#b25">[Kwak et al. 2010]</ref> M M WebGraph (WB) <ref type="bibr">[Meusel et al. [n. d.]</ref>] M M USAroad (RD) <ref type="bibr">[Demetrescu et al. [n. d.]</ref>] M 58 M Friendster (FT) <ref type="bibr" target="#b28">[Leskovec and Krevl 2014]</ref> 65.6 M 3.6 B Netflix (NX) <ref type="bibr" target="#b7">[Bennett et al. 2007]</ref> 0</p><p>Existing Frameworks. We compare GraphIt's performance to six state-ofthe-art in-memory graph processing systems: Ligra, GraphMat, Green-Marl, Galois, Gemini, and Grazelle. Ligra has fast implementations of BFS and SSSP <ref type="bibr" target="#b54">[Shun and Blelloch 2013]</ref>. Among prior work, GraphMat has the fastest shared-memory implementation of CF <ref type="bibr" target="#b56">[Sundaram et al. 2015]</ref>. Green-Marl is one of the fastest DSLs for the algorithms we evaluate <ref type="bibr" target="#b20">[Hong et al. 2012]</ref>. Galois (v2.2.1) has an efficient asynchronous engine that works well on road graphs <ref type="bibr" target="#b38">[Nguyen et al. 2013]</ref>. Gemini is a distributed graph processing system with notable shared-machine performance <ref type="bibr" target="#b66">[Zhu et al. 2016]</ref>. Compared to existing frameworks, Grazelle has the fastest PR and CC using edge list vectorization, inner loop parallelism, and NUMA optimizations <ref type="bibr" target="#b19">[Grossman et al. 2018]</ref>.  <ref type="table">Table 8</ref>. Schedules that GraphIt uses for all applications on different graphs. The schedules assume that the edgeset apply operator is labeled with s1. The keyword 'Program' and the continuation symbol '-&gt;' are omitted. 'ca' is the abbreviation for 'configApply'. Note that configApplyNumSSG uses an integer parameter (X ) which is dependent on the graph size and the cache size of a system. BC has two edgeset apply operators, denoted with s1 and s2.</p><p>Apps USAroad LiveJournal Twitter WebGraph Friendster PR caDirection("s1", "DensePull") caParallelization("s1", "dynamic-vertex-parallel")</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">DensePull-SparsePush&quot;) caParallelization(&quot;s1&quot;, &quot;dynamic-vertex-parallel&quot;) caDirection(&quot;s1</title>
		<idno>edge-aware-dynamic-vertex-parallel&quot;) caNumSSG(&quot;s1</idno>
	</analytic>
	<monogr>
		<title level="m">DensePush-SparsePush&quot;) caParallelization(&quot;s1&quot;, &quot;static-vertex-parallel&quot;) caDirection(&quot;s1</title>
		<imprint/>
	</monogr>
	<note>DensePull&quot;) SSSP caDirection(&quot;s1. SparsePush&quot;) caParallelization(&quot;s1&quot;, &quot;dynamic-vertex-parallel&quot;) caDirection(&quot;s1&quot;, &quot;DensePush-SparsePush&quot;) caParallelization(&quot;s1&quot;, &quot;dynamic-vertex-parallel&quot;) caDirection(&quot;s1&quot;, &quot;DensePush-SparsePush&quot;) caParallelization(&quot;s1&quot;, &quot;dynamic-vertex-parallel</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">DensePull&quot;) caParallelization(&quot;s1&quot;, &quot;dynamic-vertex-parallel&quot;) caNumSSG(&quot;s1&quot;, &quot;fixed-vertex-count</title>
		<idno>PRDelta caDirection(&quot;s1</idno>
	</analytic>
	<monogr>
		<title level="m">dynamic-vertex-parallel&quot;) fuseFields(&quot;OutDegree</title>
		<imprint/>
	</monogr>
	<note>static-vertex-parallel&quot;) caDirection(&quot;s2. SparsePush&quot;) caParallelization(&quot;s2&quot;, &quot;static-vertex-parallel&quot;) caDirection(&quot;s1&quot;, &quot;DensePull-SparsePush&quot;) caParallelization(&quot;s1&quot;, &quot;dynamic-vertex-parallel&quot;) caDirection(&quot;s2&quot;, &quot;DensePull-SparsePush&quot;) caParallelization(&quot;s2&quot;, &quot;dynamic-vertex-parallel&quot;) caDirection(&quot;s1&quot;, &quot;DensePull-SparsePush&quot;) caDenseVertexSet(&quot;s1&quot;, &quot;src-vertexset&quot;, &quot;bitvector&quot;, &quot;DensePull&quot;) caParallelization(&quot;s1&quot;, &quot;dynamic-vertex-parallel&quot;) caDirection(&quot;s2&quot;, &quot;DensePull-SparsePush&quot;) caDenseVertexSet(&quot;s2&quot;, &quot;src-vertexset&quot;, &quot;bitvector&quot;, &quot;DensePull&quot;) caParallelization(&quot;s2&quot;, &quot;dynamic-vertex-parallel&quot;) CF For Netflix and Netflix2x graphs caDirection(&quot;s1&quot;, &quot;DensePull&quot;) caParallelization(&quot;s1&quot;, &quot;edge-aware-dynamic-vertex-parallel&quot;) caNumSSG(&quot;s1&quot;, fixed-vertex-count, X)</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">EmptyHeaded: A Relational Engine for Graph Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">R</forename><surname>Aberger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kunle</forename><surname>Olukotun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Ré</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Management of Data (SIGMOD &apos;16</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="431" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">OpenTuner: An Extensible Framework for Program Autotuning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Ansel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shoaib</forename><surname>Kamil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kalyan</forename><surname>Veeramachaneni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Bosboom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Una-May O'</forename><surname>Reilly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Direction-optimizing Breadth-first Search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanović</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on High Performance Computing, Networking, Storage and Analysis (SC &apos;12)</title>
		<meeting>the International Conference on High Performance Computing, Networking, Storage and Analysis (SC &apos;12)</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="12" />
		</imprint>
	</monogr>
	<note>10 pages</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Locality Exists in Graph Processing: Workload Characterization on an Ivy Bridge Server</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Symposium on Workload Characterization (IISWC)</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Reducing Pagerank Communication via Propagation Blocking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><surname>Beamer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Krste</forename><surname>Asanovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Parallel and Distributed Processing Symposium</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="820" to="831" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The Netflix Prize</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Bennett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stan</forename><surname>Lanning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Netflix</forename><surname>Netflix</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">KDD Cup and Workshop in conjunction with KDD</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">To Push or To Pull: On Reducing Communication and Synchronization in Graph Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maciej</forename><surname>Besta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michal</forename><surname>Podstawski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linus</forename><surname>Groner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edgar</forename><surname>Solomonik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Torsten</forename><surname>Hoefler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th International Symposium on High-Performance Parallel and Distributed Computing (HPDC &apos;17</title>
		<meeting>the 26th International Symposium on High-Performance Parallel and Distributed Computing (HPDC &apos;17</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="93" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">CHiLL: A framework for composing high-level loop transformations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacqueline</forename><surname>Chame</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><surname>Hall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">PowerLyra: Differentiated Graph Computation and Partitioning on Skewed Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaxin</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yanzhe</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth European Conference on Computer Systems (EuroSys &apos;15)</title>
		<meeting>the Tenth European Conference on Computer Systems (EuroSys &apos;15)</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note>Article 1, 1:1-1:15 pages</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Gluon: A Communication-optimizing Substrate for Distributed Heterogeneous Graph Analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loc</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hoang-Vu</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikoli</forename><surname>Dryden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Snir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
		<idno type="DOI">10.1145/3192366.3192404</idno>
		<ptr target="https://doi.org/10.1145/3192366.3192404" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="752" to="768" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The University of Florida Sparse Matrix Collection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><forename type="middle">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yifan</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Math. Softw</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2011-12" />
		</imprint>
	</monogr>
	<note>25 pages</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Camil</forename><surname>Demetrescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Johnson</surname></persName>
		</author>
		<ptr target="http://www.dis.uniroma1.it/challenge9/." />
		<title level="m">9th DIMACS implementation challenge -shortest paths</title>
		<imprint/>
	</monogr>
	<note>n. d.. n. d.</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Liszt: A Domain Specific Language for Building Portable Mesh-based PDE Solvers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zachary</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niels</forename><surname>Joubert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francisco</forename><surname>Palacios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Oakley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Montserrat</forename><surname>Medina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Barrientos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erich</forename><surname>Elsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Ham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Aiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthik</forename><surname>Duraisamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Darve</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Juan</forename><surname>Alonso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2011 International Conference for High Performance Computing, Networking, Storage and Analysis (SC &apos;11)</title>
		<meeting>2011 International Conference for High Performance Computing, Networking, Storage and Analysis (SC &apos;11)</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
	<note>Article 9</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pixie: A System for Recommending 3+ Billion Items to 200+ Million Users in Real-Time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chantat</forename><surname>Eksombatchai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pranav</forename><surname>Jindal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jerry</forename><forename type="middle">Zitao</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuchen</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rahul</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Sugnet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Ulrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 World Wide Web Conference (WWW &apos;18</title>
		<meeting>the 2018 World Wide Web Conference (WWW &apos;18</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="1775" to="1784" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">GeaBase: A High-Performance Distributed Graph Database for Industry-Scale Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhisong</forename><surname>Fu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhengwei</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Houyu</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yize</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Min</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojie</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaomeng</forename><surname>Ye</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benquan</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xi</forename><surname>Hu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Advanced Cloud and Big Data (CBD)</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="170" to="175" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Abelian: A Compiler for Graph Analytics on Distributed, Heterogeneous Platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gurbinder</forename><surname>Gill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roshan</forename><surname>Dathathri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loc</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-319-96983-1_18</idno>
		<ptr target="https://doi.org/10.1007/978-3-319-96983-1_18" />
	</analytic>
	<monogr>
		<title level="m">Euro-Par 2018: Parallel Processing -24th International Conference on Parallel and Distributed Computing</title>
		<meeting><address><addrLine>Turin, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2018-08-27" />
			<biblScope unit="page" from="249" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">PowerGraph: Distributed Graphparallel Computation on Natural Graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haijie</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12). USENIX Association</title>
		<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12). USENIX Association<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="17" to="30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Making Pull-based Graph Processing Performant</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Samuel</forename><surname>Grossman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heiner</forename><surname>Litz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Kozyrakis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;18</title>
		<meeting>the 23rd ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;18</meeting>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="246" to="260" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Green-Marl: A DSL for Easy and Efficient Graph Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sungpack</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hassan</forename><surname>Chafi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edic</forename><surname>Sedlar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kunle</forename><surname>Olukotun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGARCH Comput. Archit. News</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="349" to="362" />
			<date type="published" when="2012-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">GraFBoost: Accelerated Flash Storage for External Graph Analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sang</forename><surname>Woo Jun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Wright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sizhuo</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuotao</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arvind</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Computer Architecture</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">PEGASUS: mining peta-scale graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charalampos</forename><forename type="middle">E</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christos</forename><surname>Tsourakakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Faloutsos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowl. Inf. Syst</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Optimizing Indirect Memory References with Milk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vladimir</forename><surname>Kiriansky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunming</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Conference on Parallel Architectures and Compilation (PACT &apos;16</title>
		<meeting>the 2016 International Conference on Parallel Architectures and Compilation (PACT &apos;16</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="299" to="312" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Simit: A Language for Physical Simulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fredrik</forename><surname>Kjolstad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shoaib</forename><surname>Kamil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">I W</forename><surname>Levin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shinjiro</forename><surname>Sueda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Desai</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Etienne</forename><surname>Vouga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danny</forename><forename type="middle">M</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gurtej</forename><surname>Kanwar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wojciech</forename><surname>Matusik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="2016-03" />
		</imprint>
	</monogr>
	<note>Article. 21 pages</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">What is Twitter, a Social Network or a News Media</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haewoon</forename><surname>Kwak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changhyun</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hosung</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sue</forename><surname>Moon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on World Wide Web (WWW &apos;10</title>
		<meeting>the 19th International Conference on World Wide Web (WWW &apos;10</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="591" to="600" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">GraphChi: Large-scale Graph Computation on Just a PC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guy</forename><surname>Blelloch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12</title>
		<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="31" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">SociaLite: Datalog Extensions for Efficient Social Network Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Monica</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiwon</forename><surname>Seo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="278" to="289" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jure</forename><surname>Leskovec</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrej</forename><surname>Krevl</surname></persName>
		</author>
		<ptr target="http://snap.stanford.edu/data." />
		<title level="m">SNAP Datasets: Stanford Large Network Dataset Collection</title>
		<imprint>
			<date type="published" when="2014-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Sparkler: Supporting Large-scale Matrix Factorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boduo</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandeep</forename><surname>Tata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yannis</forename><surname>Sismanis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conference on Extending Database Technology (EDBT &apos;13</title>
		<meeting>the 16th International Conference on Extending Database Technology (EDBT &apos;13</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="625" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Data dependence analysis on multi-dimensional array references</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiyuan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pen-Chung</forename><surname>Yew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chuag-Qi</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd international conference on Supercomputing</title>
		<meeting>the 3rd international conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="215" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">GraphLab: A New Framework For Parallel Machine Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yucheng</forename><surname>Low</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Gonzalez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aapo</forename><surname>Kyrola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Danny</forename><surname>Bickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UAI</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="340" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A Flexible Open-Source Toolbox for Scalable Complex Graph Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Lugowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Alber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aydın</forename><surname>Buluç</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Reinhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yun</forename><surname>Teng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Waranis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SDM</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Mosaic: Processing a Trillion-Edge Graph on a Single Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steffen</forename><surname>Maass</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Changwoo</forename><surname>Min</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanidhya</forename><surname>Kashyap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Woonhak</forename><surname>Kang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohan</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taesoo</forename><surname>Kim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twelfth European Conference on Computer Systems (EuroSys &apos;17</title>
		<meeting>the Twelfth European Conference on Computer Systems (EuroSys &apos;17</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="527" to="543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Everything you always wanted to know about multicore graph processing but were afraid to ask</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jasmina</forename><surname>Malicevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baptiste</forename><surname>Lepers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Efficient and exact data dependence analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">L</forename><surname>Dror E Maydan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Monica</forename><forename type="middle">S</forename><surname>Hennessy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Thinking Like a Vertex: A Survey of Vertex-Centric Frameworks for Large-Scale Distributed Graph Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Robert Ryan Mccune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Weninger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Madey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="1" to="25" />
			<date type="published" when="2015-10" />
		</imprint>
	</monogr>
	<note>39 pages</note>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Meusel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oliver</forename><surname>Lehmberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christian</forename><surname>Bizer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastiano</forename><surname>Vigna</surname></persName>
		</author>
		<ptr target="http://webdatacommons.org/hyperlinkgraph." />
		<title level="m">Web Data Commons -Hyperlink Graphs</title>
		<imprint/>
	</monogr>
	<note>n. d.. n. d.</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A Lightweight Infrastructure for Graph Analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Lenharth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles (SOSP &apos;13</title>
		<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles (SOSP &apos;13</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="456" to="471" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">When cache blocking of sparse matrix vector multiply works and why</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajesh</forename><surname>Nishtala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">W</forename><surname>Vuduc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">W</forename><surname>Demmel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Katherine</forename><forename type="middle">A</forename><surname>Yelick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Applicable Algebra in Engineering, Communication and Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="297" to="311" />
			<date type="published" when="2007-05-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Advanced compiler optimizations for supercomputers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael J</forename><surname>Padua</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wolfe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1184" to="1201" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">The PageRank Citation Ranking: Bringing Order to the Web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Brin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><surname>Winograd</surname></persName>
		</author>
		<idno>1999-66</idno>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
	<note>Stanford InfoLab</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Managing Large Graphs on Multi-cores with Graph Awareness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming</forename><surname>Vijayan Prabhakaran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuetian</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Weng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lidong</forename><surname>Mcsherry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maya</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Haridasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 USENIX Conference on Annual Technical Conference (USENIX ATC&apos;12)</title>
		<meeting>the 2012 USENIX Conference on Annual Technical Conference (USENIX ATC&apos;12)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Elixir: a system for synthesizing concurrent graph programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitrios</forename><surname>Prountzos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roman</forename><surname>Manevich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</title>
		<meeting>the 27th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="375" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Synthesizing parallel graph programs via automated planning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitrios</forename><surname>Prountzos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roman</forename><surname>Manevich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keshav</forename><surname>Pingali</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="533" to="544" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Halide: Decoupling Algorithms from Schedules for High-performance Image Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Ragan-Kelley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dillon</forename><surname>Sharlet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Connelly</forename><surname>Barnes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sylvain</forename><surname>Paris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frédo</forename><surname>Durand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="106" to="115" />
			<date type="published" when="2017-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">HMPP: A hybrid multi-core parallel programming environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephane</forename><surname>Dolbeau Romain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francois</forename><surname>Bihan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bodin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on general purpose processing on graphics processing units</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Chaos: Scale-out Graph Processing from Secondary Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabha</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Bindschaedler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jasmina</forename><surname>Malicevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles (SOSP &apos;15</title>
		<meeting>the 25th Symposium on Operating Systems Principles (SOSP &apos;15</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">121</biblScope>
			<biblScope unit="page">30</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Baghdadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kamil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Amarasinghe</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">X-Stream: Edge-centric Graph Processing Using Streaming Partitions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabha</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivo</forename><surname>Mihailovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles (SOSP &apos;13</title>
		<meeting>the Twenty-Fourth ACM Symposium on Operating Systems Principles (SOSP &apos;13</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="472" to="488" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sherif</forename><surname>Sakr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ibrahim</forename><surname>Faisal Moeen Orakzai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zuhair</forename><surname>Abdelaziz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Khayyat</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<publisher>Springer Publishing Company</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Large-Scale Graph Processing Using Apache Giraph</note>
	<note>1st ed.. Incorporated</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Navigating the Maze of Graph Analytics Frameworks Using Massive Graph Datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadathur</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Narayanan</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Md</forename><surname>Mostofa Ali Patwary</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiwon</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jongsoo</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">Amber</forename><surname>Hassaan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shubho</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhaoming</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pradeep</forename><surname>Dubey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGMOD International Conference on Management of Data</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="979" to="990" />
		</imprint>
	</monogr>
	<note>SIGMOD &apos;14</note>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aneesh</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jerry</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Praveen</forename><surname>Bommannavar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jimmy</forename><surname>Lin</surname></persName>
		</author>
		<title level="m">GraphJet: Real-time Content Recommendations at Twitter. Proc. VLDB Endow</title>
		<imprint>
			<date type="published" when="2016-09" />
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1281" to="1292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xuanhua</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhigao</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yongluan</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hai</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ligang</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bo</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qiang-Sheng</forename><surname>Hua</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Graph Processing on GPUs: A Survey. ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="1" to="81" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
	<note>35 pages</note>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Ligra: A Lightweight Graph Processing Framework for Shared Memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julian</forename><surname>Shun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guy</forename><forename type="middle">E</forename><surname>Blelloch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;13</title>
		<meeting>the 18th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP &apos;13</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">GraphGrind: Addressing Load Imbalance of Graph Partitioning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiawen</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans</forename><surname>Vandierendonck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitrios</forename><forename type="middle">S</forename><surname>Nikolopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Supercomputing (ICS &apos;17)</title>
		<meeting>the International Conference on Supercomputing (ICS &apos;17)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">GraphMat: High Performance Graph Analytics Made Productive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Narayanan</forename><surname>Sundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nadathur</forename><surname>Satish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Md Mostofa Ali</forename><surname>Patwary</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Subramanya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">J</forename><surname>Dulloor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Satya Gautam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dipankar</forename><surname>Vadlamudi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pradeep</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dubey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2015-07" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1214" to="1225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Load the Edges You Need: A Generic I/O Optimization for Disk-based Graph Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keval</forename><surname>Vora</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoqing</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajiv</forename><surname>Gupta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="507" to="522" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Graspan: A Single-machine Diskbased Graph System for Interprocedural Static Analyses of Large-scale Systems Code</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aftab</forename><surname>Hussain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhiqiang</forename><surname>Zuo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoqing</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ardalan Amiri</forename><surname>Sani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="389" to="404" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">GraphQ: Graph Query Processing with Abstraction Refinement-Scalable and Programmable Analytics over Very Large Graphs on a Single PC</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoqing</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhendong</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><forename type="middle">David</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX Annual Technical Conference</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="387" to="401" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Gunrock: A Highperformance Graph Processing Library on the GPU</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yangzihao</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuechao</forename><surname>Pan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuduo</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Riffel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">D</forename><surname>Owens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2016-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">A loop transformation theory and an algorithm to maximize parallelism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Monica</forename><forename type="middle">S</forename><surname>Wolf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="452" to="471" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Da</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yingyi</forename><surname>Bu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amol</forename><surname>Deshpande</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Big Graph Analytics Platforms. Foundations and Trends in Databases</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1" to="195" />
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">NUMA-aware Graph-structured Analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kaiyuan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rong</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibo</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>the 20th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="183" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Making caches work for graph analytics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunming</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vladimir</forename><surname>Kiriansky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charith</forename><surname>Mendis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saman</forename><surname>Amarasinghe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matei</forename><surname>Zaharia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE International Conference on Big Data (Big Data</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="293" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Flashgraph: Processing billion-node graphs on an array of commodity SSDs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Da</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Disa</forename><surname>Mhembere</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randal</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>Vogelstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carey</forename><forename type="middle">E</forename><surname>Priebe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">S</forename><surname>Szalay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th USENIX Conference on File and Storage Technologies</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="45" to="58" />
		</imprint>
	</monogr>
	<note>FAST 15</note>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Gemini: A Computation-Centric Distributed Graph Processing System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaowei</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weimin</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaosong</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">12th USENIX Symposium on Operating Systems Design and Implementation</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="301" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">GridGraph: Large-scale Graph Processing on a Single Machine Using 2-level Hierarchical Partitioning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaowei</forename><surname>Zhu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wentao</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 USENIX Conference on Usenix Annual Technical Conference (USENIX ATC &apos;15</title>
		<meeting>the 2015 USENIX Conference on Usenix Annual Technical Conference (USENIX ATC &apos;15</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="375" to="386" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
