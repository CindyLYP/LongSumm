<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Early Detection of Configuration Errors to Reduce Failure Damage</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tianyin</forename><surname>Xu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinxin</forename><surname>Jin</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Huang</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuanyuan</forename><surname>Zhou</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">University of Chicago † NetApp, Inc</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Long</forename><surname>Jin</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shankar</forename><surname>Pasupathy</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of California</orgName>
								<address>
									<settlement>San Diego</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Early Detection of Configuration Errors to Reduce Failure Damage</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Early detection is the key to minimizing failure damage induced by configuration errors, especially those errors in configurations that control failure handling and fault tolerance. Since such configurations are not needed for initialization, many systems do not check their settings early (e.g., at startup time). Consequently, the errors become latent until their manifestations cause severe damage, such as breaking the failure handling. Such latent errors are likely to escape from sysadmins&apos; observation and testing, and be deployed to production at scale. Our study shows that many of today&apos;s mature, widelyused software systems are subject to latent configuration errors (referred to as LC errors) in their critically important configurations-those related to the system&apos;s reliability, availability, and serviceability. One root cause is that many (14.0%-93.2%) of these configurations do not have any special code for checking the correctness of their settings at the system&apos;s initialization time. To help software systems detect LC errors early, we present a tool named PCHECK that analyzes the source code and automatically generates configuration checking code (called checkers). The checkers emulate the late execution that uses configuration values, and detect LC errors if the error manifestations are captured during the emulated execution. Our results show that PCHECK can help systems detect 75+% of real-world LC errors at the initialization phase, including 37 new LC errors that have not been exposed before. Compared with existing detection tools, it can detect 31% more LC errors.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivation</head><p>Failures are a fact of life in today's large-scale, rapidchanging systems in cloud and data centers <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b60">58]</ref>. To mitigate the impact of failures, tolerance and recovery mechanisms have been widely adopted, such as employing data and node redundancy, as well as supporting fast rebooting and rollback. While these mechanisms are successful in handling individual machine failures (e.g., hardware faults and memory bugs), they are less effective in handling configuration errors <ref type="bibr" target="#b18">[20,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b26">28]</ref>, especially the errors in configurations that control the failure han-dling itself. For example, an erroneous fail-over configuration resulted in a 2.5 hour outage of Google App Engine in 2010, affecting millions of end users <ref type="bibr" target="#b44">[44]</ref>. Moreover, very often, the same configuration error is deployed onto thousands of nodes and resides in persistent files on each node, making it hard to tolerate by redundancy or server rebooting. As a result, configuration errors have become one of the major causes of failures in large-scale cloud and Internet systems, as reported by many system vendors <ref type="bibr" target="#b19">[21,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b57">55]</ref> and service providers <ref type="bibr" target="#b5">[7,</ref><ref type="bibr" target="#b22">24,</ref><ref type="bibr" target="#b26">28,</ref><ref type="bibr" target="#b43">43]</ref>.</p><p>Since it is hard to completely avoid configuration errors (after all, everyone makes mistakes; as do system administrators), similar to fatal diseases like cancer, a more practical approach is to detect such errors as early as possible in order to minimize their failure damage:</p><p>• Early detection before configuration roll-out can prevent the same error from being replicated to thousands of nodes, especially in the data-center environment. • Unlike software bugs, configuration errors, once detected, can be fixed by sysadmins themselves with no need to go through developers. Therefore, if detected earlier, the errors can be corrected immediately before the configurations are put online for production. • For many configurations that control the system's failure handling, early detection of errors in their settings can prevent the system from entering an unrecoverable state (before any failures happen). Often, the combination of multiple errors (e.g., a configuration error plus a software bug) can bring down the entire service, as shown in many newsworthy outages <ref type="bibr" target="#b7">[9,</ref><ref type="bibr" target="#b42">42,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b45">45]</ref>.</p><p>Unlike software bugs that typically go through various kinds of testing before releases (such as unit testing, regression testing, stress testing, system testing, etc.), system administrators often do not perform extensive testing on configurations before rolling them out to other nodes and putting the systems online <ref type="bibr" target="#b23">[25]</ref>. Besides the lack of skills <ref type="bibr" target="#b23">[25]</ref> and the temptation of convenience <ref type="bibr" target="#b22">[24]</ref>, the more fundamental reason is that system administrators do not have the same level of understanding on how and when the system uses each configuration value internally. Thus, they are limited to simple black-box testing such as starting the system and applying a few small workloads to see how the system behaves. Due to time and knowledge limitations, system administrators typically do not  <ref type="table">Table 1</ref>: Severity of latent versus non-latent errors among the customers' configuration issues of COMP-A. LC errors contribute to 75% of the high-severity configuration issues.</p><p>Error class Mean Median Latent 1.14 1.70 Non-latent 0.87 0.41 <ref type="table">Table 2</ref>: Diagnosis time of latent versus non-latent errors among customers' configuration issues of COMP-A. The time is normalized by the average time of all the reported issues.</p><p>perform a comprehensive suite of test cases against configuration settings, especially for those hard-to-test ones (e.g., failure/error-handling related configurations) that may require complex setups and even fault injections. Therefore, early detection should inevitably fall onto the shoulder of the system itself-the system should automatically check as many configurations as possible at its early stages (the startup time). Unfortunately, many of today's systems either skip the checking or only check configurations right before the configuration values are used, as shown in our study ( §2). Typically, at the startup time, only those configuration parameters needed for initialization are checked (or directly used), while many other parameters' checking is delayed much later until when they are used in special tasks. Since such configuration parameters are neither used nor checked during normal operations, errors in their settings go undetected until their late manifestation, e.g., under circumstances like error handling and fail-over. For simplicity, we refer to such errors as latent configuration (LC) errors.</p><p>LC errors can result in severe failures, as they are often associated with configurations used to control critical situations such as fail-over <ref type="bibr" target="#b44">[44]</ref>, error handling <ref type="bibr" target="#b42">[42]</ref>, backup <ref type="bibr" target="#b36">[37]</ref>, load balancing <ref type="bibr" target="#b7">[9]</ref>, mirroring <ref type="bibr" target="#b45">[45]</ref>, etc. As explained above, their detection or exposure is often too late to limit the failure damage. Take a real-world case as an example (c.f., §2: <ref type="figure" target="#fig_2">Figure 3a)</ref>, an LC error in the fail-over configuration settings is detected only when the system encounters a failure (e.g., due to hardware faults or software bugs) and tries to fail-over to another component. In this case, the fail-over attempt also fails, making the entire system unavailable to all the clients. Tables 1 and 2 compare the severity level and diagnosis time of real-world configuration issues caused by LC errors versus non-latent configuration errors (detected at the system's startup time) of COMP-A 1 , a major storage company in the US. Although there have been fewer LC errors than non-latent ones, LC errors contribute to 75% of the high-severity issues and take much longer to diagnose, indicating their high impact and damage. <ref type="bibr" target="#b0">1</ref> We are required to keep the company and its products anonymous. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initialization</head><p>Serving requests ³Hogging the CPU for 7+ hrsĆ onfiguration error:</p><p>diskd_program = a non-existent path <ref type="figure" target="#fig_1">Figure 1</ref>: A real-world LC error from Squid <ref type="bibr" target="#b36">[37]</ref>. The error caused system hanging for 7+ hours, and resulted in 48 hours of diagnosis efforts. Later, a patch was added to check the existence of the configured path during initialization. Unfortunately, the patched check is still subject to LC errors such as incorrect file types and permissions.</p><p>The TaskTrackers were trapped into infinite loops (³When I ran jobs on a big cluster, some map tasks never got started.´)  <ref type="figure">Figure 2</ref>: A real-world LC error from MapReduce <ref type="bibr" target="#b10">[12]</ref>. When the exception handler caught the runtime exception induced by the LC error, it was already too late to avoid the downtime. After this incident, the user requested to check the configuration "at the initialization time." <ref type="figure" target="#fig_1">Figure 1</ref> shows a real-world LC error from Squid, a widely used open-source Web proxy server. The LC error resided in diskd program, a configuration parameter used only during log rotation. Squid did not check the configuration during initialization; thus, this error was exposed much later after days of execution. It caused 7+ hours of system downtime and cost 48 hours of diagnosis efforts. After the error was finally discerned, the Squid developers added a patch to proactively check the setting at system startup time to prevent such latent failures. <ref type="figure">Figure 2</ref> shows another real-world example in which an LC error failed a large-scale MapReduce job processing. This LC error was replicated to multiple nodes and crashed the TaskTrackers on those nodes. Specifically, the error caused a runtime exception on each node. The TaskTracker caught the exception and restarted the job. Unfortunately, as the error is persistent in the configuration file, restarting the job failed to get rid of the error but induced infinite loops. Note that when the exception handler caught the error, it was already too late to avoid downtime (the best choice is to terminate the jobs).</p><p>Preventing above LC-error issues would require software systems to check configurations early during the initialization time, even though the configuration values are only needed in much later execution or during special circumstances. This is indeed demonstrated by the developers' postmortem patches. As revealed in Facebook's recent study <ref type="bibr" target="#b43">[43]</ref>, 42% of the configuration errors that caused high-impact incidents are "obvious" errors (e.g., typos), indicating the limitations of code review and system testing in preventing LC errors. These errors might be detected by early checks (only if developers are willing to and remember to write the checking code).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">State of the Art</head><p>Most prior work on handling configuration errors focuses on troubleshooting and diagnosis <ref type="bibr" target="#b3">[5,</ref><ref type="bibr" target="#b4">6,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b49">48,</ref><ref type="bibr" target="#b50">49,</ref><ref type="bibr" target="#b54">52,</ref><ref type="bibr" target="#b55">53,</ref><ref type="bibr" target="#b58">56,</ref><ref type="bibr" target="#b62">60,</ref><ref type="bibr" target="#b63">61,</ref><ref type="bibr" target="#b64">62]</ref>. The techniques proposed in these work are helpful for system administrators to identify the failure root causes faster to shorten the repair time. However, they cannot prevent failures and downtime.</p><p>Most of the existing detection tools check configuration settings against apriori correctness rules (known as constraints). However, as large software systems usually have hundreds to thousands of configuration parameters, it is time-consuming and error-prone to ask developers to manually specify every single constraint, not to mention that constraints change with software evolution <ref type="bibr" target="#b63">[61]</ref>.</p><p>So far, only a few automatic configuration-error detection tools have been proposed. Most of them detect errors by learning the "normal" values from large collections of configuration settings in the field <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b59">57,</ref><ref type="bibr" target="#b61">59]</ref>. While these techniques are effective in certain scenarios, they have the following limitations, especially when being applied to cloud and data centers.</p><p>First, most of these works require a large collection of independent configuration settings from hundreds of machines. This is a rather strong requirement, as most cloud and data centers typically propagate the same configurations from one node to all the other nodes. Thereby, the settings from these nodes are not independent, and thus not useful for "learning". Second, they do not work well with configurations that are inherently different from one system to another (e.g., domain names, file paths, IP addresses) or incorrect settings that fall in normal ranges. They also cannot differentiate customized settings from erroneous ones. Furthermore, most of these tools target on specific error types (encoded by their predefined constraint templates) and are hard to generalize to detect other types of errors. A recent work learns constraints from KB (Knowledge Base) articles <ref type="bibr" target="#b30">[31]</ref>. However, this approach has the same limitations discussed above. Specially, KB articles are mainly served for postmortem diagnosis and thus may not cover every single constraint.</p><p>There are very few configuration-error detection approaches that do not rely on constraints specified manually by developers or learned from large collections of independent settings (or KB articles). The only exception (to the best of our knowledge) is conf spellchecker <ref type="bibr" target="#b34">[35]</ref> which detects simple errors based on type inference from source code. While this technique is very practical, it is limited in the types of configuration errors that can be detected, as shown in our experimental evaluation ( §4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Our Contributions</head><p>This paper makes two main contributions. First, to understand the root causes and characteristics of latent configuration (LC) errors, we study the practices of configuration checking in six mature, widely-deployed software systems (HDFS, YARN, HBase, Apache, MySQL, and Squid). Our study reveals: (1) In today's software systems, many (14.0%-93.2%) of the critically important configuration parameters (those related to the system's reliability, availability, and serviceability) do not have any special code for checking the correctness of their settings. Instead, the correctness is verified (implicitly) when the configuration values are being actually used in operations such as a file open call. (2) Many (12.0%-38.6%) of these configuration parameters are not used at all during system initialization. <ref type="formula">3</ref>Resulting from (1) and (2), 4.7%-38.6% of these critically important configuration parameters do not have any early checks and are thereby subject to LC errors that can cause severe impact on the system's dependability.</p><p>Second, to help systems detect LC errors early, we present a tool named PCHECK that analyzes the source code and automatically generates configuration checking code (called checkers) to validate the system's configuration settings at the initialization phase. PCHECK takes a unique and intuitive method to check each configuration setting-emulating the late execution that uses the configuration value; meanwhile capturing any anomalies exposed during the execution as the evidence of configuration errors. PCHECK does not require developers to manually implement checking logic, nor rely on learning a large volume of configuration data. The checkers generated by PCHECK are generic: they are not limited to any specific, predefined rule patterns, but are derived from how the program uses the parameters.</p><p>PCHECK shows that it is feasible to accurately and safely emulate late execution that uses configurations. It statically extracts the instructions that transform, propagate, and use the configuration values from the system program. To execute these instructions, PCHECK makes a best effort to produce the necessary execution context (values of dependent variables) that can be determined statically. PCHECK also "sandboxes" the emulated execution by instruction rewriting to prevent side effects on the running system or its environment.</p><p>More importantly, emulating the execution can expose many configuration errors as runtime anomalies (e.g., ex-ceptions and error code) and the emulated execution runs in a short period. PCHECK inserts instructions to capture the anomalies that may occur during the emulated execution, as the evidence to report configuration errors.</p><p>As an enforcement, PCHECK encapsulates the emulated execution and error capturing code into checkers for every configuration parameter, and invokes the checkers at the system's initialization phase. This can minimize potential LC errors, and compensate for the missing and incomplete configuration checks in real-world systems.</p><p>We implement PCHECK for C and Java programs on top of the LLVM <ref type="bibr" target="#b2">[4]</ref> and Soot <ref type="bibr" target="#b1">[3]</ref> compiler frameworks. We apply PCHECK to 58 real-world LC errors of various error types occurred in widely-used systems (each leads to severe failure damage), including 37 new LC errors that have not been exposed before. Our results show that PCHECK can detect 75+% of these real-world LC errors at the system's startup time. Compared with the existing detection tools, it can detect 31% more LC errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Understanding Root Causes of Latent Configuration Errors</head><p>To understand the root causes and characteristics of LC errors, we study the practices of the configuration checking and error detection in six mature, widely-deployed open-source software systems (c.f., <ref type="table" target="#tab_3">Table 3</ref>). They cover multiple functionalities and languages, and include both single-machine and distributed systems. We focus on configuration parameters used in components related to the system's Reliability, Availability, and Serviceability (known as RAS for short <ref type="bibr" target="#b51">[50]</ref>). For each system considered, we select all the configuration parameters of RAS-related features based on the software's official documents, including error handling, fail-over, data backup, recovery, error logging and notification, etc. The last column of <ref type="table" target="#tab_3">Table 3</ref> shows the number of the studied RAS parameters. Compared with configurations of other system components, configurations used by RAS components are more likely to be subject to LC errors due to their inherently latent nature; moreover, the impact of errors in RAS configurations is usually more severe.</p><p>Note: LC errors are not limited to RAS components. Thus, the reported numbers may not represent the overall statistics of all the LC errors in the studied systems. In addition, PCHECK, the tool presented in §3, applies to all the configuration parameters; it does not require manual efforts to select out RAS parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Methodology</head><p>We manually inspect the source code related to RAS configuration parameters of the studied systems. First, for each RAS parameter, we study the code that checks the   <ref type="table">Table 4</ref>: Number of configuration parameters that do not have any initial checking code ("missing") and that only have partial checking and thus cannot detect all potential errors ("incomplete").</p><p>parameter setting at the system's initialization phase 2 (if any) and the code that later uses the parameter's value. Then, we compare these two sets of code (checking versus usage) and examine if the initial checking is sufficient to detect configuration errors. If an error can escape from the initialization phase and break the usage code, it is a potential LC error. We verify each LC error discovered from source code by exposing and observing the impact of the error. We first inject the errors into the system's configuration files and launch the system; then we trigger the manifestation conditions to expose the error impact. For example, to verify the LC errors in the HDFS auto-failover feature, we start HDFS with the erroneous fail-over settings, trigger the fail-over procedure by killing the active NameNode, and examine if the fail-over can succeed. As all the LC errors are verified through their manifestation, there is no false positive in the reported numbers.  <ref type="table">Table 4</ref> shows the number of the studied RAS parameters that rely on the usage code for verifying correctness, because their initial checks are either missing or incomplete. Most of the studied RAS parameters in HDFS, YARN, and HBase do not have any special code for checking the correctness of their settings. These systems ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Findings</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Manifestation:</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Consequence:</head><p>HDFS auto-failover fails, and the entire HDFS service becomes unavailable.</p><p>IllegalArgumentException (when parsing timeout to an integer) IOException (when reading the key file)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">LC Errors:</head><p>Ill-formatted numbers (e.g., typos) for ssh timeout; Invalid paths for private-key files (e.g., non-existence, permission errors). ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Manifestation:</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Consequence:</head><p>Apache httpd cannot switch to the configured directory, and thus fails to generate the coredump file upon server crashing.</p><p>Error code returned by the chdir call if (apr_stat(&amp;finfo, fname, APR_FINFO_TYPE) != APR_SUCCESS) return "CoreDumpDirectory does not exist"; if (finfo.filetype != APR_DIR) return "CoreDumpDirectory is not a directory"; iCoreDumpDirectoryj</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">LC Errors:</head><p>The running program has no permission to access coredump directory .</p><p>(b) Incomplete initial checking <ref type="figure" target="#fig_2">Figure 3</ref>: New LC errors discovered in the latest versions of the studied software, both of which are found to have caused realworld failures <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b41">41]</ref>. For all these LC errors, the correctness checking is implicitly done when the parameters' values are actually used in operations, which is unfortunately too late to prevent the failures.</p><p>adopt the lazy practice of using configuration values <ref type="bibr" target="#b1">3</ref> parsing and consuming configuration settings only when the values are immediately needed for the operations, without any systematic configuration checking at the system's initialization phase.</p><p>With such a practice, even trivial errors could result in big impact on the system's dependability. <ref type="figure" target="#fig_2">Figure 3a</ref> exemplifies such cases using the new LC errors we discovered in our study. In HDFS, any LC errors (such as a naïve type error) in the auto-failover configurations could  break the fail-over procedure upon the NameNode failures (as the values are not checked or used early), making the entire HDFS service become unavailable. Apache, MySQL, and Squid all apply specific configuration checking procedures at initialization, mainly for checking data types and data ranges. However, for more complicated parameters, some checking is incomplete. <ref type="figure" target="#fig_2">Figure 3b</ref> shows another new LC error we discovered. In this case, though the initial checking code covers file existence and types, it misses other constraints such as file permissions. This leaves Apache subject to permissionrelated LC errors (which is reported as one common cause of core-dump failures upon server crash <ref type="bibr" target="#b41">[41]</ref>).</p><p>As shown by <ref type="figure" target="#fig_2">Figure 3b</ref>, one configuration parameter could have multiple subtle constraints depending on how the system uses its value. For example, a configured file path used by chdir has different constraints from files accessed by open; even for files accessed by the same open call, different flags (e.g., O RDONLY versus O CREAT) would result in different constraints. Implementing code to check such constraints is tedious and error-prone.</p><p>Finding 2: Many (12.0%-38.6%) of the studied RAS configuration parameters are not used at all during the system's initialization phase. <ref type="table" target="#tab_5">Table 5</ref> counts the studied configuration parameters that are not used at the system's initialization phase, but are consumed directly in late execution (e.g., when dealing with failures). <ref type="figure" target="#fig_2">Figure 3a</ref> is such an example. Since all these parameters are from RAS features, it is natural for their usage to come late on demand.</p><p>Some Java programs put the checking or usage code of the parameters in the class constructors, so that the errors can be exposed when the class objects are created (specially, this is used as the practice for quickly fixing LC errors <ref type="bibr" target="#b16">[18,</ref><ref type="bibr" target="#b17">19,</ref><ref type="bibr" target="#b56">54]</ref>). However, this may not fundamentally avoid LC errors if the class objects are not created during the system's initialization phase.</p><p>Note: RAS configurations can be implemented with early usage at the system's initialization phase. As shown in <ref type="table" target="#tab_5">Table 5</ref>, the majority of RAS configurations are indeed used during initializaiton. For example, all the studied systems choose to open error-log files at initialization time, rather than waiting until they have to print the error messages to the log files upon failures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>USENIX Association</head><p>12th USENIX Symposium on Operating Systems Design and Implementation 623  <ref type="table">Table 6</ref>: The number of configuration parameters that are subject to LC errors in the studied ones. 11 of these parameters have been confirmed/fixed by the developers after we reported them.  <ref type="table">Table 6</ref> shows the number of the RAS configuration parameters that are subject to LC errors in each studied system. The threats are prevalent: LC errors can reside in 10+% of the RAS parameters in five out of six systems. As all these LC errors are discovered in the latest versions, any of them could appear in real deployment and would impair the system's dependability in a latent fashion. Such prevalence of LC errors indicates the need for tool support to systematically rule out the threats.</p><p>Among the studied systems, HDFS and YARN have a particularly high percentage of RAS parameters subject to LC errors, due to their lazy evaluation of configuration values (refer to Finding 1 for details). HBase applies the same lazy practice as HDFS and YARN, but has fewer parameters subject to LC errors, because most of its RAS parameters are used during its initialization. We also find LC errors in the other studied systems, despite their initial configuration checking efforts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Implication</head><p>In summary, even mature software systems are subject to LC errors due to the deficiency of configuration checking at the initialization time. While relying on developers' discipline to add more checking code can help, the reality often fails our expectations, because implementing configuration checking code is tedious and error-prone.</p><p>Fortunately, we also observe from the study that except for explicit configuration checking code, the actual usage of configuration values (which already exists in source code) can serve as an implicit form of checking, for example, opening a file path that comes from a configuration value implies a capability check. Such usageimplied checking is often more complete and accurate than the explicit checkers written by developers, because it precisely captures how the configuration values should be used in the actual program execution. Sadly, in reality these usage-implied checking is rarely leveraged to detect LC errors, because the usage often comes too late to be useful. A natural question regarding the solution to LC errors is: can we automatically generate configuration checking code from the existing source code that uses configuration values?</p><p>3 PCHECK Design and Implementation PCHECK is a tool for enabling early detection of configuration errors for a given systems program. The objective of PCHECK is to automatically generate configuration checking code (called checkers) based on the original program, and invoke them at the system initialization phase, in order to detect LC errors.</p><p>PCHECK tries to generate checkers for every configuration parameter. It is not specific to RAS configurations and has no assumption on the existence of any LC errors. The checker of a parameter emulates how the system uses the parameter's value in the original execution, and captures anomalies exposed during the emulated execution as the evidence of configuration errors.</p><p>PCHECK is built on top of the Soot <ref type="bibr" target="#b1">[3]</ref> and LLVM [4] compiler frameworks and works for both Java and C system programs. PCHECK works on the intermediate representations (IR) of the programs (LLVM IR or Soot Jimple). It takes the original IR as inputs, and outputs the generated checkers, and inserts them into bitcode/bytecode files (which are then built into native binaries). This may require prepending the build process by replacing the compiler front-end with Soot or Clang <ref type="bibr" target="#b48">[47]</ref>.</p><p>PCHECK faces three major challenges: (1) How to automatically emulate the execution that uses configuration values? (2) Since the checkers will be inserted into the original program and will run in the same address space, how does one make the emulation safe without incurring side effects on the system's internal state and external environment? (3) How to capture anomalies during the emulated execution as the evidence of configuration errors (the emulation alone cannot directly report errors)?</p><p>To address the first challenge, PCHECK extracts the instructions that transform, propagate, and use the value of every configuration parameter using a static taint tracking method. PCHECK then makes a best effort to produce the context (values of dependent variables) necessary for emulating the execution. The extracted instructions, together with the context, are encapsulated in a checker.</p><p>For the second challenge, PCHECK "sandboxes" the auto-generated checkers by rewriting instructions that would cause side effects. PCHECK avoids modifications to global variables by copying their values to local ones, and rewrites the instructions that may have external side effects on the underlying OS.</p><p>To address the third challenge, PCHECK leverages system-and language-level error identifiers (including runtime exceptions, system-call error codes, and abnor-  <ref type="bibr" target="#b24">[26]</ref>). PCHECK replaces the original call (freopen) with check utilities based on access and stat to prevent side effects ( §3.2). To execute the instructions, the necessary execution context needs to be produced. Note that we illustrate the checker using C code for clarity; the actual code is in LLVM IR or Soot Jimple.</p><p>mal program exits) to capture the anomalies exposed during the emulation, and report configuration errors. <ref type="figure">Figure 4</ref> illustrates PCHECK's checker generation for a MySQL configuration parameter, log error, which is subject to LC errors <ref type="bibr" target="#b24">[26]</ref>. PCHECK extracts the instructions that use the configuration value and determines the values of the other dependent variables (e.g., mode) as the context. To prevent side effects, it rewrites some call instruction. It detects errors based on the return value.</p><p>Lastly, PCHECK inserts the generated checkers into the system program, and invokes these checkers at the end of the system initialization phase (annotated by developers). To detect TOCTTOU errors <ref type="bibr" target="#b2">4</ref> , PCHECK supports running checkers periodically in a separate thread.</p><p>Usage. PCHECK requires two inputs from developers: (1) specifications of the configuration interface to help PCHECK identify the initial program variables that store configuration values, as the starting points for analysis ( §3.1.1); (2) annotations of the system's initialization phase where the early checkers will be invoked ( §3.4).</p><p>In addition, PCHECK provides the tuning interface for developers to select and remove any generated checkers, as per their preference and criteria (e.g., after standard software testing of the enhanced system programs). Similarly, PCHECK provides an operational interface that allows sysadmins to enable/disable the invocation of the checkers of any specific parameters in operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Emulating Execution</head><p>To emulate the execution that uses a configuration parameter, PCHECK first identifies instructions that load the parameter's value into program variables ( §3.1.1).</p><p>Starting from there, PCHECK performs forward static taint analysis to extract all the instructions whose execution uses the parameter's value, and hence are the candidates to be included in the checkers ( §3.1.2). It then analyzes backwards to figure out the values of dependent variables in these instructions, as the execution context ( §3.1.3). Finally, PCHECK composes checkers using the above instructions and their context ( §3.1.4).</p><p>Note that the emulation does not need to include the conditions under which the configurations are used. Instead, it focuses on executing the instructions that consume the configuration values-the goal is to check if using the configuration would cause any anomalies when its value is needed. With this design, PCHECK is able to effectively handle large, non-deterministic software programs, without the need to inject/simulate hard-to-trigger error conditions under which LC errors are exposed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Identifying Starting Points</head><p>As the configuration-consuming execution always starts from loading the configuration value, PCHECK needs to identify the program variables that initially store the value of each parameter, as the starting points.</p><p>PCHECK adopts the common practices presented in previous work <ref type="bibr" target="#b6">[8,</ref><ref type="bibr" target="#b20">22,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b54">52,</ref><ref type="bibr" target="#b62">60,</ref><ref type="bibr" target="#b63">61]</ref> to obtain the mapping from configuration parameters to the corresponding variables. The basic idea is to let developers specify the interface for retrieving configuration values, and then automatically identify program variables that load the values based on the interface. As pointed out by <ref type="bibr" target="#b54">[52]</ref>, most mature systems have uniform configuration interfaces for the ease of code maintenance. For instance, to work with HDFS, PCHECK only needs to know the configuration getter functions (e.g., getInt and getString in <ref type="figure" target="#fig_2">Figure 3a</ref>) declared in a single Java class; identifying them only requires several lines of specifications using regular expressions. In general, specifying interface requires little specification efforts, compared to annotating every single variable for a large number of configuration parameters. In the evaluation, the specifications needed for most systems are less than 10 lines ( §4: <ref type="table">Table 7</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Extracting Instructions Using Configurations</head><p>For each configuration parameter, PCHECK extracts the instructions that propagate, transform, and use the parameter's value using a static taint tracking method. For a given parameter, the initial taints are the program variables that store the parameter's value ( §3.1.1). The taints are propagated via data-flow dependencies (including assignments, type casts, and arithmetic/string operations), but not through control-flow dependencies to avoid overtainting <ref type="bibr" target="#b38">[39]</ref>. All the instructions containing taints are extracted, and will be encapsulated in a checker.</p><p>Note that one parameter could be used in multiple execution paths, and thus have multiple checkers. We explain how multiple checkers are aggregated in §3.1.4.</p><p>Ordinarily, the extracted instructions from data-flow analysis do not include branches. However, if a tainted instruction is used as a branch condition whose branch body encloses other tainted instructions, PCHECK performs additional control-flow analysis to retain the control dependency of these instructions. One pattern is using a configuration value p after a null-pointer check, in the form of, if (p != NULL) { use p; }. PCHECK recovers the conditional branch and ensures that if p's value is NULL, the instructions using p inside the branch would not be reached. Moreover, PCHECK checks if a tainted branch condition leads to abnormal program states, for which it inserts error-reporting instructions (see §3.3).</p><p>The taint tracking is inter-procedural, context sensitive, and field sensitive. Inter-procedure is necessary because configuration values are commonly passed through procedure calls, as illustrated in <ref type="figure">Figure 4</ref>. We adopt a summary-based inter-procedural analysis, and assemble the execution based on arguments/returns. PCHECK maintains the call sites; thus it naturally enables context sensitivity which helps produce context by backtracking from callees to callers (c.f., §3.1.3). Field sensitivity is needed as configuration values could be stored in data structures or as class fields. PCHECK scales well for realworld software systems, as configuration-related instructions form a small part of the entire code base. We do not explicitly perform alias analysis (though it is easy to integrate), as configuration variables are seldom aliased.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Producing Execution Context</head><p>Some of the extracted instructions that use configuration variables may not be directly executable, if they contain variables that are not defined within the extracted instruction set. To execute such instructions, PCHECK needs to determine the values of these undefined variables (which we refer to as "dependent variables") in order to produce self-contained context.</p><p>PCHECK will include a variable and the corresponding instructions in the emulated execution, only when this variable's value stems from configuration values (e.g., path in <ref type="figure">Figure 4</ref>) or can be statically determined along the data-flow paths of the configuration value (e.g., mode and stream in <ref type="figure">Figure 4</ref>). PCHECK does not include dependent variables whose values come from indeterminate global variables, external inputs (from I/O or network operations such as read and recv), values defined out of the scope of the starting point, etc. For such dependent variables, PCHECK removes the instruction that uses them as operands, together with the succeeding instructions. Those variables' values may not be available during the initialization phase of the system execution; using them would lead to unexpected results.</p><p>To produce the context, PCHECK backtracks each undefined dependent variable first intra-procedurally and then inter-procedurally (to handle the arguments of procedure calls). The backtracking starts from the instruction that uses the variable as its operand, and stops until either PCHECK successfully determines the value of the variable or gives up (the value is indeterminate). In <ref type="figure">Figure 4</ref>, PCHECK backtracks mode used by the tainted instruction and successfully obtains its value "a".</p><p>PCHECK only attempts to produce the minimal context necessary to emulate execution for the purpose of checking. As an optimization, PCHECK is aware of how certain types of instructions will be rewritten in later transformations (e.g., for side-effect prevention, §3.2). In <ref type="figure">Figure 4</ref>'s example, PCHECK knows how the freopen call will be rewritten later. Therefore, it only produces the context of mode which is needed to check the file access; the other dependent variable stream is ignored as it is not needed for the checking.</p><p>Sometimes, the dependent variables come from other configuration parameters. PCHECK can capture the relationships among multiple configurations, e.g., one parameter's value has to be larger or smaller than another's.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.4">Encapsulation</head><p>For each configuration parameter, PCHECK encapsulates the configuration-consuming instructions together with their context into a checker, in the form of a function. PCHECK clones the original instructions and their operands. For local variables used as operands, PCHECK clones a new local variable and replaces the original variable with the new one. If the instructions change global variables, PCHECK generates a corresponding local variable and copies the global variable's value to the local one (to avoid changing the global program state). When it involves procedure calls, PCHECK inlines the callees.</p><p>Handling multiple execution paths. For configuration parameters whose values are used in multiple distinct execution paths, PCHECK generates multiple checkers and aggregates their results. The configuration value is considered erroneous if one of these checkers complains.</p><p>PCHECK needs to pay attention to potential path explosion to avoid generating too many checkers. Fortunately, in our experience, configuration values are usually used in a simple and straightforward way, with only a small number of different execution paths to emulate. <ref type="bibr" target="#b4">6</ref> This makes the PCHECK approach feasible.</p><p>Moreover, PCHECK merges two checkers if they are equivalent or if one is equivalent to a subset of the other. PCHECK does this by canonicalizing and comparing the instructions in the checkers' function bodies. Additionally, PCHECK merges checkers which start with the same transformation instruction sequence by reusing the intermediate transformation results.</p><p>Note that the checkers with no error identifiers ( §3.3) or considered redundant ( §3.4) will be abandoned. As shown in §4.4, the number of generated checkers are well bounded, and executing them incurs little overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Preventing Side Effects</head><p>PCHECK ensures that the generated checkers are free of side effects-running the checkers does not change the internal program state beyond the checker function itself, or the external system environment (e.g., filesystems and OSes). Therefore, PCHECK cannot blindly execute the original instructions. For example, if the checker contains instructions that call exec, running the checker would destruct the current process image. Similarly, creating or deleting files is not acceptable, as the filesystem state before and after checking would be inconsistent.</p><p>Internal side effects are prevented by design. PCHECK ensures that each checker only has local effects. As discussed in §3.1.4, PCHECK avoids modifying global variables in the checker function; instead, it copies global variable values to local variables and uses the local ones instead. The checker does not manipulate pointers if the pointed values are indeterminate.</p><p>External side effects are mainly derived from certain system and library calls that interact with the external environment (e.g., filesystems and OS states). In order to preserve the checking effectiveness without incurring external side effects, PCHECK rewrites the original call instructions to redirect the calls to predefined check utilities. A check utility models a specific system or library call based on the call semantics. It validates the arguments of the call, but does not actually execute the call. PCHECK implements check utilities for standard APIs and data structures (including system calls, libc functions for C, and Java core packages defined in SDK). The check utilities are implemented as libraries that are either statically linked into the system's bitcode (for C programs), or included in the system's classpath (for Java programs). In <ref type="figure">Figure 4</ref>, the check utility of freopen checks the arguments of the call using access and stat which are free of side effects (the original freopen call will close the file stream specified by the third argument).</p><p>PCHECK skips instructions that read/write file content or send/recv network packets, in order to stay away from external side effects and heavy checking overhead. Instead, PCHECK performs metadata checks for files and reachability checks for network addresses. This helps the generated checkers be safe and efficient, while still being able to catch a majority of real-world LC errors.</p><p>For any library calls that are not defined in PCHECK or do not have known side effects (e.g., some library calls would invoke external programs/commands), PCHECK defensively removes the call instructions (together with the succeeding instructions) to avoid unexpected effects.</p><p>One alternative approach to preventing external side effect is to running the checkers inside a sandbox or even a virtual machine at the system initialization phase. This may save the efforts of implementing the check utilies and rewriting system/library call instructions. However, such approach would impair the usability of PCHECK, because it requires additional setups from system administrators in order to run the PCHECK-enhanced program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Capturing Anomalies</head><p>As the checker emulates the execution that uses the configuration value, anomalies exposed during execution indicate that the value contains errors-the same problem that would occur during real execution. In this case, the checker reports errors and pinpoints the parameter.</p><p>PCHECK captures anomalies based on the following three types of error identifiers: (1) runtime exceptions that disrupt the emulated execution (for Java programs);</p><p>(2) error code returned by system and library calls (for C programs); and (3) abnormal program termination and error logging that indicate abnormal program states.</p><p>For Java programs, PCHECK captures runtime anomalies based on Java's Exception interface, the language's uniform mechanism for capturing error events. PCHECK places the body of the checker function in a try/catch block. The abnormal execution would throw Exception objects and fall into the catch block. In this case, the checker reports errors and prints the stack traces.</p><p>C programs do not have the uniform error interfaces. Thus, PCHECK leverages the error identifiers defined by specific system/library call semantics, i.e., the return values and errno. For example, if the access call returns -1, it means the call failed when accessing the file (with the reason being encoded in errno). In PCHECK, we predefine the error identifiers for commonly-used system and libc calls to decide whether a call succeeded or failed. If the call fails, the checker reports configuration errors.</p><p>In addition to the anomalies exposed by system and library APIs, a program usually contains hints of abnormal program states. Such hints are instructions such as exit, abort, throw, false assertion, error logging, etc. PCHECK treats these hints as one type of anomalies. If an instruction is post-dominated by any anomaly hints, the instruction itself indicates an abnormal state of execution. Thus, PCHECK reports configuration errors when the checker emulates such error instructions. PCHECK records these hints during the code analysis in §3.1.2, and inserts error-reporting instructions into the checker at the corresponding locations.</p><p>PCHECK abandons the checkers that do not contain any of the three types of error identifiers discussed above. In other words, running such checkers cannot expose any explicit anomalies (no evidence of configuration errors).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Invoking Early Checkers</head><p>Once the checkers are generated, PCHECK inserts call instructions to invoke the checkers at the program locations specified by developers. The expected location is at the end of the system initialization phase to make the checkers the last defense against LC errors. <ref type="figure" target="#fig_5">Figure 5</ref> shows the locations annotated for PCHECK to invoke the auto-generated checkers for Squid and HDFS. For server systems like Squid, the checkers should be invoked before the server starts to listen and wait for client requests. For distributed systems like HDFS, the checkers should be invoked before the system starts to connect and join the cluster. As all the evaluated systems fall in these two patterns, we believe that specifying the invocation locations is a simple practice for developers.</p><p>Some C programs may change user/group identities. Typically, the program starts as root and then switches to unprivileged users/groups (e.g., nobody) at the end of initialization before handling user requests. In <ref type="figure" target="#fig_5">Figure 5</ref>, the switch is performed inside mainInitialize. As the checkers are invoked in the end of the initialization, the checking results are not affected by user/group switches.</p><p>To capture the TOCTTOU errors, PCHECK also supports running the generated checkers periodically in a separate thread. Periodical checking is particularly useful for catching configuration errors that occur after the initial checking (e.g., due to environment changes such as remote host failures and inadvertent file deletion).</p><p>Avoiding redundant checking. PCHECK abandons the redundant checkers which are constructed from instructions that would be executed before reaching the invocation location-any configuration errors reported by such checkers should have already been detected by the sys- tem's built-in checks, or have been exposed when the configuration value is used, before the checker is called.</p><p>Creating standalone checking programs. Another option to invoking the early checkers is to create a standalone checking program comprised of the checkers, and run it when the configuration file changes. This approach eliminates the need to deal with internal side effect; on the other hand, the checking program is still prohibited to have external side effect. Note that the generated checkers start from the instructions that load configuration values ( §3.1.1); therefore, the checking program needs to include the procedures that parse configuration files and store configuration values. This is straightforward for the software systems with modularized parsing procedures <ref type="bibr" target="#b5">7</ref> , but could be difficult if the parsing procedures cannot be easily decoupled from the initialization phase (the initialization may have external side effects).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experimental Evaluation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Methodology</head><p>We first evaluate the effectiveness of PCHECK using the 37 new LC errors discovered in our study. As discussed in §2, all these new LC errors are from the latest versions of the systems; any of them can impair the corresponding RAS features such as fail-over and error handling.</p><p>As the design of PCHECK is inspired by the above LC errors, our evaluation contains two more sets of benchmarks to evaluate how PCHECK works beyond these errors. First, we evaluate PCHECK on a distinct set of 21 real-world LC errors that caused system failures in the past. These LC errors are collected from the datasets in prior studies related to configurations <ref type="bibr" target="#b4">[6,</ref><ref type="bibr" target="#b9">11,</ref><ref type="bibr" target="#b53">51,</ref><ref type="bibr" target="#b57">55,</ref><ref type="bibr" target="#b61">59]</ref>; all of them were introduced by real users and caused realworld failures. Some of these cases have different code <ref type="table" target="#tab_3">Software   Historical  New  Setup effort  HDFS  7  17  6  YARN  6  9  7  HBase  3  3  6  Apache  2  3  6  Squid  2  3  4  MySQL  1  2  31  Total  21  37</ref> N/A <ref type="table">Table 7</ref>: The number of LC error cases used in the evaluation, and the setup efforts (the lines of specifications for identifying starting points, c.f., §3.1.1 and annotations of invocation location, c.f., §3.4).  <ref type="bibr" target="#b37">[38]</ref> and unreachable emails <ref type="bibr" target="#b37">[38]</ref>; patterns from the ones we discovered in §2. <ref type="table">Table 7</ref> lists the number of these LC errors in each system. Furthermore, we apply PCHECK to 830 configuration files of the studied systems (except Squid) collected from the official mailing lists of these systems and online technical forums such as ServerFault and StackOverflow <ref type="bibr" target="#b0">[1]</ref>. This simulates the experience of using PCHECK on realworld configuration files ( §4.2). Moreover, it helps measure the false positive rate of the checking results ( §4.6).</p><p>Note that we evaluate PCHECK upon all types of LC errors, instead of any specific error types. Therefore, the evaluation results indicate the checking effectiveness of PCHECK in terms of all possible LC errors. <ref type="table" target="#tab_9">Table 8</ref> categorizes and exemplifies the LC errors used in the evaluation based on their types.</p><p>Also, the evaluation does not use synthetic errors generated by mutation or fuzzing tools (e.g., ConfErr <ref type="bibr" target="#b21">[23]</ref>). Most of the synthetic errors are not LC errors-they are manifested or detected by the system's built-in checks at the system's initialization time. Thus, using such errors would make the results less meaningful to LC errors.</p><p>For each system, we apply PCHECK to generate the early checkers and insert them in the system's program. <ref type="table">Table 7</ref> lists the setup efforts for the each system evaluated, measured by the lines of specifications for identifying the start points (c.f., §3.1.1) and annotations of the invocation locations (c.f., §3.4). Then, we apply the autogenerated checkers to the configuration files that contain these LC errors. We evaluate the effectiveness of PCHECK based on how many of the real-world LC errors can be reported by the auto-generated checkers.  We compare the checking results of PCHECK with conf spellchecker <ref type="bibr">[2,</ref><ref type="bibr" target="#b34">35]</ref>, a state-of-the-art static configuration checking tool built on top of automatic type inference of configuration values <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b34">35]</ref>. For each defined type, conf spellchecker implements corresponding checking functions which are invoked to check the validity of the configuration settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Detecting Real-world LC Errors</head><p>PCHECK detects 70+% of both historical and new LC errors (as shown in <ref type="table" target="#tab_11">Table 9</ref>), preventing the latent manifestation and resultant system damage imposed by these errors. The results are promising, especially considering that we evaluate PCHECK using all types of configuration errors instead of any specific type. Indeed, PCHECK is by design generic to any types of configuration errors that can be exposed through execution emulation. Many of these LC errors cannot be detected by the state-of-theart detection tools, as discussed below and in §4.3.</p><p>Among the different types of LC errors, PCHECK detects all the errors violating the types/formats and options/ranges constraints. These two types of errors usually go through straightforward code patterns and do not have dependencies with the system's runtime states. For example, most type/format errors in HDFS and YARN are manifested when these systems read and parse the erroneous settings through the getter functions. As the auto-generated checkers invoke the getter instructions, it triggers exceptions and detects the errors.</p><p>PCHECK detects the majority of LC errors that violate file-related constraints (including special files such as directories and executables). We observe that the majority of the file parameters fall into recognized APIs, such as open, fopen, and FileInputStream. The undetected file-related LC errors are mainly caused by (1) unknown external usage and (2) indeterminate context. The former prevents the generated checkers from being executed, and the latter stops generation of the checkers. For example, some errors reside in parameters whose values are concatenated into shell command strings, used as the argument of system() (to invoke /bin/sh to execute the command). As PCHECK has no knowledge of any  shell commands, it removes the system() call because the side effects are unknown. The other undetected errors are in directories or file prefixes which are merged with dynamic contents from user requests which cannot be obtained statically; thereby, the corresponding checkers cannot be generated. These two causes (unknown external usage and indeterminate context) also account for the undetected errors in the "other" category.</p><p>In general, PCHECK is effective in checking errors that are manifested through execution anomalies with error identifiers defined in §3.3, such as those failing at system/library calls or throwing exceptions in the controlled branch. Whereas, it is hard for PCHECK to detect errors defined by application-specific semantics, such as email addresses, internal error code, etc.</p><p>We apply conf spellchecker on the same sets of LC errors. Compared with PCHECK, conf spellchecker detects 7 (33.3%) and 11 (29.7%) less LC errors in the historical and new error benchmarks, respectively. The main reason for PCHECK's outperformance is that the execution emulation can achieve fine-grained checking towards high fidelity to the original execution. For example, conf spellchecker can only infer the type of a configuration setting to be a "File". However, it does not understand how the system accesses the file in the execution. Thus, it reports errors if and only if "the file is neither readable nor writable" <ref type="bibr">[2]</ref>. This heuristic would miss LC errors such as read-only files to be written by the system. Furthermore, type alone only describes a subset of constraints. conf spellchecker misses the LC errors that violate other types of constraints such as data ranges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Checking Real-world Configuration Files</head><p>We apply the checkers generated by PCHECK to 830 real-world configuration files. PCHECK reports 282 true configuration errors and three false alarms (discussed in §4.6). As shown in <ref type="table" target="#tab_13">Table 10</ref>, many (37.5%-87.8%) of the reported configuration errors can only be detected by considering the system's native execution environment. These configuration settings are valid in terms of format and syntax (in fact, they are likely to be correct in the original hosts). However, they are erroneous when used on the current system because the values violate environment constraints such as undefined environment vari-  <ref type="table">Table 11</ref>: The number of parameters with checkers generated by PCHECK and the total number of generated checkers (each represents a distinct parameter usage scenario).</p><p>ables, non-existent file paths, unreachable IP addresses, etc. Since PCHECK emulates the execution that uses the configuration values on the system's native execution environment, it naturally detects these errors. On the other hand, such configuration errors are not likely to be detected by traditional detection methods <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b35">36,</ref><ref type="bibr" target="#b46">46,</ref><ref type="bibr" target="#b59">57]</ref> that treat configuration values as string literals, and thus are agnostic to the execution environment. <ref type="table">Table 11</ref> shows the number of configuration parameters that have checkers generated by PCHECK and the total number of generated checkers for the evaluated systems (multiple checkers could be generated for a parameter). PCHECK generates checkers for every recognized parameter of HDFS, YARN, and HBase. Each emulated execution in these systems starts from the call instructions of getter functions, so the checkers are able to capture all the errors starting from the parsing phase to the usage phase. For Apache, MySQL and Squid, PCHECK generates fewer checkers. As these systems parse and assign parameter settings to corresponding program variables at the initialization stage, PCHECK bypasses the parsing phase and directly starts from the variables that store the configuration value. Since a large number of the Boolean and numeric variables are only used for branch control with no error identifier (both branches are valid), PCHECK does not generate checkers for them (c.f., §3.3). Moreover, many of the variables are only used at the initialization phase before reaching the invocation location, so their checkers are considered redundant and thus are abandoned (c.f., §3.4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Checker Generation</head><p>The other issues that prevent checker generation include dependencies on the system's runtime states and uses of customized APIs (e.g., Apache uses customized APR string operations which heavily rely on predefined memory pools). Fortunately, as shown in §4.2, the majority of the LC errors have standard code patterns and can be detected using PCHECK's approach. Generating checkers for the rest of the errors require more advanced analysis and program-specific semantics.</p><p>Also, we can see that the total number of checkers are well bounded, which is attributable to the execution merging ( §3.1.4) and redundancy elimination ( §3.4).  <ref type="table">Table 12</ref>: Checking overhead (measured by the time needed to run the auto-generated checkers).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Software</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Checking Overhead</head><p>The checkers are only invoked at the initialization phase or run in a separate thread, thus they have little impact on the systems' runtime performance. We measure their overhead to be the time needed to execute these checkers, by inserting time counters before and after invoking all the checkers. <ref type="table">Table 12</ref> shows the time in milliseconds (ms) to run the checkers on a 4-core, 2.50GHz processor connected to a local network (for distributed systems like HDFS, YARN, and HBase, the peer nodes are located in the same local network). The checking overhead for Apache and MySQL is negligible (less than 5ms); Squid needs around 100ms because it has a parameter that points to public IP addresses (announce host). The overhead for the three Java programs is less than a second. The main portion of the time is spent on networkand file-related checking. Since PCHECK only performs lightweight checks (e.g., metadata checks and reachability checks), the overhead is small. Note that the checkers are currently executed sequentially. It is straightforward to invoke multiple checkers in parallel to reduce overhead, as all the checkers are independent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">False Positives</head><p>We measure false positives by applying the checkers generated by PCHECK to both the default configuration values of the evaluated systems and the 830 real-world configuration files, and examine whether or not our checkers would falsely report errors. We also manually inspect the code of the generated checkers in LLVM IR and Jimple to look for potential incorrectness. Among all the configuration parameters in the evaluated systems, only three of them have false alarms reported by the auto-generated checkers: two from YARN and one from HBase. All these false positives are caused by the checkers incorrectly skipping conditional instructions affected by the configuration value ( §3.1.2), due to unsound static analysis that misses control dependencies. This results in emulating the execution that should never happen in reality-certainly, the anomalies exposed in such execution are unreal. The overall false positive rates are low. YARN has the most configuration parameters with false checkers, with the false positive rate of 1.7% (2 over 116 parameters). Note that checkers with false positives can be removed by the developers or disabled by the administrators in the field (c.f., §3: Usage).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Limitations</head><p>No tool is perfect. PCHECK is no exception. Like many other error detection tools, PCHECK is neither sound nor complete for its checking scope and the design trade-offs.</p><p>PCHECK targets on the specific type of configuration errors which are manifested through explicit, recognizable instruction-level anomalies (c.f., §3.3). It cannot detect legal misconfigurations <ref type="bibr" target="#b57">[55]</ref> that have valid values but do not deliver the intended system behavior. The common legal misconfigurations include inappropriate configuration settings that violate resource constraints or performance requirements (e.g., insufficient heap size and too small timeout). Such misconfigurations are notoriously hard to detect and are often manifested in a latent fashion as well, such as runtime out-of-memory errors <ref type="bibr" target="#b8">[10]</ref> (resources are not used up immediately). However, detecting resource-and performance-related misconfigurations would need dynamic information regarding resource usage and performance profiling, which is beyond the static methods of PCHECK.</p><p>In addition, PCHECK cannot emulate the execution that depends on runtime inputs/workloads, or does not have statically determinate context in the program code (c.f., §3.1.3). Thus, it would miss the configuration errors that are only manifested during such execution. Nevertheless, indeterminate context (e.g., those derived from inputs and workloads) can potentially be modeled with representative values, which could significantly improve the capability of checker generation.</p><p>One design choice we make is to trade soundness for safety and efficiency-PCHECK aims to detect common LC errors without incurring side effects or much overhead. For example, PCHECK does not look into file contents but only checks if the file can be accessed as expected. Similarly, PCHECK only checks the reachability of a configured IP address or host instead of connecting and sending packets to the remote host. It is possible that certain sophisticated errors can escape from PCHECK (e.g., the configured file is corrupted and thus has wrong contents). As the first step, we target on basic, common errors, as they already account for a large number of real-world LC errors <ref type="bibr" target="#b22">[24,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b57">55]</ref>. Efficiently detecting sophisticated errors may require not only deeper analysis but also application semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Concluding Remarks</head><p>This paper advocates early detection of configuration errors to minimize failure damage, especially in cloud and data-center systems. Despite all the efforts of validation, review, and testing, configuration errors (even those obvious errors) still cause many high-impact incidents of today's Internet and cloud systems. We believe that this is partly due to the lack of automatic solutions for cloud and data-center systems to detect and defend against configuration errors (the existing solutions are hard to be applied, due to their strong reliance on datasets).</p><p>We envisage that PCHECK is the first step towards a generic and systematic solution to detect configuration errors. PCHECK does not require collecting any external datasets and is not specific to any specific rules. It detects configuration errors based on how the system actually uses the configuration values. With PCHECK, we demonstrate that such detection method can effectively detect the majority (75+%) of real-world LC errors, with little runtime overhead and setup effort.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Check existence of diskd_program during initialization Use the setting of diskd_program for log rotation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Finding 1 :</head><label>1</label><figDesc>Many (14.0%-93.2%) of the studied RAS parameters do not have any special code for checking the correctness of their settings. Instead, the correctness is verified (implicitly) when the parameters' values are actually used in operations such as a file open call.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2. Initial checks: 3 .</head><label>3</label><figDesc>Late execution: Parse the timeout setting to an integer value; None. public boolean tryFence(...) { } /* hadoop-common/.../ha/ SshFenceByTcpPort.java */ Auto-failover configuration parameters: HDFS-2.6.0 dfs.ha.fencing.ssh.connect-timeout dfs.ha.fencing.ssh.private-key-files Read the file specified by the key-files setting. getString(idfs.ha.fencing.ssh .private-key-filesj) fis = new FileInputStream(prvFile); session.createSession(); ... ... int timeout = getInt(idfs.ha.fencing.ssh.connect-timeoutj);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>3 .</head><label>3</label><figDesc>Late execution: Change working directory (chdir) to the path. Check if the path points to an existent directory. static void sig_coredump(int sig) { } /* server/mpm_unix.c */ Error-handling configuration parameter: Apache httpd-2.4.10 CoreDumpDirectory if(chdir(rootpath) != 0) return errno; ... apr_filepath_set(ap_coredump_dir, ...);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>6 /Figure 4 :</head><label>64</label><figDesc>char* filename, ..., FILE *errstream) { my_freopen(filename, "a", errstream)(char *path, char *mode, FILE *stream) { result = freopen(path, mode, stream)*src/log.cc*/ /* src/log.cc */ /* src/log.cc */ /* mysys/my_fopen.c */ bool check_log_error() { char* mode = iaj; freopen(log_error_file, mode, stream); bool cr = check_util_freopen(log_error_file, mode); if (cr == false) { fprintf(stderr, "log_error is misconfigured."checker (simplified for clarity): bool check_util_freopen(char *path, char *mode); /* Predefined utility function that checks the arguments based on the call semantics without executing the call ( §3.2). */ Illustration of PCHECK's checker generation (using a real-world LC error example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Locations to invoke the checkers in Squid and HDFS NameNode. The auto-generated checkers are expected to be invoked at the end of the initialization phase.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 3 :</head><label>3</label><figDesc>The systems and the RAS parameters studied in §2.</figDesc><table><row><cell>Software</cell><cell cols="2">Deficiency of initial checking Missing Incomplete</cell><cell>Studied param.</cell></row><row><cell>HDFS</cell><cell>41 (93.2%)</cell><cell>3 (6.9%)</cell><cell></cell></row><row><cell>YARN</cell><cell>29 (82.9%)</cell><cell>5 (14.3%)</cell><cell>35</cell></row><row><cell>HBase</cell><cell>18 (72.0%)</cell><cell>5 (2.0%)</cell><cell></cell></row><row><cell>Apache</cell><cell>4 (28.6%)</cell><cell>2 (14.3%)</cell><cell>14</cell></row><row><cell>Squid</cell><cell>9 (42.9%)</cell><cell>4 (19.0%)</cell><cell>21</cell></row><row><cell>MySQL</cell><cell>6 (14.0%)</cell><cell>6 (14.0%)</cell><cell>43</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 :</head><label>5</label><figDesc>The studied configuration parameters whose values are not used at the system's initialization phase.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 8 :</head><label>8</label><figDesc>Types and examples of LC errors used in the evaluation.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11"><head>Table 9 :</head><label>9</label><figDesc>The number (percentage) of the LC errors detected by the early checkers generated by PCHECK. PCHECK detects 7 (33.3%) and 11 (29.7%) more LC errors among the historical and new LC-error benchmarks respectively, compared to conf spellchecker, a stateof-the-art configuration-error detection tool.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13"><head>Table 10 :</head><label>10</label><figDesc>Configuration errors detected by applying the checkers on real-world configuration files. Many of the errors can only be detected by considering the system's native environment ( §4.3).</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">A system's initialization phase is defined from its entry point to the point it starts to serve user requests or workloads.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">This is a bad but commonly adopted practice in Java and Python programs which rely on libraries (e.g., java.util.Properties and configparser) to directly retrieve and use configuration values from configuration files on demand, without systematic early checks.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">A TOCTTOU (Time-Of-Check-To-Time-Of-Use) error occurs after the checking phase and before the use phase, e.g., inadvertently deleting a file that had been checked early but will be used later on.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5">The interface could be APIs, data structures, or parsing functions<ref type="bibr" target="#b54">[52,</ref><ref type="bibr" target="#b34">35]</ref>. It is reported that only three types of interfaces are commonly used to store/retrieve configurations<ref type="bibr" target="#b54">[52,</ref><ref type="bibr" target="#b34">35]</ref>.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6">The emulated execution paths are not the original execution paths (they only include the configuration-related instructions).</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7">We implement this approach for HDFS, YARN, and HBase which use modularized getter functions to parse/store configuration values.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgement</head><p>We greatly appreciate the anonymous reviewers and our shepherd, Peter M. Chen, for their insightful comments and feedback. We thank the Opera group, the UCSD Systems and Networking group, and Shelby Thomas for useful discussions and paper proofreading. Tao Cai participated in the implementation of PCHECK. Liqiong Yang contributed to the study of RAS related configuration parameters. Yuanyuan Zhou's group is supported in part by NSF grants (CCR-1526966, CCR-1321006), and a gift grant from Facebook, and supports from NetApp. Shan Lu's research is supported in part by NSF grants (IIS-1546543, CNS-1563956, CNS-1514256, CCF-1514189, CCF-1439091), and generous supports from Alfred P. Sloan Foundation and Google Faculty Research Award.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="https://github.com/tianyin/configuration_datasets" />
		<title level="m">Configuration Datasets</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://sable.github.io/soot/" />
		<title level="m">Java Optimization Framework</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<ptr target="http://llvm.org/" />
		<title level="m">The LLVM Compiler Infrastructure Project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Automating Root-Cause Diagnosis of Performance Anomalies in Production Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Attariyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>X-Ray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12)</title>
		<meeting>the 10th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;12)<address><addrLine>Hollywood, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automating Configuration Troubleshooting with Dynamic Information Flow Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Attariyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Flinn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;10)</title>
		<meeting>the 9th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;10)<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Datacenter as a Computer: An Introduction to the Design of Warehousescale Machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Hölzle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Morgan and Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Users Beware: Preference Inconsistencies Ahead</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Behrang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Orso</surname></persName>
		</author>
		<idno>ES- EC/FSE&apos;15</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering</title>
		<meeting>the 10th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering<address><addrLine>Bergamo, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Why Gmail went down: Google misconfigured load balancing servers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Brodkin</surname></persName>
		</author>
		<ptr target="http://arstechnica.com/information-technology/2012/12/why-gmail-went-down-google-misconfigured-chromes-sync-server/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Interruptible Tasks: Treating Memory Pressure As Interrupts for Highly Scalable Data-Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Fang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Demsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating System Principles (SOSP&apos;15)</title>
		<meeting>the 25th Symposium on Operating System Principles (SOSP&apos;15)<address><addrLine>Monterey, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">What Bugs Live in the Cloud? A Study of 3000+ Issues in Cloud Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">S</forename><surname>Gunawi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Leesatapornwongsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Patana-Anake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Do</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Adityatama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">J</forename><surname>Eli-Azar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Laksono</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">F</forename><surname>Lukman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Mar-Tin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Satria</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th ACM Symposium on Cloud Computing (SoCC&apos;14)</title>
		<meeting>the 5th ACM Symposium on Cloud Computing (SoCC&apos;14)<address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">JobTracker trapped in a loop if it fails to localize a task</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hadoop</surname></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HADOOP-134" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Configuration getInt, getLong, and getFloat replace invalid numbers with the default value</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hadoop Issue #</surname></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HADOOP-2081" />
		<imprint>
			<date type="published" when="2081" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Configuration should trim whitespace around a lot of value types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hadoop</surname></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HADOOP-6578" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hadoop-User</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mailing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Archives</surname></persName>
		</author>
		<ptr target="http://goo.gl/N9XFvt" />
	</analytic>
	<monogr>
		<title level="j">Compression codec com.hadoop.compression.lzo.LzoCodec not found</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Trim trailing whitespace from configuration values</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hbase</surname></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HBASE-6973" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">HDFS ISSUE 5872#. Validate configuration of dfs</title>
		<ptr target="https://issues.apache.org/jira/browse/HDFS-5872" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Parse and check the configuration settings of edit log to prevent runtime errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hdfs</surname></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HDFS-7726" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Check and verify the auto-fence settings to prevent failures of auto-failover</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hdfs</surname></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/HDFS-7727" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Understanding and Dealing with Failures in Cloud-Scale Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Huang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
		<respStmt>
			<orgName>University of California San Diego, Computer Science and Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Understanding Customer Problem Troubleshooting from Storage System Logs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kanevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th USENIX Conference on File and Storage Technologies (FAST&apos;09)</title>
		<meeting>the 7th USENIX Conference on File and Storage Technologies (FAST&apos;09)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">PrefFinder: Getting the Right Preference in Configurable Software Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Qu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Robinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th IEEE/ACM International Conference on Automated Software Engineering (ASE&apos;14)</title>
		<meeting>the 29th IEEE/ACM International Conference on Automated Software Engineering (ASE&apos;14)<address><addrLine>Västerås, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Con-fErr: A Tool for Assessing Resilience to Human Configuration Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Keller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Upadhyaya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Candea</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN&apos;08)</title>
		<meeting>the 38th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN&apos;08)<address><addrLine>Anchorage, AK, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Fail at Scale: Reliability in the Face of Rapid Change</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Maurer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="44" to="49" />
			<date type="published" when="2015-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Software Testing for Sysadmin Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Moskowitz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX ;login: 40</title>
		<imprint>
			<date type="published" when="2015-04" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="37" to="45" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">No warn/error message if &quot;logerror&quot; is misconfigured (causing latent log loss</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mysql</forename><surname>Bug #74720</surname></persName>
		</author>
		<ptr target="http://bugs.mysql.com/bug.php?id=74720" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Runtime Error Caused by Misconfigured BackupDataDir</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mysql</forename><surname>Bug #75645</surname></persName>
		</author>
		<ptr target="http://bugs.mysql.com/bug.php?id=75645" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Why Do Internet Services Fail, and What Can Be Done About It?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Oppenheimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ganapathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Patter-Son</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th</title>
		<meeting>the 4th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m">USENIX Symposium on Internet Technologies and Systems (USITS&apos;03)</title>
		<meeting><address><addrLine>Seattle, WA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Mining for Misconfigured Machines in Grid Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Palatin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Leizarowitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schuster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wolff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD&apos;06)</title>
		<meeting>the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD&apos;06)<address><addrLine>Philadelphia, PA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Recovery-Oriented Computing (ROC): Motivation, Definition, Techniques, and Case Studies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Patterson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Broadwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Can-Dea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cutler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Enriquez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kiciman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Merzbacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Oppenheimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sastry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Tetzlaff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Traupman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Treuhaft</surname></persName>
		</author>
		<idno>UCB//CSD-02-1175</idno>
		<imprint>
			<date type="published" when="2002-03" />
		</imprint>
		<respStmt>
			<orgName>University of California Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep.</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Leveraging Customer Support Knowledge Bases for Automated Misconfiguration Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Potharaju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Chan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Nita-Rotaru</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Confseer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th International Conference on Very Large Data Bases (VLDB&apos;15)</title>
		<meeting>the 35th International Conference on Very Large Data Bases (VLDB&apos;15)<address><addrLine>Kohala Coast, HI, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Precomputing Possible Configuration Error Diagnosis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rabkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th IEEE/ACM International Conference on Automated Software Engineering (ASE&apos;11</title>
		<meeting>the 26th IEEE/ACM International Conference on Automated Software Engineering (ASE&apos;11<address><addrLine>Lawrence, KS, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Static Extraction of Program Configuration Options</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rabkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33th International Conference on Software Engineering (ICSE&apos;11)</title>
		<meeting>the 33th International Conference on Software Engineering (ICSE&apos;11)<address><addrLine>Honolulu, HI, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">How Hadoop Clusters Break</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rabkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software Magazine</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="88" to="94" />
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Using Program Analysis to Reduce Misconfiguration in Open Source Systems Software. PhD thesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">S</forename><surname>Rabkin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<pubPlace>Berkeley</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Probabilistic Automated Language Learning for Configuration Files</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Santolucito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Piskac</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">28th International Conference on Computer Aided Verification (CAV&apos;16)</title>
		<meeting><address><addrLine>Toronto, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<ptr target="http://bugs.squid-cache.org/show_bug.cgi?id=1703" />
		<title level="m">SQUID BUG #1703. diskd related 100% CPU after &apos;squid -k rotate</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">The mail notification feature is buggy and does not deal with configuration errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Squid</surname></persName>
		</author>
		<ptr target="http://bugs.squid-cache.org/show_bug.cgi?id=4186" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sridharan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Fink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">Thin</forename><surname>Bodík</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Slicing</surname></persName>
		</author>
		<title level="m">Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;07)</title>
		<meeting>the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI&apos;07)<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stackoverflow Question #</surname></persName>
		</author>
		<imprint>
			<date type="published" when="21253299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<ptr target="http://stackoverflow.com/questions/21253299/hadoop-sshfence-permission-denied" />
		<title level="m">Hadoop sshfence</title>
		<imprint/>
	</monogr>
	<note>permission denied</note>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">Core dump file is not generated</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stackoverflow</surname></persName>
		</author>
		<ptr target="http://stackoverflow.com/questions/7732983/core-dump-file-is-not-generated" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sverdlik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Microsoft</surname></persName>
		</author>
		<ptr target="http://www.datacenterdynamics.com/focus/archive/2012/07/microsoft-misconfigured-network-device-led-azure-outage" />
		<title level="m">Misconfigured Network Device Led to Azure Outage</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Holistic Configuration Management at Facebook</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kooburat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Venkatachalam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Dowell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Karl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating System Principles (SOSP&apos;15)</title>
		<meeting>the 25th Symposium on Operating System Principles (SOSP&apos;15)<address><addrLine>Monterey, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<ptr target="http://www.availabilitydigest.com/public_articles/0504/google_power_out.pdf" />
		<title level="m">THE AVAILABILITY DIGEST. Poor Documentation Snags Google</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Amazon: The Cloud Crash Reveals Your Importance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Thanks</surname></persName>
		</author>
		<ptr target="http://www.pcworld.com/article/226033/thanks_amazon_for_making_possible_much_of_the_internet.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Automatic Misconfiguration Troubleshooting with PeerPressure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Platt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th</title>
		<meeting>the 6th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<monogr>
		<title level="m">USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;04)</title>
		<meeting><address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Towards optimization-safe systems: Analyzing the impact of undefined behavior</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Kaashoek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Solar-Lezama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Symposium on Operating System Principles (SOSP&apos;13)</title>
		<meeting>the 24th Symposium on Operating System Principles (SOSP&apos;13)<address><addrLine>Farmington, PA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">STRIDER: A Black-box, State-based Approach to Change and Configuration Management and Support</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Verbowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dunagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Large Installation Systems Administration Conference (LISA&apos;03)</title>
		<meeting>the 17th Large Installation Systems Administration Conference (LISA&apos;03)<address><addrLine>San Diego, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Configuration Debugging as Search: Finding the Needle in the Haystack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Whitaker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Gribble</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;04)</title>
		<meeting>the 6th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;04)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">WIKIPEDIA. Reliability, availability and serviceability (computing)</title>
		<ptr target="https://en.wikipedia" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<title level="m">org/wiki/Reliability,_availability_and_ serviceability_(computing)</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">You Have Given Me Too Many Knobs! Understanding and Dealing with Over-Designed Configuration in System Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Fan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Talwadker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hey</surname></persName>
		</author>
		<idno>ES- EC/FSE&apos;15</idno>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering</title>
		<meeting>the 10th Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering<address><addrLine>Bergamo, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Do Not Blame Users for Misconfigurations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Symposium on Operating System Principles (SOSP&apos;13)</title>
		<meeting>the 24th Symposium on Operating System Principles (SOSP&apos;13)<address><addrLine>Farmington, PA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Systems Approaches to Tackling Configuration Errors: A Survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Timelineserver should validate that yarn.timeline-service.leveldb-timeline-store.ttlinterval-ms is greater than zero when level db is for timeline store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yarn Issue #</surname></persName>
		</author>
		<ptr target="https://issues.apache.org/jira/browse/YARN-2166" />
		<imprint>
			<date type="published" when="2166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">An Empirical Study on Configuration Errors in Commercial and Open Source Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">N</forename><surname>Bairava-Sundaram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pasupathy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Symposium on Operating Systems Principles (SOSP&apos;11) (Cascais</title>
		<meeting>the 23rd ACM Symposium on Operating Systems Principles (SOSP&apos;11) (Cascais<address><addrLine>Portugal</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Automated Known Problem Diagnosis with Event Traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-R</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y.-M</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-Y</forename><surname>Ma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st EuroSys Conference (EuroSys&apos;06)</title>
		<meeting>the 1st EuroSys Conference (EuroSys&apos;06)<address><addrLine>Leuven, Belgium</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Context-based Online Configuration Error Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Panigrahy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ver-Bowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kumar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 2011 USENIX Annual Technical Conference (USENIX ATC&apos;11)</title>
		<meeting>2011 USENIX Annual Technical Conference (USENIX ATC&apos;11)<address><addrLine>Portland, OR, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">Heading Off Correlated Failures through Independenceas-a-Service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zhai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">I</forename><surname>Wolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;14)</title>
		<meeting>the 11th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;14)<address><addrLine>Broomfield, CO, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">EnCore: Exploiting System Environment and Correlation Information for Misconfiguration Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Renganarayana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Bala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS&apos;14)</title>
		<meeting>the 19th International Conference on Architecture Support for Programming Languages and Operating Systems (ASPLOS&apos;14)<address><addrLine>Salt Lake City, UT, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Automated Diagnosis of Software Conguration Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th International Conference on Software Engineering (ICSE&apos;13)</title>
		<meeting>the 35th International Conference on Software Engineering (ICSE&apos;13)<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Which Configuration Option Should I Change?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Software Engineering (ICSE&apos;14)</title>
		<meeting>the 36th International Conference on Software Engineering (ICSE&apos;14)<address><addrLine>Hyderabad, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Proactive Detection of Inadequate Diagnostic Messages for Software Configuration Errors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 International Symposium on Software Testing and Analysis (ISSTA&apos;15)</title>
		<meeting>the 2015 International Symposium on Software Testing and Analysis (ISSTA&apos;15)<address><addrLine>Baltimore, MD, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
