<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dremel: Interactive Analysis of Web-Scale Datasets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Melnik</surname></persName>
							<email>melnik@google.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrey</forename><surname>Gubarev</surname></persName>
							<email>andrey@google.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jing</forename><forename type="middle">Jing</forename><surname>Long</surname></persName>
							<email>jlong@google.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><surname>Romer</surname></persName>
							<email>gromer@google.com</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Shiva Shivakumar</orgName>
								<address>
									<addrLine>Matt Tolton</addrLine>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Theo Vassilakis Google, Inc</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Dremel: Interactive Analysis of Web-Scale Datasets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>DocId</term>
					<term>10 Links Forward</term>
					<term>20 Forward</term>
					<term>40 Forward</term>
					<term>60 Name Language Code</term>
					<term>&apos;en-us&apos; Country</term>
					<term>&apos;us&apos; Language Code</term>
					<term>&apos;en&apos; Url</term>
					<term>&apos;http</term>
					<term>//A&apos; Name Url</term>
					<term>&apos;http</term>
					<term>//B&apos; Name Language Code</term>
					<term>&apos;en-gb&apos; Country</term>
					<term>&apos;gb&apos;</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Dremel is a scalable, interactive ad-hoc query system for analysis of read-only nested data. By combining multi-level execution trees and columnar data layout, it is capable of running aggregation queries over trillion-row tables in seconds. The system scales to thousands of CPUs and petabytes of data, and has thousands of users at Google. In this paper, we describe the architecture and implementation of Dremel, and explain how it complements MapReduce-based computing. We present a novel columnar storage representation for nested records and discuss experiments on few-thousand node instances of the system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Large-scale analytical data processing has become widespread in web companies and across industries, not least due to low-cost storage that enabled collecting vast amounts of business-critical data. Putting this data at the fingertips of analysts and engineers has grown increasingly important; interactive response times often make a qualitative difference in data exploration, monitoring, online customer support, rapid prototyping, debugging of data pipelines, and other tasks.</p><p>Performing interactive data analysis at scale demands a high degree of parallelism. For example, reading one terabyte of compressed data in one second using today's commodity disks would require tens of thousands of disks. Similarly, CPU-intensive queries may need to run on thousands of cores to complete within seconds. At Google, massively parallel computing is done using shared clusters of commodity machines <ref type="bibr" target="#b4">[5]</ref>. A cluster typically hosts a multitude of distributed applications that share resources, have widely varying workloads, and run on machines with different hardware parameters. An individual worker in a distributed application may take much longer to execute a given task than others, or may never complete due to failures or preemption by the cluster management system. Hence, dealing with stragglers and failures is essential for achieving fast execution and fault tolerance <ref type="bibr" target="#b9">[10]</ref>.</p><p>The data used in web and scientific computing is often nonrelational. Hence, a flexible data model is essential in these domains. Data structures used in programming languages, messages exchanged by distributed systems, structured documents, etc. lend themselves naturally to a nested representation. Normalizing and recombining such data at web scale is usually prohibitive. A nested data model underlies most of structured data processing at Google <ref type="bibr" target="#b19">[21]</ref> and reportedly at other major web companies.</p><p>This paper describes a system called Dremel 1 that supports interactive analysis of very large datasets over shared clusters of commodity machines. Unlike traditional databases, it is capable of operating on in situ nested data. In situ refers to the ability to access data 'in place', e.g., in a distributed file system (like GFS <ref type="bibr" target="#b13">[14]</ref>) or another storage layer (e.g., Bigtable <ref type="bibr" target="#b7">[8]</ref>). Dremel can execute many queries over such data that would ordinarily require a sequence of MapReduce (MR <ref type="bibr" target="#b11">[12]</ref>) jobs, but at a fraction of the execution time. Dremel is not intended as a replacement for MR and is often used in conjunction with it to analyze outputs of MR pipelines or rapidly prototype larger computations.</p><p>Dremel has been in production since 2006 and has thousands of users within Google. Multiple instances of Dremel are deployed in the company, ranging from tens to thousands of nodes. Examples of using the system include:</p><p>• Analysis of crawled web documents.</p><p>• Tracking install data for applications on Android Market.</p><p>• Crash reporting for Google products.</p><p>• OCR results from Google Books.</p><p>• Spam analysis.</p><p>• Debugging of map tiles on Google Maps.</p><p>• Tablet migrations in managed Bigtable instances.</p><p>• Results of tests run on Google's distributed build system.</p><p>• Disk I/O statistics for hundreds of thousands of disks.</p><p>• Resource monitoring for jobs run in Google's data centers.</p><p>• Symbols and dependencies in Google's codebase.</p><p>Dremel builds on ideas from web search and parallel DBMSs. First, its architecture borrows the concept of a serving tree used in distributed search engines <ref type="bibr" target="#b10">[11]</ref>. Just like a web search request, a query gets pushed down the tree and is rewritten at each step. The result of the query is assembled by aggregating the replies received from lower levels of the tree. Second, Dremel provides a high-level, SQL-like language to express ad hoc queries. In contrast to layers such as Pig <ref type="bibr" target="#b16">[18]</ref> and Hive <ref type="bibr">[16]</ref>, it executes queries natively without translating them into MR jobs.</p><p>Lastly, and importantly, Dremel uses a column-striped storage representation, which enables it to read less data from secondary Dremel is a brand of power tools that primarily rely on their speed as opposed to torque. We use this name for an internal project only. storage and reduce CPU cost due to cheaper compression. Column stores have been adopted for analyzing relational data <ref type="bibr" target="#b0">[1]</ref> but to the best of our knowledge have not been extended to nested data models. The columnar storage format that we present is supported by many data processing tools at Google, including MR, Sawzall <ref type="bibr" target="#b18">[20]</ref>, and FlumeJava <ref type="bibr" target="#b6">[7]</ref>.</p><p>In this paper we make the following contributions:</p><p>• We describe a novel columnar storage format for nested data. We present algorithms for dissecting nested records into columns and reassembling them (Section 4). • We outline Dremel's query language and execution. Both are designed to operate efficiently on column-striped nested data and do not require restructuring of nested records (Section 5). • We show how execution trees used in web search systems can be applied to database processing, and explain their benefits for answering aggregation queries efficiently (Section 6). • We present experiments on trillion-record, multi-terabyte datasets, conducted on system instances running on 1000-4000 nodes (Section 7).</p><p>This paper is structured as follows. In Section 2, we explain how Dremel is used for data analysis in combination with other data management tools. Its data model is presented in Section 3. The main contributions listed above are covered in Sections 4-8. Related work is discussed in Section 9. Section 10 is the conclusion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>We start by walking through a scenario that illustrates how interactive query processing fits into a broader data management ecosystem. Suppose that Alice, an engineer at Google, comes up with a novel idea for extracting new kinds of signals from web pages. She runs an MR job that cranks through the input data and produces a dataset containing the new signals, stored in billions of records in the distributed file system. To analyze the results of her experiment, she launches Dremel and executes several interactive commands:</p><formula xml:id="formula_0">DEFINE TABLE t AS /path/to/data/* SELECT TOP(signal1, 100), COUNT(*) FROM t</formula><p>Her commands execute in seconds. She runs a few other queries to convince herself that her algorithm works. She finds an irregularity in signal1 and digs deeper by writing a FlumeJava <ref type="bibr" target="#b6">[7]</ref> program that performs a more complex analytical computation over her output dataset. Once the issue is fixed, she sets up a pipeline which processes the incoming input data continuously. She formulates a few canned SQL queries that aggregate the results of her pipeline across various dimensions, and adds them to an interactive dashboard. Finally, she registers her new dataset in a catalog so other engineers can locate and query it quickly.</p><p>The above scenario requires interoperation between the query processor and other data management tools. The first ingredient for that is a common storage layer. The Google File System (GFS <ref type="bibr" target="#b13">[14]</ref>) is one such distributed storage layer widely used in the company. GFS uses replication to preserve the data despite faulty hardware and achieve fast response times in presence of stragglers. A highperformance storage layer is critical for in situ data management. It allows accessing the data without a time-consuming loading phase, which is a major impedance to database usage in analytical data processing <ref type="bibr" target="#b12">[13]</ref>, where it is often possible to run dozens of MR analyses before a DBMS is able to load the data and execute a single query. As an added benefit, data in a file system can be conveniently manipulated using standard tools, e.g., to transfer to another cluster, change access privileges, or identify a subset of data for analysis based on file names. The second ingredient for building interoperable data management components is a shared storage format. Columnar storage proved successful for flat relational data but making it work for Google required adapting it to a nested data model. <ref type="figure" target="#fig_0">Figure 1</ref> illustrates the main idea: all values of a nested field such as A.B.C are stored contiguously. Hence, A.B.C can be retrieved without reading A.E, A.B.D, etc. The challenge that we address is how to preserve all structural information and be able to reconstruct records from an arbitrary subset of fields. Next we discuss our data model, and then turn to algorithms and query processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DATA MODEL</head><p>In this section we present Dremel's data model and introduce some terminology used later. The data model originated in the context of distributed systems (which explains its name, 'Protocol Buffers' <ref type="bibr" target="#b19">[21]</ref>), is used widely at Google, and is available as an open source implementation. The data model is based on strongly-typed nested records. Its abstract syntax is given by:</p><formula xml:id="formula_1">τ = dom | A1 : τ [ * |?], . . . , An : τ [ * |?]</formula><p>where τ is an atomic type or a record type. Atomic types in dom comprise integers, floating-point numbers, strings, etc. Records consist of one or multiple fields. Field i in a record has a name Ai and an optional multiplicity label. Repeated fields ( * ) may occur multiple times in a record. They are interpreted as lists of values, i.e., the order of field occurences in a record is significant. Optional fields (?) may be missing from the record. Otherwise, a field is required, i.e., must appear exactly once.</p><p>To illustrate, consider <ref type="figure">Figure 2</ref>. It depicts a schema that defines a record type Document, representing a web document. The schema definition uses the concrete syntax from <ref type="bibr" target="#b19">[21]</ref>. A Document has a required integer DocId and optional Links, containing a list of Forward and Backward entries holding DocIds of other web pages. A document can have multiple Names, which are different URLs by which the document can be referenced. A Name contains a sequence of Code and (optional) Country pairs. <ref type="figure">Figure 2</ref> also shows two sample records, r1 and r2, conforming to the schema. The record structure is outlined using indentation. We will use these sample records to explain the algorithms in the next sections. The fields defined in the schema form a tree hierarchy. The full path of a nested field is denoted using the usual dotted notation, e.g., Name.Language.Code.</p><p>The nested data model backs a platform-neutral, extensible mechanism for serializing structured data at Google. Code generation tools produce bindings for programming languages such as C++ or Java. Cross-language interoperability is achieved using a standard binary on-the-wire representation of records, in which field values are laid out sequentially as they occur in the record. This way, a MR program written in Java can consume records from a data source exposed via a C++ library. Thus, if records are stored in a columnar representation, assembling them fast is important for interoperation with MR and other data processing tools. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">NESTED COLUMNAR STORAGE</head><p>As illustrated in <ref type="figure" target="#fig_0">Figure 1</ref>, our goal is to store all values of a given field consecutively to improve retrieval efficiency. In this section, we address the following challenges: lossless representation of record structure in a columnar format (Section 4.1), fast encoding (Section 4.2), and efficient record assembly (Section 4.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Repetition and Definition Levels</head><p>Values alone do not convey the structure of a record. Given two values of a repeated field, we do not know at what 'level' the value repeated (e.g., whether these values are from two different records, or two repeated values in the same record). Likewise, given a missing optional field, we do not know which enclosing records were defined explicitly. We therefore introduce the concepts of repetition and definition levels, which are defined below. For reference, see <ref type="figure" target="#fig_1">Figure 3</ref> which summarizes the repetition and definition levels for all atomic fields in our sample records.</p><p>Repetition levels. Consider field Code in <ref type="figure">Figure 2</ref>. It occurs three times in r1. Occurrences 'en-us' and 'en' are inside the first Name, while 'en-gb' is in the third Name. To disambiguate these occurrences, we attach a repetition level to each value. It tells us at what repeated field in the field's path the value has repeated. The field path Name.Language.Code contains two repeated fields, Name and Language. Hence, the repetition level of Code ranges between 0 and 2; level 0 denotes the start of a new record. Now suppose we are scanning record r1 top down. When we encounter 'en-us', we have not seen any repeated fields, i.e., the repetition level is 0. When we see 'en', field Language has repeated, so the repetition level is 2. Finally, when we encounter 'en-gb', Name has repeated most recently (Language occurred only once after Name), so the repetition level is 1. Thus, the repetition levels of Code values in r1 are 0, 2, 1.</p><p>Notice that the second Name in r1 does not contain any Code values. To determine that 'en-gb' occurs in the third Name and not in the second, we add a NULL value between 'en' and 'en-gb' (see <ref type="figure" target="#fig_1">Figure 3</ref>). Code is a required field in Language, so the fact that it is missing implies that Language is not defined. In general though, determining the level up to which nested records exist requires extra information.</p><p>Definition levels. Each value of a field with path p, esp. every NULL, has a definition level specifying how many fields in p that could be undefined (because they are optional or repeated) are ac- tually present in the record. To illustrate, observe that r1 has no Backward links. However, field Links is defined (at level 1). To preserve this information, we add a NULL value with definition level 1 to the Links.Backward column. Similarly, the missing occurrence of Name.Language.Country in r2 carries a definition level 1, while its missing occurrences in r1 have definition levels 2 (inside Name.Language) and 1 (inside Name), respectively. We use integer definition levels as opposed to is-null bits so that the data for a leaf field (e.g., Name.Language.Country) contains the information about the occurrences of its parent fields; an example of how this information is used is given in Section 4.3.</p><p>The encoding outlined above preserves the record structure losslessly. We omit the proof for space reasons.</p><p>Encoding. Each column is stored as a set of blocks. Each block contains the repetition and definition levels (henceforth, simply called levels) and compressed field values. NULLs are not stored explicitly as they are determined by the definition levels: any definition level smaller than the number of repeated and optional fields in a field's path denotes a NULL. Definition levels are not stored for values that are always defined. Similarly, repetition levels are stored only if required; for example, definition level 0 implies repetition level 0, so the latter can be omitted. In fact, in <ref type="figure" target="#fig_1">Figure 3</ref>, no levels are stored for DocId. Levels are packed as bit sequences. We only use as many bits as necessary; for example, if the maximum definition level is 3, we use 2 bits per definition level.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Splitting Records into Columns</head><p>Above we presented an encoding of the record structure in a columnar format. The next challenge we address is how to produce column stripes with repetition and definition levels efficiently.</p><p>The base algorithm for computing repetition and definition levels is given in Appendix A. The algorithm recurses into the record structure and computes the levels for each field value. As illustrated earlier, repetition and definition levels may need to be computed even if field values are missing. Many datasets used at Google are sparse; it is not uncommon to have a schema with thousands of fields, only a hundred of which are used in a given record. Hence, we try to process missing fields as cheaply as possible. To produce column stripes, we create a tree of field writers, whose structure matches the field hierarchy in the schema. The basic idea is to update field writers only when they have their own data, and not try to propagate parent state down the tree unless absolutely neces-  : Automaton for assembling records from two fields, and the records it produces sary. To do that, child writers inherit the levels from their parents. A child writer synchronizes to its parent's levels whenever a new value is added.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Record Assembly</head><p>Assembling records from columnar data efficiently is critical for record-oriented data processing tools (e.g., MR). Given a subset of fields, our goal is to reconstruct the original records as if they contained just the selected fields, with all other fields stripped away. The key idea is this: we create a finite state machine (FSM) that reads the field values and levels for each field, and appends the values sequentially to the output records. An FSM state corresponds to a field reader for each selected field. State transitions are labeled with repetition levels. Once a reader fetches a value, we look at the next repetition level to decide what next reader to use. The FSM is traversed from the start to end state once for each record. <ref type="figure" target="#fig_2">Figure 4</ref> shows an FSM that reconstructs the complete records in our running example. The start state is DocId. Once a DocId value is read, the FSM transitions to Links.Backward. After all repeated Backward values have been drained, the FSM jumps to Links.Forward, etc. The details of the record assembly algorithm are in Appendix B.</p><p>To sketch how FSM transitions are constructed, let l be the next repetition level returned by the current field reader for field f . Starting at f in the schema tree, we find its ancestor that repeats at level l and select the first leaf field n inside that ancestor. This gives us an FSM transition (f, l) → n. For example, let l = 1 be the next repetition level read by f = Name.Language.Country. Its ancestor with repetition level 1 is Name, whose first leaf field is n = Name.Url. The details of the FSM construction algorithm are in Appendix C.</p><p>If only a subset of fields need to be retrieved, we construct a simpler FSM that is cheaper to execute. <ref type="figure" target="#fig_3">Figure 5</ref> depicts an FSM for reading the fields DocId and Name.Language.Country. The figure shows the output records s1 and s2 produced by the automaton. Notice that our encoding and the assembly algorithm  To explain what the query does, consider the selection operation (the WHERE clause). Think of a nested record as a labeled tree, where each label corresponds to a field name. The selection operator prunes away the branches of the tree that do not satisfy the specified conditions. Thus, only those nested records are retained where Name.Url is defined and starts with http. Next, consider projection. Each scalar expression in the SELECT clause emits a value at the same level of nesting as the most-repeated input field used in that expression. So, the string concatenation expression emits Str values at the level of Name.Language.Code in the input schema. The COUNT expression illustrates within-record aggregation. The aggregation is done WITHIN each Name subrecord, and emits the number of occurrences of Name.Language.Code for each Name as a non-negative 64-bit integer (uint64).</p><p>The language supports nested subqueries, inter and intra-record aggregation, top-k, joins, user-defined functions, etc; some of these features are exemplified in the experimental section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">QUERY EXECUTION</head><p>We discuss the core ideas in the context of a read-only system, for simplicity. Many Dremel queries are one-pass aggregations; therefore, we focus on explaining those and use them for experiments in the next section. We defer the discussion of joins, indexing, updates, etc. to future work.</p><p>Tree architecture. Dremel uses a multi-level serving tree to execute queries (see <ref type="figure" target="#fig_5">Figure 7)</ref>. A root server receives incoming queries, reads metadata from the tables, and routes the queries to the next level in the serving tree.  When the root server receives the above query, it determines all tablets, i.e., horizontal partitions of the table, that comprise T and rewrites the query as follows:</p><formula xml:id="formula_2">SELECT A, SUM(c) FROM (R 1 1 UNION ALL ... R 1 n ) GROUP BY A Tables R 1 1 , . . . , R 1</formula><p>n are the results of queries sent to the nodes 1, . . . , n at level 1 of the serving tree:</p><formula xml:id="formula_3">R 1 i = SELECT A, COUNT(B) AS c FROM T 1 i GROUP BY A T 1</formula><p>i is a disjoint partition of tablets in T processed by server i at level 1. Each serving level performs a similar rewriting. Ultimately, the queries reach the leaves, which scan the tablets in T in parallel. On the way up, intermediate servers perform a parallel aggregation of partial results. The execution model presented above is well-suited for aggregation queries returning small and mediumsized results, which are a very common class of interactive queries. Large aggregations and other classes of queries may need to rely on execution mechanisms known from parallel DBMSs and MR.</p><p>Query dispatcher. Dremel is a multi-user system, i.e., usually several queries are executed simultaneously. A query dispatcher schedules queries based on their priorities and balances the load. Its other important role is to provide fault tolerance when one server becomes much slower than others or a tablet replica becomes unreachable.</p><p>The amount of data processed in each query is often larger than the number of processing units available for execution, which we call slots. A slot corresponds to an execution thread on a leaf server. For example, a system of 3,000 leaf servers each using 8 threads has 24,000 slots. So, a table spanning 100,000 tablets can be processed by assigning about 5 tablets to each slot. During query execution, the query dispatcher computes a histogram of tablet processing times. If a tablet takes a disproportionately long time to process, it reschedules it on another server. Some tablets may need to be redispatched multiple times.</p><p>The leaf servers read stripes of nested data in columnar representation. The blocks in each stripe are prefetched asynchronously; the read-ahead cache typically achieves hit rates of 95%. Tablets are usually three-way replicated. When a leaf server cannot access one tablet replica, it falls over to another replica.</p><p>The query dispatcher honors a parameter that specifies the minimum percentage of tablets that must be scanned before returning a result. As we demonstrate shortly, setting such parameter to a lower value (e.g., 98% instead of 100%) can often speed up execu-  <ref type="figure">Figure 8</ref>: Datasets used in the experimental study tion significantly, especially when using smaller replication factors. Each server has an internal execution tree, as depicted on the right-hand side of <ref type="figure" target="#fig_5">Figure 7</ref>. The internal tree corresponds to a physical query execution plan, including evaluation of scalar expressions. Optimized, type-specific code is generated for most scalar functions. An execution plan for project-select-aggregate queries consists of a set of iterators that scan input columns in lockstep and emit results of aggregates and scalar functions annotated with the correct repetition and definition levels, bypassing record assembly entirely during query execution. For details, see Appendix D.</p><p>Some Dremel queries, such as top-k and count-distinct, return approximate results using known one-pass algorithms (e.g., <ref type="bibr" target="#b3">[4]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EXPERIMENTS</head><p>In this section we evaluate Dremel's performance on several datasets used at Google, and examine the effectiveness of columnar storage for nested data. The properties of the datasets used in our study are summarized in <ref type="figure">Figure 8</ref>. In uncompressed, nonreplicated form the datasets occupy about a petabyte of space. All tables are three-way replicated, except one two-way replicated table, and contain from 100K to 800K tablets of varying sizes. We start by examining the basic data access characteristics on a single machine, then show how columnar storage benefits MR execution, and finally focus on Dremel's performance. The experiments were conducted on system instances running in two data centers next to many other applications, during regular business operation. Unless specified otherwise, execution times were averaged across five runs. Local disk. In the first experiment, we examine performance tradeoffs of columnar vs. record-oriented storage, scanning a 1GB fragment of table T1 containing about 300K rows (see <ref type="figure" target="#fig_7">Figure 9)</ref>. The data is stored on a local disk and takes about 375MB in compressed columnar representation. The record-oriented format uses heavier compression yet yields about the same size on disk. The experiment was done on a dual-core Intel machine with a disk providing 70MB/s read bandwidth. All reported times are cold; OS cache was flushed prior to each scan.</p><p>The figure shows five graphs, illustrating the time it takes to read and uncompress the data, and assemble and parse the records, for a subset of the fields. Graphs (a)-(c) outline the results for columnar storage. Each data point in these graphs was obtained by averaging the measurements over 30 runs, in each of which a set of columns of a given cardinality was chosen at random. Graph (a) shows reading and decompression time. Graph (b) adds the time needed to assemble nested records from columns. Graph (c) shows how long it takes to parse the records into strongly typed C++ data structures.</p><p>Graphs (d)-(e) depict the time for accessing the data on recordoriented storage. Graph (d) shows reading and decompression time. A bulk of the time is spent in decompression; in fact, the compressed data can be read from the disk in about half the time. As   <ref type="table">Table T1</ref>)</p><p>Graph (e) indicates, parsing adds another 50% on top of reading and decompression time. These costs are paid for all fields, including the ones that are not needed. The main takeaways of this experiment are the following: when few columns are read, the gains of columnar representation are of about an order of magnitude. Retrieval time for columnar nested data grows linearly with the number of fields. Record assembly and parsing are expensive, each potentially doubling the execution time. We observed similar trends on other datasets. A natural question to ask is where the top and bottom graphs cross, i.e., record-wise storage starts outperforming columnar storage. In our experience, the crossover point often lies at dozens of fields but it varies across datasets and depends on whether or not record assembly is required.</p><p>MR and Dremel. Next we illustrate a MR and Dremel execution on columnar vs. record-oriented data. We consider a case where a single field is accessed, i.e., the performance gains are most pronounced. Execution times for multiple columns can be extrapolated using the results of <ref type="figure" target="#fig_7">Figure 9</ref>. In this experiment, we count the average number of terms in a field txtField of table T1. MR execution is done using the following Sawzall <ref type="bibr" target="#b18">[20]</ref>  The number of records is stored in the variable numRecs. For each record, numWords is incremented by the number of terms in input.txtField returned by the CountWords function. After the program runs, the average term frequency can be computed as numWords/numRecs. In SQL, this computation is expressed as: Q1: SELECT SUM(CountWords(txtField)) / COUNT(*) FROM T1 <ref type="figure" target="#fig_0">Figure 10</ref> shows the execution times of two MR jobs and Dremel on a logarithmic scale. Both MR jobs are run on 3000 workers. Similarly, a 3000-node Dremel instance is used to execute Query Q1. Dremel and MR-on-columns read about 0.5TB of compressed columnar data vs. 87TB read by MR-on-records. As the figure illustrates, MR gains an order of magnitude in efficiency by switching from record-oriented to columnar storage (from hours to minutes). Another order of magnitude is achieved by using Dremel (going from minutes to seconds).</p><p>Serving tree topology. In the next experiment, we show the impact of the serving tree depth on query execution times. We consider two GROUP BY queries on <ref type="table">Table T2</ref>, each executed using   <ref type="figure" target="#fig_0">Figure 11</ref> shows the execution times for each query as a function of the server topology. In each topology, the number of leaf servers is kept constant at 2900 so that we can assume the same cumulative scan speed. In the 2-level topology (1:2900), a single root server communicates directly with the leaf servers. For 3 levels, we use a 1:100:2900 setup, i.e., an extra level of 100 intermediate servers.</p><p>The 4-level topology is 1:10:100:2900.</p><p>Query Q2 runs in 3 seconds when 3 levels are used in the serving tree and does not benefit much from an extra level. In contrast, the execution time of Q3 is halved due to increased parallelism. At 2 levels, Q3 is off the chart, as the root server needs to aggregate near-sequentially the results received from thousands of nodes. This experiment illustrates how aggregations returning many groups benefit from multi-level serving trees.</p><p>Per-tablet histograms. To drill deeper into what happens during query execution consider <ref type="figure" target="#fig_0">Figure 12</ref>. The figure shows how fast tablets get processed by the leaf servers for a specific run of Q2 and Q3. The time is measured starting at the point when a tablet got scheduled for execution in an available slot, i.e., excludes the time spent waiting in the job queue. This measurement methodology factors out the effects of other queries that are executing simultaneously. The area under each histogram corresponds to 100%. As the figure indicates, 99% of Q2 (or Q3) tablets are processed under one second (or two seconds).  Within-record aggregation. As another experiment, we examine the performance of Query Q4 run on <ref type="table">Table T3</ref>. Scalability. The following experiment illustrates the scalability of the system on a trillion-record table. Query Q5 shown below selects top-20 aid's and their number of occurrences in <ref type="table">Table T4</ref>. The query scans 4.2TB of compressed data. The query was executed using four configurations of the system, ranging from 1000 to 4000 nodes. The execution times are in <ref type="figure" target="#fig_0">Figure 13</ref>. In each run, the total expended CPU time is nearly identical, at about 300K seconds, whereas the user-perceived time decreases near-linearly with the growing size of the system. This result suggests that a larger system can be just as effective in terms of resource usage as a smaller one, yet allows faster execution.</p><p>Stragglers. Our last experiment shows the impact of stragglers.</p><p>Query Q6 below is run on a trillion-row table T5. In contrast to the other datasets, T5 is two-way replicated. Hence, the likelihood of stragglers slowing the execution is higher since there are fewer opportunities to reschedule the work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Q6: SELECT COUNT(DISTINCT a) FROM T5</head><p>Query Q6 reads over 1TB of compressed data. The compres-   <ref type="figure">Figure</ref> 14, the processing time for 99% of the tablets is below 5 seconds per tablet per slot. However, a small fraction of the tablets take a lot longer, slowing down the query response time from less than a minute to several minutes, when executed on a 2500 node system. The next section summarizes our experimental findings and the lessons we learned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">OBSERVATIONS</head><p>Dremel scans quadrillions of records per month. <ref type="figure" target="#fig_0">Figure 15</ref> shows the query response time distribution in a typical monthly workload of one Dremel system, on a logarithmic scale. As the figure indicates, most queries are processed under 10 seconds, well within the interactive range. Some queries achieve a scan throughput close to 100 billion records per second on a shared cluster, and even higher on dedicated machines. The experimental data presented above suggests the following observations:</p><p>• Scan-based queries can be executed at interactive speeds on disk-resident datasets of up to a trillion records. • Near-linear scalability in the number of columns and servers is achievable for systems containing thousands of nodes. • MR can benefit from columnar storage just like a DBMS.</p><p>• Record assembly and parsing are expensive. Software layers (beyond the query processing layer) need to be optimized to directly consume column-oriented data. • MR and query processing can be used in a complementary fashion; one layer's output can feed another's input. • In a multi-user environment, a larger system can benefit from economies of scale while offering a qualitatively better user experience. • If trading speed against accuracy is acceptable, a query can be terminated much earlier and yet see most of the data. • The bulk of a web-scale dataset can be scanned fast. Getting to the last few percent within tight time bounds is hard.</p><p>Dremel's codebase is dense; it comprises less than 100K lines of C++, Java, and Python code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">RELATED WORK</head><p>The MapReduce (MR) <ref type="bibr" target="#b11">[12]</ref> framework was designed to address the challenges of large-scale computing in the context of long-running batch jobs. Like MR, Dremel provides fault tolerant execution, a flexible data model, and in situ data processing capabilities. The success of MR led to a wide range of third-party implementations (notably open-source Hadoop <ref type="bibr" target="#b14">[15]</ref>), and a number of hybrid systems that combine parallel DBMSs with MR, offered by vendors like Aster, Cloudera, Greenplum, and Vertica. HadoopDB <ref type="bibr" target="#b2">[3]</ref> is a research system in this hybrid category. Recent articles <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b20">22]</ref> contrast MR and parallel DBMSs. Our work emphasizes the complementary nature of both paradigms.</p><p>Dremel is designed to operate at scale. Although it is conceivable that parallel DBMSs can be made to scale to thousands of nodes, we are not aware of any published work or industry reports that attempted that. Neither are we familiar with prior literature studying MR on columnar storage.</p><p>Our columnar representation of nested data builds on ideas that date back several decades: separation of structure from content and transposed representation. A recent review of work on column stores, incl. compression and query processing, can be found in <ref type="bibr" target="#b0">[1]</ref>. Many commercial DBMSs support storage of nested data using XML (e.g., <ref type="bibr" target="#b17">[19]</ref>). XML storage schemes attempt to separate the structure from the content but face more challenges due to the flexibility of the XML data model. One system that uses columnar XML representation is XMill <ref type="bibr" target="#b15">[17]</ref>. XMill is a compression tool. It stores the structure for all fields combined and is not geared for selective retrieval of columns.</p><p>The data model used in Dremel is a variation of the complex value models and nested relational models discussed in <ref type="bibr" target="#b1">[2]</ref>. Dremel's query language builds on the ideas from <ref type="bibr" target="#b8">[9]</ref>, which introduced a language that avoids restructuring when accessing nested data. In contrast, restructuring is usually required in XQuery and object-oriented query languages, e.g., using nested for-loops and constructors. We are not aware of practical implementations of <ref type="bibr" target="#b8">[9]</ref>. A recent SQL-like language operating on nested data is Pig <ref type="bibr" target="#b16">[18]</ref>. Other systems for parallel data processing include Scope <ref type="bibr" target="#b5">[6]</ref> and DryadLINQ <ref type="bibr" target="#b21">[23]</ref>, and are discussed in more detail in <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">CONCLUSIONS</head><p>We presented Dremel, a distributed system for interactive analysis of large datasets. Dremel is a custom, scalable data management solution built from simpler components. It complements the MR paradigm. We discussed its performance on trillion-record, multi-terabyte datasets of real data. We outlined the key aspects of Dremel, including its storage format, query language, and execution. In the future, we plan to cover in more depth such areas as formal algebraic specification, joins, extensibility mechanisms, etc. The algorithm for decomposing a record into columns is shown in <ref type="figure" target="#fig_0">Figure 16</ref>. Procedure DissectRecord is passed an instance of a RecordDecoder, which is used to traverse binary-encoded records.</p><p>FieldWriters form a tree hierarchy isomorphic to that of the input schema. The root FieldWriter is passed to the algorithm for each new record, with repetitionLevel set to 0. The primary job of the DissectRecord procedure is to maintain the current repetitionLevel. The current definitionLevel is uniquely determined by the tree position of the current writer, as the sum of the number of optional and repeated fields in the field's path.</p><p>The while-loop of the algorithm (Line 5) iterates over all atomic and record-valued fields contained in a given record. The set seenFields tracks whether or not a field has been seen in the record. It is used to determine what field has repeated most recently. The child repetition level chRepetitionLevel is set to that of the most recently repeated field or else defaults to its parent's level (Lines 9-13). The procedure is invoked recursively on nested records (Line 18).</p><p>In Section 4.2 we sketched how FieldWriters accumulate levels and propagate them lazily to lower-level writers. This is done as follows: each non-leaf writer keeps a sequence of (repetition, definition) levels. Each writer also has a 'version' number associated with it. Simply stated, a writer version is incremented by one whenever a level is added. It is sufficient for children to remember the last parent's version they synced. If a child writer ever gets its own (non-null) value, it synchronizes its state with the parent by fetching new levels, and only then adds the new data.</p><p>Because input data can have thousands of fields and millions records, it is not feasible to store all levels in memory. Some levels may be temporarily stored in a file on disk. For a lossless encoding of empty (sub)records, non-atomic fields (such as Name.Language in <ref type="figure">Figure 2</ref>) may need to have column stripes of their own, containing only levels but no non-NULL values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. RECORD ASSEMBLY ALGORITHM</head><p>In their on-the-wire representation, records are laid out as pairs of </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>31</head><p>End nested records up to newLevel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>32</head><p>Set lastReader to the one at newLevel.</p><p>33 end procedure <ref type="figure" target="#fig_0">Figure 17</ref>: Algorithm for assembling a record from columns a field identifier followed by a field value. Nested records can be thought of as having an 'opening tag' and a 'closing tag', similar to XML (actual binary encoding may differ, see <ref type="bibr" target="#b19">[21]</ref> for details). In the following, writing opening tags is referred to as 'starting' the record, and writing closing tags is called 'ending' it.</p><p>AssembleRecord procedure takes as input a set of FieldReaders and (implicitly) the FSM with state transitions between the readers. Variable reader holds the current FieldReader in the main routine (Line 4). Variable lastReader holds the last reader whose value we appended to the record and is available to all three procedures shown in <ref type="figure" target="#fig_0">Figure 17</ref>. The main while-loop is at Line 5. We fetch the next value from the current reader. If the value is not NULL, which is determined by looking at its definition level, we synchronize the record being assembled to the record structure of the current reader in the method MoveToLevel, and append the field value to the record. Otherwise, we merely adjust the record structure without appending any value-which needs to be done if empty records are present. On Line 12, we use a 'full definition level'. Recall that the definition level factors out required fields (only repeated and optional fields are counted). Full definition level takes all fields into account.</p><p>Procedure MoveToLevel transitions the record from the state of the lastReader to that of the nextReader (see <ref type="bibr">Line 22)</ref>. For example, suppose the lastReader corresponds to   <ref type="figure" target="#fig_0">Figure 18</ref> shows an algorithm for constructing a finite-state machine that performs record assembly. The algorithm takes as input the fields that should be populated in the records, in the order in which they appear in the schema. The algorithm uses a concept of a 'common repetition level' of two fields, which is the repetition level of their lowest common ancestor. For example, the common repetition level of Links.Backward and Links.Forward equals 1. The second concept is that of a 'barrier', which is the next field in the sequence after the current one. The intuition is that we try to process each field one by one until the barrier is hit and requires a jump to a previously seen field.</p><p>The algorithm consists of three steps. In Step 1 (Lines 6-10), we go through the common repetition levels backwards. These are guaranteed to be non-increasing. For each repetition level we encounter, we pick the left-most field in the sequence-that is the one we need to transition to when that repetition level is returned by a FieldReader. In Step 2, we fill the gaps (Lines <ref type="bibr" target="#b10">[11]</ref><ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>. The gaps arise because not all repetition levels are present in the common repetition levels computed at Line 8. In Step 3 (Lines 15-17), we set transitions for all levels that are equal to or below the barrier level to jump to the barrier field. If a FieldReader produces such a level, we need to continue constructing the nested record and do not need to bounce off the barrier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. SELECT-PROJECT-AGGREGATE</head><p>EVALUATION ALGORITHM <ref type="figure" target="#fig_0">Figure 19</ref> shows the algorithm used for evaluating select-projectaggregate queries in Dremel. The algorithm addresses a general case when a query may reference repeated fields; a simpler optimized version is used for flat-relational queries, i.e., those referencing only required and optional fields. The algorithm has two implicit inputs: a set of FieldReaders, one for each field appearing in the query, and a set of scalar expressions, including aggregate expressions, present in the query. The repetition level of a scalar expression (used in Line 8) is determined as the maximum repetition level of the fields used in that expression. In essence, the algorithm advances the readers in lockstep to the next set of values, and, if the selection conditions are met, emits the projected values. Selection and projection are controlled by two variables, fetchLevel and selectLevel. During execution, only  <ref type="figure" target="#fig_0">Figure 19</ref>: Algorithm for evaluating select-project-aggregate queries over columnar input, bypassing record assembly readers whose next repetition level is no less than fetchLevel are advanced (see Fetch method at <ref type="bibr">Line 19)</ref>. In a similar vein, only expressions whose current repetition level is no less than selectLevel are emitted (Lines 7-10). The algorithm ensures that expressions at a higher-level of nesting, i.e., those having a smaller repetition level, get evaluated and emitted only once for each deeper nested expression.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Record-wise vs. columnar representation of nested data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :</head><label>3</label><figDesc>Column-striped representation of the sample data inFigure 2,showing repetition levels (r) and definition levels (d)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Complete record assembly automaton. Edges are labeled with repetition levels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5</head><label>5</label><figDesc>Figure 5: Automaton for assembling records from two fields, and the records it produces</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>1 SELECT</head><label>1</label><figDesc>DocId AS Id, COUNT(Name.Language.Code) WITHIN Name AS Cnt, Name.Url + ',' + Name.Language.Code AS Str FROM t WHERE REGEXP(Name.Url, '^http') AND DocId &lt; 20;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>System architecture and execution inside a server node with the storage layer or access the data on local disk. Consider a simple aggregation query below:SELECT A, COUNT(B) FROM T GROUP BY A</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 :</head><label>9</label><figDesc>Performance breakdown when reading from a local disk (300K-record fragment of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>MR and Dremel execution on columnar vs. recordoriented storage (3000 nodes, 85 billion records) Execution time as a function of serving tree levels for two aggregation queries on T2 a single scan over the data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Histograms of processing times</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 :</head><label>13</label><figDesc>Scaling the system from 1000 to 4000 nodes using a top-k query Q5 on a trillion-row table T4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>The query illustrates within-record aggregation: it counts all records where the sum of a.b.c.d values occurring in the record are larger than the sum of a.b.p.q.r values. The fields repeat at different levels of nesting. Due to column striping only 13GB (out of 70TB) are read from disk and the query completes in 15 seconds. Without support for nesting, running this query on T3 would be grossly expensive. Q4 : SELECT COUNT(c1 &gt; c2) FROM (SELECT SUM(a.b.c.d) WITHIN RECORD AS c1, SUM(a.b.p.q.r) WITHIN RECORD AS c2 FROM T3)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Q5:</head><label></label><figDesc>SELECT TOP(aid, 20), COUNT(*) FROM T4 WHERE bid = {value1} AND cid = {value2}</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 14 :</head><label>14</label><figDesc>Query Q5 on T5 illustrating stragglers at 2× replication</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 15 :</head><label>15</label><figDesc>Query response time distribution in a monthly workload sion ratio for the retrieved field is about 10. As indicated in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>3 5 while decoder has more field values 6 FieldWriter chWriter = 7 child of writer for field read by decoder 8 int chRepetitionLevel = repetitionLevel 9 if 10 chRepetitionLevel = tree depth of chWriter 11 else 12 Add field ID of chWriter to seenFields 13 end if 14 if chWriter corresponds to an atomic field 15 Write value of current field read by decoder 16 using chWriter at chRepetitionLevel 17 else 18 DissectRecordFigure 16 :</head><label>3567910121415161816</label><figDesc>Add current repetitionLevel and definition level to writer 4 seenFields = {} // empty set of integers set seenFields contains field ID of chWriter Algorithm for dissecting a record into columns APPENDIX A. COLUMN-STRIPING ALGORITHM</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>1 2 record = create a new record 3 lastReader = select the root field reader in readers 4 reader = readers[0] 5 while reader has data 6 Fetch next value from reader 7 if 9 Append reader's value to record 10 else 11 MoveToLevel 23</head><label>23456791123</label><figDesc>Record AssembleRecord(FieldReaders[] readers): current value is not NULL 8 MoveToLevel(tree level of reader, reader) (full definition level of reader, reader) End nested records up to the level of the lowest common ancestor 24 of lastReader and nextReader. 25 Start nested records from the level of the lowest common ancestor 26 up to newLevel. 27 Set lastReader to the one at newLevel. 28 end procedure 29 30 ReturnToLevel(int newLevel) {</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head></head><label></label><figDesc>Links.Backward in Figure 2 and nextReader is Name.Language.Code. The method ends the nested record Links and starts new records Name and Language, in that order. Procedure ReturnsToLevel (Line 30) is a counterpart of MoveToLevel that only ends current records without starting any new ones.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>1 3 maxLevel = maximal repetition level of field 4 barrier= 5 barrierLevel = common repetition level of field and barrier 6 for each preField before field whose 7 repetition level is larger than barrierLevel: 8 backLevel = common repetition level of preField and field 9 SetFigure 18 :</head><label>345678918</label><figDesc>procedure ConstructFSM(Field[] fields): 2 for each field in fields: next field after field or final FSM state otherwise Algorithm to construct a record assembly automaton C. FSM CONSTRUCTION ALGORITHM</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>6 if 9 Emit</head><label>69</label><figDesc>WHERE clause evaluates to true: 7 for each expression in SELECT clause: 8 if (repetition level of expression) &gt;= selectLevel: in field reader set: 22 if (next repetition level of reader) &gt;= fetchLevel: 23 Advance reader to the next value 24 endif 25 nextLevel = max(nextLevel, next repetition level of reader)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>r 1 message Document { required int64 DocId; optional group Links { repeated int64 Backward; repeated int64 Forward; } repeated group Name { repeated group Language { required string Code; optional string Country; } optional string Url; }} DocId: 20 Links Backward</head><label></label><figDesc></figDesc><table><row><cell>r 2</cell></row><row><cell>: 10</cell></row><row><cell>Backward: 30</cell></row><row><cell>Forward: 80</cell></row><row><cell>Name</cell></row><row><cell>Url: 'http://C'</cell></row><row><cell>Figure 2: Two sample nested records and their schema</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Figure 6: Sample query, its result, and output schema preserve the enclosing structure of the field Country. This is important for applications that need to access, e.g., the Country appearing in the first Language of the second Name.Dremel's query language is based on SQL and is designed to be efficiently implementable on columnar nested storage. Defining the language formally is out of scope of this paper; instead, we illustrate its flavor. Each SQL statement (and algebraic operators it translates to) takes as input one or multiple nested tables and their schemas and produces a nested table and its output schema.Figure 6depicts a sample query that performs projection, selection, and within-record aggregation. The query is evaluated over the table t = {r1, r2} fromFigure 2. The fields are referenced using path expressions. The query produces a nested result although no record constructors are present in the query.</figDesc><table><row><cell>In XPath,</cell></row><row><cell>this would correspond to the ability to evaluate expressions like</cell></row><row><cell>/Name[2]/Language[1]/Country.</cell></row><row><cell>5. QUERY LANGUAGE</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>The leaf servers communicate</figDesc><table><row><cell></cell><cell>client</cell><cell cols="2">query execution tree</cell></row><row><cell>root server</cell><cell></cell><cell></cell><cell></cell></row><row><cell>intermediate servers</cell><cell>. . .</cell><cell></cell><cell>. . .</cell></row><row><cell>leaf servers</cell><cell>. . .</cell><cell>. . .</cell><cell>. . .</cell></row><row><cell>(with local</cell><cell>. . .</cell><cell></cell><cell></cell></row><row><cell>storage)</cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">storage layer (e.g., GFS)</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table name Number of records Size (unrepl., compressed) Number of fields Data center Repl. factor</head><label></label><figDesc></figDesc><table><row><cell>T1</cell><cell>85 billion</cell><cell>87 TB</cell><cell>270</cell><cell>A</cell><cell>3×</cell></row><row><cell>T2</cell><cell>24 billion</cell><cell>13 TB</cell><cell>530</cell><cell>A</cell><cell>3×</cell></row><row><cell>T3</cell><cell>4 billion</cell><cell>70 TB</cell><cell>1200</cell><cell>A</cell><cell>3×</cell></row><row><cell>T4</cell><cell>1+ trillion</cell><cell>105 TB</cell><cell></cell><cell>B</cell><cell>3×</cell></row><row><cell>T5</cell><cell>1+ trillion</cell><cell>20 TB</cell><cell>30</cell><cell>B</cell><cell>2×</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table and</head><label>and</label><figDesc>field names used below are anonymized.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table</head><label></label><figDesc>T2 contains 24 billion nested records. Each record has a repeated field item containing a numeric amount. The field item.amount repeats about 40 billion times in the dataset. The first query sums up the item amount by country:Q2: SELECT country, SUM(item.amount) FROM T2 GROUP BY countryIt returns a few hundred records and reads roughly 60GB of compressed data from disk. The second query performs a GROUP BY on a text field domain with a selection condition. It reads about 180GB and produces around 1.1 million distinct domains:</figDesc><table><row><cell>Q3: SELECT domain, SUM(item.amount) FROM T2</cell></row><row><cell>WHERE domain CONTAINS '.net'</cell></row><row><cell>GROUP BY domain</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11.">ACKNOWLEDGEMENTS</head><p>Dremel has benefited greatly from the input of many engineers and interns at Google, in particular Craig Chambers </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Column-Oriented Database Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">A</forename><surname>Boncz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Harizopoulos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">VLDB</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Foundations of Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abiteboul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Hull</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vianu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Addison Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">HadoopDB: An Architectural Hybrid of MapReduce and DBMS Technologies for Analytical Workloads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Abouzeid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bajda-Pawlikowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rasin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Silberschatz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>VLDB</publisher>
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Counting Distinct Elements in a Data Stream</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Bar-Yossef</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Jayram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Sivakumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Trevisan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RANDOM</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The Datacenter as a Computer: An Introduction to the Design of Warehouse-Scale Machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Hölzle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Morgan &amp; Claypool Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Chaiken</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Jenkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-A</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ramsey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shakib</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Weaver</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhou</surname></persName>
		</author>
		<title level="m">SCOPE: Easy and Efficient Parallel Processing of Massive Data Sets. VLDB</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">FlumeJava: Easy, Efficient Data-Parallel Pipelines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Raniwala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Perry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Adams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Henry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bradshaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Weizenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">PLDI</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Bigtable: A Distributed Storage System for Structured Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">C</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Wallach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chandra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gruber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Recursive Algebra and Query Optimization for Nested Relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">S</forename><surname>Colby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGMOD Rec</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Sorting 1PB with MapReduce. Official Google Blog</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Czajkowski</surname></persName>
		</author>
		<ptr target="http://googleblog.blogspot.com/2008/11/sorting-1pb-with-mapreduce.html" />
		<imprint>
			<date type="published" when="2008-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Challenges in Building Large-Scale Information Retrieval Systems: Invited Talk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WSDM</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">MapReduce: Simplified Data Processing on Large Clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">MapReduce: a Flexible Data Processing Tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The Google File System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Gobioff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S.-T</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOSP</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<ptr target="http://hadoop.apache.org" />
		<title level="m">Hadoop Apache Project</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">XMill: An Efficient Compressor for XML Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Liefke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Pig Latin: a Not-so-Foreign Language for Data Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Olston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tomkins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">ORDPATHs: Insert-Friendly XML Node Labels</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>O'neil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>O'neil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Cseri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schaller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Westbury</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD</title>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Interpreting the Data: Parallel Analysis with Sawzall</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Pike</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dorward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Griesemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Quinlan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Scientific Programming</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<ptr target="http://code.google.com/apis/protocolbuffers/docs/overview.html" />
		<title level="m">Protocol Buffers: Developer Guide. Available at</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">MapReduce and Parallel DBMSs: Friends or Foes?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stonebraker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Dewitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Paulson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pavlo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rasin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">DryadLINQ: A System for General-Purpose Distributed Data-Parallel Computing Using a High-Level Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Fetterly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Budiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ú</forename><surname>Erlingsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Gunda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Currey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
