<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Darwinian Data Structure Selection</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michail</forename><surname>Basios</surname></persName>
							<email>michail.basios@cs.ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lingbo</forename><surname>Li</surname></persName>
							<email>lingbo.li@cs.ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fan</forename><surname>Wu</surname></persName>
							<email>fan.wu@cs.ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leslie</forename><surname>Kanthan</surname></persName>
							<email>l.kanthan@cs.ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Earl</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
							<email>e.barr@cs.ucl.ac.uk</email>
							<affiliation key="aff0">
								<orgName type="institution">University College London</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Darwinian Data Structure Selection</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3236024.3236043</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Search-based Software Engineering</term>
					<term>Genetic Improvement</term>
					<term>Software Analysis and Optimisation</term>
					<term>Data Structure Optimisation</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Data structure selection and tuning is laborious but can vastly improve an application&apos;s performance and memory footprint. Some data structures share a common interface and enjoy multiple implementations. We call them Darwinian Data Structures (DDS), since we can subject their implementations to survival of the fittest. We introduce artemis a multi-objective, cloud-based search-based optimisation framework that automatically finds optimal, tuned DDS modulo a test suite, then changes an application to use that DDS. artemis achieves substantial performance improvements for every project in 5 Java projects from DaCapo benchmark, popular projects and 30 uniformly sampled projects from GitHub. For execution time, CPU usage, and memory consumption, artemis finds at least one solution that improves all measures for 86% (37/43) of the projects. The median improvement across the best solutions is 4.8%, 10.1%, 5.1% for runtime, memory and CPU usage. These aggregate results understate artemis&apos;s potential impact. Some of the benchmarks it improves are libraries or utility functions. Two examples are gson, a ubiquitous Java serialization framework, and xalan, Apache&apos;s XML transformation tool. artemis improves gson by 16.5%, 1% and 2.2% for memory, runtime, and CPU; artemis improves xalan&apos;s memory consumption by 23.5%. Every client of these projects will benefit from these performance improvements.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>"Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. "</p><p>-Donald E. Knuth <ref type="bibr" target="#b23">[24]</ref> 1 INTRODUCTION</p><p>Under the immense time pressures of industrial software development, developers are heeding one part of Knuth's advice: they are avoiding premature optimisation. Indeed, developers appear to be avoiding optimisation altogether and neglecting the "critical 3%". When selecting data structures from libraries, in particular, they tend to rely on defaults and neglect potential optimisations that alternative implementations or tuning parameters can offer. This, despite the impact that data structure selection and tuning can have on application performance and defects. Consider three examples. Selecting an implementation that creates unnecessary temporary objects for the program's workload <ref type="bibr" target="#b45">[46]</ref>. Selecting a combination of Scala data structures that scaled better, reducing execution time from 45 to 1.5 minutes <ref type="bibr" target="#b35">[36]</ref>. Avoiding the use of poor implementation, such as those in the Oracle bug database that leak memory <ref type="bibr" target="#b47">[48]</ref>. Optimisation is time-consuming, especially on large code bases. It is also brittle. An optimisation for one version of a program can break or become a de-optimisation in the next release. Another reason developers may avoid optimisation are development fads that focus on fast solutions, like "Premature Optimisation is the horror of all Evil" and "Hack until it works" <ref type="bibr" target="#b17">[18]</ref>. In short, optimisation is expensive and its benefits unclear for many projects. Developers need automated help.</p><p>Data structures are a particularly attractive optimisation target because they have a well-defined interface; many are tunable; and different implementations of a data structure usually represent a particular trade-off between time and storage, making some operations faster but more space-consuming or slower but more space-efficient. For instance, an ordered list makes retrieving the entire dataset in sorted order fast, but inserting new elements slow, whilst a hash table allows for quick insertions and retrievals of specific items, but listing the entire set in order is slow. We introduce Darwinian data structures, distinct data structures that are interchangeable because they share an abstract data type and can be tuned. The Darwinian data structure optimisation problem is the problem of finding an optimal implementation and tuning for a Darwinian data structure used in an input program.</p><p>We aim to help developers perform optimisation cheaply, focusing solving the data structure optimisation problem. We present artemis, a cloud-based optimisation framework that identifies Darwinian data structures and, given a test suite, automatically searches arXiv:1706.03232v3 [cs.SE] 1 Aug 2018 for optimal combinations of implementations and parameters for them. artemis is language-agnostic; we have instantiated it for Java and C++, and present optimisation results for both languages (Section 5). artemis' search is multi-objective, seeking to simultaneously improve a program's execution time, memory usage, and CPU usage while passing all the test suites. artemis scales to large code bases because is uses a Genetic algorithm on those regions of its search space with the most solutions (Section 4.4). artemis is the first technique to apply multi-objective optimisation to the Darwinian data structure selection and tuning problem.</p><p>artemis promises to change the economics of data structure optimisation. Given a set of Darwinian data structures, artemis can search for optimal solutions in the background on the cloud, freeing developers to focus on new features. artemis makes economical small optimizations, such as a few percent, that would not pay for the developer time spent realizing them. And sometimes, of course, artemis, by virtue of being used, will find unexpectedly big performance gains.</p><p>artemis is a source-to-source transformer. When artemis finds a solution, the program variants it produces differ from the original program only at constructor calls and relevant type annotations. Thus, artemis' variants are amenable, by design, to programmer inspection and do not increase technical debt <ref type="bibr" target="#b6">[7]</ref>. To ease inspection, artemis generates a diff for each changes it makes. Developers can inspect these diffs and decide which to keep and which to reject.</p><p>We report results on 8 popular diverse GitHub projects, on Da-Capo benchmark which was constructed to be representative, and a corpus of 30 GitHub projects, filtered to meet artemis's constraints and sampled uniformly at random. In this study, artemis achieves substantial performance improvements for all projects in its corpus. In terms of execution time, CPU usage, and memory consumption, artemis finds at least one solution for 37 out of 43 projects that improves all measures. Across all produced optimal solutions, the median improvement for execution time is 4.8%, memory consumption 10.1% and CPU usage 5.1%. This result is for various corpora, but it is highly likely to generalise to arbitrary programs because of the care we took to build a representative corpus (Section 5.1).</p><p>These aggregate results understate artemis's potential impact. Some of our benchmarks are libraries or utilities. All of their clients will enjoy any improvements artemis finds for them. Three examples are the Apache project's powerful XSLT processor xalan, Google-http-java-client, the unbiquitious Java library for accessing web resources, and Google's in-memory file system Jimfs. Section 5 shows that artemis improved xalan's memory consumption by 23.5%, while leaving its execution time unchanged; artemis improved Google-http-java-client's execution time by 46% and its CPU usage by 39.6%; finally, artemis improved Jimfs's execution time by 14.2% and its CPU usage by 10.7%, while leaving its memory consumption unchanged.</p><p>Our principal contributions follow:</p><p>• We formalise the Darwinian data structure selection and optimisation problem DS 2 (Section 3). • We implement artemis, a multi-language optimisation framework that automatically discovers and optimises sub-optimal data structures and their parameters. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">}</head><p>Listing 1: A function from http-java-client.</p><p>• We show the generalizability and effectiveness of artemis by conducting a large empirical study on a corpus comprising 8 popular GitHub project, 5 projects from the DaCapo benchmark, and 30 Github projects, filtered then sampled uniformly. For all 43 subjects, artemis find variants that outperforms the original for all three objectives. • We provide artemis as a service, along with its code and evaluation artifacts at http://darwinianoptimiser.com.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MOTIVATING EXAMPLE</head><p>Listing 1 contains a code snippet from google-http-java-client 1 , a popular Java library for accessing efficiently resources on the web. In the Listing 1, getAsList packages HTTP headers and is invoked frequently from other methods because they use it every time they construct an HTTP request. Thus, its functionality is important for the performance of google-http-java-client. Listing 1 uses ArrayList to instantiate the result variable. However, other List implementations share the same functionality but different non-functional properties. Thus, replacing ArrayList with other List implementations may affect the performance of the program. Considering the variant created when replacing ArrayList (Listing 1, line 4) with LinkedList, when we compare it with the original program against the same test set for 30 runs (Section 4), we see that the google-http-java-client achieves a median 46%, with 95% Confidence Interval <ref type="bibr">[45.6%, 46</ref>.3%] improvement in execution time (Section 5).</p><p>artemis, our optimization framework, automatically discovers underperforming data structures and replaces them with better choices using search-based techniques (Section 4.4). First, it automatically creates a store of data structures from the language's Collection api library (Section 4.1). Then, artemis traverses the program's ast to identify which of those data structures are used and exposes them as parameters to the artemis's optimizer (Section 4.4) by transforming line 4 into</p><formula xml:id="formula_0">List&lt;T&gt; result = new D&lt;T&gt;();</formula><p>where D is the tag that refers to the exposed parameter associated with the defined data structure type (Section 4).</p><p>Listing 1 does not specify the initial capacity size of the ArrayList, so the default size 10 was used. If the instantiated List object contains less than 10 items, the default capacity can result in memory bloat. If the List object contains more than 10 items, the default capacity can slow the execution time; more memory realllocation operations will happen. Therefore, an appropriate value must be chosen to find a good tradeoff between memory and execution time.</p><p>https://github.com/google/google-http-java-client artemis automatically exposes such arguments as tunable parameters, then adjusts them to improve the runtime performance of the program. For instance, artemis changes line 4 to the code below:</p><formula xml:id="formula_1">List&lt;T&gt; l = new ArrayList&lt;&gt;(S);</formula><p>where S refers to the exposed parameter associated with the amount of pre-allocated memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DARWINIAN DATA STRUCTURE SELECTION AND TUNING</head><p>This section defines the Darwinian data structure and parameter optimisation problem we solve in this paper.</p><p>Definition 1 (Abstract Data Type). An Abstract Data Type (ADT) is class of objects whose logical behavior is defined by a set of values and a set of operations <ref type="bibr" target="#b9">[10]</ref>.</p><p>A data structure concretely implements an ADT. For the corpus of programs C and the ADT a, the data structure extraction function dse(a, C) returns all data structures that implement a in C. This function is integral to the definition that follows. In words, Darwinian data structures are darwinian in the sense that they can be replaced to produce program mutants whose fitness we can evaluate. The ADT a has Darwinian data structures when it has more than one data structure that are equivalent over the operations the ADT defines. In Java, List is an ADT and ArrayList, which implements it, is a data structure. LinkedList also implements List, so both ArrayList and LinkedList are Darwinian. For the ADT a and the corpus C, Darwinian data structures are interchangeable. Thus, we can search the variants of P ∈ C formed by substituting one Darwinian data structure for another to improve P's nonfunctional properties, like execution time, memory consumption or CPU usage.</p><p>Just as we needed a function to extract an ADT's data structures from a corpus for Definition 2, we need a function that returns the ADT that a data structure implements: when d = dse(a, C), let adte(d, C) = a. Let Γ D bind fully scope-qualified declarations of names to Darwinian data structures in C. We use Γ D when creating variants of a program via substitution. We are interested not just searching the space of Darwinian data structures, but also tuning them via their constructor parameters. To this end, we assume without loss of generality that a defines a single constructor c and we let n.c(x) denote calling identifier n's constructor c with parameters x : τ .</p><p>To create a variant of P ∈ C that differs from P only in its k bindings of names to Darwinian data structures or their constructor initialization parameter, we define ϕ(P, (n, </p><formula xml:id="formula_2">d i ) k , d k j , x j ) = P[(n.c(x i )) k /(n.c(x j )) k ], if ∃d i , d j s.t. adte(d i ) adte(d j ) P[(n, d i ) k /(n, d j ) k ][(n.c(x i )) k /(n.c(x j )) k ],</formula><formula xml:id="formula_3">arg max (n i ,d i ) k ∈Γ k D ,d k j ∈adte(d i ,C) k ,x j ∈τ f (ϕ(P, (n i , d i ), d j , x j ))</formula><p>This vector-based definition simultaneously considers all possible rebinding of names to Darwinian data structures in P; it is also cumbersome, compared to its point-substitution analogue. We could not, however, simply present a scalar definition and then quantify over all potential DDSS substitutions, as doing so would not surface synergies and antagonisms among the substitutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ARTEMIS</head><p>The artemis's optimisation framework solves the Darwinian Data Structure Selection problem. <ref type="figure" target="#fig_2">Figure 1</ref> illustrates the architecture with its three main components: the darwinian data structures store generator (ddssg), the extractor, and the optimiser. artemis takes the language's Collection api library, the user's application source code and a test suite as input to generate an optimised version of the code with a new combination of data structures. The ddssg builds a store that contains data structure transformation rules. The extractor uses this store to discover potential data structure transformations and exposes them as tunable parameters to the optimiser (see Section 4.2). The optimiser uses a multi-objective genetic search algorithm (NSGA-II <ref type="bibr" target="#b12">[13]</ref>) to tune the parameters <ref type="bibr">[25-27, 44, 45]</ref> and to provide optimised solutions (see Section 4.4). A regression test suite is used to maintain the correctness of the transformations and to evaluate the non-functional properties of interest. artemis uses a built-in profiler that measures execution time, memory and CPU usage.</p><p>artemis relies on testing to define a performance search space and to preserve semantics. artemis therefore can only be applied to programs with a test suite. Ideally, this test suite would comprise both a regression test suite with high code coverage for maintaining the correctness of the program and a performance test suite to simulate the real-life behaviour of the program and ensure that all of the common features are covered <ref type="bibr" target="#b3">[4]</ref>. Even though performance test suites are a more appropriate and logical choice for evaluating the non-functional properties of the program, most real world programs in GitHub do not provide such performance test suite. For this reason, we use the regression test suites to evaluate the non-functional properties of the GitHub projects of this study whenever a performance test suite is not available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Darwinian Data Structure Store</head><p>artemis needs a Darwinian data structure store (ddss) from which to choose when creating variants. Let A be a set of ADTs known to be Darwinian. A developer can augment this set; <ref type="figure" target="#fig_0">Figure 2</ref> shows those that artemis knows by default. For our corpus C of Java benchmarks augmented with JDK libraries over A,</p><formula xml:id="formula_4">DDSS = a ∈A dse(a, C).<label>(1)</label></formula><p>To build the default ddss for Java, artemis extracts and traverses each project's class hierarchy, similar to the one illustrated in <ref type="figure" target="#fig_0">Figure 2</ref>. This hierarchy shows potential Darwinian data structures of a specific interface. When this traversal finishes, artemis extracts all the implementations of a particular Darwinian data    structure; e.g., List, ArrayList, LinkedList. artemis considers these implementations mutually replaceable. For Java, a default ddss is provided by artemis, which the developer can edit. For other languages, the ddss can be provided manually by the user and this step can be skipped. The optimiser, described next, uses the store during its search. The developer can also extend the store with custom user-supplied implementations or with implementations from other third-party libraries such as Google Guava Collections 2 , fastutil <ref type="bibr" target="#b2">3</ref> and Apache Commons Collections 4 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Discovering Darwinian Data Structures</head><p>The extractor takes as input the program P's source code, identifies Darwinian data structures in P modulo its store (Section 4.1),</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Code Transformations</head><p>When implementing artemis, we encountered coding practices that vastly increase the search space. Many turn out to be known bad practices <ref type="bibr" target="#b42">[43]</ref>. Consider Listing 2. In lines 2 and 8, we see two LinkedList variables that the Extractor marks darwinian and candidates for replacement by their equivalent ArrayList implementation. In these lines, user is violating the precept to "program to the interface", here List, but is, instead, declaring the variable to have the concrete, data structure not ADT, type LinkedList. This bad practice <ref type="bibr" target="#b42">[43]</ref> adds dependencies to the code, limiting code reuse. They are especially problematic for artemis, because they force artemis to apply multiple transformations to replace and optimise the data structure. Further, func3 takes a LinkedList as a parameter, not List, despite the fact that it only calls the get method defined by List on this parameter. This instance of violating the "program to the interface" precept triggers a compilation error if artemis naïvely changes func1's type. artemis transforms the code to reduce the optimiser's search space and handle these bad practices. artemis supports thee transformations -parserless, supertype, and profiler. The parserless mode changes greadily each appearance of a Darwinian implementation. When optimising List, it exhaustively tries every implementation of List for every List variable. It is parserless, since it needs only a regular expression to identify rewritings. This makes it simple, easily portable to other languages, and fast, so it is artemis' default. However, it generates invalid programs and a large search space.</p><formula xml:id="formula_5">1 void func1(){ 2 LinkedList&lt;T&gt; v; 3 v = new LinkedList&lt;&gt;(); 4 v.add(new T()); 5 int value = func3(v); 6 } 7 void func2(LinkedList&lt;T&gt; v</formula><p>artemis' sypertype transformation converts the type of a Darwinian implementation to that of their Darwinian ADT, for example LinkedList&lt;T&gt; → List&lt;T&gt; on lines, 2,7,8 and 11. For Listing 2, this tranformation exposes only two DDS to the optimiser and produces only syntactically valid code. To implement this transformation, artemis invokes Eclipse's re-factoring functionality via its API, then validates the result. artemis aims to be languageagnostic without any additional dependencies on language specific tools. For this case, artemis auto performs this transformation by adding the supertype as an equivalent parameter in the store of data structures. Whenever the ast visitor traverses a variable or parameter declaration expression it may replace the darwinian data structure with its supertype.</p><p>"All data structures are equal, but some data structures are more equal than others" <ref type="bibr" target="#b4">5</ref> ; some DDS affect a program's performance more than others, as when one stores only a few, rarely accessed items. To rank DDS, artemis profiles its input program to identify costly methods. The extractor uses this info to identify the subset of a program's DDS worth considering for optimisation. artemis' instrumentation is particularly important for large programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Search Based Parameter Tuning</head><p>The optimiser searches a combination of data structures that improves the performance of the initial program while keeps the original functionality. Practically, we can represent all those data structures as parameters that can be tuned using Search Based Software Engineering approaches <ref type="bibr" target="#b18">[19]</ref>. Because of the nature of the various conflicting performance objectives, the problem we faced here requires a multi-objective optimisation approach to search the (near) optimal solutions.</p><p>An array of integers is used to represent the tuning parameters. Each parameter refers either to a Darwinian data structure or to the initial size of that data structure. If the parameter refers to a data structure, its value represents the index in the list of Darwinian data structures. The optimiser keeps additional mapping information to distinguish the types of the parameters. For each generation, the NSGA-II applies tournament selection, followed by a uniform crossover and a uniform mutation operation. In our experiments, we designed fitness functions to capture execution time, memory consumption, and CPU usage. After fitness evaluation, artemis applies standard non-dominated selection to form the next generation. artemis repeats this process until the solutions in a generation converge. At this point, artemis returns all non-dominated solutions in the final population.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Search Space size:</head><p>We used GA because the search space is huge. Let D be the definitions of darwinian data structures in program P. Let I be the number of implementations for a particular d ∈ D. The size of the search space is:</p><formula xml:id="formula_6">d ∈D I (d) * |dom(d.c)|, where d.c is d's constructor.<label>(2)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Deployability</head><p>artemis provides optimisation as a cloud service. To use the service, developers only need to provide the source code of their project in a Maven build format and a performance test suite invoked by mvn test. artemis returns the optimised source code and a performance report. artemis exposes a RESTful API that developers can use to edit the default store of Darwinian data structures. The API also allows developers to select other Search Based algorithms; the optimiser uses NSGA-II by default. To use our tool from the command line, a simple command is used:</p><p>./artemis input−program−src where this command defaults to artemis's built in ddssg. artemis writes the source of an optimized variant of its input for each measure. artemis also supports optional parameters to customise its processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EVALUATION</head><p>To demonstrate the performance improvements that artemis automatically achieves and its broad applicability, we applied it to three corpora: 8 popular GitHub projects, 5 projects from the Dacapo Benchmark, and 30 projects, filtered to meet artemis's requirements, then sampled uniformly at random from Github. To show also that artemisis language-agnostic, we applied it to optimise Guetzli 6 (Section 5.3), a JPEG encoder written in C++.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Corpus</head><p>artemis requires projects with capable build systems and an extensive test suites. These two requirements entail that artemis be able to build and run the project against its test suite. artemis is https://github.com/google/guetzli language-agnostic but is currently only instantiated for Java and C++, so it requires Java or C++ programs. Our first corpus comprises eight popular GitHub projects. We selected these eight to have good test suites and be diverse. We defined popular to be projects that received at least 200 stars on GitHub. We deemed a test suite to be good if its line coverage met or exceeded 70%. This corpus contains projects, usually well-written, optimised and peer code-reviewed by experienced developers. We applied artemis on those projects to investigate whether it can provide a better combination of data structures than those selected by experienced human developers.</p><p>This first corpus might not be representative, precisely because of the popularity of its benchmarks. To address this threat to validity, we turned to the DaCapo benchmarks <ref type="bibr" target="#b4">[5]</ref>. The authors of DaCapo built it, from the ground up, to be representative. The goal was to provide the research community with realistic, large scale Java benchmarks that contain a good methodology for Java evaluation. Dacapo contains 14 open source, client-side Java benchmarks (version 9.12) and they come with built-in extensive evaluation. Each benchmark provides accurate measurements for execution time and memory consumption. DaCapo first appeared in 2006 to work with Java v.1.5 and has not been further updated to work with newer versions of Java. For this reason, we faced difficulties in compiling all the benchmarks and the total number of benchmarks were reduced to 5 out of 14. In this corpus we use the following five: fop, avrora, xalan, pmd and sunflow <ref type="figure" target="#fig_7">(Figure 4</ref>).</p><p>Because of its age and the fact that we are only using subset of it, our DaCapo benchmark may not be representative. To counter this threat, we uniformly sampled projects from GitHub. We discarded those that did not meet artemis's constraints, like being equipped with a build system, until we collected 30 projects. Those projects are diverse, both in domain and size. The selected projects include static analysers, testing frameworks, web clients, and graph processing applications. Their sizes vary from 576 to 94K lines of code with a median of 14881. Their popularity varies from 0 to 5642 stars with a median of 52 stars per project. The median number of tests is 170 and median line coverage ratio is 72%.</p><p>Collectively, we systematically built these corpora to be representative in order to demontrate the general applicably of the artemis' optimization framework. The full list of the programs used in this experimental study are available online in the project's website.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experimental Setup</head><p>Experiments were conducted using Microsoft Azure TM D4-v2 machines with one Intel E5-2673v3 CPU featuring 8 cores and 14GB of DRAM and built with Oracle JDK 1.8.0 and Ubuntu 16.04.4 LTS.</p><p>Performance measurements may lead to incorrect results if not handled carefully <ref type="bibr" target="#b0">[1]</ref>. Thus, a statistical rigorous performance evaluation is required <ref type="bibr" target="#b15">[16,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b27">28]</ref>. To mitigate instability and incorrect results, we differentiate VM start-up and steady-state. We ran our experiments in a fresh Azure VM that contained only the JVM and the subject. We use JUnit, which runs an entire test suite in a single JVM. We manually identified and dropped startup runs, then we spot-checked the results to confirm that the rest of the runs achieved a steady state and were exhibiting low variance. All https://darwinianoptimiser.com/corpus of the means and medians we reported fall within the computed interval with 95% confidence. To assure the accuracy and reduce the bias in the measurement, program profiling period was set as 0.1 seconds, and each generated solution was run for more than simulations. Also we use Mann Whitney U test <ref type="bibr" target="#b14">[15]</ref> to examine if the improvement is statistically significant.</p><p>To measure the memory consumption and CPU usage of a subject program, we use the popular JConsole profiler because it directly handles jdk statistics and provides elegant api. We extended JConsole to monitor only those system processes belonging to the test suite. We use Maven Surefire plugin to measure the test suite's execution time because it reports only the execution time of each individual test, excluding the measurement overhead that other Maven plugins may introduce.</p><p>For the optimiser, we chose an initial population size of and a maximum number of 900 function evaluations. We used the tournament selection (based on ranking and crowding distance), simulated binary crossover (with crossover probability 0.8) and polynomial mutation (with the mutation probability 0.1). We determined these settings from calibration trials to ensure the maturity of the results. Since NSGA-II is stochastic, we ran each experiment 30 times to obtain statistical significant results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Research Questions and Results Analysis</head><p>artemis aims to improve all objectives at the same time. Therefore the first research question we would like to answer is:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ1: What proportion of programs does artemis improve?</head><p>To answer RQ1, we applied artemis to our corpus. We inspected the generated optimal solutions from 30 runs of each subject by examining the dominate relation between the optimal and inital solutions regarding the optimisation objectives. We introduce the terms strictly dominate relation and non-dominated relation to describe the relation. Defined by Zitzler et al. <ref type="bibr" target="#b48">[49]</ref>, a solution strictly dominates another solution if it outperforms the latter in all measures. A solution is non-dominated with another solution if both outperform the other in at least one of the measures.</p><p>For DaCapo, artemis found at least one strictly dominant solution for 4 out of 5 projects; it found no such solution for sunflow. It found solutions, from which 3% are strictly dominant (median is 5.5 solutions per project) and 64% are non-dominated (median is 18 solutions per project).</p><p>For the popular Github projects, artemis found at least one strictly dominant solution for all 8 projects. The total number of solutions found is 10218 and 16% of them are strictly dominant (median is 50 solutions per project) and 59% are non-dominated (median is 749.5 solutions per project).</p><p>For the sampled Github projects, artemis found a strictly dominant solution for 25 out of 30 projects, but found no solution for projects rubix-verifier, epubcheck, d-worker, telegrambots and fqueue. It found 27503 of which 10% of them are strictly dominant (median is 24 solutions per project) and 66% are non dominant http://openjdk.java.net/tools/svc/jconsole/ 9 http://maven.apache.org/components/surefire/maven-surefire-plugin/ (median is 125 solutions per project). With these results, we answer RQ1 affirmatively:</p><p>Finding1: artemis finds optimised variants that outperform the original program in at least one measure for all programs in our representative corpus. This finding understates artemis's impact. Not only did it improve at least one measure for all programs, artemis found solutions that improve all measures for 88% of the programs.</p><p>Having found that artemis finds performance improvements, we ask "How good are these improvements" with:</p><p>RQ2: What is the average improvement that artemis provides for each program?</p><p>Though artemis aims to improve all candidate's measures, it cannot achieve that if improvements are antagonistic. In some domains, it is more important to significantly improve one of the measures than to improve slightly all measures; e.g., a high frequency trading application may want to pay the cost of additional memory overhead in order to improve the execution time. Our intuition is that the optimiser will find many solutions on the Pareto-front and at least one of them will improve each measure significantly.</p><p>We answer RQ2 quantitatively. We report the maximum improvement (median value with 95% confidence interval) for execution time, memory and CPU usage for each subject of the three corpora. We use bar charts with error bars to plot the three measures for each program. In Y axis, we represent the percentage of improvement for each measure. A value less than 100% represents an improvement and a value greater than 100% means degradation; e.g., 70% memory consumption implies that the solution consumes 70% of the memory used in the input program.</p><p>Selected popular GitHub programs. <ref type="figure" target="#fig_1">Figure 3a</ref> presents the three measures of the solutions when the execution time is minimised, for each program from the popular GitHub programs. We observe that artemis improves the execution time of every program. google-http-java-client's execution time was improved the most; its execution time was reduced by M=46%, 95% CI <ref type="bibr">[45.6%, 46.3%]</ref>. We also notice that this execution time improvement did not affect negatively the other measures, but instead the CPU usage was reduced by M=41.6%, 95% CI [39.6%, 43.6%] and memory consumption remained almost the same. The other interesting program to notice from this graph is solo, a blogging system written in Java; its execution time improved slightly by 2% but its memory consumption increased by 20.2%. Finally, for this set of solutions, the median execution time improvement is 14.13%, whilst memory consumption slightly increased by 1.99% and CPU usage decreased by 3.79%. For those programs, artemis extracted a median of 12 data structures and the optimal solutions had a median of 4 data structures changes from the original versions of the program. <ref type="figure" target="#fig_1">Figure 3b</ref> shows the solutions optimised for memory consumption. We notice that artemis improves the memory consumption for all programs, with a median value of 14%. The execution time was improved by a median value of 2.8% for these solutions, while the median value of CPU usage is slightly increased by 0.4%. We notice that solo has the best improvement by M=31.1%, 95% CI   DaCapo. <ref type="figure" target="#fig_7">Figure 4</ref> presents all solutions optimised for execution time and memory consumption for the DaCapo benchmark. We used only two measures for the DaCapo benchmark as those were the ones built in the benchmark suite. We chose not to extend or edit the profiling method of DaCapo, to avoid the risk of affecting the validity of its existing, well tested profiling process.</p><p>artemis found solutions that improve the execution time for every program without affecting significantly the memory consumption, except project xalan which had improvement (M=4.8%, 95% CI [4.6%, 5.7%] in execution time but with an increase (5.8%, 95% CI [3.5%, 7%]) in memory consumption. All solutions for optimised memory consumption did not affect execution time, except for a slight increase for program fop. Finally, for this set of solutions, the median percentage of execution time improvement is 4.8%, and 4.6% for memory consumption. For this set of programs,  Sampled GitHub programs. <ref type="figure" target="#fig_8">Figure 5</ref> presents all solutions optimised for execution time, memory consumption and CPU usage for the sampled GitHub programs. As with the previous corpora, artemis found solutions that improved each measure significantly. artemis improves the median value of execution time across all projects by 4.6%, memory consumption by 11.4% and CPU usage by 4.6%.</p><p>artemis found solutions with antagonistic improvement for projects jafka and documents4j. artemis found a solution that improves the execution time of jafka, a distributed publish-subscribe messaging system, by M=12%, 95% CI <ref type="bibr">[11.2%, 13</ref>.6%], but also increases its memory consumption by M=23.6%, 95% CI [21.4%, 25.7%]. It also found a solution that improves the memory consumption of documents4j (M=38%, 95% CI [38%, 41%]) but introduced extra CPU usage M=26.1%, 95% CI [24.2%, 28%]. A median of 9.5 data structures were extracted and the optimal solutions had a median of 5 data structures changes from the original versions of the program.</p><p>Observing again the numbers across the three corpora, we can say that they are quite consistent, showing that artemis finds optimal solutions that improve significantly the different optimisation measures. We also see that the number of Darwinian Data structures extracted (between 9.5 and 18) and the optimal solutions DDS changes (between 4 and 5) are quite similar for the three corpora.</p><p>Analysing all results from the 3 corpora we conclude the discussion of RQ2 with:</p><p>Finding2: artemis improves the median across all programs in our corpus by 4.8% execution time, 10.2% memory consumption, and 5.1% CPU usage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ3: Which Darwinian data structures does artemis find and tune?</head><p>We ask this question to understand which changes artemis makes to a program.  applied across all optimal solutions. We see that the most common transformation for all measures is replacing ArrayList with LinkedList, it appears 91, 86 and 87 times respectevely across all measures. This transformation indicates that most developers prefer to use ArrayList in their code, which in general is considered to be faster, neglecting use cases in which LinkedList performs better; e.g., when the program has many list insertion or removal operations. Except HashMap to LinkedHashMap, the other transformations happen relatively rare in the optimal solutions. Last, the median number of lines Artemis changes is 5.</p><p>Finding3: artemis extracted a median of 12 Darwinian data structures from each program and the optimal solutions had a median of 5 data structure changes from the original versions of the program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RQ4:</head><p>What is the cost of using artemis?</p><p>In order for artemis to be practical and useful in real-world situations, it is important to understand the cost of using it. The aforementioned experimental studies reveal that, even for the popular programs, the existing selection of the data structure and the setting of its parameters may be sub-optimal. Therefore, optimising the data structures and their parameters can still provide significant improvement on non-functional properties. To answer this research question, the cost of artemis for optimising a program is measured by the cost of computational resources it uses. In this study, we used a Microsoft Azure TM D4-v2 machine, which costs £0.41 per hour at a standard Pay-As-You-Go rate , to conduct all experiments.</p><p>The experiments show that an optimisation process takes 3.05 hours on average for all studied subjects. The program GraphJet and jimfs are the most and the least time-consuming programs respectively, with 19.16 hours and 3.12 minutes optimisation time. Accordingly, the average cost of applying artemis for the subjects studied is £1.25, with a range from £0.02 to £7.86. The experimental results show that overall cost of using artemis is negligible compared to a human software engineer, with the assumption that a competent software engineer can find those optimisation in a reasonable time.</p><p>artemis transforms the selection of data structure and sets parameters by rewriting source code, thereby allowing human developers to easily investigate its changes and gain insight about the usage of data structures and the characteristics of the program.  To show the versatility of the artemis framework, we ask RQ2, RQ3 and RQ4 over Google guetzli, a very popular JPEG encoder written in C++. We used the STL containers and their operations as Darwinian data structures. More specifically, we considered the push _ back and emplace _ back as equivalent implementations of the same functionality and exposed those as tunable parameters to artemis's optimiser. We collected a random sample of images (available online 11 ) and used it to construct a performance suite that evaluates the execution time of guetzli.</p><p>We answer RQ2 by showing that artemis found an optimal solution that improves execution time by 7%. We answer RQ3 by showing that artemis extracted and tuned 25 parameters and found an optimal solution with 11 parameter changes. artemis spent 1.5 hours (costs £0.62) to find optimal solutions which is between the limits reported in RQ4. Last, we spent approximately days to extend artemis to support C++, using the parserless mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>THREATS TO VALIDITY</head><p>Section 5.1 discusses the steps we took to address the threats to the external validity of the results we present here. In short, we built three subcorpora, each more representative than the last, for a total of 43 programs, diverse in size and domain. The biggest threat to the internal validity of our work is the difficulty of taking accurate performance measurements of applications running on VM, like the JVM. Section 5.2 details the steps, drawn from best practice, we took to address this threat. In essence, we conducted calibration experiments to adjust the parameters such that the http://darwinianoptimiser.com/corpus algorithm converges quickly and stops after the results become stable. For measuring the non-functional properties, we carefully chose JConsole profiler that directly gathers runtime information from jdk, such that the measurement error is minimised. Moreover, we carefully tuned JConsole to further improve the precision of the measurements by maximising its sampling frequency such that it does not miss any measurements while minimising the CPU overhead. To cater for the stochastic nature of artemis and to provide the statistic power for the results, we ran each experiment times and manually checked that experiments had a steady state and exhibited low variance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK</head><p>Multi-objective Darwinian Data Structure selection and optimisation stands between two areas: search-based software engineering and data structure performance optimisation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Search-based software engineering</head><p>Previous work applies Genetic Programming <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b28">29,</ref><ref type="bibr" target="#b29">30,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b36">37,</ref><ref type="bibr" target="#b38">39]</ref> to either improve the functionality (bug fixing) <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b16">17]</ref> or nonfunctional properties of a program <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b37">38,</ref><ref type="bibr" target="#b43">44]</ref>. Their approaches use existing code as the code base and replace some of the source code in the program under optimisation with the code from the code base. However, many of these approaches rely on the Plastic Surgery Hypothesis <ref type="bibr" target="#b1">[2]</ref>, which assumes that the solutions exist in the code base. artemis, on the other hand, does not rely on this hypothesis. artemis can harvest Darwinian data structures both from the program, but also from external code repositiories; further, artemis relies on a set of transformation rules that it can automatically exhaustively extract from library code or documentation.</p><p>Wu et al. <ref type="bibr" target="#b44">[45]</ref> introduced a mutation-based method to expose "deep" parameters, similar to those we optimise in this paper, from the program under optimisation, and tuned these parameters along with "shallow" parameters to improve the time and memory performance of the program. Though the idea of exposing additional tunable parameter is similar to artemis, their approach did not optimise data structure selection, which can sometimes be more rewarding than just tuning the parameters. Moreover, they applied their approach to a memory management library to benefit that library's clients. The extent of improvement usually depends on how much a program relies on that library. In contrast, artemis directly applies to the source code of the program, making no assumptions about which libraries the program uses, affording artemis much wider applicability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Data structure optimisation and bloat</head><p>A body of work <ref type="bibr">[3, 14, 32-34, 42, 47]</ref> has attempted to identify bloat arising from data structures. In 2009, Shacham et al. <ref type="bibr" target="#b39">[40,</ref><ref type="bibr" target="#b40">41]</ref> introduced a semantic profiler that provides online collection-usage semantics for Java programs. They instrumented Java Virtual Machine (JVM) to gather the usage statistics of collection data structures. Using heuristics, they suggest a potentially better choice for a data structure for a program.</p><p>Though developers can add heuristics, if they lack sufficient knowledge about the data structures, they may bias the heuristics and jeopardise the effectiveness of the approach. artemis directly uses the performance of a data structure profiled against a set of performance tests to determine the optimal choices of data structures. Therefore, artemis does not depend on expert human knowledge about the internal implementation and performance differences of data structures to formulate heuristics. Instead. artemis relies on carefully-chosen performance tests to minimse bias. Furthermore, artemis directly modifies the program instead of providing hints, thus users can use the fine-tuned program artemis generates without any additional manual adjustment.</p><p>Other frameworks provide users with manually or automatically generated selection heuristics to improve the data structure selection process. JitDS <ref type="bibr" target="#b11">[12]</ref> exploits declarative specifications embedded by experts in data structures to adapt them. CollectionSwitch <ref type="bibr" target="#b8">[9]</ref> uses data and user-defined performance rules to select other data structure variants. Brainy <ref type="bibr" target="#b21">[22]</ref> provides users with machine learning cost models that guide the selection of data structures. artemis does not require expert annotations, user-defined rules or any machine learning knowledge. Storage strategies <ref type="bibr" target="#b5">[6]</ref> changes VMs to optimize their performance on collections that contain a single primitive type; Artemis rewrites source code and handles user-defined types and does not make VM modifications.</p><p>In 2014, Manotas et al. <ref type="bibr" target="#b30">[31]</ref> introduced a collection data structure replacement and optimisation framework named SEEDS. Their framework replaces the collection data structures in Java applications with other data structures exhaustively and automatically select the most energy efficient one to improve the overall energy performance of the application. Conceptually artemis extends this approach to optimise both the data structures and their initialization parameters. artemis also extends the optimisation objectives from single objective to triple objectives and used Pareto non-dominated solutions to show the trade-offs between these objectives. Due to a much larger search space in our problem, the exhaustive exploration search that used by SEEDS is not practical, therefore we adopted meta-heuristic search.</p><p>Furthermore, artemis directly transforms the source code of the programs whilst SEEDS transforms the bytecode, so artemis provides developers more intuitive information about what was changed and teaches them to use more efficient data structures. Moreover, artemis can be more easily applied to other languages as it does not depend on language specific static analysers and refactoring tools such as WALA <ref type="bibr" target="#b19">[20]</ref> and Eclipse IDE's refactoring tools. In order to support another language we just need the grammar of that language and to implement a visitor that extracts a program's Darwinian data structures. We note that antlr, which artemis uses, currently provides many available grammar languages .</p><p>Apart from the novelties mentioned above, this is the largest empirical study to our knowledge compared to similar work. In the studies mentioned above, only to 7 subjects were included in the experiments. Our study included the DaCapo benchmark, 30 sampled Github subjects and 8 well-written popular subjects to show the effectiveness of artemis, therefore our results are statistically more meaningful.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>Developers frequently use underperformed data structures and forget to optimise them with respect to some critical non-functional properties once the functionalities are fulfilled. In this paper, we introduced artemis, a novel multi-objective multi-language searchbased framework that automatically selects and optimises Darwinian data structures and their arguments in a given program. artemis is language agnostic, meaning it can be easily adapted to any programming language; extending artemis to support C++ took approximately 4 days. Given as input a data structure store with Darwinian implementations, it can automatically detect and optimise them along with any additional parameters to improve the non-functional properties of the given program. In a large empirical study on 5 DaCapo benchmarks, 30 randomly sampled projects and 8 well-written popular Github projects, artemis found strong improvement for all of them. On extreme cases, artemis found 46% improvement on execution time, 44.9% improvement on memory consumption, and 49.7% improvement on CPU usage. artemis found such improvements making small changes in the source code; the median number of lines artemis changes is 5. Thus, artemis is practical and can be easily used on other projects. At last, we estimated the cost of optimising a program in machine hours. With a price of £0.41 per machine hour, the cost of optsimising any subject in this study is less than £8, with an average of £1.25. Therefore, we conclude that artemis is a practical tool for optimising the data structures in large real-world programs.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Definition 2 (</head><label>2</label><figDesc>Darwinian Data Structure). When ∃d 0 , d 1 ∈ dse(a, C)∧d 0 d 1 ∧d 0 and d 1 are observationally equivalent modulo a, d 0 and d 1 are Darwinian data structures.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>otherwise Definition 3 (</head><label>3</label><figDesc>Darwinian Data Structure Selection and Tuning). For the real-valued fitness function f over the corpus C, the Darwinian data structure and tuning problem is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>System Architecture of artemis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>DDS in the Java Collections API.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>){ LinkedList&lt;T&gt; v1 = new LinkedList&lt;&gt;(); 9 int value = func3(v1); 10 } 11 int func3(LinkedList&lt;T&gt; v){ 12 T t = v.get(0); return 2 * t.value; } Listing 2: Code to illustrate bad practices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Answers RQ2. Description. [29.3%, 33%], but with an increase of M=8.7%, 95% CI [8.5%, 8.9%] in execution time and M=21.3%, 95% CI [20.6%, 22%] in CPU usage. Graphjet, a real-time graph processing library, has the minimum improvement of M=0.9%, 95% CI [0.6%, 1.1%]. The optimal solutions had a median of 4 data structures changes per solution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>Figure 3cpresents solutions optimised for CPU usage. The median CPU usage improvement is 9.7%. The median value of execution time improved by 5.2% and the median value of memory consumption improved by 2.3%. The program with the most significant improvement in CPU is http-java-client with M=49.7%, 95% CI [48%, 51.4%], but with a decrease in memory of M=9.8%, 95% CI [7.5%, 12.9%]. The optimal solutions make a median of data structures changes to the original versions of the program.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Answers RQ2. Description. artemis extracted a median of 18 data structures per program, and the optimal solutions had a median of 5 data structures changes for the execution time optimised solutions and 4 for the memory optimised solutions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 :Finding4:</head><label>5</label><figDesc>Answers RQ2. Description. The cost of using artemis is negligible, with an average of £1.25 per project, providing engineers with insights about the optimal variants of the project under optimisation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc></figDesc><table /><note>Data structure groups.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Best execution time of popular GitHub programs. The median value is 93.3%, mean is 86.4%. Median number of dds is 12 and mean is 14.6. Median number of dds changes is 4 and mean is 5. Best memory consumption of popular GitHub programs. The median value is 86% and mean is 84%. Median number of dds is 12 and mean is 14.6. Median number of dds changes is 4 and mean is 5.85. Best CPU usage of popular GitHub programs. The median value is 90.3% and mean is 84.6%. Median number of dds is 12 and mean is 14.6.</figDesc><table><row><cell>http-java-clien t 40 60 80 100 120 140 5/11 Relative difference (\%)</cell><cell>jimfs 4/12</cell><cell>jOOL 9/27</cell><cell>cglib 5/16</cell><cell>gson 6/11</cell><cell>Grap hJet 4/6</cell><cell cols="2">solo joda-time 9/19 5/11</cell><cell>Execution Time Memory CPU</cell></row><row><cell cols="2">(a) solo http-java-clien t 40 100 120 140 7/19 2/11 Relative difference (\%)</cell><cell>gson 4/11</cell><cell>cglib 8/16</cell><cell>jOOL 14/27</cell><cell cols="2">jimfs joda-time 3/12 6/11</cell><cell>Grap hJet 3/6</cell><cell>Execution Time Memory CPU</cell></row><row><cell>(b) http-java-clien t 40 60 80 100 120 140 5/11 Relative difference (\%)</cell><cell>jOOL 17/27</cell><cell>jimfs 5/12</cell><cell>gson 6/11</cell><cell>cglib 4/16</cell><cell>solo 12/19</cell><cell cols="2">Grap hJet joda-time 3/6 5/11</cell><cell>Execution Time Memory CPU</cell></row><row><cell>(c)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note>Median number of dds changes is 5 and mean is 7.42.</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Best execution time of the Dacapo benchmark. The median value is 95.20% and mean is 95.6%. Median number of dds is 18 and mean is 14.8. Median number of dds changes is 5 and mean is 4.8. Best memory consumption of the Dacapo benchmark. The median value is 95.7% and mean is 92.1% . Median number of dds is 18 and mean is 14.8. Median number of dds changes is 3 and mean is 4.2.</figDesc><table><row><cell>Relative difference (\%)</cell><cell>60 80 100 120</cell><cell>fop 7/18</cell><cell>avrora 5/18</cell><cell>xalan 3/16</cell><cell>pmd 7/18</cell><cell>sunflow 2/4</cell><cell>Execution Time Memory</cell></row><row><cell cols="3">(a) xalan 60 80 100 120 3/16 Relative difference (\%)</cell><cell>fop 5/18</cell><cell>sunflow 2/4</cell><cell>avrora 3/18</cell><cell>pmd 8/18</cell><cell>Execution Time Memory</cell></row><row><cell>(b)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2</head><label>2</label><figDesc>contains the transformations artemis</figDesc><table><row><cell>Tranformation</cell><cell cols="3">Time Memory CPU</cell></row><row><cell>HashMap -&gt; LinkedHashMap</cell><cell>60</cell><cell>53</cell><cell>57</cell></row><row><cell>LinkedList -&gt; ArrayList</cell><cell>16</cell><cell>13</cell><cell>18</cell></row><row><cell>HashSet -&gt; LinkedHashSet</cell><cell>22</cell><cell>21</cell><cell>21</cell></row><row><cell>LinkedBlockingQueue -&gt; LinkedTransferQueue</cell><cell>1</cell><cell>2</cell><cell>2</cell></row><row><cell>ArrayList -&gt; LinkedList</cell><cell>91</cell><cell>86</cell><cell>87</cell></row><row><cell>LinkedHashSet -&gt; HashSet</cell><cell>7</cell><cell>8</cell><cell>5</cell></row><row><cell>Vector -&gt; CopyOnWriteArrayList</cell><cell>1</cell><cell>0</cell><cell>2</cell></row><row><cell>LinkedHashMap -&gt; HashMap</cell><cell>17</cell><cell>23</cell><cell>19</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 2 :</head><label>2</label><figDesc>DDS changes for optimal solutions across all measures.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Best execution time of uniformly selected GitHub programs. The median value is 95.4% and mean is 94.7%. Median number of dds is 9.5 and mean is 11.6. Median number of dds changes is 5 and mean is 4.8. Best memory consumption of the uniformly selected GitHub programs. The median value is 89.1% and mean is 86.8%. Median number of dds is 9.5 and mean is 11.6. Median number of dds changes is 5 and mean is 4.6. Best CPU usage of the uniformly selected GitHub programs. The median value is 5.1% and mean is 8%. Median number of dds is 9.5 and mean is 11.6. Median number of dds changes is 5 and mean is 4.5.</figDesc><table><row><cell></cell><cell>140</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Relative difference (\%)</cell><cell>60 80 100 120</cell><cell>6/18</cell><cell>3/12</cell><cell>7/16</cell><cell>8/20</cell><cell>5/14</cell><cell>8/16 11/19</cell><cell>4/7</cell><cell>7/16</cell><cell>5/9</cell><cell>7/13</cell><cell>6/15</cell><cell>5/7</cell><cell>6/16</cell><cell>6/12</cell><cell>1/3</cell><cell>5/8</cell><cell>3/16</cell><cell>5/7</cell><cell>1/4</cell><cell>4/7</cell><cell>4/6</cell><cell>3/6</cell><cell>3/6</cell><cell>2/10</cell><cell>4/43</cell><cell>1/3</cell><cell>5/7</cell><cell>6/9</cell><cell>3/5</cell><cell>Execution Time Memory CPU</cell></row><row><cell></cell><cell>40</cell><cell>jafka</cell><cell cols="2">zxing light -4j</cell><cell cols="14">truth map per jsoni ter quer qy shuz ai boot ique rest-assu red docu men ts4j Open LRS jobpr oxy table saw plung er rubix -veri fier even t-sto re-cm n Glow stone</cell><cell cols="3">milo cmn-valid ator tap-p lugin</cell><cell cols="9">guice poilig ht hosp ital-s ystem javap oet epub chec k d-wo rker Teleg ramB ots cmn-code c fque ue</cell><cell></cell></row><row><cell cols="3">40 140 (a) zxing 6/12 60 80 100 120 Relative difference (\%)</cell><cell cols="5">jafka docu men ts4j light -4j cmn-code c table saw quer qy 8/18 5/13 5/16 6/9 4/16 6/19</cell><cell cols="11">truth map per fque ue jsoni ter rest-assu red plung er boot ique even t-sto re-cm n Open LRS Glow stone shuz ai 8/20 8/14 1/5 5/16 5/9 5/12 6/16 7/8 8/15 6/16 3/7</cell><cell cols="6">milo poilig ht javap oet jobpr oxy epub chec k tap-p lugin 4/7 1/6 3/10 3/7 3/43 3/7</cell><cell cols="6">guice Teleg ramB ots d-wo rker hosp ital-s ystem cmn-valid ator rubix -veri fier 3/6 6/7 2/3 4/6 1/4 3/3</cell><cell>Execution Time Memory CPU</cell></row><row><cell cols="5">docu men ts4j map per (b) light -4j 40 140 60 80 100 120 5/16 3/13 8/14 Relative difference (\%)</cell><cell>jafka 6/18</cell><cell cols="2">truth plung er jsoni ter 6/20 4/12 5/16</cell><cell cols="9">zxing cmn-code c boot ique Glow stone table saw Open LRS shuz ai quer qy rest-assu red 7/12 3/9 8/16 5/16 4/16 11/15 4/7 11/19 5/9</cell><cell cols="7">milo jobpr oxy even t-sto re-cm n javap oet tap-p lugin Teleg ramB ots epub chec k 4/7 4/7 5/8 3/10 3/7 2/7 4/43</cell><cell cols="7">guice cmn-valid ator hosp ital-s ystem poilig ht d-wo rker fque ue rubix -veri fier 3/6 2/4 3/6 2/6 3/3 1/5 1/3</cell><cell>Execution Time Memory CPU</cell></row><row><cell>(c)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="10">https://azure.microsoft.com/en-gb/pricing/</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">https://github.com/google/guava 3 https://github.com/vigna/fastutil 4 https://github.com/apache/commons-collections and outputs a scope-qualified list of names of Darwinian data structures and their constructor parameters (Extracted Data Structures and Parameters inFigure 1). For all a ∈ DDSS, extractor's output realises dse(a, P) (Section 3). To mark potential substitions to the transformer, the extractor outputs a templated version of the code which replaces the data structure with data structure type identifiers (Templated Source Code inFigure 1).To find darwinian data structures, the extractor builds an Abstract Syntax Tree (ast) from its input source code. It then traverses the ast to discover potential data structure transformations based on a store of data structures as shown inTable 1. For example, when an expression node of the ast contains a LinkedList expression, the extractor marks this expression as a potential darwinian data structure that can take values from the available List implementations: LinkedList or ArrayList. The extractor maintains a copy of the ast, referred to as the rewriter, where it applies transformations, without changing the initial ast. When the ast transformation finishes, the rewriter produces the final source code which is saved as a new file.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5">Adapted from "Animal Farm" by George Orwell</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">https://github.com/antlr/grammars-v4/</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank Graham Barrett, David Martinez, Kenji Takeda and Nick Page for their invaluable assistance with respect to developing artemis. Lastly, we are grateful to Microsoft Azure and Microsoft Research for the resources and commercial support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Online feedback-directed optimization of java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hind</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Ryder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="111" to="129" />
			<date type="published" when="2002" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The plastic surgery hypothesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Brun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Devanbu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sarro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering, FSE 2014</title>
		<meeting>the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering, FSE 2014<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="306" to="317" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Optimising darwinian data structures on google guava</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Basios</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kanthan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">T</forename><surname>Barr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Search Based Software Engineering</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="161" to="167" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Testing object-oriented systems: models, patterns, and tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">V</forename><surname>Binder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Addison-Wesley Professional</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The dacapo benchmarks: Java benchmarking development and analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Blackburn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Garner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Khang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Mckinley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bentzur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Diwan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Feinberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Frampton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">Z</forename><surname>Guyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Sigplan Notices</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="169" to="190" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Storage strategies for collections in dynamically typed languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">F</forename><surname>Bolz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Diekmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Tratt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages &amp;#38; Applications, OOPSLA &apos;13</title>
		<meeting>the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages &amp;#38; Applications, OOPSLA &apos;13<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="167" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Managing technical debt in software-reliant systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kazman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kruchten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Maccormack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Nord</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Ozkaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the FSE/SDP workshop on Future of software engineering research</title>
		<meeting>the FSE/SDP workshop on Future of software engineering research</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="47" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Reducing energy consumption using genetic improvement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">R</forename><surname>Bruce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Petke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation, GECCO &apos;15</title>
		<meeting>the 2015 Annual Conference on Genetic and Evolutionary Computation, GECCO &apos;15<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1327" to="1334" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Collectionswitch: a framework for efficient and dynamic collection selection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Costa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Andrzejak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 International Symposium on Code Generation and Optimization</title>
		<meeting>the 2018 International Symposium on Code Generation and Optimization</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="16" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Abstract data types: specifications, implementations, and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Dale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">M</forename><surname>Walker</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Jones &amp; Bartlett Learning</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Pidgin crasher: searching for minimised crashing gui event sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Dan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Marginean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Search Based Software Engineering</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="253" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Just-in-time data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>De Wael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Marr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">De</forename><surname>Koster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Sartor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">De</forename><surname>Meuter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software (Onward!)</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="61" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A fast and elitist multiobjective genetic algorithm: Nsga-ii</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Deb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pratap</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Meyarivan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on evolutionary computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="182" to="197" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A scalable technique for characterizing the usage of temporaries in framework-intensive java applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Dufour</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">G</forename><surname>Ryder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sevitsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of software engineering</title>
		<meeting>the 16th ACM SIGSOFT International Symposium on Foundations of software engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="59" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Wilcoxon-mann-whitney or t-test? on assumptions for hypothesis tests and multiple interpretations of decision rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Fay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Proschan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Statistics surveys</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Statistically rigorous java performance evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Georges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Buytaert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Eeckhout</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="57" to="76" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A systematic study of automated program repair: Fixing 55 out of 105 bugs for $8 each</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Goues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dewey-Vogt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">34th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2012-06" />
			<biblScope unit="page" from="3" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Companies with hacking cultures fai</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hardin</surname></persName>
		</author>
		<ptr target="https://blog.bretthard.in/companies-with-hacking-cultures-fail-b8907a69e3d#.ffdkyb1w2" />
		<imprint>
			<date type="published" when="2016-02" />
		</imprint>
	</monogr>
	<note>Online; accessed 25</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">The current state and future of search based software engineering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Future of Software Engineering</title>
		<imprint>
			<biblScope unit="page" from="342" to="357" />
			<date type="published" when="2007" />
			<publisher>IEEE Computer Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Watson Libraries for Analysis (WALA)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="middle">T J</forename><surname>Ibm</surname></persName>
		</author>
		<ptr target="http://wala.sourceforge.net/wiki/index.php/Main_Page" />
		<imprint>
			<date type="published" when="2009-02" />
		</imprint>
	</monogr>
	<note>Online; accessed 18</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Genetic improvement using higher order mutation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Genetic and Evolutionary Computation Conference</title>
		<meeting><address><addrLine>Madrid, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07-11" />
			<biblScope unit="page" from="803" to="804" />
		</imprint>
	</monogr>
	<note>Companion Material Proceedings</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Brainy: effective selection of data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Rus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Railing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pande</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="86" to="97" />
			<date type="published" when="2011" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Rigorous benchmarking in reasonable time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kalibera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="63" to="74" />
			<date type="published" when="2013" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Structured programming with go to statements</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Knuth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="261" to="301" />
			<date type="published" when="1974-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Improving 3d medical image registration cuda software with genetic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">B</forename><surname>Langdon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Modat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Petke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Annual Conference on Genetic and Evolutionary Computation</title>
		<meeting>the 2014 Annual Conference on Genetic and Evolutionary Computation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="951" to="958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Exact analysis for next release problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Requirements Engineering Conference (RE)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="438" to="443" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Exact analysis for requirements selection and optimisation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
		<respStmt>
			<orgName>UCL (University College London</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Robust next release problem: handling uncertainty during optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Letier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Annual Conference on Genetic and Evolutionary Computation</title>
		<meeting>the 2014 Annual Conference on Genetic and Evolutionary Computation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1247" to="1254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Sbselector: Search based component selection for budget hardware</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symposium on Search Based Software Engineering</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="289" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The value of exact analysis in requirements selection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="issue">99</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Seeds: A software engineer&apos;s energyoptimization decision support framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Manotas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Pollock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clause</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th International Conference on Software Engineering, ICSE 2014</title>
		<meeting>the 36th International Conference on Software Engineering, ICSE 2014<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="503" to="514" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">The causes of bloat, the limits of health</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sevitsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="245" to="260" />
			<date type="published" when="2007" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Modeling runtime behavior in framework-based applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sevitsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Srinivasan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Object-Oriented Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="429" to="451" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Self-managed collections: Off-heap memory management for scalable query-dominated collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Nagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Bierman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dragojevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Viglas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="61" to="71" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Mutation testing of memoryrelated operators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nanavati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eighth IEEE International Conference on Software Testing, Verification and Validation, ICST 2015 Workshops</title>
		<meeting><address><addrLine>Graz, Austria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Gotchas with Scala Mutable Collections and Large Data Sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Nowling</surname></persName>
		</author>
		<ptr target="http://rnowling.github.io/software/engineering/2015/07/01/gotcha-scala-collections.html" />
		<imprint>
			<date type="published" when="2015-02" />
		</imprint>
	</monogr>
	<note>Online; accessed 18</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Genetic improvement of software: a comprehensive survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Petke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Haraldsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>White</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Woodward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Evolutionary Computation</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Using genetic improvement and code transplants to specialise a c++ program to a problem class</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Petke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">B</forename><surname>Langdon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Conference on Genetic Programming</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="137" to="149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A field guide to genetic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Poli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">B</forename><surname>Langdon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">F</forename><surname>Mcphee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Koza</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lulu. com</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Chameleon: Adaptive selection of collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;09</title>
		<meeting>the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;09<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="408" to="418" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Chameleon: Adaptive selection of collections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Shacham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vechev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Yahav</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGPLAN Not</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="408" to="418" />
			<date type="published" when="2009-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Jolt: lightweight dynamic analysis and removal of object churn</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shankar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bodik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="127" to="142" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Design patterns: Elements of reusable object-oriented software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page">11</biblScope>
			<pubPlace>Reading</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nanavati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
		<title level="m">Memory mutation testing. Information &amp; Software Technology</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="page" from="97" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Deep parameter optimisation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Weimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krinke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Annual Conference on Genetic and Evolutionary Computation</title>
		<meeting>the 2015 Annual Conference on Genetic and Evolutionary Computation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1375" to="1382" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Go with the flow: profiling copies to find runtime bloat</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rountev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sevitsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="419" to="430" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Finding low-utility data structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rountev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Schonberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Sevitsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigplan Notices</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="174" to="186" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Precise memory leak detection for java software using container profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Rountev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software Engineering, 2008. ICSE&apos;08. ACM/IEEE 30th International Conference On</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="151" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Performance assessment of multiobjective optimizers: an analysis and review</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zitzler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Thiele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Laumanns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">G</forename><surname>Da Fonseca</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Evolutionary Computation</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="117" to="132" />
			<date type="published" when="2003-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
