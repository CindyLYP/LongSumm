<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">IPA: Invariant-Preserving Applications for Weakly Consistent Replicated Databases</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valter</forename><surname>Balegas</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sérgio</forename><surname>Duarte</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carla</forename><surname>Ferreira</surname></persName>
							<email>carla.ferreira@fct.unl.pt</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Nuno</roleName><forename type="first">Rodrigo</forename><surname>Rodrigues</surname></persName>
							<email>rodrigo.rodrigues@inesc-id.pt</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nuno</forename><surname>Preguiça</surname></persName>
							<email>nuno.preguica@fct.unl.pt</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">FCT</orgName>
								<orgName type="institution" key="instit1">NOVA LINCS</orgName>
								<orgName type="institution" key="instit2">Universidade NOVA de Lisboa</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">NOVA LINCS</orgName>
								<orgName type="institution" key="instit2">Universidade NOVA de Lisboa</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution" key="instit1">NOVA LINCS</orgName>
								<orgName type="institution" key="instit2">Universidade NOVA de Lisboa</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="department">INESC-ID, Instituto Superior Técnico, U. Lisboa</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff4">
								<orgName type="institution" key="instit1">NOVA LINCS</orgName>
								<orgName type="institution" key="instit2">Universidade NOVA de Lisboa</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">IPA: Invariant-Preserving Applications for Weakly Consistent Replicated Databases</title>
					</analytic>
					<monogr>
						<idno type="ISSN">2150-8097</idno>
					</monogr>
					<idno type="DOI">10.14778/3297753.3297760</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>It is common to use weakly consistent replication to achieve high availability and low latency at a global scale. In this setting, concurrent updates may lead to states where application invariants do not hold. Some systems coordinate the execution of (conflicting) operations to avoid invariant violations, leading to high latency and reduced availability for those operations. This problem is worsened by the difficulty in identifying precisely which operations conflict. In this paper we propose a novel approach to preserve application invariants without coordinating the execution of operations. The approach consists of modifying operations in a way that application invariants are maintained in the presence of concurrent updates. When no conflicting updates occur, the modified operations present their original semantics. Otherwise, we use sensible and deterministic conflict resolution policies that preserve the invariants of the application. To implement this approach, we developed a static analysis, IPA, that identifies conflicting operations and proposes the necessary modifications to operations. Our analysis shows that IPA can avoid invariant violations in many applications, including typical database applications. Our evaluation reveals that the offline static analysis runs fast enough for being used with large applications. The overhead introduced in the modified operations is low and it leads to lower latency and higher throughput when compared with other approaches that enforce invariants.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Databases are commonly replicated in different geographical regions to ensure low latency and high availability across the globe <ref type="bibr" target="#b19">[22,</ref><ref type="bibr" target="#b46">49,</ref><ref type="bibr" target="#b17">20]</ref>. To provide these guarantees, systems often adopt weak consistency. This approach can expose temporary state divergence to clients, making application development more difficult. Many techniques have been proposed to make these systems easier to program: conflict-free replicated data types <ref type="bibr" target="#b42">[45]</ref> (CRDTs) ensure state convergence; causal consistency <ref type="bibr" target="#b36">[39,</ref><ref type="bibr" target="#b9">12,</ref><ref type="bibr" target="#b54">57]</ref> enforces that operations are made visible respecting the happens-before relation; and, finally, highly available transactions <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b46">49,</ref><ref type="bibr" target="#b54">57]</ref> can group multiple operations that must take effect all at once.</p><p>Despite these proposals, it remains difficult to develop applications under weak consistency. Several studies <ref type="bibr" target="#b7">[10,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b50">53]</ref> show that, in many applications, concurrent executions lead to the violation of application invariants, resulting in inconsistent states. To give an example, consider an online e-games platform, and assume that the application is correct when executed under strong consistency. Consider that a user enrolls in some tournament and concurrently the organizer decides to cancel the tournament. The first operation creates a new reference between the user and the tournament, while the second removes the tournament, and all references to it. Since these operations are concurrent, the remove operation does not delete the newly created reference, which now points to a tournament that no longer exists, thus breaking referential integrity.</p><p>To prevent invariant violations efficiently, some systems provide primitives for executing operations synchronously <ref type="bibr" target="#b46">[49,</ref><ref type="bibr" target="#b34">37]</ref>, paying the cost of coordination only when necessary. However, it is difficult to identify the problematic executions, especially because inconsistencies may occur only for some combinations of operations and in some specific states. The result is that programmers often end up constraining concurrency too much to preserve correctness, with an impact on the availability and latency of systems <ref type="bibr" target="#b11">[14,</ref><ref type="bibr" target="#b16">19]</ref>.</p><p>This paper proposes a novel approach for preserving application invariants under weak consistency that does not impact the availability and latency of applications. The key idea is to extend operations with updates that preventively guarantee the preservation of invariants in the presence of concurrent updates. The additional updates should have no visible effect if no concurrent operation is executed, keeping the semantics of the operation in the sequential case. These updates come into effect when needed to correct the undesirable semantics of concurrent operations. In our previous example, it is possible to maintain referential integrity by restoring the removed tournament. To this end, the enroll operation is extended with an update that prevents the concurrent deletion of the tournament.</p><p>To help programmers adopt our approach, we propose a methodology for modifying applications. The key element of the methodology is our invariant-preservation analysis (IPA) and static analysis tool that relies on information about the application, including invariants and operations, to identify which operations might lead to invariant violations and to suggest modifications to the operations to prevent those violations from occurring. Previous work employed static analysis to optimize the use of coordination in applications running under weak consistency <ref type="bibr" target="#b33">[36,</ref><ref type="bibr" target="#b11">14,</ref><ref type="bibr" target="#b41">44]</ref>. In contrast, instead of resorting to coordination for avoiding the concurrent execution of conflicting operations, we allow operations to execute concurrently and leverage conflict resolution policies to ensure a result that is deterministic (given the operations that execute concurrently) and preserves invariants. To our knowledge, our work is the first to adopt such an approach to enforce invariants that span multiple database objects (that can be stored on different machines).</p><p>Our evaluation is threefold. First, we analyzed a number of applications/benchmarks that are representative of common OLTP applications, concluding that our approach can identify the most common relational database invariant violations, and that the suggested modifications lead to sensible and deterministic semantics in the concurrent case. Furthermore, the semantics of the modified operations is equivalent to the original operations when no conflicting operation executes concurrently. Second, we analyze the scalability of the static analysis process, showing that it is fast enough to be used with large applications. Third, the results of our experiments show that the performance of the modified applications has only a small overhead compared to the unmodified versions and is faster than a state-of-the-art solution that maintains invariants using coordination to prevent invariant violations.</p><p>In this paper we make the following contributions: (i) a novel approach to preserve invariants under weak consistency without resorting to coordination, which combines the extension of operations with new updates and the use of appropriate conflict resolution policies; (ii) an algorithm that takes information about operations and application invariants and proposes modifications to operations and conflict resolution policies to preserve invariants while keeping the original semantics of the operations in the absence of conflicts; (iii) the design of new CRDTs that support the conflict resolution policies necessary for adopting our approach; (iv) an implementation and evaluation of the proposed approach.</p><p>The paper discusses the difficulties in designing applications on top of weak consistency ( §2); presents an overview of the IPA approach ( §3); presents the system model and defines the key principles for IPA ( §4); details the IPA analysis ( §5); discusses implementation details ( §6); evaluates the approach and prototype ( §7); discusses related work ( §8); and presents some final remarks ( §9).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>In this section we discuss the problem of application correctness when executing applications under weak consistency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Eventual consistency and CRDTs</head><p>Storage systems that adopt weak consistency models, such as eventual consistency <ref type="bibr" target="#b47">[50,</ref><ref type="bibr" target="#b49">52,</ref><ref type="bibr" target="#b19">22,</ref><ref type="bibr" target="#b31">34]</ref> or causal+ consistency <ref type="bibr" target="#b36">[39,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b54">57]</ref>, need to include a mechanism to merge concurrent updates, guaranteeing that all replicas converge to the same state after applying the same set of updates. In last-writer-wins, the latest update, according to some total order defined among updates, prevails. This strategy may lead to lost updates, as the effects of an update may be overwritten by a concurrent update. To address this problem, some systems, such as Cassandra, support type-specific merge for some data types -e.g., for counters, the final value reflects all updates.  Conflict-free replicated data types (CRDTs) <ref type="bibr" target="#b42">[45,</ref><ref type="bibr" target="#b43">46]</ref> are a principled approach for defining replicated objects. A CRDT is an abstract data type designed to be replicated. Any replica of a CRDT can be modified without coordination and any two replicas that receive the same set of updates converge to the same state, deterministically.</p><p>A CRDT implements type-specific concurrency semantics, namely defining how to merge concurrent updates. For example, a set exports two operations for adding and removing an element: add (e) and remove(e). As these operations do not commute when referring to the same element, the concurrency semantics must arbitrate the state of the object when an add (e) and a remove(e) execute concurrently. Several concurrency semantics are possible. In the Add-wins semantics, an add wins (takes priority) over a concurrent remove, leading to a state where e belongs to the set after applying both updates. In the Rem-wins semantics, the remove wins over a concurrent add, leading to a state where e does not belong to the set.</p><p>CRDTs were first used in research systems, such as Walter <ref type="bibr" target="#b46">[49]</ref> and SwiftCloud <ref type="bibr" target="#b54">[57]</ref>. More recently, they were adopted in production systems, such as Redis <ref type="bibr" target="#b15">[18]</ref>, Akka <ref type="bibr" target="#b1">[4]</ref> and Riak <ref type="bibr" target="#b14">[17]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Convergence is not enough</head><p>State convergence is not sufficient to guarantee application correctness, as the final state might be invalid. This can occur when the rules for maintaining convergence are defined per data-type, not considering the relations among the multiple objects of the state.</p><p>We illustrate this problem with the application that stores information for an e-games platform introduced before. In this application, the database stores information about players, tournaments and which players are enrolled in which tournaments. Players can enroll or disenroll from tournaments, and a tournament can be removed by the administrator if there are no players enrolled. There is an implicit referential integrity invariant that states that a player may only enroll in an existing tournament. Now consider the concurrent execution of two operations to remove a tournament and enroll a player in that tournament, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. In state Si, the remove verifies that there is no entry in the enrolled table referring to tournament t and removes it. In the same state, the enroll operation creates a new reference between player p1 and t. Since the effects of each operation are generated in different replicas, the remove operation does not see p1 enrolled in t, whereas enroll still sees t. When the state of both replicas converges (S f ), the state will have player p1 enrolled in tournament t, which no longer exists, thus breaking referential integrity.</p><p>We note that this problem still occurs in weakly consistent systems that provide additional guarantees, such as causal+ consistency and highly available transactions. Causal+ consistency <ref type="bibr" target="#b36">[39,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b3">6]</ref> guarantees that the effects of an operation are only visible after the effects of all operations that happened-before <ref type="bibr" target="#b32">[35]</ref> it. However, this does not impact the execution of concurrent operations.</p><p>Some systems <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b8">11,</ref><ref type="bibr" target="#b54">57,</ref><ref type="bibr" target="#b37">40]</ref> provide highly available transactions, in which a set of updates is applied atomically in a replica: concurrent transactions either see the effects of all updates or none. This type of transactions differs from ACID transactions by allowing concurrent updates to the same object, and the final value of the object is defined by the conflict resolution policy of the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">OVERVIEW</head><p>In this section we explain our proposal to modify applications to ensure invariant preservation without coordination.</p><p>The invariant violation of <ref type="figure" target="#fig_0">Figure 1</ref> can be repaired, after it is detected, by either: (i) removing the new player enrollment from the enrolled table; or (ii) restoring the tournament to its previous state. In this type of approach, known as compensations <ref type="bibr" target="#b47">[50,</ref><ref type="bibr" target="#b24">27]</ref>, when the system detects that the database is inconsistent, it applies some compensation effects to restore the database integrity.</p><p>Our insight is that in many situations the effects to restore the database integrity can be applied preventively alongside the original operations, repairing the invariant violation automatically in a conflicting execution. Going back to our previous example, restoring a tournament to its previous state can be achieved by executing a touch operation in the tournament when executing the enroll, and adopting a conflict resolution policy where the touch wins over a concurrent delete. The touch operation has no observable effect, only updating the metadata to guarantee that the concurrent execution is detected and solved according to the defined conflict resolution policy. This approach has several interesting properties. First, it does not require any form of coordination during the execution of operations, or any mechanism for detecting invariant violations at runtime (which can be expensive, particularly when the invariant relates data stored in different servers). Second, the additional operations have no observable effect if no conflicting concurrent operations are executed.</p><p>This approach requires combining appropriate conflict resolution policies with a careful selection of which updates to add to each operation. The goal is to guarantee that the extra updates have no observable effect unless a conflicting operation is executed, and that, in such cases, the additional updates guarantee that the invariant is preserved. Additionally, it is necessary to guarantee that the extra updates do not lead to the violation of any other invariant and that modified operations do not interfere among themselves.</p><p>To help in this process, we devised algorithms that use static analysis to detect executions that might violate an application invariant, and search for modifications that prevent those violations. Typically, there will be several alternative modifications for preserving invariants -the programmer must select the most appropriate for her application. In most cases, the additional updates have no observable effect and can be applied preventively with the operations.</p><p>For some cases, the additional updates might have an observable effect on the database state. To address these cases, we also support a compensation mechanism that applies these updates if a conflict violation is detected. For instance, it is not possible to prevent flight overbooking, but it is possible to compensate the event by reimbursing users or finding alternative flights. Unlike other solutions, our approach does not require coordination to execute compensations, which can execute at any replica. However, the detection of invariant violation is limited to conditions over the state of a single object.</p><p>Example: We now detail how our approach works, using the example of <ref type="figure" target="#fig_0">Figure 1</ref>. Consider that the database tables, player and tournament, and relationship, enrolled, are stored in separate sets.</p><p>As mentioned before, for preventing the invariant violation by recreating the deleted tournament, it suffices to extend the effects of the enroll operation to touch tournament t. By adopting the Add-wins policy for the tournament, with the touch tournament winning over a concurrent remove tournament, this guarantees that tournament t survives the concurrent execution of a remove t operation.</p><p>For preventing the invariant violation by deleting enrollments in removed tournaments, it suffices to extend the effects of the remove tournament t to preventively remove any concurrently enrolled pair associated with t. This does not produce any observable effect because there should be no element enrolled in t after the execution of the remove operation. Adopting a Rem-wins policy for the enrolled set guarantees that a concurrent enroll will have no effect.</p><p>We can view the modifications to the operations as a way of giving priority to one conflicting operation over the other, the same way that a Add-wins (resp. Rem-wins) set CRDT gives priority to an add over a remove (resp. a remove over an add). The additional updates guarantee that the preconditions for executing the operation that is given priority remain valid despite the execution of any concurrent operation. For example, recreating the tournament is to give priority to the enroll over the remove tournament. The enroll precondition that would be violated is that the tournament exists. Touching the tournament and selecting the Add-wins policy guarantees that the precondition remains valid despite concurrent remove tournaments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">IPA APPROACH</head><p>This section introduces the main principles underlying IPA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">System model</head><p>We consider a database composed of a set of objects fully replicated in multiple data centers. Operations over those objects can execute a sequence of reads and updates enclosed in a transaction. As the transaction executes in an initial replica, the effects of updates are recorded and queued for replication upon transaction commit. Propagation of updates can be asynchronous and must respect causal order. Hereafter, we use the term operation to refer updates produced by the execution of the transaction code in the initial replica.</p><p>We denote by o(S) the state after applying the updates of operation o to state S. A database snapshot, Sn, is the state of the database after executing a sequence of operations o1, . . . , on in the initial database state, Sinit, i.e., Sn = on(. . . (o1(Sinit))). The set of operations reflected in snapshot S is denoted by Ops(S), e.g., Ops(Sn) = {o1, . . . , on}. The state of a replica results from applying both local and remote operations, in the order received.</p><p>We say that an operation oa happened-before <ref type="bibr" target="#b32">[35]</ref>  For an execution of a given set of operations O, the happensbefore relation defines a partial order among operations, O = (O,≺). We say O = (O, &lt;) is a valid serialization of O = (O, ≺) if O is a linear extension of O, i.e., &lt; is a total order compatible with ≺.</p><p>Operations can execute concurrently, with each replica executing operations according to a different valid serialization. To guarantee state convergence, we assume the system gives the programmer the choice of various deterministic conflict resolution policies on a perobject basis, i.e., the result of applying updates that were executed concurrently is deterministic independently of the execution order. In our prototype, we rely on CRDTs <ref type="bibr" target="#b42">[45,</ref><ref type="bibr" target="#b46">49]</ref> to achieve this goal.</p><p>We consider that application correctness can be expressed in terms of invariants <ref type="bibr" target="#b6">[9,</ref><ref type="bibr" target="#b11">14,</ref><ref type="bibr" target="#b26">29]</ref>. An invariant is a logical condition expressed over the database state. A given state S preserves an invariant I iff I(S) = true, where I(S) is a function that checks the validity of the invariant in state S. A state Si is I-valid (or simply valid) iff I(Si) = true; otherwise the state is I-invalid (or simply invalid). We require the initial state, Sinit, to be valid.</p><p>We say that O = (O, &lt;) is an I-valid serialization of O = (O,≺) if O is a valid serialization of O, and I holds in every state that results from executing any possible prefix of O . If I is the conjunction of all application invariants, then we say that an application is correct if, in any possible execution of that application, every replica evolves through a sequence of I-valid states. We say that an operation o1 conflicts with o2 if the execution of o1 makes the preconditions of o2 false in some database state.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Principles for IPA</head><p>We now present the key principles for guaranteeing the correct execution of an application under weak consistency. We follow the notions introduced by Bailis et al. <ref type="bibr" target="#b6">[9]</ref>, adapting them to our model. DEFINITION 1. Given a set of commutative operations O and the happens-before relation, ≺, we say O is I-Confluent <ref type="bibr" target="#b6">[9]</ref> iff any state S, obtained by executing a prefix of any valid serialization of (O, ≺), starting from an I-valid state, is I-valid.</p><p>This means that for a set of I-Confluent operations, despite executing operations in a different serialization order, every replica will evolve only through I-valid states. Along with the commutativity of the operations, this guarantees the correctness of application execution both in terms of convergence and invariant-preservation.</p><p>To preserve invariants, an operation should only produce side effects in states that satisfy the operation preconditions. For example, for adding a player to a tournament, the player and tournament must exist. When an operation executes in the initial replica, the code of the operation verifies that the local state satisfies the preconditions.</p><p>The challenge arises when operation side-effects propagate asynchronously to remote replicas. At the remote replica, concurrent operations may have already executed, leading to a state where the operation preconditions do not hold anymore. Applying the sideeffects as-is may result in an invariant violation -e.g., applying the effects of adding a player to a tournament in a state where the tournament has been removed leads to an invariant violation. DEFINITION 2. Given a set of operations O and the happensbefore order, ≺, we say that S is an admissible state for o ∈ O iff there is a valid serialization of (O, ≺) in which S results from applying all operations that precede o to the initial state.</p><p>With this definition in place, we can state a sufficient condition for having I-Confluent operations, thus enabling the system to execute operations in remote replicas without violating the invariants. The key insight of IPA is that, in many cases, it is possible to guarantee both commutativity and the sufficient property of Theorem 1 by leveraging CRDTs and extending operations with updates that restore the operation preconditions. In the example of the previous section, an operation to enroll a player in a tournament can execute safely if it restores the player and tournament. This can be achieved by touching both the player and tournament and using an Add-wins conflict resolution policy for players and tournaments, thus protecting the enroll operation against concurrent removal of the player or tournament. The deterministic nature of Add-wins and Rem-wins, with conflicts solved based only on the type of concurrent operations, is key for achieving the intended result.</p><p>We note that it is only necessary to restore the preconditions in admissible states, as the serialization of operations must be consistent with the happens-before relation. In practice, it is necessary to execute operations in causal order and revert the effects of concurrent updates that may affect the preconditions of the operation. The additional updates in an operation should be executed atomically with the updates of the operation to guarantee that no inconsistency is observed. In our prototype, we achieve this by relying on highly available transactions <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b54">57]</ref>. In the next sections we show how to put these principles into practice.</p><p>// Application invariants @Inv("forall(Player:p, Tournament:t) :− enrolled(p, t ) ==&gt; player(p) and tournament(t)") @Inv("forall(Player:p,q, Tournament:t) :− inMatch(p, q, t) ==&gt; enrolled(p,t) and enrolled(q, t ) and ( active ( t ) or finished ( t ) )") 4 @Inv("forall(Tournament:t) :− #enrolled( * , t ) &lt;= Capacity") 5 @Inv("forall(Tournament:t) :− active(t ) or finished ( t ) ==&gt; tournament(t)") 6 @Inv("forall(Tournament:t) :− not( active ( t ) and finished ( t ) )") </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">IPA DESIGN</head><p>We now present our methodology for developing I-Confluent applications, comprising the following three steps.</p><p>Step 1: Specification: The first step consists of building a specification of the application by identifying application invariants and operation effects. We use the same specification language used in Indigo <ref type="bibr" target="#b11">[14]</ref>, requiring programmers to specify the invariants and the effects of each operation using first-order logic.</p><p>Step 2: IPA analysis: The IPA analysis, performed by our tool, is an iterative process where, in each iteration: (i) the tool identifies a pair of conflicting operations, i.e., operations that might break some invariant when executed concurrently, and proposes modifications that guarantee that invariants are preserved; (ii) the programmer chooses which conflict resolution he or she prefers. This process executes multiple times until no more conflicts exist.</p><p>Step 3: Code modification: The analysis returns a new specification of the application, which contains the selected modifications, comprising both the use of appropriate conflict resolution policies for each object and the modification to operations to avoid invariant violations. When the modifications produce no observable effect, they are appended to the corresponding operations. Otherwise, they must execute as compensations when a conflict occurs.</p><p>Fully patched applications can then execute in any replicated system that provides causal consistency, highly available transactions and the necessary type-specific conflict resolution policies. A number of systems support these features <ref type="bibr" target="#b46">[49,</ref><ref type="bibr" target="#b54">57,</ref><ref type="bibr" target="#b2">5]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Specification</head><p>The specification of an application conveys information about invariants and operation effects. This is done using first-order logic, which is sufficiently expressive to cover most common relational databases constraints and operation effects <ref type="bibr" target="#b11">[14,</ref><ref type="bibr" target="#b26">29,</ref><ref type="bibr" target="#b7">10]</ref>.</p><p>In <ref type="figure">Figure 2</ref>, we present the specification of the tournament application. Predicates are used to represent the database state. Invariants are represented by quantified boolean statements, and operation effects are modeled with predicate assignments. For example, the logical implication in line 2 specifies an invariant that says that a player p may only be enrolled in a tournament t if player p and tournament t exist in the database. Predicate assignments can either set the value of a boolean predicate to true or false, or apply an arithmetic operator to the predicate, in the case of numerical predicates. As an example, the effects of operation enroll (p, t) set the predicate enrolled (p, t) to true (line 21) and increment the number of elements in the enrolled set for tournament t (line 22).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">IPA analysis</head><p>The IPA analysis is an iterative process to modify the operations of an application in order to guarantee that application invariants are preserved when operations execute concurrently.</p><p>Algorithm 1 presents the algorithm for executing the IPA analysis. The analysis builds on two main components: (i) conflict detection, for identifying pairs of operations that may cause an invariant violation; and (ii) conflict repair, for finding a modification to a pair of conflicting operations that makes them invariant-preserving.</p><p>The main function (line 1) has three parameters: (1) the invariant, I, which is a single expression that connects all invariants with a conjunction operator; (2) the set of operations, Ops, with all operations defined in the application; and (3) the initial conflict-resolution policies for the predicates, CR, as defined by the programmer. The function consists of a loop that finds pairs of conflicting operations and a repair for each conflict. The repair consists of an extended version of the operations, which replaces the original ones, and appropriate conflict resolution policies for predicates. The loop continues until no more conflicting operations exist.</p><p>Next, we detail the main components of the analysis. For simplicity, our presentation omits some details. First, it ignores the situation when no repair can be found, which is discussed in Section 5.5. Second, the algorithm only handles boolean predicates. We discuss numerical invariants and compensations in Section 5.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Conflict detection</head><p>The conflict detection algorithm finds a pair of operations that, when executed concurrently, may break the application invariants. To this end, it considers all pairs of operations in the specification (checking conflicts pairwise is sound, as shown independently by Gotsman <ref type="bibr" target="#b26">[29]</ref> and Balegas <ref type="bibr" target="#b45">[48]</ref>).</p><p>For each pair, the algorithm first checks if the operations have opposing effects (line 8), i.e., if one sets a predicate to true while the other sets the same predicate to false, as when add tourn(t) and rem tourn(t) execute concurrently. For each opposing effect, the algorithm uses the rule specified in CR to set the value of the predicate in the operations (line 9). If no rule exists for the predicate, the programmer is asked which rule should be used (Add-wins or Rem-wins), and the updated CR rules are returned by the function.</p><p>For checking if the concurrent execution of both operations may break an invariant, it is necessary to consider their concurrent execution in all valid states. If any resulting state does not respect I, then the operations conflict. To search for an invalid execution efficiently, we rely on an SMT solver (line 10), which uses several optimizations and heuristics to avoid testing all cases exhaustively. <ref type="figure" target="#fig_4">Figure 3a</ref> exemplifies the conflict detection procedure for two operations, rem tourn(t) and enroll (p, t). To select the states to be checked, the SMT solver determines, from the invariants, the weakest precondition for executing both operations. In this case, it is necessary that tournament(t) and player (p) are set to true. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>24:</head><p>pairs ← ∅</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>25:</head><p>for p ∈ effectSets do 26:</p><formula xml:id="formula_0">pairs ← pairs ∪ {(newOp(op1 , p),op2 )} 27: pairs ← pairs ∪ {(op1 ,newOp(op2 , p)}</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>28:</head><p>return order(pairs) by increasing no. of predicates.</p><p>The SMT solver then checks if, for every state in which the weakest preconditions hold, the concurrent execution of both operations produces a valid state. In our example, executing rem tourn(t) and enroll (p, t) individually at some Sinit in which tournament(t) and player (p) are set to true, generates S1 and S2 respectively, which are valid states. However, when we combine the effects of both operations, the resulting state violates the invariant that a player must be enrolled in an existing tournament (line 2, <ref type="figure">Figure 2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Conflict repair</head><p>The conflict repair algorithm (function repairConflicts, line 11) takes two conflicting operations and tries to find modifications to the operations and conflict resolution rules that guarantee the invariants are preserved when these operations execute concurrently.</p><p>The algorithm starts by creating a pool of predicates to add to the operations to avoid the conflict. To this end, the invariant clauses that might be involved in the conflict are identified, based on the effects of the conflicting operations. The predicates involved in these clauses are the predicates that will be used to try to avoid the conflict (line 13).</p><p>The next step is to generate the modified versions of the conflicting operations by using the identified predicates (line 14). The generate function (line 21) computes all possible combinations of new effects to add to the operations, by using the powerset of the previously identified predicates (in invPreds), filtered so that in each set a predicate has only the value true or false (line 23). The function returns all pairs of operations extending the original operations with the new effects, ignoring, in each new operation, any predicate that is already present in the operation. The modified pairs are ordered by the number of predicates in each operation (line 28) to ensure that the algorithm analyses operations with fewer predicates first.  For each generated pair of operations, the algorithm checks if the effects of the modified operations are not a subset of any previously found solution, i.e., if there is a solution with fewer additional effects that solves the conflict (line 16). If that is the case, the pair is ignored. Otherwise, the algorithm checks if the new pair is nonconflicting (line 17) -this might require automatically assigning a new conflict resolution policy to a predicate that has no assigned policy yet (if a policy already exists, it is not modified). If the new pair is non-conflicting, it is added to the set of solutions (line 19).</p><p>Finally, the set of solutions is presented to the programmer, who must select the most appropriate one for the application (line 20).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Running the IPA analysis: an example</head><p>To exemplify how the IPA analysis works, we consider three operations: enroll (p, t), rem tourn(t), and rem player (p).</p><p>In the first iteration, the conflict detection procedure finds a pair of operations that conflict. Consider that this returns the pair enroll (p, t),rem tourn(t) . In this case, the invariant violated by these operations is I = enrolled (p, t) ⇒ player (p) ∧ tournament(t). The pool of predicates for generating new operations is {enrolled (p, t), player (p), tournament(t)}. The analysis creates new operations by considering the powerset of those effects. While computing the powerset has exponential complexity, the degree is usually small as the predicate pool is restricted to the predicates of the invariant clause impacted by the conflict.</p><p>With an initially empty value for the CR set, the following repair actions are possible. The first repair <ref type="figure" target="#fig_4">(Figure 3b</ref>) consists of extending the enroll (p, t) operation by setting the predicate tournament(t) to true and using the conflict resolution policy (tournament, Add-wins). When the two operations execute concurrently, an opposing effect occurs for predicate tournament(t).</p><p>With Add-wins for tournament, the resulting value for the predicate is true, leading to a state that contains tournament t, which is compliant with invariant I. Setting tournament(t) to true in operation enroll (p, t) produces no observable effect because one of the preconditions of the operation is that the value of that predicate is true, therefore the effect can be executed preventively. We note that choosing this repair will influence also the result of a concurrent add tourn(t) and rem tourn(t) -the Add-wins policy will guarantee that the tournament exists in that case. Also, this repair would not be possible if the initial conflict resolution policies included (tournament, Rem-wins).</p><p>The second repair <ref type="figure" target="#fig_4">(Figure 3c</ref>) consists of extending rem tourn(t) to force the disenrollment of every player from tournament t and using the conflict resolution policy (enrolled, Rem-wins). Since it is impossible to infer the identifier of the player that might enroll in t, we use a wildcard for the parameter p, enrolled ( * , t) = false, as shown in <ref type="figure" target="#fig_4">Figure 3c</ref>. (We show in Section 6.2 how to implement this predicate efficiently.) This additional effect is also not observable in a sequential execution, and therefore can be applied preventively.</p><p>After both solutions are presented to the programmer, he or she selects one of them, and the loop proceeds to find another conflicting pair. The conflict detection step now returns the pair (enroll (p, t), rem player (p)). The same invariant as before is violated, leading to the same pool of predicates for generating new operations.</p><p>Again, independently of the resolution selected for the first conflicting pair, two repairs are possible (as the conflict resolution policies do not restrict them). The first repair consists of extending the enroll (p, t) operation by setting the predicate player (p) to true and using the conflict resolution policy (player, Add-wins).</p><p>The second repair consists of extending the rem player (p) to force the disenrollment of the player p in every tournament and using the conflict resolution policy (enrolled, Rem-wins).</p><p>Although the most logical solution would appear to be selecting the first or second repair in both cases, it is important to note that any other combination also preserves the invariants. E.g., the programmer might decide that in case of a conflict between enroll (p, t) and rem tourn(t), the enroll will win, thus restoring the tournament (first repair), whereas in a conflict between enroll (p, t) and rem player (p), the removal of the player will win, leading to the disenrollment of the player in all tournaments (second repair).</p><p>A complete analysis is provided in a technical report <ref type="bibr" target="#b12">[15]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4">Correctness of referential integrity maintenance</head><p>We now show that the IPA approach preserves the referential integrity invariant on a generic relational database.</p><p>Consider the following definition of referential integrity: Now consider the modified operation C x with the same effects as the original operation, plus an additional effect to touch every row (y) of table Y . Further consider the use of Add-wins for table Y , where deletion of a row loses when executed concurrently with an insert or touch. With these modifications in place, the set of operations O = {C x , Dy} is now I-Confluent. To prove that, we are going to show that I holds for every possible execution of operations in O, even if we extend O with other operations that might affect I.</p><formula xml:id="formula_1">I = ∀xi ∈ X, ∃yi ∈ Y : xi.r = v ⇒ yi.s = v</formula><p>We note that C x can only execute initially in states where a row (y) exists in table Y . In these states, the concurrent execution of C x and any number of Dy operations always leads to a state where row (y) is present in table Y , since the use of Add-wins semantics for table Y guarantees that the touch of (y) in C x masks the deletion of (y) in Dy. This guarantees that the invariant I holds for O.</p><p>The invariant I continues to hold for the row added by C x even if more operations are added to O. Since Add-wins semantics are used for table Y , row (y) remains in table Y when C x is executed concurrently with any other operation, thus guaranteeing that referential integrity is maintained.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Numerical invariants</head><p>Numerical invariants are more difficult to maintain by modifying operations. For example, consider the invariant in line 4 of <ref type="figure">Figure 2</ref>, which defines a maximum capacity for a tournament. When the current number of enrolled players is Capacity − 1, two concurrent enrolls with different players lead to an invariant violation. To avoid this problem, a possible preventive modification is to disenroll some enrolled player when executing an enroll (p, t). (To be correct, different enrolls additionally need to disenroll different players.) Obviously, this is not reasonable in this application.</p><p>To circumvent this issue, we provide support for compensations <ref type="bibr" target="#b24">[27,</ref><ref type="bibr" target="#b39">42,</ref><ref type="bibr" target="#b47">50]</ref>. With compensations, the idea is to check that the precondition holds when executing the operation in the initial replica, and to check that the invariants hold when operations are integrated remotely or when the state is read. Implementations of compensation mechanisms typically require re-executing operations multiple times, or using a leader to order operations <ref type="bibr" target="#b47">[50]</ref>, to ensure that replicas converge after applying a compensation. We implement compensations without any of these limitations by relying on CRDT convergence rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Extending the analysis</head><p>To generate a compensation, instead of modifying the existing operations, the algorithm flags those operations as conflicting and generates a new operation with the additional effects to be executed when a conflict is detected. Since the new operation may conflict with other pre-existing operations, the analysis must check the execution of this operation against other operations.</p><p>The analysis can detect numerical invariant violations that involve comparison operations and arithmetic operators between multiple predicates. For example, an invariant Stock(x) ≥ 0 can be used to state that the stock of a product must be non-negative and the invariant CheckAccount(x) + Savings(x) ≥ 0 to specify that the overall balance of a client in a bank must be non-negative.</p><p>After detecting a conflict, the analysis suggests effects to repair the conflict. For instance, after identifying a conflict that violates the invariant of line 4, the compensation simply says that the value of that predicate must be decreased, i.e., that the number of players enrolled must decrease. It is up to the programmer to decide how to implement such compensation. In our example, a possible compensation is to disenroll the player and send him a notification.</p><p>The logic of compensations is application-dependent. Our tool identifies invariant violations to be fixed using compensations and lets the programmer decide how to fix the violation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Extending applications</head><p>Replicas might detect the invariant violation at any time by inspecting the local state and applying a compensation without coordinating with other replicas. The compensation operation is replicated, as any other operation, thus guaranteeing that all replicas converge to the same state. We explain how this works with an example.   Consider the invariant violation of exceeding the maximum number of allowed players in a tournament. When a violation is detected, some player will have to be disenrolled from the tournament. To fix this violation, the analysis suggests that the programmer decreases the number of players enrolled in the tournament.</p><p>Reanalyzing the new specification with this compensation raises new conflicts in the application. The compensation operation conflicts with operation do match(), as the players in a match must be part of the tournament. Therefore, the compensation must also cancel any match of the player that will be disenrolled. It is up to the programmer to decide which additional effects have to be applied as a consequence of the compensation (e.g., notify the player).</p><p>If multiple replicas concurrently detect the invariant violation, they might independently apply the compensation code. As a consequence, different players might be disenrolled in different replicas. In any case, as the effects of the compensation operations are propagated to all replicas, the system converges to a state where invariants are valid. The downside is that we might remove more players from the tournament than necessary. In our application, we use a deterministic rule to decide which player to disenroll to increase the likelihood of disenrolling the same player in all replicas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Code modification</head><p>After the IPA analysis returns the new specification of the application, the programmer must apply the proposed changes to the code of the application. In our prototype, the programmer is responsible for ensuring that the modified code follows the new specification, although code checking techniques could be used to ensure that the code matches the specification <ref type="bibr" target="#b23">[26]</ref>. <ref type="figure" target="#fig_7">Figure 4</ref> shows an excerpt of the code necessary to modify the tournament application in our prototype.</p><p>The first aspect to consider is how to store information and how to implement the conflict resolution policies. In our prototype, each predicate is represented with one or more set CRDTs: predicates player (p) and tournament(t) are represented by a set, where each element is a member of that set; predicate enrolled (p, t) is represented by a set for each tournament t and each element p is a member of that set. Setting a predicate to true corresponds to adding that element to the set and setting it to false removes it. The set CRDT used for each predicate depends on the conflict resolution policy in the new specification of the application.</p><p>In our prototype, using a given conflict resolution policy for a predicate is achieved by using the appropriate CRDT -in function ensureEnroll (line 1), the Add-wins set CRDT is used for both predicates player (p) and tournament(t).</p><p>The second aspect to consider is how to modify the original operations for implementing the new specification, with the additional effects. Instead of adding the code to the original functions, we used auxiliary functions that execute the additional effects and are called by the original operation. For example, function ensureEnroll is used to extend the enroll operation to guarantee that player p and tournament t are not concurrently removed (this corresponds to the first repair for both conflicts in the example of Section 5.2). The code simply uses the touch operation in the CRDTs for both players and tournaments, in combination with the Add-wins policy, to guarantee that player p and tournament t are not removed.</p><p>When using compensations, it is necessary to write a compensation function that runs if the invariant violation is detected at runtime. Function compensateEnrolled (line 7) shows the code for compensating an enroll when it is found that the capacity of the tournament has been exceeded. Besides canceling the enrollment (line 10), it is necessary to cancel any match that involves the player, both the matches that are already known at the replica (line 11) and those that might have been created concurrently (line 12).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Limitations</head><p>No repair found. A limitation of our approach is that the algorithm might not find any valid solution for a conflict between two operations, due to some previous decision by the programmer. Consider, e.g., an application with four predicates, A, B , C and D, connected by the following invariant A ⇒ B ⇒ C ⇒ D. For each predicate there are two operations defined, one that makes the predicate true (e.g., A t ) and another that makes it false (e.g., A f ) .</p><p>When running the IPA analysis for solving the conflict between operations C t and D f , the programmer may decide to repair the conflict by setting both predicates to false. To this end, operation D f is extended to make C = false, and the conflict resolution policy for C is Rem-wins.</p><p>Next, the conflict detection may identify the conflict between operations A t and B f . If the programmer decides to solve the conflict by making both predicates true, operation A t is extended with B = true and the conflict resolution policy for B is Add-wins.</p><p>The extended operation A t now conflicts with operation C f . However, there is no solution for solving this conflict. First, it is impossible to make predicates A, B and C true, as the conflict resolution for C is Rem-wins. Second, it is impossible to extend operation C f to make the predicate B false, as the conflict resolution for B is Add-wins.</p><p>In such cases, our tool checks if it would have been possible to solve the conflict by considering only the conflict resolution policies initially established by the programmer. If such a solution exists, it is presented to the programmer. If the programmer wants to use such a solution, because it makes sense for the semantics of the application being developed, he or she must run the analysis again, and use its output to make different decisions on the alternative repairs that are proposed. Otherwise, the pair is flagged as unsolvable and the algorithm continues, ignoring that pair in subsequent iterations. In that case, the execution of those operations must be controlled using an alternative mechanism <ref type="bibr" target="#b11">[14,</ref><ref type="bibr" target="#b34">37]</ref>. Supporting multiple applications and application evolution. Our approach can support multiple applications accessing the same database if the programmer provides a complete specification for all applications that use the database. For a running system, one can consider several scenarios of evolution: add new operations to an application; add new invariants to the database; add a new application that accesses the same database. In all cases, it is necessary to execute the IPA analysis again. If the operations and conflict resolution rules used in the original system remain unchanged, it is possible to evolve the system without having to stop it. Otherwise, it is necessary to stop the system.</p><p>A possible approach to tackle the system evolution more easily is to consider that, for every predicate defined in the system, there exists an operation to make the predicate true and an operation to make it false, even if those operations do not exist in the current application. Considering these operations, the IPA analysis will identify conflicts between the operations that exist in the application and these additional operations, and proposes alternative repairs to the programmer. With this approach, when evolving the system, if the database does not change and no additional invariant is added, as it is often the case when supporting a new application that uses the same database, the original operations will remain unchanged (as they already prevent any conflict that may occur). This approach has two main disadvantages. First, the operation may include additional effects that are of no use in the current application (as the conflicts they are solving do not occur). Second, the programmer may decide to use a repair approach that is not appropriate for the new operations, making this effort useless. Specification effort. The effort of writing specifications is arguably comparable to the effort of writing the code itself <ref type="bibr" target="#b40">[43]</ref>. We do not address this problem in this work. Previous research attempted to address this problem, proposing automatic feature extraction and code synthesis to aid the programmer in writing correct applications <ref type="bibr" target="#b41">[44,</ref><ref type="bibr" target="#b33">36,</ref><ref type="bibr" target="#b21">24,</ref><ref type="bibr" target="#b22">25,</ref><ref type="bibr" target="#b4">7]</ref>. Our approach could benefit from these complementary research efforts, not only for extracting the specification of the application from the code but also for making sure that the code of the modified version of the application matches the specification output by the IPA analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">IMPLEMENTATION</head><p>This section briefly describes the IPA prototype.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">IPA tool and database support</head><p>The IPA tool assists programmers to write invariant preserving applications. The tool receives as input an annotated Java interface with the operations and the invariants, as in the example of <ref type="figure">Figure 2</ref>, and an initial set of convergence rules. The tool runs the static analysis algorithm and outputs the modified specification of operations and auxiliary compensations, the conflict resolution rules for each predicate, and the set of unresolved conflicting pairs.</p><p>The tool uses the Z3 SMT solver <ref type="bibr" target="#b18">[21]</ref> to identify conflicting operations and propose modifications to operations. Boolean satisfiability is an NP-Complete problem, but modern SMT solvers can handle many instances of this problem efficiently, as shown by our performance evaluation. The algorithms and the tool are implemented using standard Java and the Java bindings for Z3.</p><p>Our prototype was implemented in Java, using Switfcloud <ref type="bibr" target="#b54">[57,</ref><ref type="bibr">3]</ref> as the underlying storage system. SwiftCloud provides highly available transactions, causal consistency and per-object conflict resolution based on CRDTs, allowing to easily add new data types.</p><p>We implemented several applications for the evaluation, derived from the specifications generated by our analysis. We use set CRDTs for storing the data represented by the predicates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">New CRDT designs</head><p>We now discuss the CRDTs used for supporting the resolutions proposed by IPA. A detailed specification of the data types is available in a separate document <ref type="bibr" target="#b45">[48]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">CRDTs with touch operations</head><p>When a modification requires that some predicate value is set to true, we need to ensure that the element that we are restoring is equal to the one that was observed.</p><p>To this end, we extended the Add-wins set CRDT with a touch operation. This operation simply updates the meta-data for the element in the set, with a new timestamp as if the object was created at that moment. If a concurrent remove of the same element is executed, the Add-wins policy ensures that the element will survive. Furthermore, all information associated with the element is preserved -for example, for a tournament, the element includes not only a simple identifier but a record with multiple fields.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">Remove with Wildcards</head><p>Some repairs require preventing the addition of any element that matches some condition -e.g., in the example of Section 5.2, there is a repair requiring to make enrolled ( * , t) = false, for any player and a given tournament. To implement this effect using a standard Rem-wins set CRDT, it would be necessary to execute a remove for all elements that could be concurrently added.</p><p>Doing this would be impractical because the set of possible elements is large. Instead, we created CRDTs that support wildcard values for the remove operation. For instance, the wildcard "*" represents all possible elements in the domain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3">Compensation CRDTs</head><p>For some invariants, it is possible to encapsulate the logic for detecting conflicts and applying the compensations automatically. Consider the invariant #enrolled (p, t) ≤ Capacity. We use a set to store the information about players enrolled in a tournament. To ensure that the application is always consistent, whenever the application accesses the set, the object automatically verifies if its state is consistent, and applies the compensation if necessary.</p><p>We implemented Limited Size Set CRDTs that allow the programmer to define the constraint that must be maintained, and the compensation to execute when the constraint is violated. Whenever the object is read, the code is executed automatically, ensuring that any observed state is consistent. The effects of the compensation, in case it is executed, are committed in the enclosing transaction.</p><p>To select the elements to be removed in the compensation it is possible to leverage the history information of the set to remove the last elements added to the set. This does not prevent more elements than necessary from being removed, because the state of replicas might diverge, but it reduces the chance of that happening.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">EVALUATION</head><p>Our evaluation intends to answer the following questions: (i) What classes of invariants and applications can be handled by our approach?</p><p>(ii) What is the scalability of the static analysis process? (iii) How does the performance of modified applications compare to other solutions?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Invariants covered by IPA</head><p>This section surveys the invariants covered by our approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Classes of invariants</head><p>Prior work has analyzed invariants used in real applications <ref type="bibr" target="#b7">[10,</ref><ref type="bibr" target="#b6">9,</ref><ref type="bibr" target="#b34">37]</ref>. <ref type="table" target="#tab_4">Table 1</ref> summarizes whether these invariants are I-Confluent <ref type="bibr" target="#b6">[9]</ref> or can be made I-Confluent by using IPA.</p><p>Sequential identifiers: Sequential identifiers are useful to enforce a total order of elements. In general, generating these identifiers requires coordination to avoid collisions. No solution based on weak consistency can maintain this invariant. However, it has been shown that, in most cases, applications could easily replace the use of sequential identifiers by unique identifiers <ref type="bibr" target="#b5">[8,</ref><ref type="bibr" target="#b48">51]</ref>.</p><p>Unique identifiers: Unique identifiers can be preserved without coordination, and as such are I-Confluent. Unique identifiers do not provide a sequential order, but can still provide a total order of identifiers compatible with the happens-before relation.</p><p>Numerical invariants: Numerical invariants assert conditions involving numerical predicates (e.g., p(x) &lt; k). In general, preserving these invariants requires coordination. However, as it has been shown, it is possible to enforce some constraints on top of weak consistency by relying on escrow techniques <ref type="bibr" target="#b13">[16,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b38">41]</ref>. IPA allows to maintain these invariants using compensations as long as the application is compatible with using this approach. In TPC-C/W we can use compensations to replenish the stock, for instance.</p><p>Aggregation constraint: Imposing a bound on the size of a collection, e.g., limiting the players enrolled in a tournament, can be addressed using a numerical invariant over a predicate that represents the size of the collection, thus sharing its properties.</p><p>Aggregation inclusion: Ensuring that an element is eventually added or removed from a collection is I-Confluent, provided no dependencies to other objects exist. If that is not the case, referential integrity might be required.</p><p>Referential integrity: Preserving relations and dependencies among objects, such as foreign keys in relational databases and references to keys in key-value stores, is not I-Confluent. IPA fully supports this invariant, as exemplified throughout the paper.</p><p>Disjunctions: Applications often specify that one of several conditions must be met by using a disjunction. IPA can address this type of invariant by extending an operation to ensure that the disjunction is always true. This is an extension of the mechanism for supporting referential integrity, as in this case there might be several alternative conditions that restore the validity of the invariant.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Invariants in applications</head><p>We now analyze how IPA can address the invariants of some selected applications (summarized in <ref type="table" target="#tab_4">Table 1</ref>). These application are representative of general OLTP workloads.</p><p>Tournament: This application manages the information for an on-line game and showcases most of the invariants that our solution can address. It is based on an application used in prior work <ref type="bibr" target="#b26">[29,</ref><ref type="bibr" target="#b11">14]</ref> with a few new constraints. For this application, IPA is capable of proposing multiple alternative resolutions that either reconstruct broken dependencies, or clear them, to avoid inconsistencies due to concurrent executions, as discussed throughout this paper.</p><p>Twitter: We implemented a simple Twitter clone that relies heavily on referential integrity to implement user timelines and maintain subscription information. When some user tweets, we write those tweets to the timelines of the followers. This leads to consistency issues when tweets and users are removed concurrently with tweeting. We implemented two versions, using the Add-wins and the Rem-wins policy to solve conflicts, respectively. For example, if a user tweets and his or her account is concurrently removed, for the Add-wins version the user and tweets are restored, whereas for Rem-wins the user and tweets are removed. Other conflicts are solved similarly.</p><p>Ticket: This application, based on FusionTicket <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b53">56]</ref>, manages ticket reservations. The main invariant is that tickets for events cannot be oversold. We use the Limited Size Set CRDT to cancel a ticket sale and reimburse the customer when tickets are oversold. The transfer of money to the account of the customer crosses the boundaries of the system and therefore must use a different mechanism (e.g., a message queue). TPC-W and TPC-C: These standard database benchmarks overlook some aspects of real-world applications, such as having operations to manage product listings. In our specification, we extended these applications to include such operations, which introduced referential integrity constraints. To implement the inventory size threshold we used compensations to increase the stock (in accordance with the specification). An alternative would be to cancel the oversold purchases, as in the previous example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.3">Summary</head><p>The types of invariants we support <ref type="table" target="#tab_4">(Table 1)</ref> are common in many applications, as previously shown <ref type="bibr" target="#b7">[10]</ref>. The examples we discussed show that our language is expressive enough to address complex applications, including typical relational database applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Off-line analysis performance</head><p>We evaluate the scalability of the proposed approach, by analyzing the execution time of the IPA analysis as the size and complexity of the application increases using a micro-benchmark.</p><p>To vary the size of the application, we vary the number of predicates. For each predicate, there are two operations, one that makes the predicate true and another that makes the predicate false. Thus, for 10 predicates, we have 20 operations. For all predicates, we use the Add-wins conflict resolution policy.</p><p>All predicates belong to some invariant clause. To vary the complexity, we vary the number of predicates that are connected by invariants. For a chain size of one, the invariants defined connect only pairs of predicates: P1 ⇒ P2, P3 ⇒ P4, P5 ⇒ P6, etc. For a chain size of two, the invariants connect groups of three predicates: P1 ⇒ P2 and P2 ⇒ P3, P4 ⇒ P5 and P5 ⇒ P6, etc. Increasing the size of the chain, increases both the number of clauses in the invariant and the average number of effects in each operation for a specification without conflicts -e.g., with a chain of size one, the operation that makes P1 true only needs to make P2 also true, while with a chain of size two it also needs to make P3 true.</p><p>The results were obtained in a laptop, running MacOS 10.13.6, with an Intel i7 2.8 GHz Quad-Core processor and 16GB of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Conflict detection</head><p>We start by evaluating the time to detect a conflict. The worst case scenario is when the analysis finds the conflict in the last pair that is checked. To approximate this, we run our tool with a correct specification, so that the algorithm analyzes all pairs of operations. <ref type="figure">Figure 5</ref> shows the execution time (in seconds) for different configurations of the benchmark, with different lines corresponding to increasing the number of operations in the chain.</p><p>We first observe that, as expected, the execution time of the algorithm grows quadratically, due to testing all pairs of operations. Second, we observe that the cost of testing all pairs dominates the cost of the algorithm, since changing the size of the chain does not impact the results significantly. The results show that the overall execution time is reasonable for an offline process, as testing all combinations of pairs of 100 operations takes less than 100 seconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.2">Conflict repair</head><p>Our second experiment evaluates the time to repair conflicts. To this end, from a specification that is invariant-preserving, we have removed the additional effects that avoid conflicts in a single operation, selecting one of the operations with more additional effects (e.g., in the chain of size two, from the operation that makes P1 true, we removed the changes to P2 and P3). <ref type="figure">Figure 6</ref> presents the sum of the time spent in proposing repairs until a correct solution is generated (this excludes the time to detect conflicts). As expected, when the chain is longer, our tool takes more time to find a correct solution, as it repairs the conflicts one at a time. Still, in our configurations, this time is low.</p><p>These results show that the running time of our tool is dominated by the time to detect conflicts and that this time is reasonable for an offline process, making our approach practical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Runtime performance</head><p>In this section, we compare the performance of applications modified using our approach against alternative solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.1">System configurations</head><p>Our evaluation was performed in a geo-replicated setting on Amazon EC2. The database deployment consists of three servers running in three geographical regions (US-WEST, US-EAST and EU-IE). The table below shows the latency between each region.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RTT (ms) US-East US-West US-West -EU-IE 93 161</head><p>The application server is co-located with the storage system of each region. We use SwiftCloud to implement all different approaches that we evaluate. Clients are installed in other machines in the same availability zones as the corresponding closest servers.</p><p>Performance of applications is compared with the following alternative approaches:</p><p>Causal Consistency (Causal): This configuration uses the original applications running with causal consistency, which does not maintain invariants for conflicting operations.</p><p>Strong Consistency (Strong): All updates are forwarded to the US-EAST replica to enforce serialization. This minimizes the average latency for updates.</p><p>Invariant violation avoidance (Indigo <ref type="bibr" target="#b11">[14]</ref>): Applications modified to use the efficient coordination mechanisms proposed in Indigo [2] to prevent invariant violations. Conflicting operations need to acquire reservations to safely execute operations. Each set of conflicting operations coordinated using different reservations, and each reservation can be shared by multiple replicas, allowing a high level of concurrency.</p><p>Invariant Preserving Applications (IPA): Applications are modified using our IPA approach, which maintains invariants without coordination, on top of Causal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.2">Throughput and latency</head><p>We evaluate the scalability of each configuration by measuring the latency and throughput with different loads on the system, using the Tournament application. The workload comprises 35% of write operations, and the initial database contains 1000 players and 100 tournaments. All operations are conflicting in the original application. In the IPA modified version, all operations are I-Confluent using a mix of conflict resolution policies. In Indigo, every pair of operations is protected by a different reservation.</p><p>To test the scalability of the system, we increase the number of clients contacting each server by running extra client threads until peak throughput is achieved. <ref type="figure" target="#fig_6">Figure 7</ref> shows that Strong presents the highest average latency, which is a consequence of having 2 3 of operations being forwarded to a remote server. Even if it would be possible to improve the scalability of our implementation, this figure highlights that even when contention is low, the average latency is already much higher than with weak consistency approaches. Causal shows the best scalability with the lowest latency. Our approach, IPA, performs slightly worse than Causal, as additional updates need to be executed to preserve application invariants. In the Causal version, concurrent updates may lead to invariant violation.</p><p>When compared to Indigo, our approach performs slightly better. The reason for this is that updates in Indigo need to acquire reservations for coordinating the execution of concurrent updates, which is more costly than the additional updates in the IPA version. The advantage is small because reservations are exchanged among replicas infrequently after they are acquired. Additionally, as many reservations can be shared, they allow a high degree of concurrency. <ref type="figure">Figure 8</ref> presents the latency for the write operations and highlights more clearly the differences between the configurations. We omit the Strong column. The average latency of operations in Indigo is higher than the latency for IPA or Causal and also exhibits a higher standard deviation. Both are explained by the occasional need for Indigo replicas to trade reservations. Compared to Causal, the latency of write operations is only slightly higher in IPA, which is due to the extra updates executed. We further study the overhead associated with executing extra effects in Section 7.3.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.3">Comparing different conflict resolution schemes</head><p>We implemented Twitter using Add-wins and Rem-wins strategies to compare the costs of each approach. The initial database contains 1000 users, and 96% of the operations are writes. <ref type="figure">Figure 9</ref> shows the latency of each operation for the different version. The Add-wins version has a higher latency for operations that create tweets (tweet and retweet). This overhead is due to the additional effect of touching the user, to ensure that when a user tweets, or retweets, he or she will not be removed concurrently.</p><p>The Rem-wins version has a higher latency for remove operations, due to the additional effects. The delete tweet operation needs to remove the tweet from all timelines that have the tweet. The remove user has a small overhead, as it only has to issue a remove with a wildcard in the followers and to set a compensation for removing tweets in the user object -when user u1 reads a timeline, the application checks, for each tweet, that its author, u2, was removed, triggering a compensation to remove the tweets from the timeline of u1 in this case. This also leads to a slight overhead in the read timeline operation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.4">Scalability of compensations</head><p>We evaluate the scalability of the compensation mechanism implemented in the Limited Size Set CRDT with the Ticket application, by increasing contention. The initial database has 500 flights and 10000 customers, and all operations in the workload read and update the database, with reads triggering the execution of compensations when a flight is overbooked. <ref type="figure" target="#fig_0">Figure 10</ref> presents the performance with an increasing load. The red dots in the figure indicate the average number of invariant violations that were observed at that throughput, when using Causal. This confirms the intuition that as contention rises, the divergence window grows larger, increasing the chance for invariant violation. In Causal, this exposes the application to consistency anomalies, while in IPA executing compensations preserves invariants at all times. As expected, compensations incur on some overhead, but still provide latency comparable to Causal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.5">Microbenchmarks</head><p>IPA avoids invariant violations by executing extra updates in one or more objects. In this section, we evaluate the overhead of adding additional effects to operations. We analyze the impact of executing increasingly more updates in comparison to the costs of executing the original operation in strong consistency and Indigo. These microbenchmark use a Set CRDT to store information.</p><p>Operations on a single object: We measure the speedup of an application modified with IPA versus the original operation running on Strong. <ref type="figure" target="#fig_0">Figure 11 (top)</ref> shows that the original operation is about 28× faster in IPA than in Strong. Adding more updates to this operation makes the speedup decrease. When we execute 2048 updates to a single object, the average latency is still about 40ms.</p><p>Operations over multiple objects: Executing updates on a single object imposes a low overhead on the system, because the object is read and written to storage only once and subsequent updates only impose processing costs. Now we evaluate the overhead when the additional effects of modified operations update multiple objects.</p><p>The original application reads a varying number of objects to check some condition and then executes a single write operation to an object. The modified application checks the same condition, but executes a write for each object. <ref type="figure" target="#fig_0">Figure 11</ref> (bottom) shows performance dropping faster than when executing updates over single objects. At 64 objects, it starts to pay off to switch to Strong.</p><p>In practice, in the evaluated applications, we require only a few extra updates per object over a small number of objects. In Twitter, which needs to execute more writes due to our implementation of the timeline, we were able to execute them lazily via compensations.</p><p>Comparison with Indigo: In Indigo <ref type="bibr" target="#b11">[14]</ref>, operations might execute locally if the replica holds some specific reservation. Multiple operations might be able to execute concurrently at different replicas if all of them can share the same reservation. If a replica requires some reservation that is being used exclusively, the replica must request remote replicas to release the reservation, before acquiring it. This approach only avoids coordination when a replica holds the necessary reservations to execute the operation. Thus, the latency of an application depends on the contention for obtaining reservations.</p><p>In this experiment, we evaluate the impact of varying the percentage of operations that compete to acquire opposing reservations. We compare the performance of this solution against executing the same operation in IPA. <ref type="figure" target="#fig_0">Figure 12</ref> shows that the performance of IPA is equivalent to Indigo with no contention for reservations, and that the latency of Indigo rises steadily as contention increases.</p><p>Despite the overhead for executing the additional effects, IPA provides a predictable latency of operations, which is not the case for Indigo, whose operations latency depend on the current distribution of reservations. Furthermore, our approach is fault-tolerant as a client can execute operations as long as it can access a single server. In Indigo, if a server that holds the reservation needed to execute some operation becomes unavailable, the operation cannot execute.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Achieving low latency, high availability and data consistency in distributed systems is difficult, as postulated in the CAP theorem <ref type="bibr" target="#b25">[28]</ref>. In recent years, researchers and practitioners have studied the trade-offs in distributed systems to provide the best consistency guarantees for different types of applications <ref type="bibr" target="#b17">[20,</ref><ref type="bibr" target="#b19">22,</ref><ref type="bibr" target="#b36">39,</ref><ref type="bibr" target="#b5">8,</ref><ref type="bibr" target="#b34">37,</ref><ref type="bibr" target="#b11">14]</ref>.  Systems that ensure strong consistency <ref type="bibr" target="#b17">[20,</ref><ref type="bibr" target="#b55">58,</ref><ref type="bibr" target="#b20">23,</ref><ref type="bibr" target="#b30">33]</ref> require coordination across replicas, which is expensive in geo-replicated scenarios. In Megastore <ref type="bibr" target="#b10">[13]</ref>, data is partitioned at a fine granularity to achieve low latency, while MDCC <ref type="bibr" target="#b30">[33]</ref> exploits commutativity and protocol optimizations to improve performance. Spanner <ref type="bibr" target="#b17">[20]</ref> and Farm <ref type="bibr" target="#b20">[23]</ref> harness custom hardware to improve performance.</p><p>Systems that use weak consistency are widely deployed in the real-world <ref type="bibr" target="#b44">[47,</ref><ref type="bibr" target="#b31">34]</ref>, but can be difficult to use <ref type="bibr" target="#b7">[10]</ref>. Many systems provide causal consistency coupled with object convergence and transactions <ref type="bibr" target="#b36">[39,</ref><ref type="bibr" target="#b54">57,</ref><ref type="bibr" target="#b37">40,</ref><ref type="bibr" target="#b5">8]</ref>, which all can be implemented efficiently without hindering the availability of the system. Convergent data types <ref type="bibr" target="#b42">[45]</ref> provide automatic replica convergence, which lessens the programming effort in these systems. However, data type convergence alone cannot prevent invariant violations involving multiple objects. To mitigate the problem, RedBlue <ref type="bibr" target="#b34">[37]</ref> and Walter <ref type="bibr" target="#b46">[49]</ref> provide support for executing operations under weak or strong consistency to allow fast operations when invariants are not at risk, and consistent operations otherwise. Sieve <ref type="bibr" target="#b33">[36]</ref> and Blazes <ref type="bibr" target="#b4">[7]</ref> address the problem of automating the use of the most appropriate consistency alternative, while Indigo <ref type="bibr" target="#b11">[14]</ref>, Olisipo <ref type="bibr" target="#b35">[38]</ref>, Lucy <ref type="bibr" target="#b51">[54]</ref>, and the Homeostasis protocol <ref type="bibr" target="#b41">[44]</ref> try to minimize the use of the strong consistency path. Despite improving the latency of operations in the general case, systems that depend on coordination to execute some operations may still become unavailable and exhibit high latency. IPA completely avoids the drawbacks of coordination, while being able to preserve a wide range of invariants.</p><p>Helland and Campbell have suggested that applications should handle invariant violations as part of the application logic, as an alternative to executing operations under strong consistency to prevent violations <ref type="bibr" target="#b28">[31]</ref>. The idea of compensations <ref type="bibr" target="#b24">[27]</ref> is to execute operations optimistically and explicitly rollback the effects when conflicts are detected. A few systems have explored this model. In PLANET <ref type="bibr" target="#b39">[42]</ref>, transactions execute speculatively, allowing the system to provide the control back to the client before the transaction commit confirmation arrives. In Bayou <ref type="bibr" target="#b47">[50]</ref>, transactions commit locally and remain in a tentative state, until all replicas agree on the ordering of operations. Existing systems that use compensations still use some form of coordination to commit transactions. Our approach departs from this model by modifying the operations to ensure they can always commit locally, while preserving invariants. We show that our approach does not modify the semantics of operations when no conflicting concurrent operations execute.</p><p>Recent papers focused on proving correctness of distributed systems <ref type="bibr" target="#b27">[30,</ref><ref type="bibr" target="#b52">55]</ref>. These proposals complement ours, as they focus on attesting if implementations conform to some specification, whereas we aim to provide a methodology for implementing correct applications on top of the assumptions of our chosen consistency model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSION</head><p>In this paper, we proposed a novel approach for supporting correct and highly available applications on top of weak consistency. By extending operations with additional effects, we can ensure invariant preservation at all times with sensible semantics. Our IPA analysis and tool assist the programmer via static analysis to identify which operations might lead to an invariant violation, when executed concurrently, and by suggesting modifications to the operations.</p><p>Our experimental evaluation shows that the static analysis can handle large applications in reasonable time for an offline process, and that the modified applications have similar performance to their unmodified counterparts that do not preserve invariants.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Concurrent execution of enroll (p, t) and rem tourn(t) leads to an invariant violation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>operation o b , executed initially in database snapshot S b , oa ≺ o b , iff oa ∈ Ops(S b ). Operations oa and o b are concurrent, oa o b iff oa ≺ o b ∧o b ≺ oa.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>THEOREM 1 .</head><label>1</label><figDesc>Given a set of commutative operations O and the happens-before order among them, ≺, if for any operation o and admissible state S of o, o(S) is also an I-valid state, then O is an I-Confluent set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>7 8 9 @ 10 RESULT 11 @ 13 RESULT 14 @ 18 @ 21 @ 22 @ 25 @ 26 @ 29 @ 32 @ 36 @Figure 2 :</head><label>791011131418212225262932362</label><figDesc>public interface TournamentApp { // Operations effects and signatures True("player(p)") add player(Player p); False("player(p)") rem player(Player p); True("tournament(t)") RESULT add tourn(Tournament t); False("tournament(t)") RESULT rem tourn(Tournament t); 20 True("enrolled(p, t )") Inc("#enrolled( * , t )") 23 RESULT enroll(Player p, Tournament t) ; 24 False("enrolled(p, t )") Dec("#enrolled( * , t)") 27 RESULT disenroll(Player p, Tournament t) ; True("active(t)") RESULT begin tourn(Tournament t); True("finished(t)") @False("active( t )") RESULT finish tourn(Tournament t) ; True("inMatch(p, q, t)") RESULT do match(Player p, Player q, Tournament t) ; } Tournament application specification.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Analysis of conflicts and resolutions of a pair of operations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1</head><label></label><figDesc>void ensureEnroll ( String p, String t ) { AddWinsSet tournamentIndex = getCRDT(TOUR IDX, ADD WINS); AddWinsSet playerIndex = getCRDT(PLR IDX, ADD WINS);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>7</head><label>7</label><figDesc>void compensateEnrolled( String p, String t ) { AddWinsSet enrolled = getCRDT(ENROLLED PFX + t, ADD WINS); RemWinsSet matches = getCRDT(MATCHES PFX + t, REM WINS); enrolled .remove(p); matches.rem(new Match(p, " * ", t )); matches.touch rem(new Match(p, " * ", t )); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Auxiliary functions for implementing the modified version of the Tournament application.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Execution time of analysis with no conflict. Time to generate repairs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :Figure 8 :Figure 9 :</head><label>789</label><figDesc>Peak throughput for Tournament. Latency of individual operations in Tournament. Latency of individual operations in Twitter.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :Figure 11 :Figure 12 :</head><label>101112</label><figDesc>Peak throughput for Ticket benchmark. Red dots indicate number of invariant violations observed during runtime. Speedup of executing multiple writes in IPA versus Strong. Latency of operations with varying percentage of reservation types in comparison to no reservations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Algorithm 1 IPA algorithm and main functions. IPA main loop. 1: function IPA(I , Ops, CR) 2: while existsConflictingPair(I , Ops, CR) do 3: opPair ← findConflictingPair(I , Ops, CR) 4: (newPair ,CR)← repairConflicts(I , opPair , CR) 5: Ops.replace(opPair , newPair ) 6: return (Ops,CR) Checks if a pair is conflicting. [invoked in line 17] 7: function ISCONFLICTING(I , OpPair , CR) 8: OpPair ), CR) IPA algorithm for repairing conflicts. [invoked in line 4] 11: function REPAIRCONFLICTS(I , OpPair , CR) 12:</figDesc><table><row><cell></cell><cell>if opposingEffects(OpPair ) then</cell></row><row><cell>9:</cell><cell>(OpPair , CR) ← apply(OpPair , CR)</cell></row><row><cell>10:</cell><cell>return (SMTCheckConflicting(I , sols ← ∅</cell></row><row><cell>13:</cell><cell>invPreds ← {getPreds(i) | i ∈ invClauses(I , opPair )}</cell></row><row><cell>14:</cell><cell>newOpPairsList ← generate(invPreds, I , OpPair )</cell></row><row><cell>15:</cell><cell>for newOpPair ∈ newOpPairsList do</cell></row><row><cell>16:</cell><cell>if not isPairSubset(newOpPair , sols) then</cell></row><row><cell>17:</cell><cell>(result,newCR)← isConflicting(I ,newOpPair ,CR)</cell></row><row><cell>18:</cell><cell>if result == FALSE then</cell></row><row><cell>19:</cell><cell>sols ← sols ∪ {(newOpPair , newCR)}</cell></row><row><cell>20:</cell><cell>return USERPickResolution(sols)</cell></row><row><cell></cell><cell>New operation generation. [invoked in line 14]</cell></row><row><cell cols="2">21: function GENERATE(invPreds , I , (op1 , op2 ))</cell></row><row><cell>22:</cell><cell>seed ← {p(true), p(false) | p ∈ invPreds}</cell></row><row><cell>23:</cell><cell></cell></row></table><note>effectSets ← powerSetFiltered(seed)</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>, which says that for every row of table X that has value v for column r, there must be a row intable Y with value v for column s. Without loss of generality, we consider the case where table Y has a single column and table X has two columns, where the second one refers to a row in table Y . Operation Cx creates a new row (x, y) in a table X, if and only if there is a row in table Y with value y. Operation Dy deletes row (y) in table Y , if and only if there is no row in table X, where the second column has the value y.Let SCD be the set of admissible states where the preconditions of both Cx and Dy hold. Consider the state s where table X is empty and table Y contains a single row with value (y). State s is an admissible state for both Cx and Dy and thus it is possible to concurrently execute Cx and Dy. However, as I(Cx(Dy(s))) = false, the set of operations {Cx, Dy} is not I-Confluent.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>Common classes of invariants in applications.</figDesc><table><row><cell>Inv. Type</cell><cell cols="6">I-Conf. IPA TPC Tour Ticket Twitter</cell></row><row><cell>Sequential id.</cell><cell>No</cell><cell>No</cell><cell cols="2">Yes -</cell><cell>-</cell><cell>-</cell></row><row><cell>Unique id.</cell><cell>Yes</cell><cell>Yes</cell><cell cols="2">Yes Yes</cell><cell>Yes</cell><cell>Yes</cell></row><row><cell>Numerical inv.</cell><cell>No</cell><cell cols="3">Comp. Yes -</cell><cell>-</cell><cell>-</cell></row><row><cell>Aggreg. const.</cell><cell>No</cell><cell cols="2">Comp. -</cell><cell>-</cell><cell>-</cell><cell>-</cell></row><row><cell>Aggreg. incl.</cell><cell>Yes</cell><cell>Yes</cell><cell cols="2">-Yes</cell><cell>-</cell><cell>-</cell></row><row><cell>Ref. integrity</cell><cell>No</cell><cell>Yes</cell><cell cols="2">Yes Yes</cell><cell>-</cell><cell>Yes</cell></row><row><cell>Disjunctions</cell><cell>No</cell><cell>Yes</cell><cell cols="2">-Yes</cell><cell>-</cell><cell>-</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers for their comments that helped improving the paper. This work was partially supported by EU H2020 LightKone project (732505), and FCT/MCTES grants SFRH/ BD/87540/2012, UID/CEC/04516/2013, UID/CEC/50021/2013, Lisboa-01-0145-FEDER-032662 /PTDC/CCI-INF/32662/2017, and PTDC/CCI-INF/32081/2017. Computing resources were provided by an Amazon Web Services (AWS) in Education Research Grant.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<ptr target="http://www.fusionticket.org/" />
		<title level="m">Fusion Ticket</title>
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Akka</surname></persName>
		</author>
		<ptr target="https://doc.akka.io/docs/akka/current/distributed-data.html" />
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Cure: Strong semantics meets high availability and low latency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D</forename><surname>Akkoorath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">Z</forename><surname>Tomsic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bravo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Crain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bieniusa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th IEEE International Conference on Distributed Computing Systems (ICDCS 2016)</title>
		<meeting>the 36th IEEE International Conference on Distributed Computing Systems (ICDCS 2016)<address><addrLine>Nara, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-06" />
			<biblScope unit="page" from="405" to="414" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">ChainReaction: A Causal+ Consistent Datastore Based on Chain Replication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Almeida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leitão</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Rodrigues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 8th ACM European Conference on Computer Systems, EuroSys &apos;13</title>
		<meeting>8th ACM European Conference on Computer Systems, EuroSys &apos;13<address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="85" to="98" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Blazes: Coordination analysis for distributed programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Alvaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE 30th International Conference on Data Engineering</title>
		<meeting>the IEEE 30th International Conference on Data Engineering<address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-04-04" />
			<biblScope unit="page" from="52" to="63" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Highly available transactions: Virtues and limitations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bailis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Davidson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Coordination avoidance in database systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bailis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="185" to="196" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Feral Concurrency Control: An Empirical Investigation of Modern Application Integrity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bailis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;15</title>
		<meeting>the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;15<address><addrLine>Melbourne, Victoria, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1327" to="1342" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Scalable Atomic Visibility with RAMP Transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bailis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fekete</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2014 ACM SIGMOD Conference Conference on Management of Data, SIGMOD &apos;14</title>
		<meeting>2014 ACM SIGMOD Conference Conference on Management of Data, SIGMOD &apos;14<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="27" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Bolt-on Causal Consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bailis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ghodsi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Stoica</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;13</title>
		<meeting>the 2013 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;13<address><addrLine>New York, New York, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="761" to="772" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Megastore: Providing Scalable, Highly Available Storage for Interactive Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Khorlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-M</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Yushprakh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Innovative Data system Research (CIDR)</title>
		<meeting>the Conference on Innovative Data system Research (CIDR)</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="223" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Putting Consistency Back into Eventual Consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Balegas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duarte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Najafzadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth European Conference on Computer Systems, EuroSys &apos;15</title>
		<meeting>the Tenth European Conference on Computer Systems, EuroSys &apos;15<address><addrLine>Bordeaux, France</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">IPA: Invariant-preserving Applications for Weakly-consistent Replicated Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Balegas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duarte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<idno>abs/1802.08474</idno>
		<imprint>
			<date type="published" when="2018" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Extending Eventually Consistent Cloud Databases for Enforcing Numeric Invariants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Balegas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Serra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duarte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 34th IEEE Symposium on Reliable Distributed Systems (SRDS)</title>
		<meeting>the 34th IEEE Symposium on Reliable Distributed Systems (SRDS)<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-09" />
			<biblScope unit="page" from="31" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Basho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Riak</surname></persName>
		</author>
		<ptr target="http://basho.com" />
		<imprint>
			<date type="published" when="2017-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Under the Hood: Redis CRDTs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Biyikoglu</surname></persName>
		</author>
		<ptr target="https://goo.gl/tGqU7h" />
		<imprint>
			<date type="published" when="2018-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Logic and Lattices for Distributed Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Conway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Marczak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Alvaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Maier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 3rd ACM Symposium on Cloud Computing, SoCC &apos;12</title>
		<meeting>the 3rd ACM Symposium on Cloud Computing, SoCC &apos;12<address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="1" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Spanner: Google&apos;s Globally-distributed Database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hochschild</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kanthak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kogan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Melnik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mwaura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Nagle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Rolig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Saito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Szymaniak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Woodford</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 10th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;12</title>
		<meeting>10th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;12<address><addrLine>Hollywood, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="251" to="264" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Z3: An Efficient SMT Solver</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>De Moura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Bjørner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS&apos;08/ETAPS&apos;08</title>
		<meeting>the 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems, TACAS&apos;08/ETAPS&apos;08<address><addrLine>Budapest, Hungary</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="337" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dynamo: Amazon&apos;s Highly Available Key-value Store</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Decandia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hastorun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jampani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Kakulapati</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pilchin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sivasubramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Vosshall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Vogels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st ACM SIGOPS Symposium on Operating Systems Principles, SOSP &apos;07</title>
		<meeting>the 21st ACM SIGOPS Symposium on Operating Systems Principles, SOSP &apos;07<address><addrLine>Stevenson, Washington, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="205" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">No Compromises: Distributed Transactions with Consistency, Availability, and Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dragojević</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Narayanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">B</forename><surname>Nightingale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Renzelmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shamis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Badam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, SOSP &apos;15</title>
		<meeting>the 25th Symposium on Operating Systems Principles, SOSP &apos;15<address><addrLine>Monterey, California</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="54" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">The Daikon System for Dynamic Detection of Likely Invariants</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Perkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mccamant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Pacheco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Tschantz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xiao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science of Computer Programming</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">1-3</biblScope>
			<biblScope unit="page" from="35" to="45" />
			<date type="published" when="2007-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Houdini, an Annotation Assistant for ESC/Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium of Formal Methods Europe on Formal Methods for Increasing Software Productivity, FME &apos;01</title>
		<meeting>the International Symposium of Formal Methods Europe on Formal Methods for Increasing Software Productivity, FME &apos;01<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="500" to="517" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Extended Static Checking for Java</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">R M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lillibridge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Nelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Stata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, PLDI &apos;02</title>
		<meeting>the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, PLDI &apos;02<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="234" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Garcia-Molina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Salem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sagas</surname></persName>
		</author>
		<title level="m">Proceedings of the 1987 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;87</title>
		<meeting>the 1987 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;87<address><addrLine>San Francisco, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1987" />
			<biblScope unit="page" from="249" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Brewer&apos;s Conjecture and the Feasibility of Consistent, Available, Partition-tolerant Web Services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gilbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGACT News</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="51" to="59" />
			<date type="published" when="2002-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Cause I&apos;m Strong Enough: Reasoning About Consistency Choices in Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gotsman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ferreira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Najafzadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL &apos;16</title>
		<meeting>the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL &apos;16<address><addrLine>St. Petersburg, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="371" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">IronFleet: Proving Practical Distributed Systems Correct</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hawblitzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kapritsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Lorch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">L</forename><surname>Roberts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Setty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Zill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Symposium on Operating Systems Principles, SOSP &apos;15</title>
		<meeting>the 25th Symposium on Operating Systems Principles, SOSP &apos;15<address><addrLine>Monterey, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1" to="17" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Building on quicksand</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Helland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Campbell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Online Proceedings of CIDR 2009 Fourth Biennial Conference on Innovative Data Systems Research</title>
		<meeting><address><addrLine>Asilomar, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Disciplined Inconsistency with Consistency Types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Holt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bornholt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Ports</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Oskin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ceze</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th ACM Symposium on Cloud Computing, SoCC &apos;16</title>
		<meeting>the 7th ACM Symposium on Cloud Computing, SoCC &apos;16<address><addrLine>Santa Clara, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="279" to="293" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">MDCC: Multi-data Center Consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kraska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 8th ACM European Conference on Computer Systems, EuroSys &apos;13</title>
		<meeting>8th ACM European Conference on Computer Systems, EuroSys &apos;13<address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="113" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Cassandra: A Decentralized Structured Storage System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lakshman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIGOPS Oper. Syst. Rev</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="2010-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Time, Clocks, and the Ordering of Events in a Distributed System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Automating the Choice of Consistency Levels in Replicated Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Leitão</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vafeiadis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 USENIX Annual Technical Conference (USENIX ATC 14)</title>
		<meeting>the 2014 USENIX Annual Technical Conference (USENIX ATC 14)<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014-06" />
			<biblScope unit="page" from="281" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Making Geo-replicated Systems Fast As Possible, Consistent when Necessary</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Porto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 10th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;12</title>
		<meeting>10th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;12<address><addrLine>Hollywood, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="265" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Fine-grained consistency for geo-replicated systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rodrigues</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2018 USENIX Annual Technical Conference (USENIX ATC 18)</title>
		<meeting>the 2018 USENIX Annual Technical Conference (USENIX ATC 18)<address><addrLine>Boston, MA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2018" />
			<biblScope unit="page" from="359" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Don&apos;t Settle for Eventual: Scalable Causal Consistency for Wide-area Storage with COPS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Andersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Symposium on Operating Systems Principles, SOSP &apos;11</title>
		<meeting>the 23rd ACM Symposium on Operating Systems Principles, SOSP &apos;11<address><addrLine>Cascais, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="401" to="416" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Stronger Semantics for Low-latency Geo-replicated Storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Freedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kaminsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">G</forename><surname>Andersen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 10th USENIX Conference on Networked Systems Design and Implementation, NSDI&apos;13</title>
		<meeting>10th USENIX Conference on Networked Systems Design and Implementation, NSDI&apos;13<address><addrLine>Lombard, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="313" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>O'neil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Escrow Transactional Method. ACM Trans. Database Syst</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="405" to="430" />
			<date type="published" when="1986-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">PLANET: Making Progress with Commit Processing in Unpredictable Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kraska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fekete</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;14</title>
		<meeting>the 2014 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;14<address><addrLine>Snowbird, Utah, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="3" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Precise Documentation: The Key to Better Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">L</forename><surname>Parnas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Future of Software Engineering</title>
		<editor>S. Nanz</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="125" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">The Homeostasis Protocol: Avoiding Transaction Coordination Through Program Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bender</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hojjat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Koch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Foster</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;15</title>
		<meeting>the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;15<address><addrLine>Melbourne, Victoria, Australia</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1311" to="1326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">A comprehensive Study of Convergent and Commutative Replicated Data Types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Baquero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zawirski</surname></persName>
		</author>
		<idno>RR-7506</idno>
	</analytic>
	<monogr>
		<title level="j">INRIA</title>
		<imprint>
			<date type="published" when="2011-01" />
		</imprint>
	</monogr>
	<note type="report_type">Research Report</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Conflict-free Replicated Data Types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Baquero</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zawirski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th Conference Conference on Stabilization, Safety, and Security of Distributed Systems, SSS&apos;11</title>
		<meeting>the 13th Conference Conference on Stabilization, Safety, and Security of Distributed Systems, SSS&apos;11<address><addrLine>Grenoble, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="386" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Amazon DynamoDB: A Seamlessly Scalable Non-relational Database Service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sivasubramanian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;12</title>
		<meeting>the 2012 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;12<address><addrLine>Scottsdale, Arizona, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="729" to="730" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Invariant Preservation in Geo-replicated Data Stores</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">B</forename><surname>Sousa</surname></persName>
		</author>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">2017</biblScope>
		</imprint>
		<respStmt>
			<orgName>Faculdade de Ciências e Tecnologia, Universidade NOVA de Lisboa</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Transactional Storage for Geo-replicated Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sovran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Aguilera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM Symposium on Operating Systems Principles, SOSP &apos;11</title>
		<meeting>the 23rd ACM Symposium on Operating Systems Principles, SOSP &apos;11<address><addrLine>Cascais, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="385" to="400" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">B</forename><surname>Terry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">M</forename><surname>Theimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Petersen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">J</forename><surname>Demers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Spreitzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">H</forename><surname>Hauser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th ACM Symposium on Operating Systems Principles, SOSP &apos;95</title>
		<meeting>the 15th ACM Symposium on Operating Systems Principles, SOSP &apos;95<address><addrLine>Copper Mountain, Colorado, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="172" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Speedy Transactions in Multicore In-memory Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kohler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Symposium on Operating Systems Principles, SOSP &apos;13</title>
		<meeting>the 24th ACM Symposium on Operating Systems Principles, SOSP &apos;13<address><addrLine>Farminton, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="18" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Eventually consistent</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Vogels</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="40" to="44" />
			<date type="published" when="2009-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">ACIDRain: Concurrency-Related Attacks on Database-Backed Web Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Warszawski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bailis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data, SIGMOD &apos;17</title>
		<meeting>the 2017 ACM International Conference on Management of Data, SIGMOD &apos;17<address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="5" to="20" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<title level="m" type="main">Interactive checks for coordination avoidance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Whittaker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="14" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Verdi: A Framework for Implementing and Formally Verifying Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Wilcox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Woos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Panchekha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Tatlock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Anderson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;15</title>
		<meeting>the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation, PLDI &apos;15<address><addrLine>Portland, OR, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="357" to="368" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Salt: Combining acid and base in a distributed database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kapritsos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Yaghmazadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mahajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;14</title>
		<meeting>the 11th USENIX Conference on Operating Systems Design and Implementation, OSDI&apos;14<address><addrLine>Broomfield, CO, USA</addrLine></address></meeting>
		<imprint>
			<publisher>USENIX Association</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="495" to="509" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Write Fast, Read in the Past: Causal Consistency for Client-Side Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zawirski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Preguiça</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duarte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bieniusa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Balegas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Middleware Conference, Middleware &apos;15</title>
		<meeting>the 16th Annual Middleware Conference, Middleware &apos;15<address><addrLine>Vancouver, BC, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="75" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Transaction Chains: Achieving Serializability with Low Latency in Geo-distributed Storage Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Power</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sovran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Aguilera</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th ACM Symposium on Operating Systems Principles, SOSP &apos;13</title>
		<meeting>the 24th ACM Symposium on Operating Systems Principles, SOSP &apos;13<address><addrLine>Farminton, Pennsylvania, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="276" to="291" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
