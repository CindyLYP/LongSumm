<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fine-Grained, Secure and Efficient Data Provenance on Blockchain Systems</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pingcheng</forename><surname>Ruan</surname></persName>
							<email>ruanpc@comp.nus.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tien</forename><surname>Tuan</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anh</forename><surname>Dinh</surname></persName>
							<email>dinhtta@comp.nus.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qian</forename><surname>Lin</surname></persName>
							<email>linqian@comp.nus.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Beng</forename><forename type="middle">Chin</forename><surname>Ooi</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meihui</forename><surname>Zhang</surname></persName>
							<email>meihui_zhang@bit.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gang</forename><surname>Chen</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">National University of Singapore</orgName>
								<orgName type="institution" key="instit2">Zhejiang University ‡ Beijing Institute of Technology</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fine-Grained, Secure and Efficient Data Provenance on Blockchain Systems</title>
					</analytic>
					<monogr>
						<idno type="ISSN">2150-8097</idno>
					</monogr>
					<idno type="DOI">10.14778/3329772.3329775</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:41+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The success of Bitcoin and other cryptocurrencies bring enormous interest to blockchains. A blockchain system implements a tamper-evident ledger for recording transactions that modify some global states. The system captures entire evolution history of the states. The management of that history, also known as data provenance or lineage, has been studied extensively in database systems. However, querying data history in existing blockchains can only be done by replaying all transactions. This approach is applicable to large-scale, offline analysis, but is not suitable for online transaction processing. We present LineageChain, a fine-grained, secure and efficient provenance system for blockchains. LineageChain exposes provenance information to smart contracts via simple and elegant interfaces, thereby enabling a new class of blockchain applications whose execution logics depend on provenance information at runtime. LineageChain captures provenance during contract execution, and efficiently stores it in a Merkle tree. LineageChain provides a novel skip list index designed for supporting efficient provenance query processing. We have implemented LineageChain on top of Hyperledger and a blockchain-optimized storage system called ForkBase. Our extensive evaluation of LineageChain demonstrates its benefits to the new class of blockchain applications, its efficient query, and its small storage overhead.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Blockchains are capturing attention from both academia and industry. A blockchain is a chain of blocks, in which each block contains many transactions and is linked with the previous block via a hash pointer. It was firstly introduced in Bitcoin <ref type="bibr" target="#b27">[27]</ref>, where Satoshi Nakamoto employs it to batch cryptocurrency transactions. Often referred to as decentralized ledger, the chain ensures integrity of the complete transaction history. It is replicated over a peer-topeer (P2P) network, and a distributed consensus protocol, namely Proof-of-Work (PoW), is used to ensure that honest nodes in the network have the same ledger. More recent blockchains, for instance Ethereum <ref type="bibr" target="#b0">[1]</ref> and Hyperledger <ref type="bibr" target="#b1">[2]</ref>, extend the original design to support applications beyond cryptocurrencies. In particular, they add smart contracts which encode arbitrary, Turing-complete computation on top of the blockchain. A smart contract has its states stored on the blockchain, and the states are modified via transactions that invoke the contract.</p><p>Blockchains are disrupting many industries, including finance <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b29">29]</ref>, supply chain <ref type="bibr" target="#b24">[24,</ref><ref type="bibr" target="#b35">35]</ref>, and healthcare <ref type="bibr" target="#b3">[4]</ref>. These industries are exploiting two distinct advantages of blockchains over traditional data management systems. First, a blockchain is decentralized, which allows mutually distrusting parties to manage the data together instead of trusting a single party. Second, the blockchain provides integrity protection (tamper evidence) to all transactions recorded in the ledger. In other words, the complete transaction history is secure.</p><p>The management of data history, or data provenance, has been extensively studied in databases, and many systems have been designed to support provenance <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b30">30,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b36">36]</ref>. In the context of blockchain, there is explicit, but only coarse-grained support for data provenance. In particular, the blockchain can be seen as having some states (with known initial values), and every transaction moves the system to new states. The evolution history of the states (or provenance) can be securely and completely reconstructed by replaying all transactions. This reconstruction can be done during offline analysis. During contract execution (or runtime), however, no provenance information is safely available to smart contracts. In other words, smart contracts cannot access historical blockchain states in a tamper-evident manner. The lack of secure, fine-grained, runtime access to provenance therefore restricts the expressiveness of the business logic the contract can encode.</p><p>Consider an example smart contract shown in <ref type="figure">Figure 1</ref>, which contains a method for transferring a number of tokens from one user to another. Suppose user A wants to send tokens to B based on the latter's historical balance in recent months. For example, A only sends token if B's average balance per day is more than t. It is not currently possible to  <ref type="figure">Figure 1</ref>: A smart contract that manages for token management.</p><p>write a contract method for this operation. To work around this, A needs to first compute the historical balance of B by querying and replaying all on-chain transactions, then based on the result issues the Transfer transaction. Besides performance overhead incurred from multiple interactions with the blockchain, this approach is not safe: it fails to achieve transaction serializability. In particular, suppose A issues the Transfer transaction tx based on its computation of B's historical balance. But before tx is received by the blockchain, another transaction is committed such that B's average balance becomes t &lt; t. Consequently, when tx is later committed, it will have been based on stale state, and therefore fails to meet the intended business logic. In blockchains with native currencies, serializability violation can be exploited for Transaction-Ordering attacks that cause substantial financial loss to the users <ref type="bibr" target="#b25">[25]</ref>.</p><p>In this paper, we design and implement a fine-grained, secure and efficient provenance system for blockchains, called LineageChain. In particular, we aim to enable a new class of smart contracts that can access provenance information at runtime. Although our goal is similar to that of existing works in adding provenance to databases <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b35">35,</ref><ref type="bibr" target="#b31">31]</ref>, we face three unique challenges due to the nature of blockchain. First, there is a lack of data operators whose semantics capture provenance in the form of input-output dependency. More specifically, for general data management workloads (i.e., non-cryptocurrency), current blockchains expose only generic operators, for example, put and get of key-value tuples. These operators do not have input-output dependency. In contrast, relational databases operators such as map, join, union, are defined as relations between input and output, which clearly capture their dependencies. To overcome this lack of provenance-friendly operators, we instrument blockchain runtime to record read-write dependency of all the states used in any contract invocation, which is then passed to a user-defined method that specifies which dependency to be persisted.</p><p>The second challenge is that blockchains assume an adversarial environment, therefore any captured provenance must be made tamper evident. To address this, we store provenance in a Merkle tree data structure that also allows for efficient verification. The final challenge is to ensure that provenance queries are fast, because a large execution overhead is undesirable due to the Verifier's Dilemma <ref type="bibr" target="#b26">[26]</ref>. To address this challenge, we design a novel skip list index that is optimized for provenance queries. The index incurs small storage overhead, and its performance is independent of the number of blocks in the blockchain.</p><p>In summary, we make the following contributions:</p><p>• We introduce a system, called LineageChain that efficiently captures fine-grained provenance for blockchains. It stores provenance securely, and exposes simple access interface to smart contracts. • We design a novel index optimized for querying blockchain provenance. The index incurs small storage overhead, and its performance is independent of the blockchain size. It is adapted from the skip list but we completely remove the randomness to fit for deterministic blockchains. • We implement LineageChain for Hyperledger <ref type="bibr" target="#b1">[2]</ref>.</p><p>Our implementation builds on top of ForkBase, a blockchain-optimized storage <ref type="bibr" target="#b37">[37]</ref>. We conduct extensive evaluation of LineageChain. The results demonstrate its benefits to provenance-dependent applications, and its efficient query and small storage overhead. LineageChain is a component of our Hyperledger++ system <ref type="bibr" target="#b2">[3]</ref>, for which we improve Hyperledger's execution and storage layer for the secure runtime provenance support. Elsewhere, we have addressed the consensus bottleneck by applying sharding efficiently and exploiting trusted hardware to scale out system horizontally, to substantially improve the system throughput <ref type="bibr" target="#b14">[15]</ref>. We have also improved the storage efficiency by designing a tamper-evident storage engine that supports efficient forking called Forkbase. We are currently incorporating smart contract verification to enhance the correctness of smart contracts.</p><p>The remainder of the paper is organized as follows. Section 2 provides background on blockchains. Section 3 describes our design for capturing provenance, and the interface exposed to smart contracts. Section 4 discusses how we store provenance, and Section 5 describes our new index. Section 6 presents our implementation. Section 7 reports the performance of LineageChain. Section 8 discusses related work, and Section 9 concludes this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND AND OVERVIEW</head><p>In this section, we present relevant background on blockchain systems <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b6">7]</ref>, and design choices that affect index structure requirements. Following which, we present an overview of LineageChain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Blockchain Systems</head><p>A blockchain system consists of multiple nodes that do not trust each other. Current blockchains can be broadly classified as permissionless or permissioned. In the former, any node can join or leave the network. In the latter, membership is strictly controlled, and a node must be authenticated and granted permission to join the network. Consensus. Except for a few permissioned blockchains with high auditability, most blockchains assume the Byzantine failure model, in which faulty nodes behave arbitrarily. Under this hostile environment. They use a Byzantine Fault Tolerance (BFT) consensus protocol to ensure that honest nodes agree on the same states. Examples of BFT protocols include Proof-of-work (PoW) which is used in Bitcoin <ref type="bibr" target="#b27">[27]</ref>, and PBFT <ref type="bibr" target="#b10">[11]</ref> which is used in Hyperledger. Classic BFT protocols, such as PBFT, guarantee that honest nodes have the identical chain of blocks. PoW and its variants, on the other hand, allow for inconsistency because the chain can have forks. These protocols handle forks by deterministically selecting one branch over the other. For example, in PoW the longest branch is selected.</p><p>Data model. Different blockchains adopt different data models for their states. Bitcoin' states are unspent coins modeled as Unspent Transaction Outputs (UTXOs), which consists of outputs of transactions that have not been used as inputs to another transaction. The UTXO model lends itself to simple transaction verification, because nodes only need to check that the transaction output has not been used in the past. More recent blockchains, namely Ethereum and Hyperledger, support general states that can be modified arbitrarily by smart contracts. They adopt an account-based data model, in which each account has its own local states stored on the blockchain. A smart contract transaction can write arbitrary data to the storage. This flexible data model comes at the cost of integrity protection and verification of the account states. In this paper, we focus on the accountbased data model. Block structure. A block in the blockchain stores the transactions and the global states. The block header contains the following fields.</p><p>• PreviousBlockHash: reference to the previous block in the chain. Block verification. Algorithm 1 illustrates how a node uses the block header to verify if a block it receives from the network is valid. If the block is valid, it is appended to the chain. When PoW is used for consensus, the node first checks if Nonce is the correct solution to the PoW puzzle. This step is skipped if a deterministic consensus protocol, such as PBFT, is used. Next, it checks if the list of transactions has not been tampered with, by computing and verifying TransactionDigest from the list. It then tentatively re-executes the included transactions. During execution, the states are accessed via some index structures. After the execution, the node checks if the resulting states match with StateDigest. If they do, the block is considered valid and the new states are committed to the storage. Otherwise, the states are rolled back to those before execution. We note that Algorithm 1 takes as input an object gState that represents the global states. If the blockchain does not have forks, e.g., Hyperledger, this object is the latest states. However, when there are forks, e.g., in Ethereum, this object may refer to the global states at a point in the past.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">State Organization</head><p>The most important feature of blockchain is the guarantee of data integrity, which implies that the global states must be tamper evident. The block verification algorithm above is crucial for the security of blockchain. We note that the algorithm requires access to all history snapshots of the states, as well as the ability to update the states in batch. These requirements present new challenges in designing an index structure for organizing blockchain states. In particular, traditional database indices such as B+ tree cannot be used. We now elaborate on the requirements for a blockchain index, and explain how they are met in Ethereum and Hyperledger. LineageChain builds on existing blockchain indices to ensure security for the captured provenance. Tamper evidence. A user may want to read some states without downloading and executing all the transactions. Thus, the index structure must be able to generate an integrity proof for any state. In addition, the index must provide a unique digest for the global states, so that nodes can quickly check if the post-execution states are identical across the network. Incremental update. The size of global states in a typical blockchain application is large, but one block only updates a small part of the states. For example, some states may be updated at every block, whereas other may be updated much more infrequently. Because the index must be updated at every block, it must be efficient at handling incremental updates. Snapshot. A snapshot of the index, as well as of the global states, must be made at every block. This is crucial to realize the immutability property of blockchain which allows users to read any historical states. It is also important for block verification. As explained earlier, when a new block is received that creates a fork, an old snapshot of the state must be used as input for verification. Even when the blockchain allows no forks, snapshots enable roll-back when the received block is found to be invalid after execution (step 4 in Algorithm 1).</p><p>Existing blockchains use indices that are based on Merkle tree. In particular, <ref type="bibr">Ethereum</ref>   <ref type="figure">Figure 2</ref>: The example ledger with the corresponding gState between the block interval Tree (MBT). In a Merkle tree, content of the parent node is recursively defined by those of the child nodes. The root node uniquely identifies the content of all the leaf nodes. A proof of integrity can be efficiently constructed without reading the entire tree. Therefore, the Merkle tree meets the first requirement. This structure is also suitable for incremental updates (second requirement), because only the nodes affected by the update need to be changed. To support efficient snapshots, an update in the Merkle tree recursively creates new nodes in the path affected by the change. The new root then serves as index of the new snapshot, and is then included in the block header.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">LineageChain Overview</head><p>Given a smart contract on an existing blockchain, Lin-eageChain enriches it with fine-grained, secure and efficient provenance as follows. First, the contract can implement a helper method to define the exact provenance information to be captured at every contract invocation. By default, all read-write dependencies of all the states are recorded. Second, new methods can be added that make use of provenance at runtime. As far as a contract developer is concerned, these are the only two changes from the existing, non-provenance blockchain. The captured information is then stored in an enhanced blockchain storage that ensures efficient tracking and tamper evidence of provenance. On top of this storage, we build a skip list index to support fast provenance queries. These changes to the blockchain storage are invisible to the contract developer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">FINE-GRAINED PROVENANCE</head><p>In this section, we describe our approach to capture provenance during smart contract execution. We present APIs that allow the contract to query provenance at runtime. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Capturing Provenance</head><p>Blockchains support only a small set of data operators for general workloads, namely read and write. These operators are not provenance friendly, in the sense that they  <ref type="figure">Figure 3</ref>: The provenance helper method for Token contract. It defines dependency between the sender identifier and recipient identifier. This method is invoke after every invocation of the Token contract.</p><p>do not capture any data association (input-output dependency). In contrast, relational databases or big data systems have many provenance-friendly operators, such as map, reduce and join, whose semantics meaningfully capture the association. For instance, the output of join is clearly derived from (or is dependent on) the input data.</p><p>In LineageChain, every contract method can be made provenance-friendly via a helper method. More specifically, during transaction execution, LineageChain collects the identifiers and values of the accessed states, i.e., ones used in read and write operations. The results are a read set reads and write set writes. For Txn1, reads = {Addr1 : 100, Addr2 : 100}, and writes = {Addr1 : 90, Addr2 : 110}. After the execution finishes, these sets are passed to a userdefined method prov_helper, together with the name of the contract method. prov_helper has the following signature: It returns a set of dependencies based on the input read and write sets. <ref type="figure">Figure 3</ref> shows implementation of the helper method for the Token contract. It first computes the identifier of the sender and recipient from the read and write sets. Specifically, the identifier whose value in writes is lower than that in reads is the sender, and the opposite is true for the recipient. It then returns a dependency set of a single element: the recipient-sender dependency. In our example, for Txn1, this method returns {Addr2 : [Addr1]}</p><p>LineageChain ensures that prov_helper is invoked immediately after every successfully contract execution. If the method is left empty, LineageChain uses all identifiers in the read set as dependency of each identifier in the write set. Interested readers may observe that the vanilla Hyperledger already computes for the read/write set during the endorsement phase. Orthogonal to ours, they are internally used for the concurrency control to achieve one-copy serializability. Instead, we allow contract developers to capture for their application-level provenance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Smart Contract APIs</head><p>Current smart contracts can only safely access the latest blockchain state. In Hyperledger, for example, the get(k) operation returns the last value of k that is written or being batched. In Ethereum, on the other hand, when a smart contract reads a value of k at block b, the system considers the snapshot of states at block b − 1 as the latest states. Although there may exist a block b &gt; b on a different branch, the smart contract always treats what returned from the storage layer as the latest state.</p><p>The main limitation of the current APIs is that the smart contract cannot tamper-evidently read previous values of a state. Instead, the contract has to explicit track historical versions, for example by maintaining a list of versions for every state. This approach is costly both in terms of storage and computation. LineageChain addresses this limitation with three additional smart contract APIs.</p><p>• Hist(stateID, [blockNum]): returns the tuple (val, blkStart, txnID) where val is the value of stateID at block blockNum. If blockNum is not specified, the latest block is used. txID is the transaction that sets stateID to val, and blkStart is the block number at which txID is executed. • Backward(stateID, blkNum): returns a list of tuples (depStateID, depBlkNum) where depStateID is the dependency state of stateID at block blkNum. depBlkNum is the block number at which the value of depStateID is set. In our example, Backward(Addr2, N) returns (Addr1, M). • Forward(stateID, blkNum): similar to the Backward API, but returns the states of which stateID is a dependency. For example, Forward(Addr1, L) returnss (Addr2, M). <ref type="figure" target="#fig_2">Figure 4</ref> demonstrates how the above APIs are used to express smart contract logics that are currently impossible in the secure manner. (The vanilla Hyperledger optionally provides a historyDB for the historical query. But implemented from the flat storage, it does not provide the tamperevidence guarantee, which is our major contribution. ) We add two additional methods to the original contract, both of which use the new APIs. The Refund method examines an account's average balance in the recent month and makes the refund accordingly. The Blacklist method marks an address as blacklisted if one of its last 5 transactions is with a blacklisted address.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">SECURE PROVENANCE STORAGE</head><p>In this section, we discuss how LineageChain enhances existing blockchain storage layer to provide efficient tracking and tamper evidence for the captured provenance. Our key insight is to reorganize the flat leaf nodes in the original Merkle tree into a Merkle DAG. We first describe the Merkle DAG structure, then discuss its properties. Finally, we explain how to exploit the blockchain execution model to support forward provenance tracking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Merkle DAG</head><p>Let k be the unique identifier of a blockchain state, whose evolution history is expected to be tracked. Let v be the unique version number that identifies the state in its evolution history. When the state at version v is updated, the new version v is strictly greater than v. In LineageChain, we directly use the block number as its version  Definition 1. A transaction, identified by tid which is strictly increasing, reads a set of input states S i tid and updates a set of output states S o tid . A valid transaction satisfies the following properties:</p><formula xml:id="formula_0">v. Let s k,v</formula><formula xml:id="formula_1">∀s k 1 ,v 1 , s k 2 ,v 2 ∈ S o tid . k1 = k2 ∧ v1 = v2 (1) ∀s k 1 ,v 1 ∈ S i tid , s k 2 ,v 2 ∈ S o tid . v1 &lt; v2 (2) ∀s k,v ∈ S i tid , s k,v ∈ S i tid . tid &lt; tid ⇒ v ≤ v . (3) tid = tid ⇒ S o tid ∩ S o tid = ∅<label>(4)</label></formula><p>Property (1) means that the versions of all output states of a transaction are identical, because they are updated by the same transaction in the same block. Property (2) implies the version of any input state is strictly lower than that of the output version. This makes sense because the blockchain establishes a total order over the transactions, and because the input states can only be updated in previous transactions. Property <ref type="bibr" target="#b2">(3)</ref> specifies that, for all the states with the same identifier, the input of later transactions can never have an earlier version. This ensures the input state of any transaction must be up-to-date during execution time. Finally, Property <ref type="bibr" target="#b3">(4)</ref>    </p><formula xml:id="formula_2">s k 1 ,v 3 , s k 2 ,v 4 , s k 3 ,v</formula><formula xml:id="formula_3">dep(s) ⊂ S i tid where s ∈ S o tid .</formula><p>We note that dep, which is returned by prov_helper method, is only a subset of the read set.</p><p>Definition 3. The entry Es k,v of the state s k,v is a tuple containing the current version, the state value, and the hashes of the entries of its dependent state. More specifically:</p><formula xml:id="formula_4">Es k,v = v, s k,v , {hash(E s )|s ∈ dep(s k,v )}</formula><p>An entry uniquely identifies a state. In LineageChain, we associate each entry with its corresponding hash. </p><formula xml:id="formula_5">S b = {k : hash(E s b k )|∀s b k ∈ S latest,b }.</formula><p>LineageChain stores χ b as the state digest in the block header.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Discussion</head><p>Our new Merkle DAG can be easily integrated to existing blockchain index structures. In particular, existing Merkle index such as MPT stores state values directly at the leaves, whereas the Merkle DAG in LineageChain stores the entry hashes of the latest state versions at the leaves. By adding one more level of indirection, we maintain the three properties of the index (tamper evidence, incremental update and snapshot), while enhancing it with the ability to traverse the DAG to extract fine-grained provenance information. Recall that the state entry hash captures the entire evolution history of the state. Since this hash is protected by the Merkle index for tamper evidence, so is the state history. In other words, we add integrity protection for provenance without any extra cost to the index structure. For example, suppose a client wants to read a specific version of a state, it first reads the state entry hash at the latest block. This read operation can be verified against tampering, as in existing blockchains. Next, the client traverses the DAG from this hash to read the required version. Because the DAG is tamper evident, the integrity of the read version is guaranteed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Support for Forward Tracking</head><p>One problem of the above DAG model is that it does not support forward tracking, because the hash pointers only reference backward dependencies. When a state is updated, these backward dependencies are permanently established, so that they belong to the immutable derivation history of the state. However, the state can be read by future transaction, therefore its forward dependencies cannot be determined at the time of update.</p><p>Our key insight here is that only forward dependencies of the latest state are mutable. Once the state is updated, due to the execution model of blockchain smart contract, in which the latest state is always read, forward dependencies of the previous state version becomes permanent. As a result, they can be included into the derivation history. <ref type="figure">Figure 6</ref> illustrates an example, in which forward dependencies of s k 1 ,v 1 becomes fixed when the state is updated to s k 1 ,v 3 . This is because when the transaction that outputs</p><formula xml:id="formula_6">s k 0 ,v 4 is executed, it reads s k 1 ,v 3 instead of s k 1 ,v 1 .</formula><p>In LineageChain, for each state s k,v at its latest version, we buffer a list of forward pointers to the entries whose dependencies include s k,v . We refer to this list as Fs k,v , which is defined more precisely as follows:</p><formula xml:id="formula_7">Fs k,v = {hash(E s )|s k,v ∈ dep(s )}</formula><p>When the state is updated to s k,v for v &gt; v, we store Fs k,v at the entry of s k,v .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EFFICIENT PROVENANCE QUERIES</head><p>The Merkle DAG structure supports efficient access to the latest state version, since the state index at block b contains pointers to all the latest versions at this block. To read the latest version of s, one simply reads χ b , follows the index to the entry for s, and then reads the state value from the entry. However, querying an arbitrary version in the DAG is inefficient, because one has to start at the DAG head  and traverse a long the edges towards the requested version. Supporting fast version queries is important when the user wants to examine the state history only from a specific version (for auditing purposes, for example). It is also important for provenance-dependent smart contracts because such queries directly affect contract execution time.</p><p>In this section, we describe a novel index that facilitates fast version queries. The index is designed for permissioned blockchains. We discuss its efficiency and how to extend it to permisionless blockchains.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Deterministic Append-Only Skip List</head><p>We propose to build an index on top of a state DAG to enable fast version queries. The index has a skip list structure, which we call Deterministic Append-only Skip List (or DASL). It is designed for blockchains, exploiting the fact that the blockchain is append-only, and randomness is not well supported <ref type="bibr" target="#b9">[10]</ref>. More specifically, a DASL has two distinct properties compared to a normal skip list. First, it is append-only. The index keys of the appended items, which are versions in our case, are strictly increasing. Second, it is deterministic, that is, the index structure is uniquely determined by the values of the appended items, unlike a stochastic skip list. For ease of explanation, we assume that version numbers are positive integers.</p><p>Definition 6. Let V k = v0, v1, ... be the sequence of version numbers of states with identifier k, in which vi &lt; vj for all i &lt; j. A DASL index for k consists of N linked lists L0, L1, .., LN−1. Let v i−1 j and v i j be the versions in the (j − 1) th and j th node of list Li. Let b be the base number, a system-wide parameter. The content of Li is constructed as follows: <ref type="figure">Figure 7</ref> shows how DASL is stored with the state in a data structure called Node. This structure (also referred to as node) consists of the state version and value. A node belongs to multiple lists (or levels), hence it maintains a list of pointers to some version numbers, and another list of pointers to other nodes. Both lists are of size N , and the i th entry of a list points to the previous version (or the previous node) of this node in level Li. For the same key, the version number uniquely identifies the node, hence we use version numbers to refer to the corresponding nodes.</p><formula xml:id="formula_8">1) v0 ∈ Li 2) Given v i j−1 , v i j is the smallest version in V k such that: v i j−1 b i &lt; v i j b i<label>(5)</label></formula><p>We can view a list as consisting of continuous, nonoverlapping intervals of certain sizes. In particular, the j th interval of Li represents the range R i j = [jb i , (j +1)b i ). Only the smallest version in V k that falls in this range is included in the list. <ref type="figure" target="#fig_5">Figure 8(a)</ref> gives an example of a DASL structure with b = 2. It can be seen that when the version numbers are sparsely distributed, the lists at lower levels are identical. In this case, b can be increased to create larger intervals which can reduce the overlapping among lower-level lists.</p><p>A DASL and a skip list share two properties. First, if a version number appears in Li, it also appears in Lj where j &lt; i. Second, with b = 2, suppose the last level that a version appears in is i, then this version's preceding neighbour in Li appears in Lj where j &gt; i. Given these properties, a query for a version in the DASL is executed in the same way as in the skip list. More specifically, the query traverses a high-level list as much as possible, starting from the last version in the last list. It moves to a lower level only if the preceding version in the current list is strictly smaller than the requested version. In DASL, the query for version vq returns the largest version v ∈ V k such that v ≤ vq (the inequality occurs when vq does not exist). This result represents the value of the state which is visible at time of vq.</p><p>We now describe how a new node is appended to DASL. The challenge is to determine the lists that should include the new node. Algorithm 2 details the steps that find the lists, and subsequently the previous versions, of the new node. The key idea is to start from the last node in L0, then keep increasing the list level until the current node and the new node belong to the same interval (line 9 -18). <ref type="figure" target="#fig_5">Figure  8</ref>(b) shows the result of appending a node with version 12 to the original DASL. The algorithm starts at node 10 and moves up to list L1 and L2. It stops at L3 because in this level node 10 and 12 belong to the same interval, i.e., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b15">16)</ref>. Thus, the new node is appended to list L0 to L2. When the algorithm reaches the last level and is still able to append, it creates a new level where node 0 is the first entry and repeats the process (line <ref type="bibr">21 -24)</ref>. In <ref type="figure" target="#fig_5">Figure 8</ref>(b), when appending version 16, all existing lists can be used. The algorithm then creates L4 with node 1 and appends the node to it. It also creates level L5, but then discards it because node 16 will not be appended since it belongs to same interval of [0, 32) with node 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Discussion</head><p>Integrating to Merkle DAG The DASL is integrated to the Merkle DAG as follows. The node structure ( <ref type="figure">Figure 7)</ref> is stored in the state entry (Definition 3). The node pointers are implemented entry hashes. The Merkle tree structure remains unchanged. In each stage, the traversal will take at most b hops on the same list before moving to the next level. And there are at most log b d levels to traverse.) Hence, b controls the tradeoff between the space overhead and query delay. One benefit of this property is that DASL queries favor more recent versions, i.e. d are small, which is useful for smart contracts that work use recent rather than old versions. Another benefit is that the performance of such recent-version queries does not change as the state history grows.</p><p>Extending to permissionless blockchains.</p><p>We note that DASL incurs storage overhead. The version query also incurs some computation cost, even though it is more efficient with DASL than without it. These costs may be small enough such that they do not affect the performance of a permissioned blockchain, as we demonstrate in Section 7. However, they need to be carefully managed in a permisionless blockchain where any overhead directly translates to monetary cost to the miners. In particular, any additional cost to the miner triggers the Verifier Dilemma <ref type="bibr" target="#b26">[26]</ref> and compromises the incentive mechanism of the blockchain.</p><p>A malicious user could issue a transaction that references a very old version. Reading earlier versions is more expensive, because there are more hops involved. This overhead is born by all nodes in the network, since every node in the  <ref type="figure">Figure 9</ref>: LineageChain's software stack. The original storage layer is replaced with the implementation that supports fine-grained provenance. The original execution layer is instrumented with a provenance capture engine. The application layer contains the new helper method and provenance query APIs. The consensus layer is unchanged.</p><p>network has to execute the same transaction. Current public blockchains prevent such denial-of-service attack by explicitly charging a fee for each operation in the transaction. In Ethereum, the transaction owner pays for the resource consumption in gas. A transaction that writes more data or consumes more CPUs has to pay more gas. Thus, rational users are deterred from running too complex transactions on the blockchain.</p><p>As DASL consumes resources, its costs must be explicitly accounted for in permissionless blockchains. More specifically, during deployment, the contract owner specifies which states require DASL support. Alternatively, DASL support can be automatically inferred from the contract's source code. The deployment fee should reflect this extra storage cost for DASL. If the fee is too high, the owner can lower it by increasing b. During contract execution, the execution engine must charge the cost of DASL queries to the transaction fee. In particular, a query that requires more hops to find the requested version incurs a higher transaction fee. Users may empirically estimate the hops (as well as the cost) based on the above-derived theoretical upper bound.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">IMPLEMENTATION</head><p>In this section, we present our implementation of Lin-eageChain based on Hyperledger. We implement Lin-eageChain both on Hyperledger v0.6 and v1.3. Although the two blockchains follow different designs, they share the same four logical layers: storage, execution, consensus and application layer <ref type="bibr" target="#b19">[19]</ref>. <ref type="figure">Figure 9</ref> depicts these layers and highlights the changes we make to the original Hyperledger's stack. In particular, we completely replace Hyperledger's storage layer with our implementation of the Merkle DAG and DASL index. This new storage is built on top of Fork-Base <ref type="bibr" target="#b37">[37]</ref>, a state-of-the-art blockchain storage system with support for version tracking. We instrument the original execution engine to record read and write sets during contract execution. At the application layer we add a new helper method and three provenance APIs. The execution engine is modified to invoke the helper method after every successful contract execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Storage Layer Implementation</head><p>Instead of implementing the storage layer from scratch, we leverage ForkBase for its support of version tracking. We exploit three properties of ForkBase in LineageChain. The first is the fork semantics, with which the application can specify a branch for the update. Given a branch, ForkBase provides access to the latest value. The second property is tamper evidence, in which every update returns a tamperevident identifier vid which captures the entire evolution history of the updated value. A data object in ForkBase is uniquely identified by the key and vid. In LineageChain, vid is used as the entry hash in the DAG, and as the pointer in DASL. The third property is the rich set of built-in data types including map, list and set.</p><p>Algorithm 3 details our implementation for updating states and computing the global state digest when a block is being committed. The update function is invoked with a new state and a list of dependencies. We first prepare the list of backward pointers by retrieving the latest vids of the dependent states (line 5-8). Next, we build the pointers for the DASL index, then retrieve the forward pointers of the previous state (line 9). The metadata from these steps are serialized and stored together with the updated value in ForkBase (line <ref type="bibr" target="#b13">[14]</ref><ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref>. The result is a new vid for the update, which is appended to the list of forward pointers of every dependent state (line <ref type="bibr" target="#b18">[18]</ref><ref type="bibr" target="#b19">[19]</ref><ref type="bibr" target="#b20">[20]</ref>. vid is now the latest version (line 21).</p><p>The global states are stored in a map object in ForkBase. To compute the global state digest, we simply update the map object with the new vids computed for this block. The update operation of the map object, which is built as a Merkle tree in ForkBase, returns a digest latest_vid which is then included to the block header. This digest provides tamper evidence for the evolution histories of all the states up to the current block.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Application and Execution Layer Implementation</head><p>In Hyperledger, users write their smart contracts by implementing the Chaincode interface. Given a chaincode, the execution engine triggers the Init and Invoke method during deployment and invocation respectively. Both methods take as input an instance of ChaincodeStubInterface which supplies relevant context, such as access to the ledger states, to the smart contract.</p><p>We add the helper method, called ProvHelper, to the Chaincode interface. This method's signature, and how to write user-defined provenance rules with it, are explained in Section 3. The execution engine intercepts PutState and GetStates during execution to record the read set and the write set. It invokes ProvHelper when the execution finishes, passing it the ChaincodeStubInterface, the name of the method, and the recorded read and write sets. The three new provenance APIs, namely Hist, Backward and Forward, are added to ChaincodeStubInterface and therefore are accessible to all contract methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">PERFORMANCE EVALUATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Baselines and Experimental Setup</head><p>We evaluate LineageChain against two baselines. In the first baseline, called Hyperledger+, we directly store provenance information to Hyperledger's original storage, i.e., RocksDB, and relies on RocksDB's internal index to support provenance query. In the second baseline, called LineageChain-, we use ForkBase for the storage of state versions. This baseline does not support multi-state dependency, nor does it have DASL index. We use this to evaluate the storage overhead for the index and for tracking multistate dependency, and performance benefits of the index.</p><p>We perform three sets of experiments. First, we evaluate the performance of LineageChain for provenancedependent blockchain applications. We compare it against the approach that queries provenance offline before issuing blockchain transactions. Second, we evaluate the performance of provenance queries in LineageChain on a single machine. For single-state version queries, we use the YCSB benchmark provided in BLOCKBENCH <ref type="bibr" target="#b19">[19]</ref> to populate the blockchain states with key-value tuples. We then measure the latencies of two queries: one that retrieves a state at a specific block, and one that iterates over the state history. For multi-state dependency tracking, we implement a contract for a supply chain application In this application, a phone is assembled from intermediary components which are made from other components or raw material. The supply chain creates a DAG representing the derivation history of a phone. The maximum depth of the DAG is 6. We generate synthetic data for this contract, and examine the latency of the operation that uses Backtrack to retrieve dependencies of a given phone.</p><p>In the third set of experiments, we evaluate the provenance impact on the overall performance of the blockchain in the distributed setting. To this end, we run the Smallbank benchmark in BLOCKBENCH on multiple nodes. We measure the overall throughput, and analyze the cost breakdown to understand the overhead of provenance support.</p><p>Our experiments are conducted on a local clusters of 16 nodes. Each node is equipped with E5-1650 3.5GHz CPU, 32GB RAM, and 2TB hard disk. The nodes are connected via 1Gbps Ethernet. The results reported are based on Hyperledger v0.6, unless stated otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Experimental Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Provenance-dependent applications</head><p>We implement a simple provenance-dependent blockchain application by modifying the YCSB benchmark in BLOCK-BENCH such that the update operation depends on historical values. With LineageChain, the contract has direct access to the provenance information, and the client remains the same as in the original YCSB. Without LineageChain, the client is modified such that it reads B latest blocks before issuing transactions. B represents how far behind the client is to the latest states.</p><p>We run the experiments using the LineageChain implementation on Hyperledger v1.3, with 16 nodes and 1 client. <ref type="figure">Figure 10</ref>(a) shows transaction latency with varying B. It can be seen that with LineageChain, the latency remains almost constant because the client does not have to fetch any block for the provenance query. In contrast, without LineageChain, the latency increases linearly with B. This demonstrates the performance benefit of having access to provenance information at runtime.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Provenance queries</head><p>We first create 500 key-value tuples and then continuously issue update transactions until there are more 10k blocks in the ledger. Each block contains 500 transactions. We then execute a query for the values of a key at different block numbers. <ref type="figure" target="#fig_10">Figure 11(a)</ref> illustrates the query latency with increasing block distance from the last block. It can be seen that when the distance is small, LineageChain-has the lowest latency. LineageChain-does not have DASL index, hence for this query it performs linear scan from the latest version. Therefore, it is fast when the requested version is very recent because the number of read is small. However, its performance degrades quickly as the distance increases. In particular, when the block distance reaches 128, the query is 4× slower than LineageChain. We observe that the query latency in Hyperledger+ is independent of the block distance. It is because the query uses RocksDB index directly. LineageChain outperforms both LineageChain-and Hyper-ledger+. Due to DASL, the query latency in LineageChain  <ref type="figure">Figure 10</ref>:</p><p>Performance of (a) a provenancedependent blockchain application and (b) BFS Traversal latency is low when the block distance is small. When the block distance increases, the latency in LineageChain increases only logarithmically, as opposed to linearly in LineageChain-.</p><p>We repeat the experiment above while fixing the block distance to 64 and varying the total number of blocks. <ref type="figure" target="#fig_10">Figure 11(b)</ref> shows the results for the version query when the number of block increases. It can be seen that the query latency in both LineageChain and Hyperledger+ remains roughly the same. In other words, the performance of version queries in these systems are independent of the block numbers, which is due to the DAG data model that tracks state versions. LineageChain outperforms Hyperledger+ thanks to the index that reduces the number of hops needed to be read. An interesting observation is that the latency of Hyperledger+ fluctuates significantly. We attribute this fluctuation to RocksDB's log-structure-merge tree index, in which the requested version may reside at different levels of the tree when the total number of block increases.</p><p>Next, we measure the latency for the operation that scan the entire version history of a given key. <ref type="figure" target="#fig_10">Figure 11(c)</ref> shows the scan latency with increasing number of blocks. For Hy-perledger+, we first construct the key range and rely on RocksDB iterator for the scanning. LineageChain-and Lin-eageChain both use ForkBase iterator, therefore they have the same performance. As the number of block increases, the version history becomes longer which accounts for the linear increase in latency in both systems. However, Lin-eageChain outperforms Hyperledger+ by a constant factor. We attribute this difference to ForkBase's optimizations for version tracking.</p><p>Finally, we evaluate the query performance with multistate dependency. We populate the blockchain states with raw materials and issue transactions that create new phones. We perform a breadth-first search to retrieve all the dependencies of a phone. For this experiment, we only compare Hyperledger+ and LineageChain, because LineageChaindoes not support multi-state dependencies. <ref type="figure">Figure 10</ref>  shows the performance with varying search depths, in which the latency of both Hyperledger+ and LineageChain grow exponentially with increasing depths. However, Lin-eageChain outperforms the baseline. It is because the index in LineageChain directly captures the dependencies, whereas each backtrack operation in Hyperledger+ requires traversing on RocksDB index. As the number of queries increases with the search level, their performance gap accumulates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LineageChain overhead</head><p>We run the Smallbank benchmark with a single client and increasing number of nodes. The client uses 16 threads and issues 16 transactions per second. We examine the overhead of provenance support on the overall performance of the blockchain. <ref type="figure" target="#fig_11">Figure 12</ref> shows the transaction latency and overall throughput. We do not observe significant differences between LineageChain and the other baselines. In particular, the transaction latency is around 1.2s, and the throughput decreases from roughly 118tps to 108tps.</p><p>We break down the block latency into three components: consensus latency (the block proposal phase), execution latency (when transactions are executed), and commit latency (when the states are committed to the storage). <ref type="figure" target="#fig_12">Figure 13</ref> shows the detailed breakdown when the number of nodes is 8, 12 and 16. It can be seen that the execution phase accounts for a majority of the cost. There is no significant difference in block execution time of Hyperledger+ and Lin-eageChain. Hence, the overhead of the provenance capture engine is negligible. The block commit latency in LineageChain-and Lin-eageChain are 2× higher than that of Hyperledger+. It is due to ForkBase's computation to update its internal data structures during commit. However, the block commit phase accounts for less than 20% of the total block latency. We further note that the transaction latency is in order of seconds, whereas a block latency is in in order of hundreds of milliseconds. Thus, any extra overhead incurred by provenance support does not result in any visible differences in the user-perceived performance of the blockchain.</p><p>Next, we examine the breakdown in storage cost of Lin-eageChain. <ref type="figure" target="#fig_2">Figure 14</ref> shows the storage breakdown with varying number of blocks. The block size is fixed at 500 transactions per block. <ref type="figure" target="#fig_2">Figure 14</ref> shows the breakdown with varying block sizes, while fixing the number of blocks at 1000. It can be seen that the storage size grows linearly with the number of blocks and block sizes. We observe that the block content accounts for the majority the storage cost. In contrast, the extra provenance and DASL index account for only 2 − 4% of the total space consumption. In LineageChain, the DASL pointers are implemented as 20byte vid strings. A new state will at most add D + log(N ) new pointers where N is the number of previous versions and D is the number of dependent states. When compared with kilobyte-sized blocks, the storage consumption of these pointers is not significant. As a result, the storage overhead of DASL is small.</p><p>Finally, we evaluate LineageChain overhead on Hyperledger v1.3. This version of Hyperledger uses a different consensus protocol and more simplified data model than v0.6. We use 16 nodes and vary the offer load by increasing the client's transaction rate. <ref type="figure" target="#fig_3">Figure 15</ref> shows the performance overhead. At saturation, LineageChain-and Lin-eageChain add less than 200ms in latency, compared to the original Hyperledger that has no provenance support. In contrast, Hyperledger+ adds more than 1s. LineageChainand LineageChain reach similar throughput as the original Hyperledger, which is around 350tps. Hyperledger+ peaks at around 330tps. These results demonstrate that Lin-eageChain's overhead over the original Hyperledger is small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">RELATED WORK</head><p>Data Provenance Data provenance has been studied extensively in database systems. Support for provenance has been added to a wide range of systems, from relational databases <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b7">8]</ref>, collaborative data sharing systems <ref type="bibr" target="#b23">[23,</ref><ref type="bibr" target="#b33">33]</ref>, to big data platforms <ref type="bibr" target="#b30">[30,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b36">36]</ref>. However, these systems have different requirements on provenance and therefore face different challenges. As a result, their provenance solutions are ad-hoc and do not generalize well. In relational databases, Peter Buneman et al. <ref type="bibr" target="#b8">[9]</ref> propose an approach for query provenance, in which they identify two types of provenance for databases: "why" and "where" provenance. In Hadoop and other MapReduce systems, data derivation graphs are established based on the data flow from mappers to reducers <ref type="bibr" target="#b21">[21]</ref>. Titian <ref type="bibr" target="#b22">[22]</ref> instruments Spark's original RDDs to capture data transformation. Other works exploit provenance in specific application domains, such as networks <ref type="bibr" target="#b11">[12]</ref>, language processing <ref type="bibr" target="#b17">[17]</ref> and interactive workflow applications <ref type="bibr" target="#b31">[31]</ref>. They focus on improving provenance storage and query efficiency.</p><p>Our work shares the same spirit as the above. We add provenance capabilities to blockchains, which enables a new class of blockchain applications. We design a new data model and index that are optimized for blockchains. Our system addresses the unique challenges raised by the decentralization nature of blockchains.</p><p>Blockchain Most research in blockchain systems focuses on security of permissionless blockchains. One open challenge is to improve incentive compatibility. A protocol is incentive compatible if honest participants get rewards proportional to its contributions to the network. Bitcoin, for example, is not incentive compatible <ref type="bibr" target="#b20">[20,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b28">28]</ref>. Another challenge is to improve smart contracts security. Recent vulnerabilities in Ethereum that resulted in substantial financial loss has prompted many efforts in finding bugs and securing smart contracts with programming language techniques <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b25">25]</ref>. As a data management system, blockchain has poor performance. BLOCKBENCH <ref type="bibr" target="#b19">[19]</ref> compares several blockchains with in-memory databases and shows orders of magnitude difference in transaction throughput.</p><p>Our work aims to enrich blockchain capabilities by introducing provenance. It is orthogonal to those above that aim to improve security and performance of the consensus protocol. The most closely related work to ours is Fork-Base <ref type="bibr" target="#b37">[37]</ref>. In fact, current LineageChain implementation is built on top of ForkBase to leverage its version tracking capability. However, our novelties over ForkBase include multi-state dependency tracking, efficient index, and rich APIs for accessing provenance at runtime. Another similar recent work is VChain <ref type="bibr" target="#b38">[38]</ref>, where researchers achieve the integrity of boolean range queries over the historical data on blockchain databases. But different from ours, they are optimizing for the offline analytical query. Instead, we extend the provenance support to blockchain online transactions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">CONCLUSIONS</head><p>In this paper, we presented LineageChain, a fine-grained, secure and efficient provenance system for blockchains. The system efficiently captures provenance information during runtime and stores it in a secure storage. It exposes simple APIs to smart contracts, which enables a new class of provenance-dependent blockchain applications. Provenance queries are efficient in LineageChain, thanks to a novel skip list index. We implemented LineageChain on top of Hyperledger and benchmarked it against several baselines. The results show the benefits of LineageChain in supporting rich, provenance-dependent applications. They demonstrate that provenance queries are efficient, and that the system incurs small storage overhead.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.">ACKNOWLEDGMENTS</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Running example. Throughout this section, we use as running example the token smart contract shown inFigure 1. Figure 2 depicts how the global states are modified by the contract. In particular, the contract is deployed at block L th in the blockchain. Two addresses Addr1 and Addr2 are initialized with 100 tokens. Two transactions Txn1 and Txn2 that transfer tokens between the two addresses are committed at block M and N respectively. The value of Addr1 is 100 from block R to block M − 1, 90 from block M to N − 1, and 70 from block N . The global state gState is essentially a map of addresses to their values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>method prov_helper(name: string, reads: map(string, byte[]), writes: map(string, byte[])) returns map(string, string[]);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Smart contract with provenancedependent methods. denote the value of the state with identifier k at version v. We drop the subscripts if the meaning of k and v are not important. For any k = k and v = v , s k,v and s k ,v represent the values of two different states at different versions. s b k represents the state value with identifier k at its latest version before block b. In our example, for k = Addr1 and v = M , s k,v = 90.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>A Merkle DAG for storing provenance. s k 2 ,v and s k 3 ,v 4 updated by the same transaction (tid4), but their dependencies are different. b contains two transactions, tid3 and tid4. Its latest states include</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Definition 4 .</head><label>4</label><figDesc>The set of latest states at block b, denoted as S latest,b is defined as:S latest,b = k {s b k }Let U b be the updated states in block b. We can computeS latest,b by recursively combining U b with S latest,b−1 \ U b . Definition 5. χ b is the root of a Merkle tree built on the map S b where</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>(a) A DASL containing versions 1, 3, 5 and 10. The base b is 2. The intervals for L2 and L3 are shown in blue lines. (b) The new DASL after appending version 12 and 16. L4 is created when appending version 16. L5 is created, then discarded.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Algorithm 2 : 7 l 8 if l &gt; 0 then 9 for 16 if not finish then 17 cur 20 finish = true; 21 while</head><label>278916172021</label><figDesc>DASL Append Input: version v and last node last Output: previous versions and nodes 1 level=0; // list level 2 pre_versions = []; 3 pre_nodes = []; 4 finish = false ; 5 cur = last ; 6 while not finish do = cur-&gt;pre_versions.size() ; j=level; j&lt;l; ++j do 10 if cur-&gt;version / b j &lt; v / b j then 11 pre_versions.append(cur-&gt;version); = cur-&gt;pre_versions[l-1] ; 18 level = l 19 else /* We have reached the last level */ cur-&gt;version / b level &lt; v / b level do 22 ++level; 23 pre_versions.append(cur-&gt;version);24pre_nodes.append(cur); 25 return pre_version, pre_nodes;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Speed-storage tradeoff As a skip list variant, DASL shares the same lineage space complexity and logarithmic query time complexity. Suppose there are v * number of versions and the base of DASL is b. The maximum number of required pointers is b(v * −1) b−1 . (There are at most log b v * levels and the i-th level takes at most v * b i − 1 pointers.) Suppose the queried version is v q and the query distance d = v * − v q , the maximum number of hops in such query is capped at 2b log b d . (A query traversal from the end will undergo two stages, one stage towards lower levels and the other stage back towards upper levels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Algorithm 3 : 5 List&lt;vid&gt; back_vids; 6 for dep_id in dep_ids do 7 back_vid 9 forward_vids</head><label>35679</label><figDesc>Provenance update and digest Computation 1 fb.Map&lt;id,vid&gt; latest; 2 String branch = "default"; // Buffered forward pointers 3 Map&lt;id, List&lt;vid» forward; Input: id, version, value of the updated state Input: ids of the dependent states, dep_ids 4 Function Update(id, version, value, dep_ids): /* Backward pointers */ = forward[id]; /* Retrieve pointer to last DASL node */ last_vid = latest[id]; /* Refer DASL Append in Algorithm 2 */ pre_versions, pre_vids = DaslAppend(version, last_vid); node = new DaslNode{version, pre_versions, pre_vids} ; meta = Serialize(back_vids, forward_vids, node) ; /* Store the updated value */ new_vid = fb.Put(id, branch, value, meta); /* Update forward pointers */ for dep_id in dep_ids do forward[dep_id].push_back(new_vid); forward[id].Clear(); latest[id] = new_vid; Output: The state digest for the committed block Function ComputeDigest(): latest_vid = fb.Put("state", branch, latest, nil); return latest_vid;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 11 :</head><label>11</label><figDesc>Latency of the version query on YCSB with increasing block distance (a) and increasing number of blocks (b). Latency of the version scan with increasing block number (c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 :</head><label>12</label><figDesc>Performance under Smallbank workload.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 13 :</head><label>13</label><figDesc>Latency breakdown. H+, L-, L stands for Hyperledger+, LineageChain-and LineageChain respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 14 :Figure 15 :</head><label>1415</label><figDesc>Storage cost breakdown. Performance on Hyperledger v1.3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>means that every state update is unique.</figDesc><table><row><cell></cell><cell></cell><cell>Block b-1</cell><cell></cell><cell>Block b</cell><cell>Root Hash</cell></row><row><cell>…...</cell><cell></cell><cell>tid1 Digest</cell><cell></cell><cell>tid3 Digest</cell><cell></cell></row><row><cell></cell><cell></cell><cell>tid2</cell><cell></cell><cell>tid4</cell><cell>Merkle</cell></row><row><cell>s k1,v1</cell><cell>tid1</cell><cell>s k1,v2</cell><cell>tid3</cell><cell>s k1,v3</cell><cell>Tree</cell></row><row><cell>s k2,v1</cell><cell></cell><cell></cell><cell>tid4</cell><cell>s k2,v4</cell><cell></cell></row><row><cell></cell><cell>tid2</cell><cell>s k3,v2</cell><cell>tid4</cell><cell>s k3,v4</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc><ref type="bibr" target="#b3">4</ref> , from which a Merkle tree is built.Definition 2. The dependency of state s is a subset of the input states of the transaction that outputs s. More specifically:</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>Figure 6: Forward tracking support. Afters k 1 ,v1 is updated, there can only be s k 0 ,v 2 and s k 2 ,v 2 that are dependent on s k 1 ,v 1 . Future states can only depend on s k 1 ,v3 . Forward pointers of s k 1 ,v 1 are stored in the entry of s k 1 ,v 3 .</figDesc><table><row><cell>s k0,v2</cell><cell>s k0,v4</cell></row><row><cell>s k1,v1</cell><cell>s k1,v3</cell></row><row><cell>s k2,v2</cell><cell>s k2,v4</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>Node structure that captures a state s k,v with value val</figDesc><table><row><cell cols="4">struct Node {</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">Version v;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">Value val;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="8">List&lt;Version&gt; pre_versions;</cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">List&lt;Node*&gt; pre_nodes;</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>}</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">Figure 7: A 1 3 5 L 0 :</cell><cell>10</cell><cell>L 0 :</cell><cell>1</cell><cell>3</cell><cell>5</cell><cell>10</cell><cell>12</cell><cell>16</cell></row><row><cell>L 1 :</cell><cell>1</cell><cell>3</cell><cell>5</cell><cell>10</cell><cell>L 1 : L 2 :</cell><cell>1 1</cell><cell>3</cell><cell>5 5</cell><cell>10 10</cell><cell>12 12</cell><cell>16 16</cell></row><row><cell>L :</cell><cell>1</cell><cell></cell><cell>5</cell><cell>10</cell><cell>L 3 :</cell><cell>1 0</cell><cell></cell><cell>7 8</cell><cell>10</cell><cell cols="2">16 15 16 23</cell></row><row><cell>L 3 :</cell><cell>1 0 0</cell><cell>3 4</cell><cell>7 8 7 8</cell><cell>10 11 15</cell><cell>L 4 : L 5 :</cell><cell>1 0</cell><cell></cell><cell></cell><cell></cell><cell>15 16</cell><cell>16 16</cell></row><row><cell></cell><cell></cell><cell>(a)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Storage Layer ForkBase DAG Model with DASL Index</head><label></label><figDesc></figDesc><table><row><cell>Application</cell><cell></cell><cell></cell></row><row><cell>Original</cell><cell>Provenance</cell><cell cols="2">Provenance Helper</cell></row><row><cell>Handler</cell><cell>Query Handler</cell><cell cols="2">Method Specification</cell></row><row><cell cols="2">Consensus Layer (Unchanged)</cell><cell></cell></row><row><cell>Execution Layer</cell><cell></cell><cell></cell></row><row><cell>Execution Engine</cell><cell></cell><cell>Accessed States</cell><cell>Engine Provenane</cell></row><row><cell></cell><cell></cell><cell>Provenance</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research is supported by Singapore Ministry of Education Academic Research Fund Tier 3 under MOE's official grant number MOE2017-T3-1-007.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ethereum</surname></persName>
		</author>
		<ptr target="https://www.ethereum.org" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="https://www.hyperledger.org" />
		<title level="m">Hyperledger</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hyperledger++</surname></persName>
		</author>
		<ptr target="https://www.comp.nus.edu.sg/dbsystem/hyperledger++/index.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Medilot</surname></persName>
		</author>
		<ptr target="https://medilot.com" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Hadoopprov: Towards provenance as a first class citizen in mapreduce</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Akoush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Sohan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hopper</surname></persName>
		</author>
		<editor>TaPP</editor>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A survey of attacks on ethereum smart contracts (sok)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Atzei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bartoletti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cimoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Principles of Security and Trust</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="164" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sonnino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Al-Bassam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Azouvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mccorry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Meiklejohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Danezis</surname></persName>
		</author>
		<ptr target="https://arxiv.org/abs/1711.03936" />
		<title level="m">Consensus in the age of blockchain</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Provenance management in curated databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2006 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2006 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="539" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Why and where: A characterization of data provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Buneman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Wang-Chiew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International conference on database theory</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="316" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schubert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vukolić</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1603.07351</idno>
		<title level="m">Non-determinism in byzantine fault-tolerant replication</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Practical byzantine fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">OSDI</title>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="volume">99</biblScope>
			<biblScope unit="page" from="173" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Distributed provenance compression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">T</forename><surname>Lehri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">Kuan</forename><surname>Loh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Alur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Loo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data</title>
		<meeting>the 2017 ACM International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="203" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Provenance in databases: Why, how, and where</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cheney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends R in Databases</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="379" to="474" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Dbnotes: a post-it system for relational databases based on provenance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chiticariu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-C</forename><surname>Tan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Vijayvargiya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2005 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="942" to="944" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Dang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T A</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Loghin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E.-C</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1804.00399</idno>
		<title level="m">Towards scaling blockchain systems via sharding</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Step by step towards creating a safe smart contract: Lessons and insights from a cryptocurrency lab</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Delmolino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Arnett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Financial Cryptography and Data Security</title>
		<imprint>
			<biblScope unit="page" from="79" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Springer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Provenance for natural language queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Deutch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gilad</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="577" to="588" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Untangling blockchain: A data processing view of blockchain systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T A</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1366" to="1385" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Blockbench: A framework for analyzing private blockchains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T A</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Tan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM International Conference on Management of Data</title>
		<meeting>the 2017 ACM International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1085" to="1100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Majority is not enough: Bitcoin mining is vulnerable</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Eyal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">G</forename><surname>Sirer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="95" to="102" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Provenance for generalized map and reduce workflows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ikeda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Titian: Data provenance support in spark</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Interlandi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">D</forename><surname>Tetali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">A</forename><surname>Gulzar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Millstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Condie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="216" to="227" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">The orchestra collaborative data sharing system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">G</forename><surname>Ives</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karvounarakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Tannen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">P</forename><surname>Talukdar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jacob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigmod Record</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="26" to="32" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Digital supply chain transformation toward blockchain integration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Korpela</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hallikas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dahlberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proceedings of the 50th Hawaii international conference on system sciences</title>
		<meeting>the 50th Hawaii international conference on system sciences</meeting>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Making smart contracts smarter</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Luu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D.-H</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Olickel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Saxena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hobor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</title>
		<meeting>the 2016 ACM SIGSAC Conference on Computer and Communications Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="254" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Demystifying incentives in the consensus computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Luu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Teutsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Saxena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Bitcoin: A peer-to-peer electronic cash system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Nakamoto</surname></persName>
		</author>
		<ptr target="https://bitcoin.org/bitcoin.pdf" />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Stubborn mining: Generalizing selfish mining and combining with an eclipse attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Nayak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Security and Privacy (EuroS&amp;P), 2016 IEEE European Symposium on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="305" to="320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Blockchain-a financial technology for future sustainable development</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><forename type="middle">K</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">3rd International Conference on Green Technology and Sustainable Development (GTSD)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="51" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Ramp: A system for capturing and tracing provenance in mapreduce workflows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Park</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ikeda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Widom</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Smoke: Fine-grained lineage at interactive speed</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Psallidas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="719" to="732" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Optimal selfish mining strategies in bitcoin</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Sapirshtein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Sompolinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Zohar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Financial Cryptography and Data Security</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="515" to="532" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">A survey of data provenance in e-science</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">L</forename><surname>Simmhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Plale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Sigmod Record</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="31" to="36" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">How blockchain is changing finance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tapscott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Tapscott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Harvard Business Review</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">An agri-food supply chain traceability system for china based on rfid &amp; blockchain technology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Tian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Service Systems and Service Management (ICSSSM), 2016 13th International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Big data provenance: Challenges, state of the art and opportunities</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Crawl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Purawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Altintas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2015 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2509" to="2516" />
		</imprint>
	</monogr>
	<note>Big Data (Big Data</note>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Forkbase: An efficient storage engine for blockchain and forkable applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">T A</forename><surname>Dinh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Ooi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ruan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1137" to="1150" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xu</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1812.02386</idno>
		<title level="m">vchain: Enabling verifiable boolean range queries over blockchain databases</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
