<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Optimizing Search Engines using Clickthrough Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thorsten</forename><surname>Joachims</surname></persName>
							<email>tj@cs.cornell.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science Ithaca</orgName>
								<orgName type="institution">Cornell University</orgName>
								<address>
									<postCode>14853</postCode>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Optimizing Search Engines using Clickthrough Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>This paper presents an approach to automatically optimizing the retrieval quality of search engines using clickthrough data. Intuitively, a good information retrieval system should present relevant documents high in the ranking, with less relevant documents following below. While previous approaches to learning retrieval functions from examples exist, they typically require training data generated from relevance judgments by experts. This makes them difficult and expensive to apply. The goal of this paper is to develop a method that utilizes clickthrough data for training, namely the query-log of the search engine in connection with the log of links the users clicked on in the presented ranking. Such clickthrough data is available in abundance and can be recorded at very low cost. Taking a Support Vector Machine (SVM) approach, this paper presents a method for learning retrieval functions. From a theoretical perspective, this method is shown to be well-founded in a risk minimization framework. Furthermore, it is shown to be feasible even for large sets of queries and features. The theoretical results are verified in a controlled experiment. It shows that the method can effectively adapt the retrieval function of a meta-search engine to a particular group of users, outperforming Google in terms of retrieval quality after only a couple of hundred training examples.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Which WWW page(s) does a user actually want to retrieve when he types some keywords into a search engine? There are typically thousands of pages that contain these words, but the user is interested in a much smaller subset. One could simply ask the user for feedback. If we knew the set of pages actually relevant to the user's query, we could use this as training data for optimizing (and even personalizing) the retrieval function.</p><p>Unfortunately, experience shows that users are only rarely willing to give explicit feedback. However, this paper argues that sufficient information is already hidden in the logfiles of WWW search engines. Since major search engines re-ceive millions of queries per day, such data is available in abundance. Compared to explicit feedback data, which is typically elicited in laborious user studies, any information that can be extracted from logfiles is virtually free and substantially more timely.</p><p>This paper presents an approach to learning retrieval functions by analyzing which links the users click on in the presented ranking. This leads to a problem of learning with preference examples like "for query q, document da should be ranked higher than document d b ". More generally, I will formulate the problem of learning a ranking function over a finite domain in terms of empirical risk minimization. For this formulation, I will present a Support Vector Machine (SVM) algorithm that leads to a convex program and that can be extended to non-linear ranking functions. Experiments show that the method can successfully learn a highly effective retrieval function for a meta-search engine.</p><p>This paper is structured as follows. It starts with a definition of what clickthrough data is, how it can be recorded, and how it can be used to generate training examples in the form of preferences. Section 3 then introduces a general framework for learning retrieval functions, leading to an SVM algorithm for learning parameterized orderings in Section 4. Section 5 evaluates the method based on experimental results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">CLICKTHROUGH DATA IN SEARCH ENGINES</head><p>Clickthrough data in search engines can be thought of as triplets (q, r, c) consisting of the query q, the ranking r presented to the user, and the set c of links the user clicked on. <ref type="figure" target="#fig_0">Figure 1</ref> illustrates this with an example: the user asked the query "support vector machine", received the ranking shown in <ref type="figure" target="#fig_0">Figure 1</ref>, and then clicked on the links ranked 1, 3, and 7. Since every query corresponds to one triplet, the amount of data that is potentially available is virtually unlimited.</p><p>Clearly, users do not click on links at random, but make a (somewhat) informed choice. While clickthrough data is typically noisy and clicks are not "perfect" relevance judgments, the clicks are likely to convey some information. The key question is: how can this information be extracted? Before deriving a model of how clickthrough data can be analyzed, let's first consider how it can be recorded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Recording Clickthrough Data</head><p>Clickthrough data can be recorded with little overhead and without compromising the functionality and usefulness of the search engine. In particular, compared to explicit user feedback, it does not add any overhead for the user. The query q and the returned ranking r can easily be recorded whenever the resulting ranking is displayed to the user. For recording the clicks, a simple proxy system can keep a logfile. For the experiments in this paper, the following system was used.</p><p>Each query is assigned a unique ID which is stored in the query-log along with the query words and the presented ranking. The links on the results-page presented to the user do not lead directly to the suggested document, but point to a proxy server. These links encode the query-ID and the URL of the suggested document. When the user clicks on the link, the proxy-server records the URL and the query-ID in the click-log. The proxy then uses the HTTP Location command to forward the user to the target URL. This process can be made transparent to the user and does not influence system performance.</p><p>This shows that clickthrough data can be recorded easily and at little cost. Let's now address the key question of how it can be analyzed in a principled and efficient way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">What Kind of Information does Clickthrough Data Convey?</head><p>There are strong dependencies between the three parts of (q, r, c). The presented ranking r depends on the query q as determined by the retrieval function implemented in the search engine. Furthermore, the set c of clicked-on links depends on both the query q and the presented ranking r. First, a user is more likely to click on a link, if it is relevant to q <ref type="bibr" target="#b40">[16]</ref>. While this dependency is desirable and interesting for analysis, the dependency of the clicks on the presented ranking r muddies the water. In particular, a user is less likely to click on a link low in the ranking, independent of how relevant it is. In the extreme, the probability that the user clicks on a link at rank 10.000 is virtually zero even if it is the document most relevant to the query. No user will scroll down the ranking far enough to observe this link. Therefore, in order to get interpretable and meaningful retrieval function bxx tfc hand-tuned avg. clickrank 6.26±1.14 6.18±1.33 6.04± 0.92 <ref type="table">Table 1</ref>: Average clickrank for three retrieval functions ("bxx", "tfc" <ref type="bibr" target="#b47">[23]</ref> , and a "hand-tuned" strategy that uses different weights according to HTML tags) implemented in LASER. Rows correspond to the retrieval method used by LASER at query time; columns hold values from subsequent evaluation with other methods. Figures reported are means and two standard errors. The data for this table is taken from <ref type="bibr">[5]</ref> .</p><p>results from clickthrough data, it is necessary to consider and model the dependencies of c on q and r appropriately.</p><p>Before defining such a model, let's first consider an interpretation of clickthrough data that is not appropriate. A click on a particular link cannot be seen as an absolute relevance judgment. Consider the empirical data in <ref type="table">Table 1</ref>. The data is taken from <ref type="bibr">[5]</ref> and was recorded for the search engine LASER covering the WWW of the CMU School of Computer Science. The table shows the average rank of the clicks per query (e.g. 3.67 in the example in <ref type="figure" target="#fig_0">Figure 1</ref>). Each table cell contains the average clickrank for three retrieval strategies averaged over ≈ queries. The average clickrank is almost equal for all methods. However, according to subjective judgments, the three retrieval functions are substantially different in their ranking quality. The lack of difference in the observed average clickrank can be explained as follows. Since users typically scan only the first l (e.g. l ≈ 10 <ref type="bibr" target="#b48">[24]</ref>) links of the ranking, clicking on a link cannot be interpreted as a relevance judgment on an absolute scale. Maybe a document ranked much lower in the list was much more relevant, but the user never saw it. It appears that users click on the (relatively) most promising links in the top l, independent of their absolute relevance. How can these relative preference judgments be captured and analyzed?</p><p>Consider again the example from Figure 1. While it is not possible to infer that the links 1, 3, and 7 are relevant on an absolute scale, it is much more plausible to infer that link 3 is more relevant than link 2 with probability higher than random. Assuming that the user scanned the ranking from top to bottom, he must have observed link before clicking on 3, making a decision to not click on it. Given that the abstracts presented with the links are sufficiently informative, this gives some indication of the user's preferences. Similarly, it is possible to infer that link 7 is more relevant than links 2, 4, 5, and 6. This means that clickthrough data does not convey absolute relevance judgments, but partial relative relevance judgments for the links the user browsed through. A search engine ranking the returned links according to their relevance to q should have ranked links 3 ahead of 2, and link 7 ahead of 2, 4, 5, and 6. Denoting the ranking preferred by the user with r * , we get partial <ref type="bibr">(</ref> This strategy for extracting preference feedback is summarized in the following algorithm. Unfortunatly, this type of feedback is not suitable for standard machine learning algorithms. The following derives a new learning algorithm, so that this "weak" type of relative feedback can be used as training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">A FRAMEWORK FOR LEARNING OF RETRIEVAL FUNCTIONS</head><p>The problem of information retrieval can be formalized as follows. For a query q and a document collection D = {d1, ..., dm}, the optimal retrieval system should return a ranking r * that orders the documents in D according to their relevance to the query. While the query is often represented as merely a set of keywords, more abstractly it can also incorporate information about the user and the state of the information search.</p><p>Typically, retrieval systems do not achieve an optimal ordering r * . Instead, an operational retrieval function f is evaluated by how closely its ordering r f(q) approximates the optimum. Formally, both r * and r f(q) are binary relations over D × D that fulfill the properties of a weak ordering, i.e. r * ⊂ D × D and r f(q) ⊂ D × D being asymmetric, and negatively transitive. If a document di is ranked higher than dj for an ordering r, i.e. di &lt;r dj, then (di, dj) ∈ r, otherwise (di, dj) ∈ r. If not stated otherwise, let's assume for simplicity that r * and r f(q) are both strict orderings. This means that for all pairs (d1, d2) ∈ D × D either di &lt;r dj or dj &lt;r di. However, it is straightforward to generalize most of the following result to r * being a weak ordering.</p><p>What is an appropriate measure of similarity between the system ranking r f(q) and the target ranking r * ? For a binary relevance scale, Average Precision <ref type="bibr">[1]</ref> is most frequently used in information retrieval. However, most information retrieval researchers agree that binary relevance is very coarse and that it is merely used as as simplifying assumption. Since the method presented in the following does not require such a simplification, we will depart from a binary relevance scheme and adapt <ref type="bibr">Kendall</ref> orderings. In this case, Kendall's τ can be defined as:</p><formula xml:id="formula_0">τ (ra, r b ) = P − Q P + Q = 1 − 2Q m 2<label>(2)</label></formula><p>As an example, consider the two rankings ra and r b as follows:</p><formula xml:id="formula_1">d1 &lt;r a d2 &lt;r a d3 &lt;r a d4 &lt;r a d5 (3) d3 &lt;r b d2 &lt;r b d1 &lt;r b d4 &lt;r b d5 (4)</formula><p>The number of discordant pairs is 3 (ie. {d2, d3}, {d1, d2}, {d1, d3}), while all remaining 7 pairs are concordant. Therefore, τ (ra, r b ) = 0.4. Why is this similarity measure appropriate for information retrieval? Equation (2) depends only on Q for a fixed collection. Taken as a distance measure, Q fulfills the axioms of Kemeny and Snell <ref type="bibr" target="#b42">[18]</ref> for strict orderings. Furthermore, it is proportional to the measure of Yao <ref type="bibr" target="#b50">[26]</ref> proposed for evaluating information retrieval systems. If applied to a binary relevance scale, it is easy to see that maximizing (2) is equivalent to minimizing the average rank of the relevant documents. And finally, τ (r f(q) , r * ) is related to Average Precision <ref type="bibr">[1]</ref>. In particular, the number of inversions Q gives a lower bound on the Average Precision as follows.</p><formula xml:id="formula_2">AvgP rec(r f(q) ) ≥ 1 R Q + R + 1 2 −1 R i=1 √ i 2 (5)</formula><p>R is the number of relevant documents. The proof is given in the appendix. These arguments show how τ (r f(q) , r * ) relates to retrieval quality. They demonstrate that maximizing τ (r f(q) , r * ) is connected to improved retrieval quality in multiple frameworks.</p><p>We are now in a position to define the problem of learning a ranking function. For a fixed but unknown distribution Pr(q, r * ) of queries and target rankings on a document collection D with m documents, the goal is to learn a retrieval function f(q) for which the expected Kendall's τ</p><formula xml:id="formula_3">τP (f) = τ (r f(q) , r * )d Pr(q, r * )<label>(6)</label></formula><p>is maximal. Note that (6) is (proportional to) a risk functional <ref type="bibr" target="#b49">[25]</ref> with −τ as the loss function. While the goal of learning is now defined, the question remains whether it is possible to design learning methods that optimize (6)?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">AN SVM ALGORITHM FOR LEARNING OF RANKING FUNCTIONS</head><p>Most work on machine learning in information retrieval does not consider the formulation of above, but simplifies the task to a binary classification problem with the two classes "relevant" and "non-relevant". Such a simplification has several drawbacks. For example, due to a strong majority of "non-relevant" documents, a learner will typically achieve the maximum predictive classification accuracy, if it always responds "non-relevant", independent of where the relevant documents are ranked. But even more importantly, Section 2.2 showed that such absolute relevance judgments cannot be extracted from clickthrough data, so that they are simply not available. Therefore, the following algorithm directly addresses (6), taking an empirical risk minimization approach <ref type="bibr" target="#b49">[25]</ref>. Given an independently and identically distributed training sample S of size n containing queries q with their target rankings r *</p><formula xml:id="formula_4">(q 1 , r * 1 ), (q 2 , r * 2 ), ..., (q n , r * n ).<label>(7)</label></formula><p>the learner L will select a ranking function f from a family of ranking functions F that maximizes the empirical τ</p><formula xml:id="formula_5">τS(f) = 1 n n i=1 τ (r f(q i ) , r * i ).<label>(8)</label></formula><p>on the training sample. Note that this setup is analogous to e.g. classification by minimizing training error, just that the target is not a class label, but a binary ordering relation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Ranking SVM Algorithm</head><p>Is it possible to design an algorithm and a family of ranking functions F so that (a) finding the function f ∈ F maximizing (8) is efficient, and (b) that this function generalizes well beyond the training data. Consider the class of linear ranking functions</p><formula xml:id="formula_6">(di, dj) ∈ f w (q) ⇐⇒ wΦ(q, di) &gt; wΦ(q, dj).<label>(9)</label></formula><p>w is a weight vector that is adjusted by learning. Φ(q, d) is a mapping onto features that describe the match between query q and document d like in the description-oriented retrieval approach of Fuhr et al. <ref type="bibr">[10]</ref> <ref type="bibr" target="#b35">[11]</ref>. Such features are, for example, the number of words that query and document share, the number of words they share inside certain HTML tags (e.g. TITLE, H1, H2, ...), or the page-rank of d <ref type="bibr" target="#b46">[22]</ref> (see also Section 5.2). <ref type="figure" target="#fig_3">Figure 2</ref> illustrates how the weight vector w determines the ordering of four points in a twodimensional example. For any weight vector w, the points are ordered by their projection onto w (or, equivalently, by their signed distance to a hyperplane with normal vector w). This means that for w1 the points are ordered (1, 2, 3, 4), while w2 implies the ordering (2, 3, 1, 4). Instead of maximizing (8) directly, it is equivalent to minimize the number Q of discordant pairs in Equation (2). For the class of linear ranking functions (9), this is equivalent to finding the weight vector so that the maximum number of the following inequalities is fulfilled.</p><formula xml:id="formula_7">∀(di, dj) ∈ r * 1 : wΦ(q 1 , di) &gt; wΦ(q 1 , dj)<label>(10)</label></formula><p>...</p><formula xml:id="formula_8">∀(di, dj) ∈ r * n : wΦ(q n , di) &gt; wΦ(q n , dj)<label>(11)</label></formula><p>Unfortunately, a direct generalization of the result in <ref type="bibr" target="#b37">[13]</ref> shows that this problem is NP-hard. However, just like in classification SVMs <ref type="bibr">[7]</ref>, it is possible to approximate the solution by introducing (non-negative) slack variables ξ i,j,k and minimizing the upper bound ξ i,j,k . Adding SVM regularization for margin maximization to the objective leads to the following optimization problem, which is similar to the ordinal regression approach in <ref type="bibr" target="#b36">[12]</ref>.</p><formula xml:id="formula_9">Optimization Problem 1. (Ranking SVM) minimize: V ( w, ξ) = 1 2 w • w + C ξ i,j,k<label>(12)</label></formula><p>subject to:</p><formula xml:id="formula_10">∀(di, dj) ∈ r * 1 : wΦ(q 1 , di) ≥ wΦ(q 1 , dj) + 1 − ξi,j,1 ...<label>(13)</label></formula><formula xml:id="formula_11">∀(di, dj) ∈ r * n : wΦ(q n , di) ≥ wΦ(q n , dj) + 1 − ξi,j,n ∀i∀j∀k : ξ i,j,k ≥ 0 (14)</formula><p>C is a parameter that allows trading-off margin size against training error. Geometrically, the margin δ is the distance between the closest two projections within all target rankings. This is illustrated in <ref type="figure" target="#fig_3">Figure 2</ref>.</p><p>Optimization Problem 1 is convex and has no local optima. By rearranging the constraints (13) as</p><formula xml:id="formula_12">w (Φ(q k , di) − Φ(q k , dj)) ≥ 1 − ξ i,j,k ,<label>(15)</label></formula><p>it becomes apparent that the optimization problem is equivalent to that of a classification SVM on pairwise difference vectors Φ(q k , di) − Φ(q k , dj). Due to this similarity, it can be solved using decomposition algorithms similar to those used for SVM classification. In the following, an adaptation of the SV M light algorithm <ref type="bibr" target="#b38">[14]</ref> is used for training . It can be shown that the learned retrieval function f w * can always be represented as a linear combination of the feature vectors.</p><formula xml:id="formula_13">(di, dj) ∈ f w * (q) (16) ⇐⇒ w * Φ(q, di) &gt; w * Φ(q, dj) (17) ⇐⇒ α * k,l Φ(q k , d l )Φ(q, di) &gt; α * k,l Φ(q k , d l )Φ(q, dj) (18)</formula><p>This makes it possible to use Kernels [4] <ref type="bibr" target="#b49">[25]</ref> and extend the Ranking SVM algorithm to non-linear retrieval functions. The α * k,l can be derived from the values of the dual variables at the solution.</p><p>Most commonly, f w * will be used for ranking the set of documents according to a new query q. In this case it is sufficient to sort the documents by their value of</p><formula xml:id="formula_14">rsv(q, di) = w * Φ(q, di) = α * k,l Φ(q k , d l )Φ(q, dj).<label>(19)</label></formula><p>If Kernels are not used, this property makes the application of the learned retrieval function very efficient. Fast algorithms exists for computing rankings based on linear functions by means of inverted indices (see e.g. <ref type="bibr">[1]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Using Partial Feedback</head><p>If clickthrough logs are the source of training data, the full target ranking r * for a query q is not observable. However, as shown in Section 2.2, a subset r ⊆ r * can be inferred from the logfile. It is straightforward to adapt the Ranking SVM to the case of such partial data by replacing r * with the observed preferences r . Given a training set S</p><formula xml:id="formula_15">(q 1 , r 1 ), (q 2 , r 2 ), ..., (q n , r n )<label>(20)</label></formula><p>with partial information about the target ranking, this results in the following algorithm.</p><p>Optimization Problem 2. (Ranking SVM (partial))</p><formula xml:id="formula_16">minimize: V ( w, ξ) = 1 2 w • w + C ξ i,j,k<label>(21)</label></formula><p>subject to:</p><formula xml:id="formula_17">∀(di, dj) ∈ r 1 : wΦ(q 1 , di) &gt; wΦ(q 1 , dj) + 1 − ξi,j,1 ... (22) ∀(di, dj) ∈ r n : wΦ(q n , di) &gt; wΦ(q n , dj) + 1 − ξi,j,n ∀i∀j∀k : ξ i,j,k ≥ 0<label>(23)</label></formula><p>The resulting retrieval function is defined analogously. Using this algorithm results in finding a ranking function that has a low number of discordant pairs with respect to the observed parts of the target ranking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">EXPERIMENTS</head><p>The following experiments verify whether the inferences drawn from the clickthrough data are justified, and whether the Ranking SVM can successfully use such partial preference data. First, the experiment setup in the framework of a meta-search engine is described. It follow the results of an offline experiment and an online experiment. The offline experiment is designed to verify that the Ranking SVM can indeed learn a retrieval function maximizing Kendall's τ on partial preference feedback. The online experiment goes further and verifies that the learned retrieval function does improve retrieval quality as desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Experiment Setup: Meta-Search</head><p>To elicit data and provide a framework for testing the algorithm, I implemented a WWW meta-search engine called "Striver". Meta-search engines combine the results of several basic search engines without having a database of their own. Such a setup has several advantages. First, it is easy to implement while covering a large document collectionnamely the whole WWW. Second, the basic search engines provide a basis for comparison.</p><p>The "Striver" meta-search engine works as follows. The user types a query into Striver's interface. This query is forwarded to "Google", "MSNSearch", "Excite", "Altavista", and "Hotbot". The results pages returned by these basic search engines are analyzed and the top 100 suggested links are extracted. After canonicalizing URLs, the union of these links composes the candidate set V . Striver ranks the links in V according to its learned retrieval function f w * and presents the top 50 links to the user. For each link, the system displays the title of the page along with its URL. The clicks of the user are recorded using the proxy system described in Section 2.1.</p><p>To be able to compare the quality of different retrieval functions, the method described in <ref type="bibr" target="#b40">[16]</ref> is used. The key idea is to present two rankings at the same time. This particular form of presentation leads to a blind statistical test so that the clicks of the user demonstrate unbiased preferences. In particular, to compared two rankings A and B, they are combined into a single ranking C so that the following condition holds for any top l links of the combined ranking. The top l links of the combined ranking C contain the top ka links from A and the top k b links from B, with |ka − k b | ≤ 1. In other words, if the user scans the links of C from top to bottom, at any point he has seen almost equally many links from the top of A as from the top of B. It is shown in <ref type="bibr" target="#b40">[16]</ref> that such a combined ranking always exists and that it can be constructed efficiently.</p><p>An example is given in <ref type="figure" target="#fig_4">Figure 3</ref>. The results of two retrieval functions are combined into one ranking that is presented to the user. Note that the abstracts and all other aspects of the presentation are unified, so that the user cannot tell which retrieval strategy proposed a particular page. In the example, the user clicks on links 1, 3, and 7. What inference can one draw from these clicks?</p><p>In the example, the user must have seen the top 4 links from both individual rankings, since he clicked on link 7 in the combined ranking. He decided to click on 3 links in the top 4 in ranking A (namely 1, 2, and 4), but only on 1 link in ranking B (namely 1). It is reasonable to conclude, that (with probability larger than random) the top 4 links from A were judged to be better than those from B for this query.</p><p>It is straightforward to design hypothesis tests regarding the user preferences based on such a combined ranking. Roughly speaking, if a user does not have any preference regarding A or B, he will click equally often on links in the top k of each ranking. If for a sample of pairs (A1, B1), ... , (As, Bs) the user clicks on significantly more links from A than from B, then A must contain more relevant links than B in the following sense. Formalizing the assumption that</p><p>• users click by some &gt; 0 more often on a more relevant link than on a less relevant link</p><p>• and that the decision of the user to click on a link is not influenced by other factors (i.e. links from both A it is proven and empirically verified in <ref type="bibr" target="#b40">[16]</ref> that the conclusions drawn from this method lead to the same result as an evaluation with explicit manual relevance judgments for large s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Offline Experiment</head><p>This experiment verifies that the Ranking SVM can indeed learn regularities using partial feedback from clickthrough data. To generate a first training set, I used the Striver search engine for all of my own queries during October, 2001. Striver displayed the results of Google and MSNSearch using the combination method from the previous section. All clickthrough triplets were recorded. This resulted in 112 queries with a non-empty set of clicks. This data provides the basis for the following offline experiment.</p><p>To learn a retrieval function using the Ranking SVM, it is necessary to design a suitable feature mapping Φ(q, d) describing the match between a query q and a document d. The following features are used in the experiment. However, this set of features is likely to be far from optimal. While the attributes reflect some of my intuition about what could be important for learning a good ranking, I included only those features that were easy to implement. Furthermore, I did not do any feature selection or similar tuning, so that an appropriate design of features promises much room for improvement. The implemented features are the following:   <ref type="table">Table 2</ref>: Pairwise comparison of the learned retrieval function with Google, MSNSearch, and the non-learning meta-search ranking. The counts indicate for how many queries a user clicked on more links from the top of the ranking returned by the respective retrieval function. From the 112 queries, pairwise preferences were extracted according to Algorithm 1 described in Section 2.2. In addition, 50 constraints were added for each clicked-on document indicating that it should be ranked higher than a random other document in the candidate set V . While the latter constraints are not based on user feedback, they should hold for the optimal ranking in most cases. These additional constraints help stabilize the learning result and keep the learned ranking function somewhat close to the original rankings. <ref type="figure" target="#fig_6">Figure 4</ref> shows the predictive performance of the Ranking SVM. To produce the graph, the full data set is split randomly into a training and a test set. The x-axis shows the number of training queries. The y-axis shows the percentage of pairwise preference constraints that are not fulfilled in the test set. Each point is an average over 10 (5-20 training queries) / 20 (40-80 training queries) different test/training splits. When training the Ranking SVM, no kernel was used and C, the trade-off between training error and margin, was selected from C ∈ {0.001, 0.003, 0.005, 0.01} by minimizing leave-one-out error on the training set. The graph shows that the Ranking SVM can learn regularities in the prefer-ences. The test error decreases to around 10%. The graph also shows the number of constraints violated by the rankings produced by Google and MSNSearch. Their error rates are substantially larger than for the learned retrieval function.</p><p>These results provide a first proof of concept and justify a larger-scale experiment with multiple users. In particular, while the offline experiment verifies that the Ranking SVM can learn to predict the preference constraints, it is not clear whether the learned retrieval function does improve the retrieval quality objectively. This question is addressed by the following experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Interactive Online Experiment</head><p>To show that the learned retrieval function improves retrieval, the following online experiment was conducted. Starting on October 31 st , 2001, the Striver search engine was made available to a group of approximately 20 users. The group consisted of researcher and students of the AI unit at the University of Dortmund headed by Prof. K. Morik. They were asked to use Striver just like they would use any other WWW search engine. By November 20 th , the system had collected 260 training queries (with at least one click). On these queries, the Ranking SVM was trained using the same Φ(q, d) and the same general setup as described above. The learned function was then implemented in Striver and used for ranking the candidate set V . During the evaluation period lasting until December 2 nd , the learned retrieval function is compared against:</p><p>• Google</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• MSNSearch</head><p>• Toprank: A baseline meta-search engine that ranks links retrieved at rank 1 by either Google, MSNSearch, Altavista, Excite, or Hotbot, before links ranked 2, before those ranked 3 etc.</p><p>The different strategies are compared using the method described in Section 5.1. The learned retrieval strategy is presented in combination with one of the three baseline rankings selected at random. <ref type="table">Table 2</ref> shows for how many queries users click on more/less links from the top of the learned retrieval function. The first line of the table compares the learned retrieval function with Google. On 29 queries, the users click on more links from the learned function, on 13 queries they click on more links from Google, and on 27+19 queries they click on an equal number (or none). Using a two-tailed binomial sign test, the difference is significant at a 95%-level, leading to the conclusion that the learned retrieval function is better than that of Google for this group of users. The same applies to the other two comparisons.  <ref type="table">Table 3</ref>: Features with largest and smallest weights as learned from the training data in the online experiment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Analysis of the Learned Function</head><p>The previous result shows that the learned function improves retrieval. But what does the learned function look like? Is it reasonable and intuitive? Since the Ranking SVM learns a linear function, one can analyze the function by studying the learned weights. <ref type="table">Table 3</ref> displays the weights of some features, in particular, those with the highest absolute weights. Roughly speaking, a high positive (negative) weight indicates that documents with these features should be higher (lower) in the ranking.</p><p>The weights in <ref type="table">Table 3</ref> are reasonable for this group of users. Since many queries were for scientific material, it appears natural that URLs from the domain "citeseer" (and the alias "nec") received positive weight. The most influential weights are for the cosine match between query and abstract, whether the URL is in the top 10 from Google, and for the cosine match between query and the words in the URL. A document receives large negative weights, if it is not ranked top 1 by any search engine, if it not in the top 10 of any search engine (note that the second implies the first), and if the URL is long. All these weights are reasonable and make sense intuitively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">DISCUSSION AND RELATED WORK</head><p>The experimental results show that the Ranking SVM can successfully learn an improved retrieval function from clickthrough data. Without any explicit feedback or manual parameter tuning, it has automatically adapted to the particular preferences of a group of ≈ 20 users. This improvement is not only a verification that the Ranking SVM can learn using partial ranking feedback, but also an argument for personalizing retrieval functions. Unlike conventional search engines that have to "fit" their retrieval function to large and therefore heterogeneous groups of users due to the cost of manual tuning, machine learning techniques can improve retrieval substantially by tailoring the retrieval function to small and homogenous groups (or even individuals) without prohibitive costs.</p><p>While previous work on learning retrieval functions exists (e.g. <ref type="bibr">[10]</ref>), most methods require explicit relevance judgments. Most closely related is the approach of Bartell et al. <ref type="bibr">[2]</ref>. They present a mixture-of-experts algorithms for linearly combining ranking experts by maximizing a different rank correlation criterion. However, in their setup they rely on explicit relevance judgments. A similar algorithm for combining rankings was proposed by Cohen at al. <ref type="bibr">[6]</ref>. They show empirically and theoretically that their algorithm finds a combination that performs close to the best of the basic experts. The boosting algorithm of Freund et al. <ref type="bibr">[9]</ref> is an approach to combining many weak ranking rules into a strong ranking functions. While they also (approximately) minimize the number of inversions, they do not explicitly consider a distribution over queries and target rankings. However, their algorithm can probably be adapted to the setting considered in this paper. Algorithmically most closely related is the SVM approach to ordinal regression by Herbrich et al. <ref type="bibr" target="#b36">[12]</ref>. But, again, they consider a different sampling model. In ordinal regression all objects interact and they are ranked on the same scale. For the ranking problem in information retrieval, rankings need to be consistent only within a query, but not between queries. This makes the ranking problem less constrained. For example, in the ranking problem two documents di and dj can end up at very different ranks for two different queries q k and q l even if they have exactly the same feature vector (i.e. Φ(q k , di) = Φ(q l , dj)). An elegant perceptron-like algorithm for ordinal regression was recently proposed by Crammer and Singer <ref type="bibr">[8]</ref>. An interesting question is whether such an online algorithm can also be used to solve the optimization problem connected to the Ranking SVM.</p><p>Some attempts have been made to use implicit feedback by observing clicking behavior in retrieval systems <ref type="bibr">[5]</ref> and browsing assistants <ref type="bibr" target="#b41">[17]</ref> <ref type="bibr" target="#b44">[20]</ref>. However, the semantics of the learning process and its results are unclear as demonstrated in Section 2.2. The commercial search engine "Direct Hit" makes use of clickthrough data. The precise mechanism, however, is unpublished. While for a different problem, an interesting use of clickthrough data was proposed in <ref type="bibr">[3]</ref>. They use clickthrough data for identifying related queries and URLs.</p><p>What are the computational demands of training the Ranking SVM on clickthrough data? Since SV M light <ref type="bibr" target="#b39">[15]</ref> solves the dual optimization problem, it depends only on inner products between feature vectors Φ(q, d). If these feature vectors are sparse as above, SV M light can handle millions of features efficiently. Most influential on the training time is the number of constraints in Optimization Problem 2. However, when using clickthrough data, the number of constraints scales only linearly with the number of queries, if the number of clicks per query is upper bounded. In other applications, SV M light has already showed that it can solve problems with several millions of constraints using a regular desktop computer. However, scaling to the order of magnitude found in major search engines is an interesting open problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSIONS AND FUTURE WORK</head><p>This paper presented an approach to mining logfiles of WWW search engines with the goal of improving their retrieval performance automatically. The key insight is that such clickthrough data can provide training data in the form of relative preferences. Based on a new formulation of the learning problem in information retrieval, this paper derives an algorithm for learning a ranking function. Taking a Support Vector approach, the resulting training problem is tractable even for large numbers of queries and large numbers of features. Experimental results show that the algorithm performs well in practice, successfully adapting the retrieval function of a meta-search engine to the preferences of a group of users. This paper opens a series of question regarding the use machine learning in search engines. What is a good size of a user group and how can such groups be determined? Clearly, there is a trade-off between the amount of training data (ie. large group) and maximum homogeneity (ie. single user). Is it possible to use clustering algorithms to find homogenous groups of users? Furthermore, can clickthrough data also be used to adapt a search engine not to a group of users, but to the properties of a particular document collection? In particular, the factory-settings of any off-the-shelf retrieval system are necessarily suboptimal for any particular collection. Shipping off-the-shelf search engines with learning capabilities would enable them to optimize (and maintain) their performance automatically after being installed in a company intranet.</p><p>However, the algorithm is not limited to meta-search engines on the WWW. There are many situations where the goal of learning is a ranking based on some parameter (e.g. query). In particular, most recommender problems can be cast in this way. Particularly interesting in the recommender setting is the fact that the Ranking SVM can be trained with partial preference data. For example, consider a recommender system that aims to learn my TV watching preferences. By observing my "channel surfing" behavior, the system can infer which shows I prefer over other programs at a particular time. But again, this is a relative preference, not a preference on an absolute scale.</p><p>Open questions regarding the algorithm itself concern its theoretical characterization and its efficient implementation. Is it possible to prove generalization bounds based on the margin? Or, even more interesting from a practical point of view, is it possible to analyze the process of multiple learning/feedback steps in the sense of an incremental online algorithm? As elaborated before, there is a dependence between the links presented to the user, and those for which the system receives feedback. It would be interesting to explore active learning ideas to optimize this feedback. In this framework it might also be possible to explore mechanisms that make the algorithm robust against "spamming". It is currently not clear in how far a single user could maliciously influence the ranking function by repeatedly clicking on particular links. Regarding algorithms for solving the optimization problem, it seems likely that they can be further sped up, since the constraints have a special form. In particular, online algorithms would be most appropriate in many application settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>Theorem 1. Let r rel be the ranking placing all relevant documents ahead of all non-relevant documents and let rsys be the learned ranking. If Q is the number of discordant pairs between r rel and rsys, then the average precison is at least AvgP rec(rsys, r rel ) ≥</p><formula xml:id="formula_18">1 R Q + R + 1 2 −1 R i=1 √ i 2</formula><p>if there are R relevant documents.</p><p>Proof. If p1, ..., pR are the ranks of the relevant documents in rsys sorted in increasing order, then Average Precision can be computed as</p><formula xml:id="formula_19">AvgP rec(rsys, r rel ) = 1 R R i=1 i pi<label>(24)</label></formula><p>What is the minimum value of AvgP rec(rsys, r rel ), given that the number of discordant pairs is fixed. It is easy to see that the sum of the ranks p1 + ... + pR is related to the number of discordant Q as follows. Relaxing the problem by removing the last two sets of constraints can only decrease the minimum, so that the solution without the constraints is still a lower bound. The remaining problem is convex and can be solved using Lagrange multipliers. The Lagrangian is L(p1, ..., pR, β) = 1 R </p><formula xml:id="formula_20">R i=1 i pi + β R i=1 pi−Q − R + 1 2 .<label>(30</label></formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Ranking presented for the query "support vector machine". Marked in bold are the links the user clicked on.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm 1 .</head><label>1</label><figDesc>(Extracting Preference Feedback from Clickthrough) For a ranking (link1, link2, link3, ...) and a set C containing the ranks of the clicked-on links, extract a preference example linki &lt;r * linkj for all pairs 1 ≤ j &lt; i, with i ∈ C and j ∈ C.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>'s τ [19][21] as a performance measure. For comparing the ordinal correlation of two random variables, Kendall's τ is the most frequently used measure in statistics. For two finite strict orderings ra ⊂ D × D and r b ⊂ D × D, Kendall's τ can be defined based on the number P of concordant pairs and the number Q of discordant pairs (inversions). A pair di = dj is concordant, if both ra and r b agree in how they order di and dj. It is discordant if they disagree. Note, that on a finite domain D of m documents, the sum of P and Q is m 2 for strict</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Example of how two weight vectors w1 and w2 rank four points.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Example for query "support vector machine". The two upper boxes show the rankings returned by retrieval functions A and B. The lower box contains the combined ranking presented to the user. The links the user clicked on are marked in bold.and B are presented in the same way)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>1 .</head><label>1</label><figDesc>Rank in other search engines (38 features total): rank X: 100 minus rank in X ∈ {Google, MSN-Search, Altavista, Hotbot, Excite} divided by 100 (minimum 0) top1 X: ranked #1 in X ∈ {Google, MSNSearch, Altavista, Hotbot, Excite} (binary {0, 1}) top10 X: ranked in top 10 in X ∈ {Google, MSN-Search, Altavista, Hotbot, Excite} (binary {0, 1}) top50 X: ranked in top 50 in X ∈ {Google, MSN-Search, Altavista, Hotbot, Excite} (binary {0, 1}) top1count X: ranked #1 in X of the 5 search engines top10count X: ranked in top 10 in X of the 5 search engines top50count X: ranked in top 50 in X of the 5 search engines</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Generalization error of the Ranking SVM depending on the size of the training set. The error bars show one standard error. domain X: domain X of URL (binary attribute {0, 1} for each domain name) abstract contains home: word "home" appears in URL or title (binary attribute {0, 1}) url contains tilde: URL contains "∼" (binary attribute {0, 1}) url X: URL X as an atom (binary attribute {0, 1})</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>1 2 ( 25 )</head><label>125</label><figDesc>p1 + ... + pR = Q + R + It is now possible to write the lower bound as the following integer optimization problem. It computes the worst possible Average Precision for a fixed value of Q. minimize: P (p1, ..., pR)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>)</head><label></label><figDesc>At the minimum of the optimization problem, the Lagrangian is known to have partial derivatives equal to zero. Starting with the partial derivatives for the pi δ L(p1, ..., pR, β) δ pi = −i R −1 p pi, and substituting back into the Lagrangian leads to L(p1, ..., pR, β) = 2 R β, and again substituting into the Lagrangian leads to the desired solution.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Available at http : //svmlight.joachims.org</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGEMENTS</head><p>Many thanks to Prof. Morik and the AI unit at the University of Dortmund for providing their help and the resources for the experiments. Thanks also to Rich Caruana, Alexandru Niculescu-Mizil, Phoebe Sengers, John Kleinberg, and Lillian Lee for helpful discussions, as well as Wim Verhaegh for helping to clarify the connection to recommender systems.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Support Vector Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Svm-Light</surname></persName>
		</author>
		<ptr target="http://ais.gmd.de/∼thorsten/svmlight/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">An Introduction to Support Vector Machines</title>
		<ptr target="http://www.support−vector.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Archives of SUPPORT-VECTOR-MACHINES@JISCMAIL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Su P P Ort−v Ect Or−m Achin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Es</surname></persName>
		</author>
		<ptr target="http://www.jiscmail.ac.uk/lists/" />
	</analytic>
	<monogr>
		<title level="m">Support Vector Machine and Kernel Methods References</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://svm.research.bell−labs.com/SVT/SVMsvt.html" />
		<title level="m">Lucent Technologies: SVM demo applet</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="http://www.support−vector.net/software.html" />
		<title level="m">Support Vector Machine -The Software</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Lagrangian Support Vector Machine Home Page</title>
		<ptr target="http://www.cs.wisc.edu/dmi/lsvmRankingA:1.KernelMachineshttp://svm.first.gmd.de/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Support Vector Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Svm-Light</surname></persName>
		</author>
		<ptr target="http://ais.gmd.de/∼thorsten/svmlight/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Support Vector Machine and Kernel</title>
		<ptr target="http://svm.....com/SVMrefs.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<ptr target="http://svm.....com/SVT/SVMsvt.html" />
		<title level="m">Lucent Technologies: SVM demo applet</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<ptr target="http://www.support−vector.net/software.html" />
		<title level="m">Support Vector Machine -The Software</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<ptr target="http://svm.first.gmd.de/" />
		<title level="m">/ Ranking B: 1. Kernel Machines</title>
		<imprint/>
	</monogr>
	<note>Support Vector Machine</note>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">An Introduction to Support Vector Machines</title>
		<ptr target="http://www.support−vector.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Archives</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Support-Vector-Machines</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Su P P Ort</surname></persName>
		</author>
		<ptr target="http://www.jiscmail.ac.uk/lists/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Support Vector Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Svm-Light</surname></persName>
		</author>
		<ptr target="http://ais.gmd.de/∼thorsten/svmlight/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<ptr target="http://www.support−vector.net/software.html" />
		<title level="m">Support Vector Machine -The Software</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Lagrangian Support Vector Machine Home Page</title>
		<ptr target="http://www.cs.wisc.edu/dmi/lsvm" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">.</forename><forename type="middle">.</forename><surname>Support</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Bennett</surname></persName>
		</author>
		<ptr target="http://citeseer.../bennett97support.htmlCombinedResults" />
		<imprint>
			<pubPlace>Blue (ResearchIndex</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<ptr target="http://svm.first.gmd.de/" />
		<title level="m">Kernel Machines</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Support Vector Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Svm-Light</surname></persName>
		</author>
		<ptr target="http://ais.gmd.de/∼thorsten/svmlight/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">An Introduction to Support Vector Machines</title>
		<ptr target="http://www.support−vector.net/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Archives of SUPPORT-VECTOR-MACHINES@JISCMAIL</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Su P P Ort−v Ect Or−m Achin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Es</surname></persName>
		</author>
		<ptr target="http://www.jiscmail.ac.uk/lists/" />
	</analytic>
	<monogr>
		<title level="m">Support Vector Machine and Kernel Methods References</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<ptr target="http://svm.research.bell−labs.com/SVT/SVMsvt.html" />
		<title level="m">Lucent Technologies: SVM demo applet</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<ptr target="http://www.support−vector.net/software.html" />
		<title level="m">Support Vector Machine -The Software</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Lagrangian Support Vector Machine Home Page</title>
		<ptr target="http://www.cs.wisc.edu/dmi/lsvm9" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Baeza-Yates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ribeiro-Neto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Modern Information Retrieval. Addison-Wesley-Longman</title>
		<imprint>
			<date type="published" when="1999-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Automatic combination of multiple ranked retrieval systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Bartell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cottrell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Belew</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual ACM SIGIR Conf. on Research and Development in Information Retrieval (SIGIR)</title>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Agglomerative clustering of a search engine query log</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Beeferman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD)</title>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">A traininig algorithm for optimal margin classifiers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">E</forename><surname>Boser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">M</forename><surname>Guyon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">N</forename><surname>Vapnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Annual ACM Workshop on Computational Learning Theory</title>
		<editor>D. Haussler</editor>
		<meeting>the 5th Annual ACM Workshop on Computational Learning Theory</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="144" to="152" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">A machine learning architecture for optimizing web search engines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Boyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Freitag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI Workshop on Internet Based Information Systems</title>
		<imprint>
			<date type="published" when="1996-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Learning to order things</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shapire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Support-vector networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cortes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">N</forename><surname>Vapnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Machine Learning Journal</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="273" to="297" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Pranking with ranking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Crammer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems (NIPS)</title>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">An efficient boosting algorithm for combining preferences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Freund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shapire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning (ICML)</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Optimum polynomial retrieval functions based on the probability ranking principle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Fuhr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Information Systems</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="183" to="204" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Air/x -a rule-based multistage indexing system for large subject fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Fuhr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hartmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lustig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schwantner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tzeras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Knorz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RIAO</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="606" to="623" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Large margin rank boundaries for ordinal regression</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Herbrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Graepel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Obermayer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Large Margin Classifiers</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="115" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Robust trainability of single neurons</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Höffgen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Van Horn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">50</biblScope>
			<biblScope unit="page" from="114" to="125" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Making large-scale SVM learning practical</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Kernel Methods -Support Vector Learning, chapter 11</title>
		<editor>B. Schölkopf, C. Burges, and A. Smola</editor>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Learning to Classify Text Using Support Vector Machines -Methods, Theory, and Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Kluwer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Unbiased evaluation of retrieval quality using clickthrough data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
		<ptr target="http://www.joachims.org" />
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>Cornell University, Department of Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">WebWatcher: a tour guide for the world wide web</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Joachims</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Freitag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="770" to="777" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Mathematical Models in the Social Sciences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kemeny</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Snell</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1962" />
			<publisher>Ginn &amp; Co</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kendall</surname></persName>
		</author>
		<title level="m">Rank Correlation Methods. Hafner</title>
		<imprint>
			<date type="published" when="1955" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Letizia: An agent that assists Web browsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Lieberman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifteenth International Joint Conference on Artificial Intelligence (IJCAI &apos;95)</title>
		<meeting>the Fifteenth International Joint Conference on Artificial Intelligence (IJCAI &apos;95)<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Introduction to the Theory of Statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Graybill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1974" />
			<publisher>McGraw-Hill</publisher>
		</imprint>
	</monogr>
	<note>3 edition</note>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Pagerank, an eigenvector based ranking approach for hypertext</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Brin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st Annual ACM/SIGIR International Conference on Research and Development in Information Retrieval</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Term weighting approaches in automatic text retrieval</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Salton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Buckley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information Processing and Management</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="513" to="523" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Analysis of a very large altavista query log</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Silverstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Henzinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Marais</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moricz</surname></persName>
		</author>
		<idno>SRC 1998-014</idno>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
		<respStmt>
			<orgName>Digital Systems Research Center</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Vapnik</surname></persName>
		</author>
		<title level="m">Statistical Learning Theory</title>
		<meeting><address><addrLine>Chichester, GB</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Measuring retrieval effectiveness based on user preference of documents</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Yao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Society for Information Science</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="133" to="145" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
