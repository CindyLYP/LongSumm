<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Learning Independent Causal Mechanisms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giambattista</forename><surname>Parascandolo</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Niki</forename><surname>Kilbertus</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mateo</forename><surname>Rojas-Carulla</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernhard</forename><surname>Schölkopf</surname></persName>
						</author>
						<title level="a" type="main">Learning Independent Causal Mechanisms</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Statistical learning relies upon data sampled from a distribution, and we usually do not care what actually generated it in the first place. From the point of view of causal modeling, the structure of each distribution is induced by physical mechanisms that give rise to dependences between observables. Mechanisms, however, can be meaningful autonomous modules of generative models that make sense beyond a particular entailed data distribution, lending themselves to transfer between problems. We develop an algorithm to recover a set of independent (inverse) mechanisms from a set of transformed data points. The approach is unsupervised and based on a set of experts that compete for data generated by the mechanisms, driving specialization. We analyze the proposed method in a series of experiments on image data. Each expert learns to map a subset of the transformed data back to a reference distribution. The learned mechanisms generalize to novel domains. We discuss implications for transfer learning and links to recent trends in generative modeling.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Humans are able to recognize objects such as handwritten digits based on distorted inputs. They can correctly label translated, corrupted, or inverted digits, without having to relearn them from scratch. The same applies for new objects, essentially after having seen them once. Arguably, human intelligence utilizes mechanisms (such as translation) that are independent from an input domain and thus generalize across object classes. These mechanisms are modular, reusable and broadly applicable, and the problem of learning  <ref type="figure">Figure 1</ref>. An overview of the problem setup. Given a sample from a canonical distribution P , and one from a mixture of transformed distributions Qi obtained by mechanisms Mi on P , we want to learn inverse mechanisms Ei as independent modules. Modules (or experts) compete amongst each other for data points, encouraging specialization.</p><p>them from data is fundamental for the study of transfer and domain adaptation.</p><p>In the field of causality, the concept of independent mechanisms plays a central role both on the conceptual level and, more recently, in applications to inference. The independent mechanisms (IM) assumption states that the causal generative process of a system's variables is composed of autonomous modules that do not inform or influence each other <ref type="bibr" target="#b19">(Schölkopf et al., 2012;</ref><ref type="bibr" target="#b17">Peters et al., 2017)</ref>.</p><p>If a joint density is Markovian with respect to a directed graph G, we can write it as</p><formula xml:id="formula_0">p(x) = p(x 1 , . . . , x d ) = d j=1 p(x j |pa j G ),<label>(1)</label></formula><p>where pa j G denotes the parents of variable x j in the graph. For a given joint density, there are usually many decompositions of the form (1), with respect to different graphs. If G is a causal graph, i.e., if its edges denote direct causation <ref type="bibr" target="#b16">(Pearl, 2000)</ref>, then the conditional p(x j |pa G j ) can be thought of as physical mechanism generating x j from its parents, and we refer to it as a causal conditional. In this case, we consider the factorization (1) a generative model where the term "generative" truly refers to a physical generative process. As an aside, we note that in the alter-arXiv:1712.00961v5 <ref type="bibr">[cs.</ref>LG] 8 Sep 2018 native view of causal models as structural equation models, each of the causal conditionals corresponds to a functional mapping and a noise variable <ref type="bibr" target="#b16">(Pearl, 2000)</ref>.</p><p>By the IM assumption, the causal conditionals are autonomous modules that do not influence or inform each other. This has multiple consequences. First, knowledge of one mechanism does not contain information about another one (Appendix D). Second, if one mechanism changes (e.g., due to distribution shift), there is no reason that other mechanisms should also change, i.e., they tend to remain invariant. As a special case, it is (in principle) possible to locally intervene on one mechanism (for instance, by setting it to a constant) without affecting any of the other modules. In all these cases, most of (1) will remain unchanged. However, since the overall density will change, most generic (non-causal) conditionals would change.</p><p>The IM assumption can be exploited when performing causal structure inference <ref type="bibr" target="#b17">(Peters et al., 2017)</ref>. However, it also has implications for machine learning more broadly. A model which is expressed in terms of causal conditionals (rather than conditionals with respect to some other factorization) is likely to have components that better transfer or generalize to other settings <ref type="bibr" target="#b19">(Schölkopf et al., 2012)</ref>, and its modules are better suited for building complex models from simpler ones. Independent mechanisms as sub-components can be trained independently, from multiple domains, and are more likely to be re-usable. They may also be easier to interpret and provide more insight since they correspond to physical mechanisms.</p><p>Animate intelligence cannot afford to learn new models from scratch for every new task. Rather, it is likely to rely on robust local components that can flexibly be re-used and re-purposed. It also requires local mechanisms for adapting and training modules rather than re-training the whole brain every time a new task is learned. Currently, machine learning excels at optimizing well-defined tasks from large i.i.d. datasets. However, if we want to move towards life-long learning and generalization across tasks, then we need to understand how modules can be learnt from data and shared between tasks.</p><p>In the present paper, we focus on a class of such modules, and on algorithms to learn them from data. We describe an architecture using competing experts that automatically specialize on different image transformations. The resulting model is attractive for lifelong learning, with the possibility of easily adding, removing, retraining, and re-purposing its components independently. It is unsupervised in the sense that the images are not labeled by the transformations they have undergone. We only need a sample from a reference distribution and a set of transformed images. The transformed images are based on another sample, and no pairing or information about the transformations is available.</p><p>We test our approach on MNIST digits which have undergone various transformations such as contrast inversion, noise addition and translation. Information about the nature and number of such transformations is not known at the beginning of training. We identify the independent mechanisms linking the reference distribution to a distribution of modified digits, and learn to invert them without supervision.</p><p>The inverse mechanisms can be re-purposed as preprocessors, to transform modified digits which are subsequently classified using a standard MNIST classifier. The trained experts also generalize to Omniglot characters, none of which were seen during training. These are promising results pointing towards a form of robustness that animate intelligence excels at.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Related work</head><p>Our work mainly draws from mixtures of experts, domain adaptation, and causality.</p><p>Early works on mixture of experts date back to the early nineties <ref type="bibr" target="#b9">(Jacobs et al., 1991;</ref><ref type="bibr" target="#b11">Jordan &amp; Jacobs, 1994)</ref>, and since then the topic has been subject of extensive research. Recent work includes that of <ref type="bibr" target="#b20">Shazeer et al. (2017)</ref>, successfully training a mixture of 1000 experts using a gating mechanism that selects only a fraction of experts for each example. <ref type="bibr" target="#b0">Aljundi et al. (2017)</ref> train a network of experts on multiple tasks, with a focus on lifelong learning; autoencoders are trained for each task and used as gating mechanisms. <ref type="bibr" target="#b15">Lee et al. (2016)</ref> propose Stochastic Multiple Choice Learning, an algorithm which resembles the one we describe in Section 3, aimed at training mixture of experts to propose a diverse set of outputs. The main differences are that our model is trained jointly with a learned selection system which is valid also at test time, that our trained experts learn independent mechanisms and can be combined (cf. <ref type="figure">Figure 8)</ref>, and in the way experts are initialized.</p><p>Another research direction that is relevant to our work is unsupervised domain adaptation <ref type="bibr" target="#b1">(Bousmalis et al., 2017)</ref>. These methods often use some supervision from labeled data and/or match the two distributions in a learned feature space (e.g. <ref type="bibr" target="#b21">Tzeng et al., 2017)</ref>.</p><p>The novelty of our work lies in the following aspects: (1) we automatically identify and invert a set of independent (inverse) causal mechanisms; (2) we do so using only data from an original distribution and from the mixture of transformed data, without labels; (3) the architecture is modular, can be easily expanded, and its trained modules can be reused; and (4) the method relies on competition of experts.</p><p>Ideas from the field of causal inference inspire the present work. Understanding the data generating mechanisms plays a key role in causal inference, and goes beyond the statistical assumptions usually exploited in machine learning. Causality provides a framework for understanding how a system responds to interventions, and causal graphical models as well as structural equation models (SEM) are common ways of describing causal systems <ref type="bibr" target="#b16">(Pearl, 2000;</ref><ref type="bibr" target="#b17">Peters et al., 2017)</ref>. The IM assumption discussed in the introduction can be used for identification of causal models <ref type="bibr" target="#b4">(Daniušis et al., 2010;</ref><ref type="bibr" target="#b22">Zhang et al., 2015)</ref>, but causality has also proven a useful tool for discussing and understanding machine learning in the non-i.i.d. regime. Recent applications include semi-supervised learning <ref type="bibr" target="#b19">(Schölkopf et al., 2012)</ref> and transfer learning <ref type="bibr" target="#b18">(Rojas-Carulla et al., 2015)</ref>, in which the authors focus only on linear regression models. We seek to extend applications of causal inference to more complex settings and aim to learn causal mechanisms and ultimately causal SEMs without supervision.</p><p>On the conceptual level, our setting is related to recent work on deep learning for disentangling factors of variation <ref type="bibr" target="#b2">(Chen et al., 2016;</ref><ref type="bibr" target="#b6">Higgins et al., 2017)</ref> as well as non-linear ICA <ref type="bibr" target="#b7">(Hyvarinen &amp; Morioka, 2016)</ref>. In our work, causal mechanisms play the role of factors of variation. The main difference is that we recover mechanisms as independent modules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Learning causal mechanisms as independent modules</head><p>The aim of this section is twofold. First, we describe the generative process of our data. We start with a distribution P that we will call "canonical" and an a priori unknown number of independent mechanisms which act on (examples drawn from) P . At training time, a sample from the canonical distribution is available, as well as a dataset obtained by applying the mechanisms to (unseen) examples drawn from P . Second, we propose an algorithm which recovers and learns to invert the mechanisms in an unsupervised fashion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Formal setting</head><p>Consider a canonical distribution P on R d , e.g., the empirical distribution defined by MNIST digits on pixel space. We further consider N measurable functions M 1 , . . . , M N :</p><formula xml:id="formula_1">R d → R d , called mechanisms.</formula><p>We think of these as independent causal mechanisms in nature, and their number is a priori unknown. A more formal definition of independence between mechanisms is relegated to Appendix D. The mechanisms give rise to</p><formula xml:id="formula_2">N distributions Q 1 , . . . , Q N where Q j = M j (P ). 1</formula><p>This setup is illustrated in <ref type="figure">Figure 1</ref>. In the MNIST example, we consider translations or adding noise</p><p>Each distribution Qj is defined as the pushforward measure of P induced by Mj.</p><p>as mechanisms, i.e., the corresponding Q distributions are translated and noisy MNIST digits.</p><p>At training time, we receive a dataset</p><formula xml:id="formula_3">D Q = (x i ) n i=1 drawn i.i.d</formula><p>. from a mixture of Q 1 , . . . , Q N , and a dataset D P sampled independently from the canonical distribution P . Our goal is to identify the underlying mechanisms M 1 , . . . , M N and learn approximate inverse mappings which allow us to map the examples from D Q back to their counterpart in P .</p><p>If we were given distinct datasets D Qj each drawn from Q j , we could individually learn each mechanism, resulting in independent (approximations of the) mechanisms regardless of the properties of the training procedure. This is due to the fact that the datasets are drawn from independent mechanisms in the first place, and the separate training procedure cannot generate a dependence between them. This statement does not require that the procedure is successful, i.e., that the obtained mechanisms approximate the true M j in some metric.</p><p>In contrast, we do not require access to the distinct datasets. Instead we construct a larger set D Q by first taking the union of the sets D Qj , and then applying a random permutation. This corresponds to a dataset where each element has been generated by one of the (independent) mechanisms, but we do not know by which one. Clearly, it should be harder to identify and learn independent mechanisms from such a dataset. We next describe an approach to handle this setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Competitive learning of independent mechanisms</head><p>The training machine is composed of N parametric functions E 1 , . . . , E N with distinct trainable parameters θ 1 , . . . , θ N . We refer to these functions as the experts. Note that we do not require N = N , since the real number of mechanisms is unknown a priori. The goal is to maximize an objective function c : R d → R with the key property that c takes high values on the support of the canonical distribution P , and low values outside. Note that c could be a parametric function, and its parameters could be jointly optimized with the experts during training. Below, we specify the details of this rather general definition.</p><p>During training, the experts compete for the data points. Each example x from D Q is fed to all experts independently and in parallel. Comparing the outputs of all experts c j = c(E j (x )), we select the winning expert E j * , where j * = arg max j (c j ). Its parameters θ j * are updated such as to maximize c(E j * (x )), while the other experts remain unchanged. The motivation behind competitively updating only the winning expert is to enforce specialization; the best performing expert becomes even better at mapping x back to the corresponding example from the canonical distribution. We will describe below that alongside with the expert's parameters, we train parameters of <ref type="figure">Figure 2</ref>. We show how a transformed example, here a noisy digit, is processed by a competition of experts. Only Expert 3 is specializing on denoising, it wins the example and gets trained on it, whereas the others perform translations and are not updated.</p><p>c (which in our experiments will be carried in an adversarial fashion). <ref type="figure">Figure 2</ref> depicts this procedure. Overall, our optimization problem reads:</p><formula xml:id="formula_4">θ * 1 ,...,θ * N =argmax θ1 ,...,θ N E x ∼Q max j∈{1,...,N } c(E θj (x )) . (2)</formula><p>The training described above raises a number of questions, which we address next.</p><p>1. Selecting the appropriate number of experts. Generally, the number of mechanisms N which generated the dataset D Q is not available a priori. Therefore, we require an adaptive procedure to choose the number of experts N . This is one of the challenges shared with most clustering techniques. Given the modular behavior of the procedure, experts may be added or removed during or after training, making the framework very flexible. Assuming however that the number of experts is fixed, the following behaviors could occur.</p><p>If N &gt; N (too many experts): a) some of the experts do not specialize and do not win any example in the dataset; or b) some tasks are divided between experts (for instance, each expert can specialize in a mode of the distribution of the same task). In a), the inactive experts can be re-moved, and in b) experts sharing the same task can be merged into a wider expert. 2</p><p>If N &lt; N (too few experts): a) some of the experts specialize in multiple tasks or b) some of the tasks are not learned by the experts, so that data points from such tasks lead to a poor score across all experts. We provide experiments substantiating these claims in appendix A.1.</p><p>2. Convergence criterion. Since the problem is unsupervised, there is no straightforward way of measuring convergence, which raises the question of how to choose a stopping time for the competitive procedure. As an example, one may act according to one of the following: a) fix a maximum number of iterations or b) stop if each example is assigned to the same experts for a pre-defined number of iterations (i.e., each expert consistently wins the same data points).</p><p>3. Time and space complexity. Each example has to be evaluated by all experts in order to assign it to the winning expert.While this results in a computational cost that depends linearly on the number of experts, these evaluations can be done in parallel and therefore the time complexity of a single iteration can be bounded by the complexity to compute the output of a single expert. Moreover, as each expert will in principle have a smaller architecture than a single large network, the committee of experts will typically be faster to execute.</p><p>Concrete protocol for neural networks. One possible model class for the experts are deep neural networks. Training using backpropagation is particularly well suited for the online nature of the training proposed: after an expert wins a data point x , its parameters are updated by backpropagation, while the other experts remain untouched. Moreover, recent advances in generative modeling give rise to natural choices for the loss function c. For instance, through adversarial training <ref type="bibr" target="#b5">(Goodfellow et al., 2014)</ref>, one can use as objective function the output of a discriminator network trained on the canonical sample D P and against the outputs of the experts. In the next section we introduce a formal description of a training procedure based on adversarial training in Algorithm 1, and empirically evaluate its performance.</p><p>While in this work we focus on adversarial training, preliminary experiments have shown that similar results can be achieved for example with variational autoencoders (VAE) <ref type="bibr" target="#b13">(Kingma &amp; Welling, 2013)</ref>. Given a VAE trained on the canonical distribution P , one may define c(x ) as the opposite of the VAE loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Experiments</head><p>In this set of experiments we test the method presented in Section 3 on the MNIST dataset transformed with the set of mechanisms described in detail in the Appendix C, i.e., eight directions of translations by 4 pixels (up, down, left, right, and the four diagonals), contrast inversion, addition of noise, for a total of 10 transformations. We split the training partition of MNIST in half, and transform all and only the examples in the first half; this ensures that there is no matching ground truth in the dataset, and that learning is unsupervised. As a preprocessing step, the digits are zero-padded so that they have size 32 × 32 pixels, and the pixel intensities are scaled between 0 and 1. This is done even before any mechanism is applied. We use neural networks for both the experts and the selection mechanism, and employ an adversarial training scheme.</p><p>Each expert E i can be seen as a generator from a GAN conditioned on an input image rather than (as usually) a noise vector. A discriminator D provides gradients for training the experts and acts also as a selection mechanism c: only the expert whose output obtains the higher score from D wins the example, and is trained on it to maximize the output of D.</p><p>We describe the exact algorithm used to train the networks in these experiments in Algorithm 1. The discriminator is trained to maximize the following cross-entropy loss:</p><formula xml:id="formula_5">max θ D E x∼P log(D θ D (x)) + 1 N N j=1 E x ∼Q log(1−D θ D (E θj (x )))<label>(3)</label></formula><p>For simplicity, we assume for the rest of this section that the number of experts N equals the number of true mechanisms N . Results where N = N are relegated to Appendix A.1.</p><p>Neural nets details. Each expert is a CNN with five convolutional layers, 32 filters per layer of size 3 × 3, ELU <ref type="bibr" target="#b3">(Clevert et al., 2015)</ref> as activation function, batch normalization <ref type="bibr" target="#b8">(Ioffe &amp; Szegedy, 2015)</ref>, and zero padding. The discriminator is also a CNN, with average pooling every two convolutional layers, growing number of filters, and a fully connected layer with 1024 neurons as last hidden layer. Both networks are trained using Adam as optimizer <ref type="bibr" target="#b12">(Kingma &amp; Ba, 2014)</ref>, with the default hyper-parameters.</p><p>Unless specified otherwise, after a random weight initialization we first train the experts to approximate the identity mapping on our data, by pretraining them on predicting identical input-output pairs randomly selected from the transformed dataset. This makes the experts start from similar Algorithm 1 Learning independent mechanisms using competition of experts and adversarial training Precondition: X: data sampled from P ; X : data sampled from D Q ; D discriminator; N : number of experts; T : maximum number of iterations;</p><p>(p) highlights that the steps in the instruction can be executed in parallel Initialize experts as approximately identity (p):</p><formula xml:id="formula_6">1 {E i ← TrainAsIdentityOn(X )} N j=1 2 for t ← 1 to T do</formula><p>Sample minibatches:</p><p>3</p><p>x, x ← Sample(X), Sample(X ) Scores from D for all outputs from the experts (p): <ref type="figure">Figure 3</ref>. The top row contains 16 random inputs to the networks, and the bottom row the corresponding outputs from the highest scoring experts against the discriminator after 1000 iterations.</p><formula xml:id="formula_7">4 {c j ← D(E j (x ))} N j=1 Update D (p): 5 θ t+1 D ← Adam θ t D , ∇ log D(x) +∇(1/N N j=1 log(1 − c j )) Update experts (p): 6 {θ t+1 Ej ← Adam(θ t Ej , ∇ max j∈1,...,N log(c j ))} N j=1</formula><p>grounds, and we found that this improved the speed and robustness of convergence. We will refer to this as approximate identity initialization for the rest of the paper.</p><p>A minibatch of 32 transformed MNIST digits, each transformed by a randomly chosen mechanism, is fed to all experts E i . The outputs are fed to the discriminator D, which computes a score for each of them. For each example the cross entropy loss in Equation (3) and the resulting gradients are computed only for the output of the highest scoring expert, and they are used to update both the discriminator (when 0 is the target in the cross entropy) and the winning expert (when using 1 as the target). In order to further support the winning expert, we punish the losing experts by training the discriminator against their outputs as well. Then, a minibatch of canonical MNIST digit is used in order to update the discriminator with 'real' data. We refer to the above procedure as one iteration.</p><p>We ran the experiments 10 times with different random seeds for the initializations. Each experiment is run for iterations.  Each expert learns to specialize on a different mechanism, as shown by the score approaching 1. Each curve is smoothed with a moving average of 50 iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Results</head><p>The experts correctly specialized on inverting exactly one mechanism each in 7 out of the 10 runs; in the remaining 3 runs the results were only slightly suboptimal: one expert specialized on two tasks, one expert did not specialize on any, and the remaining experts still specialized on one task each, thus still covering all the existing tasks. In <ref type="figure">Figure we</ref> show a randomly selected batch of inputs and corresponding outputs from the model. Each independent mechanism was inverted by a different expert.</p><p>We first discuss our three main findings, and then move on to additional experiments.</p><p>1. The experts specialize w.r.t. c. In <ref type="figure" target="#fig_1">Figure 4</ref>, we plot the scores assigned by the discriminator for each expert on each task in a typical successful run. Each expert is represented with the same color and linestyle across all tasks. The figure shows that after an initial phase of heavy competition, the experts exhibit the desired behavior and obtain a high score on D on one mechanism each. Note how the green expert tries to learn two similar tasks until iteration 750 (left and left-down translation), at which point the red expert takes over one of the tasks. Subsequently, both specialize rapidly. <ref type="figure">Figure 5</ref> provides further evidence, by visualizing that the assignments of data points to experts induced by c are meaningful. We report the proportion of examples from each task assigned to each expert at the beginning and at the end of training: at first, the assignment of experts to tasks by the discriminator is almost uniform; by the end of the training, each expert wins almost all examples coming from one transformation, and no others.</p><p>2. The transformed outputs improve a classifier. In order to test if the committee of experts can recover a good approximation of the original digits, we test the output of our experts against a pretrained standard MNIST classifier. For this, we use the test partition of the data. We compare the accuracy for three inputs: a) the test digits transformed by the mechanisms, b) the transformed digits after being processed by the highest scoring experts (which tries to invert the mechanisms), c) the original test digits. The latter can be seen as an upper bound to the accuracy that can be achieved.</p><p>As shown by the two dashed horizontal lines in <ref type="figure">Figure 6</ref>, the transformed test digits achieve a 40% accuracy when tested directly on the classifier, while the untransformed digits would achieve ≈ 99% accuracy. The accuracy for the output digits starts at 40% -due to the identity initialization (b) After iterations <ref type="figure">Figure 5</ref>. The proportion of data won by each expert for each transformation on the digits from the test set.</p><p>of the experts -but it subsequently quickly approaches the performance on the original digits as it is trained. Note that after about 600 iterations, i.e., once the networks have seen about one third of the whole dataset once, the accuracy has almost reached the upper bound.</p><p>3. The experts learn mechanisms that generalize. Given that towards the end of training, each expert E i is updated only on data points from Q i , one could imagine that they will not perform well on data points from other distributions. In fact this is not the case. Not only do all experts E i generalize to all other transformed distributions Q j , but also to different datasets all together. To show this, we use the Omniglot dataset of letters from different alphabets <ref type="bibr" target="#b14">(Lake et al., 2015)</ref> and rescale them to 46 × 46 pixels (instead of 32 × 32 of MNIST, which is not an issue since the experts are fully convolutional). We transform a random sample with all mechanisms M i and test each on all experts E i , which have only been trained on MNIST. As shown in <ref type="figure">Figure 7</ref>, each network consistently applies the same transformation also on inputs outside of the domain they have specialized on. They indeed learn a mechanism that is independent of the input.</p><p>Having made our main points, we continue with a few more observations. Classifier accuracy E(transf) orig transf <ref type="figure">Figure 6</ref>. Accuracy of a pretrained CNN MNIST classifier on transformed test digits DQ, on the same digits after going through our model, and on the original digits. Our system manages to invert the transformations, with the classifier accuracy quickly approaching the optimum. Note that 600 iterations correspond to having seen about a third of the dataset.</p><p>The learned inverse mechanisms can be combined. We test whether the trained experts could in principle be used to undo several transformations applied at once, even though the training set consisted only of images transformed by a single mechanism. For simplicity, we assume we know which transformations were used. In <ref type="figure">Figure 8</ref>, we test on Omniglot letters transformed with three consecutive transformations (noise, up left translation, contrast inversion) by applying the corresponding experts previously trained on MNIST, and correctly recover the original letters.</p><p>Effect of the approximate identity initialization. For the same experiments but without the approximate identity initialization, several experts fail to specialize. Out of new runs with random initialization, only one experiment had arguably good results, with eight experts specializing on one task each, one on two tasks, and the last one on none. The performance was worse in the remaining runs. The problem was not that the algorithm takes longer to converge following a random initialization, as with an additional experiment for 10 000 iterations the results did not improve. Instead, the random initialization can lead to one expert winning examples from many tasks at the beginning of training, in which case it is hard for the others to catch up.</p><p>A simple single-net baseline. Training a single network instead of a committee of experts makes the problem more difficult to solve. Using identical training settings, we trained a single network once with 32, once with 64, and once with 128 filters per layer, and none of them managed to correctly learn more than one inverse mechanism. Note that a single network with 128 filters per layer has about twice as many parameters overall as the committee of 10 experts with 32 filters per layer each. We also tried a) random initialization instead of the approximate identity, b) reducing Specifically, the network performs well on the contrast inversion task, and poorly on all others. <ref type="figure">Figure 7</ref>. Each column shows how each expert transforms the input presented on top. We arrange the tasks such that the diagonal contains the highest scoring expert for the input given at the top of the column. The experts have learned the inverse mechanisms, consistently applying them to previously unseen symbols.</p><p>the learning rate of the discriminator by a factor of 10, and c) increasing the receptive field by adding two pooling and two upsampling layers, without any improvement. While we do not exclude that careful hyperparameter tuning may enable a single net to learn multiple mechanisms, it certainly was not straightforward in our experiments.</p><p>Specialization occurs also with higher capacity experts. While in principle with infinite capacity and data, a single expert could solve all tasks simultaneously, in practice limited resources and the proposed training procedure favor specialization in independent modules. Increasing the size of the experts from 32 filters per layer to or 128 filters, 5 or enlarging the overall receptive field by using two pooling and two upsampling layers, still resulted in good specialization of the experts, with no more than two experts specializing on two tasks at once.</p><p>Fewer examples from the canonical distribution. In some applications, we might only have a small sample from the original distribution. Interestingly, if we reduce the number of examples from the original distribution from 30 000 down to 64, we find that all experts still specialize and recover good approximations of the inverse mechanisms, using the exact same training protocol. Although the output digits turn out less clean and sharp, we still achieve 96% accuracy on the pretrained MNIST classifier.</p><p>Equivalent to an increase of parameters from ∼27K to ∼110K or ∼440K parameters respectively. <ref type="figure">Figure 8</ref>. First row: input Omniglot letters that were transformed with noise, contrast inversion and translation up left. Second to fourth row: application of denoising, contrast inverting and right down translating experts. Last row: ground truth. Although the experts were not trained on a combination of mechanisms nor on Omniglot letters, they can be used to recover the original digits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Conclusions</head><p>We have developed a method to identify and learn a set of independent causal mechanisms. Here these are inverse mechanisms, but an extension to forward mechanisms appears feasible and worthwhile. We reported promising results in experiments using image transformations; future work could study more complex settings and diverse domains. The method does not explicitly minimize a measure of dependence of mechanisms, but works if the data generating process contains independent mechanisms in the first place: As the different tasks (mechanisms) do not contain information about each other, improving on one of them does not improve performance on another, which is exactly what encourages specialization.</p><p>A natural extension of our work is to consider independent mechanisms that simultaneously affect the data (e.g., lighting and position in a portrait), and to allow multiple passes through our committee of experts to identify local mechanisms (akin to Lie derivatives) from more complex datasets -for instance, using recurrent neural networks that allow the application of multiple mechanisms by iteration. With many experts, the computational cost (or parallel processing) might become unnecessarily high. This could be mitigated by hybrid approaches incorporating gated mixture of experts or a hierarchical selection of competing experts.</p><p>We believe our work constitutes a promising connection between causal modeling and deep learning. As discussed in the introduction, causality has a lot to offer for crucial machine learning problems such as transfer or compositional modeling. Our systems sheds light on these issues. Independent modules as sub-components could be learned using multiple domains or tasks, added subsequently, and transferred to other problems. This may constitute a step towards causally motivated life-long learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A. Additional results.</head><p>A.1. Too many or too few experts. Too many experts. When there are too many experts, for most tasks only one wins all the examples, as shown in <ref type="figure">Figure 9</ref> where the model has 16 experts for 10 tasks. In this case the remaining experts do not specialize at all and therefore can be removed from the architecture. Had several experts specialized on the same task, they could be combined after determining that they perform the same task. Since the accuracy on the transformed data tested on the pretrained classifier reaches again the upperbound of the untransformed data, and since the progress is very similar to that illustrated in <ref type="figure">Figure 6</ref>, we omit this plot.</p><p>Too few experts. For a committee of 6 experts, the networks do not reconstruct properly most of the digits, which is reflected by an overall low objective function value on the data. Also, the accuracy achieved by the pretrained MNIST classifier does not exceed 72%. A few experts are inevitably assigned to multiple tasks, and by looking at <ref type="figure">Figure 9</ref> it is interesting to see that the clustering result is still meaningful (e.g., expert 5 is assigned to left, down-left, and up-left translation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B. Details of neural networks</head><p>In <ref type="table" target="#tab_1">Table 1</ref> we report the configuration of the neural networks used in these experiments.</p><p>For the approximate identity initialization we train each network for a maximum of 500 iterations, or until the mean squared error of the reconstructed images is below 0.002.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C. Transformations</head><p>In our experiments we use the following transformations  <ref type="figure">Figure 9</ref>. The proportion of data won by each expert for each transformation on the digits from the test set, for the case of 10 mechanisms and more experts (16 on left) or too few (6 on the right). Note how on the left experts 0, 1, 7, 11, 12, 13, do not win any data points, and can therefore be discarded.</p><p>• Translations: the image is shifted by 4 pixels in one of the eight directions up, down, left, right and the four diagonals.</p><p>• Contrast (or color) inversion: the value of each pixeloriginally in the range [0, 1] -is recomputed as 1− the original value.</p><p>• Noise addition: random Gaussian noise with zero mean and variance 0.25 is added to the original image, which is then clamped again to the [0, 1] interval. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D. Notes on the Formalization of Independence of Mechanisms</head><p>In this section we briefly discuss the notion of independence of mechanisms as in , where the independence principle is formalized in terms of algorithmic complexity (also known as Kolmogorov complexity). We summarize the main points needed in the present context. We parametrize each mechanism by a bit string x. The Kolmogorov complexity K(x) of x is the length of the shortest program generating x on an a priori chosen universal Turing machine. The algorithmic mutual information can be defined as I(x : y) := K(x) + K(y) − K(x, y), and it can be shown to equal I(x : y) = K(y) − K(y|x * ),</p><p>where for technical reasons we need to work with x * , the shortest description of x (which is in general uncomputable).</p><p>Here, the conditional Kolmogorov complexity K(y|x) is defined as the length of the shortest program that generates y from x. The algorithmic mutual information measures the algorithmic information two objects have in common. We define two mechanisms to be (algorithmically) independent whenever the length of the shortest description of the two bit strings together is not shorter than the sum of the shortest individual descriptions (note it cannot be longer), i.e., if their algorithmic mutual information vanishes. <ref type="bibr">6</ref> In view of (4), this means that K(y) = K(y|x * ).</p><p>We will say that two mechanisms x and y are independent whenever the complexity of the conditional mechanism y|x is comparable to the complexity of the unconditional one y. If, in contrast, the two mechanisms were closely related, then we would expect that we can mimic one of the mechanisms by applying the other one followed by a low complexity conditional mechanism.</p><p>All statements are valid up to additive constants, linked to the choice of a Turing machine which produces the object (bit string) when given its compression as an input. For details, see .</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 .</head><label>4</label><figDesc>Experts' performance, measured by discriminator scores. Each line color/style represents one expert. For each of ten different mechanisms (top left to bottom right), the experts are being fed transformed digits.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Max Planck Institute for Intelligent Systems 2 Max Planck ETH Center for Learning Systems 3 University of Cambridge. Correspondence to: Giambattista Parascandolo &lt;gparascandolo@tue.mpg.de&gt;. Proceedings of the 35 th International Conference on Machine Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018 by the author(s).</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>Q</cell></row><row><cell></cell><cell>Q2</cell><cell>• • •</cell><cell></cell></row><row><cell>Q1</cell><cell></cell><cell></cell><cell>QN</cell></row><row><cell></cell><cell>M2</cell><cell>E2</cell><cell></cell></row><row><cell>M1</cell><cell>E1</cell><cell>EN</cell><cell>MN</cell></row><row><cell></cell><cell></cell><cell>P</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 .</head><label>1</label><figDesc>Architectures of the neural networks used in the experiment section. BN stands for Batch normalization, FC for fully connected. All convolutions are preceded by a 1 pixel zero padding.</figDesc><table><row><cell></cell><cell>Discriminator</cell></row><row><cell></cell><cell>Layers</cell></row><row><cell></cell><cell>× 3, 16, ELU</cell></row><row><cell>Expert</cell><cell>× 3, 16, ELU</cell></row><row><cell>Layers</cell><cell>× 3, 16, ELU</cell></row><row><cell>× 3, 32, BN, ELU × 3, 32, BN, ELU × 3, 32, BN, ELU × 3, 32, BN, ELU 3 × 3, 1, sigmoid</cell><cell>× 2, avg pooling × 3, 32, ELU × 3, 32, ELU × 2, avg pooling × 3, 64, ELU × 3, 64, ELU</cell></row><row><cell></cell><cell>× 2, avg pooling</cell></row><row><cell></cell><cell>1024, FC, ELU</cell></row><row><cell></cell><cell>1, FC, sigmoid</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">However, note that in order to do this, it is necessary to first acknowledge that the two experts have learned part of the same task, which would require extra information or visual inspection.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">For the exact experimental parameters and architectures see the Appendix B or the PyTorch implementation we will release.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Expert gate: Lifelong learning with a network of experts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Aljundi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Chakravarty</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tuytelaars</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="3366" to="3375" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Unsupervised pixel-level domain adaptation with generative adversarial networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bousmalis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Silberman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dohan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Krishnan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="3722" to="3731" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Infogan: Interpretable representation learning by information maximizing generative adversarial nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Houthooft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schulman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Abbeel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="2172" to="2180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Fast and accurate deep network learning by exponential linear units (elus)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D.-A</forename><surname>Clevert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Unterthiner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hochreiter</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1511.07289</idno>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Inferring deterministic causal relations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Daniušis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Janzing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mooij</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zscheischler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Steudel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">26th Conference on Uncertainty in Artificial Intelligence</title>
		<editor>Grünwald, P. and Spirtes, P.</editor>
		<meeting><address><addrLine>Corvallis, OR</addrLine></address></meeting>
		<imprint>
			<publisher>AUAI Press</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="143" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Generative adversarial nets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pouget-Abadie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mirza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Warde-Farley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ozair</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="2672" to="2680" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">betavae: Learning basic visual concepts with a constrained variational framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Higgins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Matthey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Burgess</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Glorot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botvinick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lerchner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations (ICLR</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Unsupervised feature extraction by time-contrastive learning and nonlinear ica</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hyvarinen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Morioka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="3765" to="3773" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Batch normalization: Accelerating deep network training by reducing internal covariate shift</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ioffe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Szegedy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="448" to="456" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Adaptive mixtures of local experts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Nowlan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="79" to="87" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Causal inference using the algorithmic Markov condition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Janzing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="5168" to="5194" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hierarchical mixtures of experts and the EM algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Jacobs</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="181" to="214" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Adam</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1412.6980</idno>
		<title level="m">A method for stochastic optimization</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Auto-encoding variational bayes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Welling</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1312.6114</idno>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Human-level concept learning through probabilistic program induction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">M</forename><surname>Lake</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Tenenbaum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">350</biblScope>
			<biblScope unit="issue">6266</biblScope>
			<biblScope unit="page" from="1332" to="1338" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Stochastic multiple choice learning for training diverse deep ensembles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Purushwalkam Shiva Prakash</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Cogswell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ranjan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Crandall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Batra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="2119" to="2127" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Pearl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Causality</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Elements of Causal Inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Janzing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Causal transfer in machine learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rojas-Carulla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Turner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Peters</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1507.05333</idno>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">On causal and anticausal learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Janzing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Peters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Sgouritsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Mooij</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th International Conference on Machine Learning (ICML)</title>
		<editor>Langford, J. and Pineau, J.</editor>
		<meeting>the 29th International Conference on Machine Learning (ICML)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Omnipress</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1255" to="1262" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Outrageously large neural networks: The sparsely-gated mixture-of-experts layer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Shazeer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mirhoseini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Maziarz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1701.06538</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Adversarial discriminative domain adaptation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tzeng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Saenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darrell</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision and Pattern Recognition (CVPR)</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Distinguishing cause from effect based on exogeneity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Schölkopf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Fifteenth Conference on Theoretical Aspects of Rationality and Knowledge</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="261" to="271" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
