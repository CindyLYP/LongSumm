<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Making Smart Contracts Smarter</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loi</forename><surname>Luu</surname></persName>
							<email>loiluu@comp.nus.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duc-Hiep</forename><surname>Chu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hrishi</forename><surname>Olickel</surname></persName>
							<email>hrishi.olickel@yale-nus.edu.sg</email>
							<affiliation key="aff2">
								<orgName type="institution">Yale-NUS College</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
							<email>prateeks@comp.nus.edu.sg</email>
							<affiliation key="aff3">
								<orgName type="institution">National University of Singapore</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aquinas</forename><surname>Hobor</surname></persName>
							<email>hobor@comp.nus.edu.sg</email>
							<affiliation key="aff4">
								<orgName type="institution">Yale-NUS College&amp; National University of Singapore</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Making Smart Contracts Smarter</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/2976749.2978309</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Code Storage Balance PrivBlock Nonce ListOfTxs Blockchain state TimeStamp PrivBlock Nonce ListOfTxs Blockchain state TimeStamp Update(PrevState, ListOfTxs) Block i Block i+1 Time</keywords>
			</textClass>
			<abstract>
				<p>Cryptocurrencies record transactions in a decentralized data structure called a blockchain. Two of the most popular cryptocurrencies, Bitcoin and Ethereum, support the feature to encode rules or scripts for processing transactions. This feature has evolved to give practical shape to the ideas of smart contracts, or full-fledged programs that are run on blockchains. Recently, Ethereum&apos;s smart contract system has seen steady adoption, supporting tens of thousands of contracts, holding millions dollars worth of virtual coins. In this paper, we investigate the security of running smart contracts based on Ethereum in an open distributed network like those of cryptocurrencies. We introduce several new security problems in which an adversary can manipulate smart contract execution to gain profit. These bugs suggest subtle gaps in the understanding of the distributed semantics of the underlying platform. As a refinement, we propose ways to enhance the operational semantics of Ethereum to make contracts less vulnerable. For developers writing contracts for the existing Ethereum system, we build a symbolic execution tool called Oyente to find potential security bugs. Among 19, 366 existing Ethereum contracts, Oyente flags 8, 833 of them as vulnerable, including the TheDAO bug which led to a 60 million US dollar loss in June 2016. We also discuss the severity of other attacks for several case studies which have source code available and confirm the attacks (which target only our accounts) in the main Ethereum network.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Decentralized cryptocurrencies have gained considerable interest and adoption since Bitcoin was introduced in 2009 <ref type="bibr" target="#b0">[1]</ref>. At a high level, cryptocurrencies are administered publicly by users in their network without relying on any trusted parties. Users in a cryptocurrency network run a consensus protocol to maintain and secure a shared ledger of data (the blockchain). Blockchains were initially introduced for peer-to-peer Bitcoin payments <ref type="bibr" target="#b0">[1]</ref>, but more recently, it has Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than the author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. been used more broadly <ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref><ref type="bibr" target="#b3">[4]</ref>. One prominent new use for blockchains is to enable smart contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CCS'16, October 24 -28, 2016, Vienna, Austria</head><p>A smart contract is a program that runs on the blockchain and has its correct execution enforced by the consensus protocol <ref type="bibr" target="#b4">[5]</ref>. A contract can encode any set of rules represented in its programming language-for instance, a contract can execute transfers when certain events happen (e.g. payment of security deposits in an escrow system). Accordingly, smart contracts can implement a wide range of applications, including financial instruments (e.g., sub-currencies, financial derivatives, savings wallets, wills) and self-enforcing or autonomous governance applications (e.g., outsourced computation <ref type="bibr" target="#b5">[6]</ref>, decentralized gambling <ref type="bibr" target="#b6">[7]</ref>).</p><p>A smart contract is identified by an address (a 160-bit identifier) and its code resides on the blockchain. Users invoke a smart contract in present cryptocurrencies by sending transactions to the contract address. Specifically, if a new transaction is accepted by the blockchain and has a contract address as the recipient, then all participants on the mining network execute the contract code with the current state of the blockchain and the transaction payloads as inputs. The network then agrees on the output and the next state of the contract by participating in a consensus protocol. Ethereum, a more recent cryptocurrency, is a prominent Turing-complete smart contract platform <ref type="bibr" target="#b1">[2]</ref>. Unlike Bitcoin, Ethereum supports stateful contracts in which values can persist on the blockchain to be used in multiple invocations. In the last six months alone, roughly 15, 000 smart contracts have been deployed in the Ethereum network, suggesting a steady growth in the usage of the platform (see <ref type="figure" target="#fig_1">Figure 1</ref>). As Ethereum receives more public exposure and other similar projects like Rootstock <ref type="bibr" target="#b7">[8]</ref> and Coun-terParty [9] emerge on top of the Bitcoin blockchain, we expect the number of smart contracts to grow.</p><p>Security problems in smart contracts. Smart contracts can handle large numbers of virtual coins worth hundreds of dollars apiece, easily making financial incentives high enough to attract adversaries. Unlike traditional distributed application platforms, smart contract platforms such as Ethereum operate in open (or permissionless) networks into which arbitrary participants can join. Thus, their execution is vulnerable to attempted manipulation by arbitrary adversariesa threat that is restricted to accidental failures in traditional permissioned networks such as centralized cloud services <ref type="bibr" target="#b8">[10,</ref><ref type="bibr" target="#b9">11]</ref>. Although users in Ethereum have to follow a predefined protocol when participating in the network, we show that there is considerable room for manipulation of a smart contract's execution by the network participants. For example, Ethereum (and Bitcoin) allow network participants (or miners) to decide which transactions to accept, how to order transactions, set the block timestamp and so on. Contracts which depend on any of these sources need to be aware of the subtle semantics of the underlying platform and explicitly guard against manipulation.</p><p>Unfortunately, the security of smart contracts has not received much attention, although several anecdotal incidents of smart contracts malfunctioning have recently been reported, including contracts that do not execute as expected <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b10">12,</ref><ref type="bibr" target="#b11">13]</ref> and/or that have locked away thousands of dollars worth of virtual coins <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b11">13]</ref>. In contrast to classical distributed applications that can be patched when bugs are detected, smart contracts are irreversible and immutable. There is no way to patch a buggy smart contract, regardless of its popularity or how much money it has, without reversing the blockchain (a formidable task). Therefore, reasoning about the correctness of smart contracts before deployment is critical, as is designing a safe smart contract system.</p><p>In this paper, we document several new security flaws of Ethereum smart contracts and give examples of real-world instances for each problem. These security flaws make contracts susceptible to abuse by several parties (including miners and contracts' users). We believe that these flaws arise in practice because of a semantic gap between the assumptions contract writers make about the underlying execution semantics and the actual semantics of the smart contract system. Specifically, we show how different parties can exploit contracts which have differing output states depending on the order of transactions and input block timestamp. To our knowledge, these semantic gaps have not been previously identified. We also document other serious but known problems such as improperly handled aborts/exceptions and logical flaws. Previous work has discussed these conceptually, often with simple self-constructed examples <ref type="bibr" target="#b12">[14]</ref>. In our work, we study their impact on tens of thousands of real-life contracts, showing how these vulnerabilities can be used to sabotage or steal coins from benign users.</p><p>More importantly, our work emphasizes the subtle and/or missing abstractions in smart contract semantics that lead developers to a false sense of security. We propose refinements to Ethereum's protocol that do not require changes to existing smart contracts. However, such solutions do require all clients in the network to upgrade, thus running the risk of not seeing real deployment. If such a requirement is unacceptable, we provide a tool called Oyente for users to detect bugs in as a pre-deployment mitigation. Oyente is a symbolic execution tool exclusively designed to analyze Ethereum smart contracts. It follows the execution model of Ethereum smart contracts <ref type="bibr" target="#b13">[15]</ref> and directly works with Ethereum virtual machine (EVM) byte code without access to the high level representation (e.g., Solidity <ref type="bibr" target="#b14">[16]</ref>, Serpent <ref type="bibr" target="#b15">[17]</ref>). This design choice is vital because the Ethereum blockchain only stores the EVM byte code of contracts, not their source. Oyente is open source and will be available for public use soon from our project page <ref type="bibr" target="#b16">[18]</ref>.</p><p>Evaluation. We ran Oyente on 19, 366 smart contracts from the first 1, 460, 000 blocks in Ethereum network and found that 8, 833 contracts potentially have the documented bugs. These contracts currently have a total balance of about 3, 068, 654 million Ethers, approximately equivalent to 30 million USD at the time of writing. Moreover, Oyente can detect the infamous TheDAO bug, which caused a loss of 60 million US dollars to TheDAO's investors in June 2016 <ref type="bibr" target="#b17">[19]</ref>. We further discuss our results and our verified attack with one of the most active contracts of Ethereum (affecting only our own accounts), in Section 6.</p><p>Although we use Ethereum's smart contracts throughout this paper, Oyente and the security problems are largely platform agnostic. We believe Oyente can be extended to upcoming platforms such as CounterParty or Rootstock.</p><p>Contributions. This paper makes the following contributions.</p><p>• We document several new classes of security bugs in Ethereum smart contracts.</p><p>• We formalize the semantics of Ethereum smart contracts and propose recomendations as solutions for the documented bugs.</p><p>• We provide Oyente, a symbolic execution tool which analyses Ethereum smart contracts to detect bugs.</p><p>• We run Oyente on real Ethereum smart contracts and confirmed the attacks in the real Ethereum network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">BACKGROUND</head><p>We give a brief introduction to smart contracts and their execution model. Our discussion is restricted to most popular smart contract platform called Ethereum, but the security problems discussed in this paper may be of wider application to other open distributed application platforms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Consensus Protocol</head><p>Decentralized cryptocurrencies secure and maintain a shared ledger of facts between a set of peer-to-peer network operators (or miners). Miners run a peer-to-peer consensus protocol called the Nakamoto consensus protocol. The shared ledger is called a blockchain and is replicated by all miners. The ledger is organized as a hash-chain of blocks ordered by time, wherein each block has a set of facts, as shown in <ref type="figure" target="#fig_2">Figure 2</ref>. In every epoch, each miner proposes their own block to update the blockchain. Miners can select a sequence of new transactions to be included in the proposed block. At a high level, Nakamoto consensus works by probabilistically electing a leader among all the miners via a proof-of-work puzzle <ref type="bibr" target="#b0">[1]</ref>. The leader then broadcasts its proposed block to all miners. If the proposed block obeys a certain pre- defined validity constraints, such as those ensuring mitigation of "double-spending" attacks, then all miners update their ledger to include the new block. We exclude certain details about the consensus protocol, such as the use of the longest-chain rule for resolving probabilistic discrepancies in leader election. Instead, we refer readers to the original Bitcoin or Ethereum paper for details <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref>.</p><p>A blockchain state σ is a mapping from addresses to accounts; the state of an account at address γ is σ[γ]. While Bitcoin only has normal accounts which hold some coins, Ethereum additionally supports smart contract accounts which have coins, executable code and persistent (private) storage. Ethereum supports its own currency called Ether; users can transfer coins to each other using normal transactions as in Bitcoin, and additionally can invoke contracts using contract-invoking transactions. Conceptually, Ethereum can be viewed as a transaction-based state machine, where its state is updated after every transaction. A valid transition from σ to σ , via transaction T is denoted as σ T −→ σ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Smart Contracts in Ethereum</head><p>A smart contract (or contract for short) is an "autonomous agent" stored in the blockchain, encoded as part of a "creation" transaction that introduces a contract to the blockchain. Once successfully created, a smart contract is identified by a contract address; each contract holds some amount of of virtual coins (Ether), has its own private storage, and is associated with its predefined executable code. A contract state consists of two main parts: a private storage and the amount of virtual coins (Ether) it holds (called balance). Contract code can manipulate variables like in traditional imperative programs. The code of an Ethereum contract is in a low-level, stack-based bytecode language referred to as Ethereum virtual machine (EVM) code. Users define contracts using high-level programming languages, e.g., Solidity <ref type="bibr" target="#b14">[16]</ref> (a JavaScript-like language), which are then compiled into EVM code. To invoke a contract at address γ, users send a transaction to the contract address. A transaction typically includes: payment (to the contract) for the execution (in Ether) and/ or input data for the invocation.</p><p>An Example. <ref type="figure" target="#fig_3">Figure 3</ref> is a simple contract, defined in Solidity, which rewards anyone who solves a computational puzzle and submits the solution to the contract. The creator of the contract includes the compiled (EVM) code of Puzzle in a "contract creation" transaction. When such transaction is accepted to the blockchain, all miners will unanimously  modify the blockchain state σ, adding a new contract account in three following steps. First, a unique address for the new contract is prepared. Then the contract's private storage is allocated and initialized by running the constructor (i.e., Puzzle() function in Line 8). Finally, the executable EVM code portion that corresponds to the anonymous function (Line 15 onwards) is associated with the contract.</p><p>Any transaction invoking this contract will execute the anonymous function() (Line 15) by default. The information of the sender, the value (amount of Ether sent to the contract) and the included data of the invocation transaction is stored in a default input variable called msg. For example, the contract owner updates the reward variable by invoking a transaction To with some Ether (i.e., in msg.value). Before updating the reward variable to the new value (Line 20), the contract indeed sends back to the owner, an amount of Ether that is equal to the current reward value (Line 19). The result of To is a new state of Puzzle which has a different reward value. Similarly, users can submit their solution in a different transaction payload (e.g., msg.data) to claim the reward (Line 22-29). If the solution is correct, the contract sends the reward to the submitter (Line 26).</p><p>Gas system. By design, the smart contract is a mechanism to execute code distributively. To ensure fair compensation for expended computation effort, Ethereum pays miners some fees proportional to the required computation. Specifically, each instruction in the Ethereum bytecode has a pre-specified amount of gas. When a user sends a transaction to invoke a contract, she has to specify how much gas she is willing to provide for the execution (called gasLimit) as well as the price for each gas unit (called gasPrice). A miner who includes the transaction in his proposed block subsequently receives the transaction fee corresponding to the amount of gas the execution actually burns multiplied by gasPrice. If some execution requires more gas than gasLimit, the execution is terminated with an exception, the state σ is reverted to the initial state as if the execution did not happen. In case of such aborts, the sender still has to pay all the gasLimit to the miner though, as a countermeasure against resource-exhaustion attacks <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">SECURITY BUGS IN CONTRACTS</head><p>We discuss several security bugs which allow malicious miners or users to exploit and gain profit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Transaction-Ordering Dependence</head><p>As discussed in Section 2, a block includes a set of transactions, hence the blockchain state is updated several times in each epoch. Let us consider a scenario where the blockchain is at state σ and the new block includes two transactions (e.g., Ti, Tj) invoking the same contract. In such a scenario, users have uncertain knowledge of which state the contract is at when their individual invocation is executed. For example, Ti is applied when the contract is at either state σ[α] or state σ [α] where σ T j −→ σ , depending on the order between Ti and Tj. Thus, there is a discrepancy between the state of the contract that users may intend to invoke at, and the actual state when their corresponding execution happens. Only the miner who mines the block can decide the order of these transactions, consequently the order of updates. As a result, the final state of a contract depends on how the miner orders the transactions invoking it. We call such contracts as transaction-ordering dependent (or TOD) contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Attacks</head><p>It may be not obvious to the readers why having dependence on the transaction ordering is problematic for smart contracts. The reasons are twofold. First, even a benign invocation to the contract may yield an unexpected result to users if there are concurrent invocations. Second, a malicious user can exploit the TOD contracts to gain more profits, even steal users' money. We explain the two scenarios below by using the Puzzle contract in <ref type="figure" target="#fig_3">Figure 3</ref>.</p><p>Benign scenario. We consider two transactions To and Tu sending to Puzzle at roughly the same time. To is from the contract owner to update the reward and Tu is from a user who submits a valid solution to claim the reward. Since To and Tu are broadcast to the network at roughly the same time, the next block will most likely include both the transactions. The order of the two transactions decides how much reward the user receives for the solution. The user expects to receive the reward that he observes when submitting his solution, but he may receive a different reward if To is executed first. The problem is more significant if the contract serves as a decentralized exchange or market place <ref type="bibr" target="#b18">[20,</ref><ref type="bibr" target="#b19">21]</ref>. In these contracts, sellers frequently update the price, and users send their orders to buy some items ( <ref type="figure">Figure 4</ref>). Depending on the transaction ordering, users' buy requests may or may not go through. Even worse, buyers may have to pay much higher than the observed price when they issue the buy requests.</p><p>Malicious scenario. The above scenario may just be an accident because the owner of Puzzle does not know when a solution is submitted. However, a malicious owner can exploit transaction-ordering dependence to gain financial advantage. Note that there is a time gap between when transaction Tu is broadcast and when it is included in a block. In Ethereum, the time to find a new block is around 12 sec-  <ref type="figure">Figure 4</ref>: A contract that acts as a market place where users can buy/ sell some tokens. Due to TOD, some order may or may not go through.</p><p>contract theRun { 2 uint private Last_Payout = 0; uint256 salt = block . timestamp ; function random returns ( uint256 result ){ uint256 y = salt * block . number /( salt %5); uint256 seed = block . number /3 + ( salt %300) + Last_Payout + y ; // h = the blockhash of the seed -th last block uint256 h = uint256 ( block . blockhash ( seed )); // random number between 1 and 100 return uint256 ( h % 100) + 1; 12 }} <ref type="figure">Figure 5</ref>: A real contract which depends on block timestamp to send out money <ref type="bibr" target="#b20">[22]</ref>. This code is simplified from the original code to save space.</p><p>onds. Thus, a malicious owner of the Puzzle contract can keep listening to the network to see if there is a transaction which submits a solution to his contract. If so, he sends his transaction To to update the reward and make it as small as zero. With a certain chance, both To and Tu are included in the new block and his To is placed (so executed) before the Tc. Thus the owner can enjoy a free solution for his puzzle. The owner can even bias the chance of his transaction winning the race (i.e., to be executed first) by participating directly in the mining, setting higher gasPrice for his transaction (i.e., to incentivize miners to include it in the next block) and/or colluding with other miners.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Timestamp Dependence</head><p>The next security problem that a contract may have uses the block timestamp as a triggering condition to execute some critical operations, e.g., sending money. We call such contracts as timestamp-dependent contracts.</p><p>A good example of a timestamp-dependent contract is the theRun contract in <ref type="figure">Figure 5</ref>, which uses a homegrown random number generator to decide who wins the jackpot <ref type="bibr" target="#b20">[22]</ref>. Technically TheRun uses the hash of some previous block as the random seed to select the winner (Line 9-10). The choice of block is determined based on the current block timestamp (Line 5-7).</p><p>Let us recall that when mining a block, a miner has to set the timestamp for the block <ref type="figure" target="#fig_2">(Figure 2</ref>). Normally, the timestamp is set as the current time of the miner's local system. However, the miner can vary this value by roughly 900 seconds, while still having other miners accept the block <ref type="bibr">[</ref></p><formula xml:id="formula_0">23] 1 .</formula><p>The variation of block timestamp may now be less than 900 seconds according to the fact that Ethereum requires nodes in the network to have roughly "same" local timestamps.</p><p>Specifically, on receiving a new block and after checking other validity checks, miners check if the block timestamp is greater than the timestamp of previous block and is within 900 seconds from the timestamp on their local system. Thus, the adversary can choose different block timestamps to manipulate the outcome of timestamp-dependent contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Attacks</head><p>A miner can set the block timestamp to be a specific value which influences the value of the timestamp-dependent condition and favor the miner. For example in the theRun contract, the hash of previous block and block number are known, other contract variables like last payout which contribute to the generation of the random seed are also known. Thus the miner can precompute and select the timestamp so the function random produces an outcome that favors him. As a result, the adversary may completely bias the outcome of the random seed to be any value, thus awarding the jackpot to any player he pleases. Thus, theRun is vulnerable to any adversary who can manipulate the block timestamp.</p><p>While theRun uses timestamp as a insecure deterministic random seed, other contracts use block timestamp as global timestamp and perform some time-dependent computation. We show in Section 6 an example which uses timestamp for this purpose and is vulnerable to manipulation. Unfortunately, there are many other contracts which are timestampdependent. As we show in Section 6, among the first 19, 366 contracts, 83 of them depend on the block timestamp to transfer Ether to different addresses.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Mishandled Exceptions</head><p>In Ethereum, there are several ways for a contract to call another, e.g., via send instruction or call a contract's function directly (e.g.,aContract.someFunction()). If there is an exception raised (e.g., not enough gas, exceeding call stack limit) in the callee contract, the callee contract terminates, reverts its state and returns false. However, depending on how the call is made, the exception in the callee contract may or may not get propagated to the caller. For example, if the call is made via the send instruction, the caller contract should explicitly check the return value to verify if the call has been executed properly. This inconsistent exception propagation policy leads to many cases where exceptions are not handled properly. As we later show in Section 6, 27.9% of the contracts do not check the return values after calling other contracts via send. We discuss the threats of not validating return value of a contract call via our example in <ref type="figure">Figure 6</ref>, which is a code snippet of a real contract <ref type="bibr" target="#b10">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Attacks</head><p>The KingOfTheEtherThrone (KoET for short) contract in <ref type="figure">Figure 6</ref> allows users to claim as "king of Ether" by paying some amount of Ether that the current king requires. A king gets profit (i.e., compensation) from the difference between the price he paid to the king before him and the price other pays to be his successor. When a user claims the throne, the contract sends the compensation to the ceded king (Line 15), and assigns the user as the new king (Line 18-20).</p><p>The KoET contract does not check the result of the compensation transaction in Line 15 before assigning the new However, we could not find any updated document from Ethereum regarding the new possible variation, thus keeping 900 seconds.  <ref type="figure">Figure 6</ref>: A code snippet of a real contract which does not check the return value after calling other contracts <ref type="bibr" target="#b10">[12]</ref>.</p><p>king. Thus, if for some reason, the compensation transaction does not finish properly, the current king loses his throne without any compensation. In fact, an instance of such a problem occurred and led to the termination of KoET <ref type="bibr" target="#b10">[12]</ref>. The reason reported in <ref type="bibr" target="#b10">[12]</ref> is that the address A k of the current king is not a normal address, but a contract address. When sending a transaction (or call) to A k , some code will be executed, thus requiring more gas than a transaction to a normal address. However, KoET does not know what A k executes internally beforehand to decide how much gas to give in the send instruction. Hence A k runs out of gas and throws an exception. As a result, the state (and balance) of A k remains unchanged, the compensation is returned to KoET and the current king loses his throne without any compensation.</p><p>The above problem often arises when a contract sends money to a dynamic address, since the sender does not know how much gas to allocate for the transaction. The contract should always check if the transaction succeeds before executing subsequent logic. The callee contract may throw an exception of any type (e.g., division by zero, array index out of bound and so on).</p><p>In this scenario, the recipient (or callee) seems at fault, causing the send to fail. However, as we show next, a malicious user who invokes the caller contract can cause the send to fail deliberately, regardless of what the callee does.</p><p>Deliberately exceeding the call-stack's depth limit. The Ethereum Virtual Machine implementation limits the call-stack's depth to 1024 frames. The call-stack's depth increases by one if a contract calls another via the send or call instruction. This opens an attack vector to deliberately cause the send instruction in Line 15 of KoET contract to fail. Specifically, an attacker can prepare a contract to call itself 1023 times before sending a transaction to KoET to claim the throne from the current king. Thus, the attacker ensures that the call-stack's depth of KoET reaches 1024, causing the send instruction in Line 15 to fail. As the result, the current king will not receive any payment. This callstack problem was identified in a previous report <ref type="bibr" target="#b22">[24]</ref>, but remains unfixed in the current Ethereum protocol.</p><p>Exploiting call stack limit to gain benefit. In the previous attack to KoET, the attacker does not receive any direct  benefit besides causing other users to lose their entitlement. However, in many other examples, the attacker can exploit to directly benefit as well. In Ethereum, many contracts implement verifiable Ponzi (or pyramid) schemes <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b24">26]</ref>. These contracts pay investors interest for their investments from the subsequent investments by others. An attacker can invest his money, make payments to previous investors fail so he can receive his interest early. We discuss one of such contracts in Section 6. Specifically, we show that 5, 411 contracts (27.9%) are vulnerable to attacks that deliberately exceed the call-depth limit. We also conduct the attack in one of the most popular contracts in Ethereum (with no harm to others, but our own accounts) to confirm our finding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Reentrancy Vulnerability</head><p>Reentrancy is a well-known vulnerability with a recent TheDao hack <ref type="bibr" target="#b17">[19]</ref>, where the attacker exploited the reentrancy vulnerability to steal over 3, 600, 000 Ether, or 60 million US Dollars at the time the attack happened. For the completeness of this paper, we discuss the vulnerability here as we later on describe how one can implement reentrancy's detection in our tool Oyente in Section 5.</p><p>In Ethereum, when a contract calls another, the current execution waits for the call to finish. This can lead to an issue when the recipient of the call makes use of the intermediate state the caller is in. This may not be immediately obvious when writing the contract if possible malicious behavior on the side of the callee is not considered.</p><p>Attack example. We can see an example of this attack in sendBalance ( <ref type="figure" target="#fig_4">Figure 7</ref>). The contract being called by sendBalance can simply call it again, since the balance for this contract has not yet been set to zero. In <ref type="figure" target="#fig_4">Figure 7</ref>, Line 11 sends the current balance of the withdrawer -as indicated by the internal variable userBalances -to the contract address wishing to withdraw its balance. However, the variable userBalances is only zeroed after the call is made, which means that the persistent storage of the contract which records users' balances has not yet been altered. The callee contract of the call in Line 11, using its default function, can call withdrawBalance until the contract is emptied of Ether -or it depletes available gas -whichever comes first.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">TOWARDS A BETTER DESIGN</head><p>We formalize a "lightweight" semantics for Ethereum in Section 4.1, and then build on this formalism in Section 4.2 to recommend solutions to the security issues identified in Section 3. Despite being lightweight, our formalism rigorously captures interesting features of Ethereum, exposing the subtleties in its semantics, which further enables us to state our proposed solutions precisely.</p><p>We use the following notation: ← to denote assignment, • to denote an arbitrary element (when the specific value is important), ⇓ to denote big-step evaluation, and ; to denote small-step evaluation. Finally, a[i → v] returns a new array identical to a, but on position i contains the value v; this notation of array update also applies to nested arrays.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Operational Semantics of Ethereum</head><p>Recall (from Section 2) that a canonical state of Ethereum, denoted by σ, is a mapping between addresses and account states. We write a valid transition from σ to σ via transaction T as σ T −→ σ .</p><p>Formation and Validation of a Block. To model the formation of the blockchain and the execution of blocks, we define a global Ethereum state as a pair BC, σ , where BC is the current block chain and σ is as before. Γ denotes the stream of incoming new transactions. For simplicity, we do not model miner rewards.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Propose</head><p>TXs ← Some transaction sequence (T1 . . . Tn) from Γ B ← blockid ; timestamp ; TXs ; . . .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>proof-of-work(B, BC)</head><formula xml:id="formula_1">∀ i, 1 ≤ i ≤ n : σi−1 T i −→ σi BC, σ0 ⇓ B • BC, σn Remove T1 . . . Tn from Γ and broadcast B Accept Receive B ≡ blockid ; timestamp ; TXs ; . . . TXs ≡ (T1 . . . Tn) ∀ i, 1 ≤ i ≤ n : σi−1 T i −→ σi BC, σ0 ⇓ B • BC, σn</formula><p>Remove T1 . . . Tn from Γ and broadcast B The actions of the miners to form and validate blocks are given in <ref type="figure" target="#fig_5">Figure 8</ref>. Only one "elected leader" executes successfully the Propose rule at a time. Other miners use the Accept rule to "repeat" the transitions σi−1 T i −→ σi after the leader broadcasts block B.</p><p>Security Issues: As discussed earlier, the issue of timestampdependence arises because the elected leader has some slack in setting the timestamp, yet other miners still accept the block. On the other hand, the issue of transaction-orderingdependence exists because of some inevitable order among Ti; yet we have shown that when dealing with Ether (or money), this might lead to undesirable outcomes.</p><p>Transaction Execution. A transaction can activate the code execution of a contract. In Ethereum, the execution can access to three types of space in which to store data: (1) an operand LIFO stack s; (2) an auxiliary memory l, an infinitely expandable array; and (3) the contract's longterm storage str, which is part of σ[id] for a given contract address id. Unlike stack and auxiliary memory, which reset after computation ends, storage persists as part of σ.</p><p>We define a virtual machine's execution state µ as a configuration A, σ , where A is a call stack (of activation records) and σ is as before. The activation record stack is defined as:</p><formula xml:id="formula_2">A ∆ = A normal | e exc • A normal A normal ∆ = M, pc, l, s • A normal |</formula><p>where denotes an empty call stack; e exc denotes that an exception has been thrown; and each part of an activation record M, pc, l, s has the following meaning: M : the contract code array pc : the address of the next instruction to be executed l : an auxiliary memory (e.g. for inputs , outputs) s : an operand stack. Though a transaction in Ethereum is a complex structure and specifies a number of fields, we abstract it to a triple id, v, l where id is the identifier of the to-be-invoked contract, v is the value to be deposited to the contract, and l is an data array capturing the values of input parameters. Thus a transaction execution can be modeled with the rules in <ref type="figure" target="#fig_6">Figure 9</ref>: the first rule describes an execution that terminates successfully (or "normal halting") while the second rule describes one that terminates with an exception. Note that the execution of a transaction is intended to follow the "transactional semantics" of which two important properties are: (1) Atomicity, requiring that each transaction be "all or nothing". In other words, if one part of the transaction fails, then the entire transaction fails and the state is left unchanged; and (2) Consistency, ensuring that any transaction will bring the system from one valid state to another. We will show, later in this section, how these properties might be violated, when we discuss the operational semantics of EVM instructions. Execution of EVM Instructions. We have distilled EVM into a language EtherLite, which is a stack machine augmented with a memory and some Ethereum-like features. The instructions ins ∈ instruction of EtherLite are:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TX-success</head><formula xml:id="formula_3">T ≡ id, v, l M ← Lookup(σ, id) σ ← σ[id][bal → (σ[id][bal] + v)] M, 0, l, • , σ ; * , σ σ T −→ σ TX-exception T ≡ id, v, l M ← Lookup(σ, id) σ ← σ[id][bal → (σ[id][bal] + v)] M, 0, l, • , σ ; * e exc • , • σ T −→ σ</formula><formula xml:id="formula_4">ins ∆ = push v | pop | op | bne | mload | mstore | sload | sstore | call | return | suicide | create | getstate</formula><p>The push instruction takes an argument v ∈ value which is either a numeric constant z, code label λ, memory address α, or contract/recipient address γ and adds it to the top of the "operand stack". The pop instruction removes (forgets) the top element of the operand stack. The op instruction, representing all of the arithmetic and logical etc. operations, pops its arguments, performs the operation, and pushes the result. Conditional branch bne is a standard "branch if not equal to zero". It pops two elements z and λ from the top of the operand stack; if z is nonzero then the program counter is set to λ, otherwise it is the program counter is incremented. The load and store instructions respectively reads from and writes to memory in the natural way. However, here we have two types of load and store, dealing with two types of memory mentioned above. While mload and mstore deal with the auxiliary memory l, sload and sstore respectively assesses and updates the contract storage str, i.e., the state of the contract. Let us now discuss more interesting instructions inspired from Ethereum. The key instructions are call and return, whose operational semantics are provided in <ref type="table" target="#tab_4">Table 1</ref> 2 . Each row describes the conditions under which an execution can move from configuration µ to configuration µ , i.e. µ ; µ . The first column indicates the instruction form captured by the rule. If the instruction about to be executed matches that form and all the (side) conditions in the second column are satisfied, then a step may be made from a configuration matching the pattern in the third column to a configuration matching the pattern in the last column.</p><p>A call instruction is roughly analogous to a remote procedure call <ref type="bibr" target="#b2">3</ref> . The arguments placed on the operand stack, are the destination γ, amount of Ether to transfer z, and two values st and sz (for "start address" and "size") to specify a slice of memory which contains additional function-specific parameters. The next two values in the operand stack similarly specify a place for the return value(s); they are exposed (in the rules) when the call is returned, or an exception has occurred. Unlike the operand stack, which has no fixed maximum size, the call stack has a maximum size of 1, 024. If the call stack is already full then the remote call will cause an exception (second rule for call). When the remote call returns, a special flag is placed onto the operand stack, with 1 indicating a successful call (second rule for return) and 0 indicating an unspecified exception (rule EXC).</p><p>There are two important points to note. First, an exception at a callee is not limited to (call) stack overflow. It could be due to various reasons such as gas exhaustion, division by zero, etc. Second, exceptions are not propagated automatically. Contract writers who wish to do so must explicitly check for the 0 and then raise a new exception, typically by jumping to an invalid label. For certain high-level commands in Solidity, a code snippet to perform these steps is inserted by the compiler.</p><p>Security Issues: Recall the security issues discussed in Section 3.3, in particular when exceptions are mishandled. The root cause of the problem is in the inconsistency of how exceptions influence the final state, depending whether a contract method is invoked as a transaction, or via the call instruction. In the former case, rule TX-exception in <ref type="figure" target="#fig_6">Figure 9</ref>, the execution is aborted ; while in the latter case, row exc <ref type="table" target="#tab_4">Table 1</ref>, a flag 0 is pushed into the operand stack of the caller. The way that an exception occurs at a callee, and is converted into a flag 0 (and the execution continues normally) indeed breaks the atomicity property. In other words, Ethereum transactions do not have atomicity in their semantics. This can lead to serious consequences, especially given </p><formula xml:id="formula_5">v • • • • • • • • • s • A, σ M, pc + 1, l, 0 • s • A, σ return M, pc, •, • • , σ , σ return a ≡ M , pc , l 0 , st • sz • s n ← min(sz , sz) 0 ≤ i &lt; n : l i+1 ← l i [st + i → l[st + i]] M, pc, l, st • sz • s • a • A, σ M , pc + 1, l n , 1 • s • A, σ EXC exceptional halting of callee e exc • M, pc, l, st • sz • s • A, σ M, pc + 1, l, 0 • s • A, σ</formula><p>that money transfers in Ethereum are mostly done using the call instruction. There are three remaining instructions: suicide, create, and getstate. The suicide instruction transfers all of the remaining Ether to recipient γ and then terminates the contract; although somewhat similar to call in that Ether changes hands, it does not use the call stack. The create instruction creates a new contract account, taking three arguments from the operand stack. They are the amount of Ether to be put in the new contract, and two values to specify a slice of memory which contains the bytecode for the new contract. It proceeds in three steps:</p><p>1. Creating a new address and allocating storage for the new contract. The specified amount of Ether is also deposited into the contract.</p><p>2. Initializing the contract's storage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Depositing the associated code body into the contract.</head><p>If the contract creation is successful, the address of new contract is pushed onto the operand stack; otherwise, a flag value of 0 is pushed. The three above-mentioned steps rely on certain helper procedures, which we will not attempt to capture with our formalism. Note that: (1) while the initialization code is executing, the newly created address exists but with no intrinsic body code; and (2) if the initialization ends up with an exception then the state is left with a "zombie" account, and any remaining balance will be locked into the account forever. In other words, an unsuccessful contract creation might lead to an invalid contract residing in the system, breaking the consistency property of the "transactional semantics". This issue might not directly lead to some security attacks, it is clearly undesirable in the current design of Ethereum. Lastly, getstate is an abstract instruction of which the concrete instance related to the security problem in 3.2 is to get the current block timestamp. A getstate instruction typically pushes certain "special" value onto the stack: in particular, the current timestamp, block id, remaining gas, current balance, and this contract's own address. Note that some of these values should be thought of as constants (e.g. current timestamp, block id), while others are updated in tandem with the execution of a transaction (e.g. remaining gas, current balance).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Recommendations for Better Semantics</head><p>We propose improvements to the operational semantics of Ethereum to fix the security problems discussed in Section 3. To deploy these proposals, all clients in the Ethereum network must upgrade.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Guarded Transactions (for TOD)</head><p>Recall that a TOD contract is vulnerable because users are uncertain about which state the contract will be in when their transactions is executed. This seems inevitable because miners can set arbitrary order between transactions (rule Propose). To eliminate the TOD problem, we need to guarantee that an invocation of a contract code either returns the expected output or fails, even given the inherent non-deterministic order between selected transactions. Guard Condition. Our new rules for transaction execution are given in <ref type="figure" target="#fig_1">Figure 10</ref>. A transaction T now additionally specifies a guard condition g; the current state σ needs to satisfy g for the execution of T to go through. If g is not satisfied, the transaction is simply dropped by the new rule TX-stale. For transactions which do not provide g, we simply consider g ≡ true. This solution guarantees that either the sender gets the expected output or the transaction fails. The solution is also backward-compatible because we do not require changes in existing contract code: old transactions can simply take the default guard condition true.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TX-stale</head><formula xml:id="formula_6">T ≡ g, •, •, • σ g σ T −→ σ TX-success T ≡ g, id, v, l M ← Lookup(σ, id) σ g σ ← σ[id][bal → (σ[id][bal] + v)] M, 0, l, • , σ ; * , σ σ T −→ σ TX-exception T ≡ g, id, v, l M ← Lookup(σ, id) σ g σ ← σ[id][bal → (σ[id][bal] + v)] M, 0, l, • , σ ; * e exc • , • σ T −→ σ</formula><p>To illustrate, let us revisit the Puzzle contract in Sec-tion 3.1. A user who submits a transaction Tu to claim the reward should specify the condition g ≡ (reward == R), where R is the current reward stored in the contract. If the owner's transaction is executed first, g is invalidated and the user's transaction Tu will abort, meaning the owner will not get the solution <ref type="bibr" target="#b3">4</ref> . Note that Puzzle is only one example of a more serious class of contracts serving as decentralized exchanges or market places (see Section 3.1). With our solution, buyers can easily avoid paying a price much higher than what they observe when issuing the buy orders. Note that "guarded transactions" resemble the "compareand-swap" (CAS) instruction supported by most modern processors. CAS is a key standard multithreaded synchronization primitive, and "guarded transactions" equips Ethereum with equivalent power.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Deterministic Timestamp</head><p>Allowing contracts to access to the block timestamp is essentially a redundant feature that renders contracts vulnerable to manipulation by adversaries. Typically, block timestamp is used for two purposes: serving as a deterministic random seed (e.g., in theRun contract) and as a global timestamp in a distributed network (in <ref type="bibr" target="#b23">[25,</ref><ref type="bibr" target="#b24">26,</ref><ref type="bibr">28]</ref>). Using block timestamp as a random seed is not wise since the entropy is low and the timestamp is easy to manipulate. There are ways to obtain better random seeds on the blockchain <ref type="bibr">[29,</ref><ref type="bibr" target="#b26">30]</ref>.</p><p>Rather than using the easily-manipulable timestamp, contracts should use the block index-a new block is created approximately every 12 seconds in Ethereum-to model global time. The block index always increments (by one), removing any flexibility for an attacker to bias the output of contract executions that access the time.</p><p>A practical fix is to translate existing notions of timestamp into block numbers. The change can be implemented by returning the block id for the instruction TIMESTAMP and translating the associated expressions. For example, the condition timestamp -lastTime &gt; 24 hours can be rewritten as blockNumber -lastBlock &gt; 7,200. This implementation requires changes to only the getstate instruction from Section 4.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">Better Exception Handling</head><p>A straightforward solution is to check the return value whenever a contract calls another. Currently, the Solidity compiler inserts a code snippet to perform exception forwarding, except when the call is made via send or call, which are considered low-level instructions (from Solidity point of view). This half-way solution still leaves the "atomicity property" broken.</p><p>A better solution is to automatically propagate the exception at the level of EVM from callee to caller; this can be easily implemented but requires all clients to upgrade. We can additionally provide a mechanism for proper exception handling, e.g., by having explicit throw and catch EVM instructions. If an exception is (implicitly or explicitly) thrown in the callee and not properly handled, the state of the caller can be reverted. This approach and has been used in many popular programming languages including C++, Java and Python. Note that adding throw and catch instructions Owners can read the solution from the transaction data if it is in plain-text, but solutions to this are well-studied <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b12">14,</ref><ref type="bibr" target="#b25">27]</ref>. does not help when the contract owner/writer is malicious and deliberately plants a bug in the contract.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">THE Oyente TOOL</head><p>Our solutions proposed in the previous Section do require all clients in the network to up-grade, thus running the risk of not seeing real deployment. As a pre-deployment mitigation, we provide a tool called Oyente to help: (1) developers to write better contracts; and (2) users to avoid invoking problematic contracts. Importantly, other analyses can also be implemented as independent plugins, without interfering with our existing features. E.g., a straightforward extension of Oyente is to compute more precise estimation of worst-case gas consumption for contracts.</p><p>Our analysis tool is based upon symbolic execution <ref type="bibr" target="#b27">[31]</ref>. Symbolic execution <ref type="bibr" target="#b4">5</ref> represents the values of program variables as symbolic expressions of the input symbolic values. Each symbolic path has a path condition which is a formula over the symbolic inputs built by accumulating constraints which those inputs must satisfy in order for execution to follow that path. A path is infeasible if its path condition is unsatisfiable. Otherwise, the path is feasible.</p><p>We choose symbolic execution because it can statically reason about a program path-by-path. On one hand, this is superior to dynamic testing, which reasons about a program input-by-input. For Ethereum, dynamic testing would even require much more effort to simulate the execution environment. As an example, to detect the transaction-ordering dependence, we must compare the outcomes of the interleaving of different execution paths. It is difficult to approach this with dynamic testing, given the non-determinism and complexity of the blockchain behaviors.</p><p>On the other hand, by reasoning about one path at a time, symbolic execution can achieve better precision (or less false positives) compared to traditional approaches using static taint analysis or general data flow analysis. In those approaches, abstract program states are often merged, admitting states that never happen in a real execution, and eventually lead to high false positives. <ref type="figure" target="#fig_1">Figure 11</ref> depicts the architecture overview of Oyente. It takes two inputs including bytecode of a contract to be analyzed and the current Ethereum global state. It answers whether the contract has any security problems (e.g., TOD, timestamp-dependence, mishandled exceptions), outputting "problematic" symbolic paths to the users. One by-product of our tool is the Control Flow Graph (CFG) of the contract bytecode. We plan that in the future Oyente will be able to work as an interactive debugger, thus we feed the CFG and the problematic paths into a Graph Visualizer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Design Overview</head><p>The bytecode is publicly available on the blockchain and Oyente interprets EVM instruction set to faithfully maps instructions to constraints, i.e., bit-level accuracy. The Ethereum global state provides the initialized (or current) values of contract variables, thus enabling more precise analysis. All other variables including value, data of message call are treated as input symbolic values.</p><p>Oyente follows a modular design. It consists of four main components, namely CFGBuilder, Explorer, CoreAnalysis and Validator. CFGBuilder constructs a Control Flow Graph of the contract, where nodes are basic execution blocks, and edges represent execution jumps between the blocks. Explorer is our main module which symbolically executes the contract. The output of Explorer is then fed to the CoreAnalysis where we implement our logic to target the vulnerabilities identified in Section 3. Finally, Validator filters out some false positives before reporting to the users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Implementation</head><p>We implement Oyente in Python with roughly 4, 000 lines of code. Currently, we employ Z3 <ref type="bibr" target="#b29">[33]</ref> as our solver to decide satisfiability. Oyente faithfully simulates Ethereum Virtual Machine (EVM) code which has 64 distinct instructions in its language. Oyente is able to detect all the three security problems discussed in Section 3. We describe each component below.</p><p>CFG Builder. CFGBuilder builds a skeletal control flow graph which contains all the basic blocks as nodes, and some edges representing jumps of which the targets can be determined by locally investigating the corresponding source nodes. However, some edges cannot be determined statically at this phase, thus they are constructed on the fly during symbolic execution in the later phase.</p><p>Explorer. Our Explorer starts with the entry node of the skeletal CFG. At any one time, Explorer may be executing a number of symbolic states. The core of Explorer is an interpreter loop which gets a state to run and then symbolically executes a single instruction in the context of that state. This loop continues until there are no states remaining, or a user-defined timeout is reached.</p><p>A conditional jump (JUMPI) takes a boolean expression (branch condition) and alters the program counter of the state based on whether the condition is true or false. Explorer queries Z3 to determine if the branch condition is either provably true or provably false along the current path; if so, the program counter is updated to the appropriate target address. Otherwise, both branches are possible: we then explore both paths in Depth First Search manner, updating the program counter and path condition for each path appropriately. More edges might be added to the skeletal CFG.</p><p>At the end of the exploration phase, we produce a set of symbolic traces. Each trace is associated with a path constraint and auxiliary data that the analyses in later phase require. The employment of a constraint solver, Z3 in particular, helps us eliminate provably infeasible traces from consideration.</p><p>Core Analysis. CoreAnalysis contains sub-components to detect contracts which are TOD, timestamp-dependent or mishandled exceptions. Currently, the Explorer collects only paths which exhibit distinct flows of Ether. Thus, we detect if a contract is TOD if it sends out Ether differently when the order of transactions changes. Similarly, we check if a contract is timestamp-dependent if the condition to send includes the block timestamp. We describe how we implement our analyses as below.</p><p>• TOD detection. Explorer returns a set of traces and the corresponding Ether flow for each trace. Our analysis thus checks if two different traces have different Ether flows. If a contract has such pairs of traces, Oyente reports it as a TOD contract.</p><p>• Timestamp dependence detection. We use a special symbolic variable to represent the block timestamp. Note that the block timestamp stays constant during the execution. Thus, given a path condition of a trace, we check if this symbolic variable is included. A contract is flagged as timestamp-dependent if any of its traces depends on this symbolic variable.</p><p>• Mishandled exceptions. Detecting a mishandled exception is straightforward. Recall that if a callee yields an exception, it pushes 0 to the caller's operand stack. Thus we only need to check if the contract executes the ISZERO instruction (which checks if the top value of the stack is 0) after every call. If it does not, any exception occurred in the callee is ignored. Thus, we flags such contract as a contract that mishandles exceptions.</p><p>• Reentrancy Detection. We make use of path conditions in order to check for reentrancy vulnerability. At each CALL that is encountered, we obtain the path condition for the execution before the CALL is executed. We then check if such condition with updated variables (e.g., storage values) still holds (i.e., if the call can be executed again). If so, we consider this a vulnerability, since it is possible for the callee to re-execute the call before finishing it.</p><p>Validation. The last component is Validator which attempts to remove false positives. For instance, given a contract flagged as TOD by CoreAnalysis and its two traces t1 and t2 exhibiting different Ether flows, Validator queries Z3 to check if both ordering (t1, t2) and (t2, t1) are feasible. If no such t1 and t2 exist, the case is considered as a false positive. However, because we have not fully simulated the execution environment of Ethereum, Validator is far from being complete. For the results presented in Section 6, we resort to best-effort manual analysis to confirm the security bugs. In other words, the current main usage of Oyente is to flag potentially vulnerable contracts; full-fledged false positive detection is left for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">EVALUATION</head><p>We measure the efficacy of Oyente via quantitative and qualitative analyses. We run Oyente on all contracts in the first 1, 459, 999 blocks of Ethereum. Our goals are threefold. First, we aim to measure the prevalence of the security bugs discussed in Section 3 in the real Ethereum contracts. Second, we highlight that our design and implementation choices are driven by the characteristics of real-life smart contracts, and that Oyente is robust enough to handle them. Lastly, we present several case studies demonstrating misunderstandings that many contract developers have about the subtle semantics of Ethereum. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Benchmarks and Tool Robustness</head><p>We collected 19, 366 smart contracts from the blockchain as of May 5, 2016. These contracts currently hold a total balance of 3, 068, 654 Ether, or 30 Million US dollars at the time of writing. The balance in contracts vary significantly: most of contracts do not hold any Ether (e.g., balance is zero), 10% of them have at least 1 Ether, while the highest balance (2, 401, 557 Ether) accounts for 38.9% of the total balance in all contracts. On an average, a contract has 318.5 Ether, or equivalently 4523 US dollars. This suggests that attackers are well-incentivized to target and exploit flaws in smart contracts to gain profit.</p><p>Ethereum contracts vary from being simple to fairly complex. <ref type="figure" target="#fig_1">Figure 13</ref> shows that the number of instructions in a contract ranges from 18 to 23, 609, with an average of 2, 505 and a median of 838. The number of distinct instructions used in a single contract is shown in <ref type="figure" target="#fig_1">Figure 13</ref>. It shows that to handle these real-world contracts, Oyente needs to correctly handle the logic of 63 instructions. We choose to build Oyente on EVM bytecode rather than the source code (e.g., Solidity <ref type="bibr" target="#b14">[16]</ref>) because only a small number contracts have source code publicly available on public repositories <ref type="bibr">[34,</ref><ref type="bibr" target="#b30">35]</ref>. Oyente finds a total number of 366, 213 feasible execution paths which took a total analysis time of roughly 3, 000 hours on Amazon EC2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Quantitative analysis</head><p>Experimental setup. We run Oyente on 19, 366 contracts in our benchmark. All experiments are conducted on 4 Amazon EC2 m4.10xlarge instances, each has 40 Amazon vCPU with 160 GB of memory and runs 64-bit Ubuntu 14.04. We use Z3 v4.4.1 as our constraint solver <ref type="bibr" target="#b29">[33]</ref>. We set a timeout for our symbolic execution (e.g.,Explorer component) of 30 mins per contract. The timeout for each Z3 request is set to 1 second. We observe that the running time depends near linearly on the number of explored paths, i.e., the complexity of contracts. tracts which have at least one security issue discussed in Section 3. Out of these, 1, 682 are distinct (by direct comparison of the bytecode). Of these, we were able to collect source code for only 175 contracts to confirm the tool's correctness; we manually check for false positives. Among all contracts with source, Oyente has a low false positive rate of 6.4%, i.e., only 10 cases out of 175.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Results</head><p>Mishandled exceptions. 5, 411 contracts have mishandled exceptions flagged by Oyente, which account for 27.9% of the contracts in our benchmark. Out of these 5, 411 contracts, 1, 385 are found to be distinct and 116 contracts have source code available. By manual analysis, we verify that all these 116 contracts are true positives. In order to confirm, we identify if any external calls (SEND, CALL instructions) are present and not followed by any checks for failures. These failure checks are implemented by verifying if the return value is non-zero.</p><p>The prevalence of this problem is explained by the following observation. In the first 1, 459, 999 blocks on the public blockchain, 180, 394 cross-contract calls were processed. For each contract invocation, there may be additional calls to other contracts, thus increasing the call-stack depth. These can be due to function or library calls, external account transactions, or nested recursive contract calls. We plot the call-stack depths of these contract invocations in <ref type="figure" target="#fig_1">Figure 14</ref>, which shows that most of them involve some level of nesting (e.g., invoking other contracts). Further, all contract invocations do not exceed the call-stack depth of 50 in benign runs, which is far below the call-stack depth's limit of 1, 024. This explains why exceptions are commonly unexpected and unhandled in benign invocations.</p><p>Transaction-ordering dependence. The TOD contracts are less common with 3, 056 contracts, or 15.7% of the contracts in our benchmarks. Of these contracts, there are 135 distinct contracts and 32 have source code available. We manually verify that 9 of them are false positives and 23 are true positives. In order to confirm, we look for different flows of Ether wherein the outcome depends on the order of the input transactions.</p><p>Several true positive cases, where this dependence is exploitable, are discussed later. As an example of a false positive, <ref type="figure" target="#fig_1">Figure 15</ref>  Call-stack depth Number of Invocations <ref type="figure" target="#fig_1">Figure 14</ref>: Call-stack depth statistics in 180, 394 contract invocations in Ethereum network in Line 4) returns Ether to the sender if some requirement is not met, while the latter (Line 7-17) pays out to previous participants. Oyente recognized the two flows of Ether and flagged the contract as potentially buggy. However, the order in which these flows are executed by incoming transactions does not affect the intended payouts and recipients therein. The tool could involve more time-consuming analyses to resolve such cases in the future. The final state of the contract remains the same.</p><p>Timestamp dependence. Oyente reports 83 timestampdependent contracts in our benchmark, out of which 52 are distinct. Only 7 of these have source code available, which we manually verified for false positives. To confirm, we check if timestamp is included in the path condition of a flow of Ether, such that manipulation of the block timestamp would result in a different payout or recipient from the contract.</p><p>Reentrancy Handling. Oyente reports 340 instances of this vulnerability, out of which 186 are distinct. Only 2 of these have source code available, one of which is the infamous TheDAO contract <ref type="bibr" target="#b17">[19]</ref>. The other known-source contract has reentrancy vulnerability, but the vulnerability is not exploitable since it uses the SEND instruction instead of a CALL to call to a different account. The significant difference here is that a CALL sends all of the remaining gas to the callee at the time it is made, whereas a SEND limits this amount. This simple change would limit the damage from possible reentrancy attack. We further test Oyente on a number of publicly available reentrancy examples <ref type="bibr" target="#b31">[36]</ref>  <ref type="bibr" target="#b32">[37]</ref>, and Oyente confirms all cases where repeated execution of a call was possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Qualitative Analysis</head><p>We investigate several contracts flagged by Oyente to show how it helps analyze Ethereum smart contracts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.1">Severity of Attacks</head><p>We have found vulnerable contracts which have different levels of damage severity reported in Section 6.2. For instance, the PonziGovernMental <ref type="bibr" target="#b24">[26]</ref> contract with highest balance (1, 099.5 Ether) flagged by Oyente among the mishandled exception category. The contract operates as below.</p><p>• The contract accepts investments from users. New investments pay to previous investors and add to the jackpot.  • After 12 hours without no new investment, the last investor and the contract owner shares the jackpot. The code to handle the last step is in <ref type="figure" target="#fig_1">Figure 17</ref>. Line 7 and 9 use send instructions to send Ether, which may not execute correctly as discussed in Section 3.3. The contract does not check if the operations were successful, leaving it vulnerable to attack.</p><p>Stealing Ether from investors. Let us consider the code snippet from <ref type="figure" target="#fig_1">Figure 17</ref> which has a subtle bug. Line 11 seems harmless in that it pays out the owners after all creditors have been paid, with all remaining amount. However, if the owners were to call the contract with a carefully constructed call-stack size of 1023, none of the send instructions would succeed, resulting in no Ether going out. A second call to the contract would result in the owners receiving the entirety of the contract's balance and forcing previous investors to lose all Ether invested in the contract. Similar attacks exist in other contracts as well (see <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b23">25]</ref>).</p><p>Manipulation of contract outcome. PonziGovernMental is another example of timestamp-dependent contract. In Line 5, PonziGovernMental determines the current time by using the current block timestamp. If a user invokes PonziGovernMental when it is close to 12 hours since the last deposit, the miner can set the next block timestamp to make the condition in Line 5 either valid or invalid. Thus, miners can force the PonziGovernMental contract to finish the current round earlier by picking a timestamp value which is ahead of the current time. Alternatively, miners can extend the round for 12 hours by choosing a smaller timestamp. Thus, miners who have a stake in the contract will set the timestamp to a value which favors their outcome. The problem also exists in other contracts (see <ref type="bibr">[28]</ref>).</p><p>Lock or Sabotage Others' Funds. Attackers can also prevent others from receiving their legitimate payments. One example of such an attack is in EtherID, which is one of the most active contracts in Ethereum with 57, 738 received/sent transactions as of writing <ref type="bibr" target="#b33">[38]</ref>. EtherID works as a name registrar for Ethereum network to allow users to create, buy and sell any ID (like a token). The code which handles users' requests to buy a registered ID is in <ref type="figure" target="#fig_1">Figure 18</ref>. The code checks if the buyer has enough Ethers (Line 2), sends the payment to the existing owner (Line 4) and change the ownership of the ID (Line 5-10). As described in Section 3.3, the send instruction in Line 4 may fail. As a result, the ID  <ref type="figure" target="#fig_1">Figure 16</ref>: A contract conducts the call-stack attack by calling itself 1023 times before sending a buy request to EtherID.</p><p>owners may not receive the payment and still have to transfer the ownership of their ID to the buyers. There is no way for the owners to claim the payment later on. The Ether value is locked in the contract forever.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Public Verification</head><p>Verifying the above attack on the public blockchain is feasible, but for ethical reasons we do not conduct our attack confirmation on contracts <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b23">25,</ref><ref type="bibr" target="#b24">26]</ref> where users may lose funds. Instead, we perform our verification on EtherID contract on which the attack has less severity. More importantly, EtherID allows us to target our own accounts, other accounts are not affected in the experiments.</p><p>We verify the problem of EtherID by creating our own IDs and self-purchasing them. We show that the registers of our IDs do not receive the intended payments when the registers use contract wallets, or when the buyers are malicious and conduct the call-stack exceeding attack.</p><p>Our two IDs are dummywallet and foowallet registered by two addresses 0x33dc532ec9b61ee7d8adf558ff248542c2a2a62e and 0x62ec11a7fb5e35bd9e243eb7f867a303e0dfe08b respectively. The price to buy either of the ID is 0.01 Ether. The address 0x33dc532... is a contract address, which performs some computation (thus burning gas) on receiving any payment.</p><p>We then send two transactions from different addresses to buy the two IDs. The first transaction 6 purchases dummywallet. However, 0x33dc532... is a contract address, which is implemented to burn all the provided gas on receiving any payment without doing anything else. Thus the send function in Line 4 of EtherID to 0x33dc532... will fail. As a result, 0x33dc532... sells it ID without receiving any payment. The fund 0.01 Ethers is kept in the contract EtherID forever.</p><p>The second transaction 7 sent from a contract, which calls itself 1023 times before sending a buy request to EtherID to buy foowallet. The code snippet to perform such attack is in <ref type="figure" target="#fig_1">Figure 16</ref>. When EtherID executes send in Line 4, the call stack already has 1024 frames, so send fails regardless of how much gas is used. Hence, the address 0x62ec11a7... does not receive the payment of 0.01 Ethers as it should.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">RELATED WORK</head><p>Smart Contract Security. Delmolino et al. <ref type="bibr" target="#b12">[14]</ref> show that even a simple self-construct contract (e.g., "Rock, Paper, TX hash:</p><p>0xb169b07c274a71727ecfe9d0610d09917c45-4c1216cd659350f83ef44ba071b4 <ref type="bibr" target="#b6">7</ref> TX hash: 0x0c10fafe0cdbfff32abfe53d57ec861d09-986cc1050c850481f79b1a862bb10a Scissors") can contain several logic problems, including:</p><p>• Contracts do not refund. Some contracts proceed further only if users send a certain amount of Ether. However, these contracts sometimes "forget" to refund users if users send less than what is required.</p><p>• Lack of cryptography to achieve fairness. Some contracts perform computation based on users' inputs to decide the outcome (e.g., rolling a die). However, those contracts store users' input in plaintext on the blockchain. Thus, malicious users can submit inputs biased in their favor.</p><p>• Incentive misalignment. Some contracts do not incentivize users to follow intended behavior. Consider a gambling game that uses a commit-reveal scheme in which participants first submit their encrypted move along with a deposit before later revealing it. After the first move is revealed, the second user may realize his move will lose. Since his deposit lost, he may not be willing to spend gas to reveal his choice. These security problems are more about logical flaws in the implementation of contracts. In contrast, our paper documents new security bugs stemming from semantic misunderstandings of smart contract developers. We suggest improvements to the semantics and introduce Oyente to detect these bugs in existing contracts in the Ethereum blockchain. Our evaluation showed that 8, 519 existing contracts contain at least one of the new bugs. The call-stack problem of Ethereum was reported previously in a security audit by Miller et al. <ref type="bibr" target="#b22">[24]</ref>. The bug, however, still remains unfixed.</p><p>Other work also studies security and/or privacy concerns in designing smart contracts <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b25">27,</ref><ref type="bibr" target="#b34">39,</ref><ref type="bibr" target="#b35">40]</ref>. For instance, Hawk <ref type="bibr" target="#b25">[27]</ref> provides confidential execution for contracts by leveraging cryptographic techniques and Town Crier <ref type="bibr" target="#b34">[39]</ref> feeds reliable, trustworthy data from trusted web servers to smart contracts via hardware rooted trust.</p><p>Distributed Systems and Programming Languages. Security problems in smart contracts are often related to problems in traditional distributed systems. For example, concurrency control in multiuser distributed database systems (DBMS) <ref type="bibr" target="#b36">[41]</ref> is superficially similar to the transactionorder dependency problem. However, transaction-ordering problems in permissionless distributed systems like cryp-  <ref type="figure" target="#fig_1">Figure 18</ref>: EtherID contract, which allows users to register, buy and sell any ID. This code snippet handles buy requests from users.</p><p>tocurrencies are more complex than in traditional systems because adversaries can manipulate the order.</p><p>Many previous works attempt to build a global timestamp in distributed systems, in both asynchronous and synchronous settings <ref type="bibr" target="#b37">[42]</ref><ref type="bibr" target="#b38">[43]</ref><ref type="bibr" target="#b39">[44]</ref>. Time in distributed systems traditionally forms a partial order rather than the the total order given by the blockchain. As we discussed in Section 3, having access to the block timestamp (in addition to the block id) is redundant and invites attack. Lastly, propagating exceptions is inspired by the exception handling mechanism in modern languages <ref type="bibr" target="#b40">[45,</ref><ref type="bibr" target="#b41">46]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">ACKNOWLEDGMENT</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>c 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00 DOI: http://dx.doi.org/10.1145/2976749.2978309</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Number of smart contracts in Ethereum has increased rapidly.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>The blockchain's design in popular cryptocurrencies like Bitcoin and Ethereum. Each block consists of several transactions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>A contract that rewards users who solve a computational puzzle.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 :</head><label>7</label><figDesc>An example of the reentrancy bug. The contract implements a simple bank account.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>Proposing and Accepting a Block</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Rules for Transaction Execution. Lookup(σ,id) finds the associated code of contract address id in state σ; σ[id][bal] refers to the balance of the contract at address id in state σ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>New Rules for Transaction Execution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Overview Architecture of Oyente. Main components are within the dotted area. Shaded boxes are publicly available.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 12 :</head><label>12</label><figDesc>Number of buggy contracts per each security problem reported by Oyente.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Performance.</head><label></label><figDesc>On average, Oyente takes 350 seconds to analyze a contract. 267 contracts require more than 30 minutes to analyze. The number of paths explored by Oyente ranges from 1 to 4613 with an average of 19 per contract and a median of 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 12 Figure 13 :</head><label>1213</label><figDesc>reports our results. Oyente flags 8, 833 con-Number of instructions in each contract</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>shows a case where there are two separate flows of Ether, but the order of their execution does not change the outcome of the contract. The first flow (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 15 :</head><label>15</label><figDesc>A false positive TOD contract flagged by Oyente. This contract implements a typical ponzi scheme.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 17 :</head><label>17</label><figDesc>function l e n d G o v e r n m e n t M o n e y ( address buddy ) returns ( bool ) { uint amount = msg . value ; 4 // check the condition to end the game if ( l a s t T i m e O f N e w C r e d i t + TWELVE_HOURS &gt; block . timestamp ) { msg . sender . send ( amount ); // Sends jacpot to the last creditor c r e d i t o r A d d r e s s e s [ c r e d i t o r A d d r e s s e s . length -1] . send ( pro fitF rom Cras h ); owner . send ( this . balance ); 12 13 // Reset contract state 14 l a s t C r e d i t o r P a y e d O u t = 0; 15 l a s t T i m e O f N e w C r e d i t = block . timestamp ; 16 pr ofit From Cras h = 0; 17 c r e d i t o r A d d r e s s e s = new address [](0); 18 cr edit orAm ount s = new uint [](0); round += 1; return false ; }} PonziGovernmentMental contract, with over 1000 Ether, allows users to participate/profit from the creation/fall of a government.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>1</head><label></label><figDesc>// ID on sale , and enough money 2 if ( d . price &gt; 0 &amp;&amp; msg . value &gt;= d . price ){ 3 if ( d . price &gt; 0) 4 address ( d . owner ). send ( d . price ); 5 d . owner = msg . sender ; // Change the ownership 6 d . price = price ; // New price d . transfer = transfer ; // New transfer d . expires = block . number + expires ; DomainChanged ( msg . sender , domain , 0 ); }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 1 :</head><label>1</label><figDesc>Operational Semantics of call and return. EXC stands for "Exception".Lookup(σ, γ) σ ← σ[id][bal → σ[id][bal] − z] σ ← σ [γ][bal → σ[id][bal] + z] M, pc, l, γ • z • st • sz • s • A, σ M , 0, l , • a • A, σ</figDesc><table><row><cell>M [pc]</cell><cell>Conditions</cell><cell>µ</cell><cell>µ</cell></row><row><cell cols="2">call M ← call id ← address of the executing contract a ← M, pc, l, s id ← address of the executing contract σ[id][bal] &lt; v or |A| = 1023</cell><cell>M, pc, l, • •</cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">For completeness, operational semantics of other instructions are provided in the Appendix.<ref type="bibr" target="#b2">3</ref> Ethereum has several additional variants of call, including CALLCODE and DELEGATECALL which we do not model in EtherLite.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5">Symbolic execution can also be viewed as abstract interpretation<ref type="bibr" target="#b28">[32]</ref>.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>We thank Brian Demsky, Vitalik Buterin, Yaron Welner, Gregory J. Duck, Christian Reitwiessner, Dawn Song, Andrew Miller, Jason Teutsch, Alex Zikai Wen, Patrick Cousot and Joseph Chow for useful discussions and feedback on the early version of the paper. </p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head> <ref type="table">Table 2</ref> <p>describes the operational semantics of EtherLite. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M [pc]</head><p>Conditions µ µ </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Bitcoin: A peer-to-peer electronic cash system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satoshi</forename><surname>Nakamoto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Ethereum&apos;s white paper</title>
		<ptr target="https://github.com/ethereum/wiki/wiki/White-Paper" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>Ethereum Foundation</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Permacoin: Repurposing Bitcoin work for long-term data preservation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Parno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Katz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Security and Privacy</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://kencode.de/projects/ePlug/Factom-Linux-Whitepaper.pdf" />
		<title level="m">The world&apos;s first blockchain operating system (bos)</title>
		<imprint>
			<date type="published" when="2015-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The idea of smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Szabo</surname></persName>
		</author>
		<ptr target="http://szabo.best.vwh.net/smartcontractsidea.html" />
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Demystifying incentives in the consensus computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loi</forename><surname>Luu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Teutsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raghav</forename><surname>Kulkarni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Saxena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22Nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15</title>
		<meeting>the 22Nd ACM SIGSAC Conference on Computer and Communications Security, CCS &apos;15</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="706" to="719" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">EtherDice smart contract is down for maintenance</title>
		<ptr target="https://www.reddit.com/r/ethereum/comments/47f028/etherdiceisdownformaintenancewearehaving/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rsk Labs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rootstock</surname></persName>
		</author>
		<ptr target="http://www.rootstock.io/" />
		<title level="m">Smart contracts platform powered by Bitcoin</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Spanner: Google&apos;s globally distributed database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Fikes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Frost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrey</forename><surname>Gubarev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Heiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Hochschild</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wilson</forename><surname>Hsieh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Kanthak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eugene</forename><surname>Kogan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongyi</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<date type="published" when="2013-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Megastore: Providing scalable, highly available storage for interactive services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Baker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Bond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">C</forename><surname>Corbett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrey</forename><surname>Furman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Khorlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Michel</forename><surname>Larson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yawei</forename><surname>Leon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vadim</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yushprakh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Innovative Data system Research (CIDR)</title>
		<meeting>the Conference on Innovative Data system Research (CIDR)</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="223" to="234" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kingoftheetherthrone</forename><surname>Smart Contract</surname></persName>
		</author>
		<ptr target="https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">GovernMental&apos;s 1100 ETH payout is stuck because it uses too much gas</title>
		<ptr target="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentalsethjackpotpayoutisstuck/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Step by step towards creating a safe smart contract: Lessons and insights from a cryptocurrency lab</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Delmolino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><surname>Arnett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="volume">460</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Ethereum: A secure decentralised generalised transaction ledger</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gavin</forename><surname>Wood</surname></persName>
		</author>
		<ptr target="http://gavwood.com/paper.pdf" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The solidity contract-oriented programming language</title>
		<ptr target="https://github.com/ethereum/solidity" />
		<imprint/>
	</monogr>
	<note>Ethereum Foundation</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The serpent contract-oriented programming language</title>
		<ptr target="https://github.com/ethereum/serpent" />
		<imprint/>
	</monogr>
	<note>Ethereum Foundation</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Oyente</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Page</surname></persName>
		</author>
		<ptr target="https://www.comp.nus.edu.sg/˜loiluu/oyente.html" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<ptr target="http://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code" />
		<title level="m">TheDAO smart contract</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">EtherEx: A fully decentralized cryptocurrency exchange</title>
		<ptr target="https://etherex.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">EtherOpt: A decentralized options exchange</title>
		<ptr target="http://etheropt.github.io/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">The Run smart contract</title>
		<ptr target="https://etherscan.io/address/0xcac337492149bdb66b088bf5914bedfbf78ccc18" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Block validation algorithm</title>
		<ptr target="https://github.com/ethereum/wiki/wiki/Block-Protocol-2.0#block-validation-algorithm" />
		<imprint/>
	</monogr>
	<note>Ethereum Foundation</note>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Gas economics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Warner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Wilcox</surname></persName>
		</author>
		<ptr target="https://github.com/LeastAuthority/ethereum-analyses/blob/master/GasEcon.md" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Protect The Castle Contract</title>
		<ptr target="http://protect-the-castle.ether-contract.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title/>
		<ptr target="http://governmental.github.io/GovernMental/" />
	</analytic>
	<monogr>
		<title level="j">GovernMental Smart Contract</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Hawk: The blockchain model of cryptography and privacy-preserving smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zikai</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charalampos</forename><surname>Papamanthou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 IEEE Symposium on Security and Privacy, SP &apos;16</title>
		<meeting>the 2016 IEEE Symposium on Security and Privacy, SP &apos;16</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">On Bitcoin as a public randomness source. Cryptology ePrint Archive</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Bonneau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Goldfeder</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
		<imprint>
			<date type="published" when="1015" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Symbolic execution and program testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">C</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="385" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><surname>Cousot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Radhia</forename><surname>Cousot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages</title>
		<meeting>the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1977" />
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Microsoft Corporation. The Z3 theorem prover</title>
		<ptr target="https://github.com/Z3Prover/z3" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">The Ethereum network stats</title>
		<ptr target="https://etherchain.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Tokenwith invariants -vulnerable contracts in ethereum</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Borah</surname></persName>
		</author>
		<ptr target="https://github.com/PeterBorah/smart-contract-security-examples/blob/7d7ef27b12f15318871c44512b70737176d23c5f/contracts/TokenWithInvariants.sol" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">More ethereum attacks: Race-to-empty is the real deal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Vessenes</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Naverniouk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Etherid</surname></persName>
		</author>
		<ptr target="http://etherid.org/" />
		<title level="m">Ethereum name registrar</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Town crier: An authenticated data feed for smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ethan</forename><surname>Cecchetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyle</forename><surname>Croman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">The ring of Gyges: Investigating the future of criminal smart contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ari</forename><surname>Juels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmed</forename><surname>Kosba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elaine</forename><surname>Shi</surname></persName>
		</author>
		<ptr target="http://eprint.iacr.org/" />
	</analytic>
	<monogr>
		<title level="j">Cryptology ePrint Archive</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
	<note type="report_type">Report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Concurrency control in distributed database systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Philip</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Bernstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Goodman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="185" to="221" />
			<date type="published" when="1981-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Virtual time and global states of distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Friedemann</forename><surname>Mattern</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Parallel and Distributed Algorithms</title>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="215" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Timestamps in message-passing systems that preserve the partial ordering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Fidge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Australian Computer Science Conference</title>
		<meeting>the 11th Australian Computer Science Conference</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="56" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leslie</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Exception handling for C++</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Koening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bjarne</forename><surname>Stroustrup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Object-Oriented Programming</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="16" to="33" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">The Definition of Standard ML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robin</forename><surname>Milner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mads</forename><surname>Tofte</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Macqueen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
