<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main"></title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2017-01-30">30 Jan 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Diederik</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
							<email>dpkingma@openai.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jimmy</forename><surname>Lei Ba</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Amsterdam</orgName>
								<address>
									<region>OpenAI</region>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">University of Toronto</orgName>
							</affiliation>
						</author>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2017-01-30">30 Jan 2017</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1412.6980v9[cs.LG]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:40+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We introduce Adam, an algorithm for first-order gradient-based optimization of stochastic objective functions, based on adaptive estimates of lower-order moments. The method is straightforward to implement, is computationally efficient, has little memory requirements, is invariant to diagonal rescaling of the gradients, and is well suited for problems that are large in terms of data and/or parameters. The method is also appropriate for non-stationary objectives and problems with very noisy and/or sparse gradients. The hyper-parameters have intuitive interpretations and typically require little tuning. Some connections to related algorithms, on which Adam was inspired, are discussed. We also analyze the theoretical convergence properties of the algorithm and provide a regret bound on the convergence rate that is comparable to the best known results under the online convex optimization framework. Empirical results demonstrate that Adam works well in practice and compares favorably to other stochastic optimization methods. Finally, we discuss AdaMax, a variant of Adam based on the infinity norm. * Equal contribution. Author ordering determined by coin flip over a Google Hangout.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Stochastic gradient-based optimization is of core practical importance in many fields of science and engineering. Many problems in these fields can be cast as the optimization of some scalar parameterized objective function requiring maximization or minimization with respect to its parameters. If the function is differentiable w.r.t. its parameters, gradient descent is a relatively efficient optimization method, since the computation of first-order partial derivatives w.r.t. all the parameters is of the same computational complexity as just evaluating the function. Often, objective functions are stochastic. For example, many objective functions are composed of a sum of subfunctions evaluated at different subsamples of data; in this case optimization can be made more efficient by taking gradient steps w.r.t. individual subfunctions, i.e. stochastic gradient descent (SGD) or ascent. SGD proved itself as an efficient and effective optimization method that was central in many machine learning success stories, such as recent advances in deep learning <ref type="bibr" target="#b1">(Deng et al., 2013;</ref><ref type="bibr" target="#b9">Krizhevsky et al., 2012;</ref><ref type="bibr" target="#b5">Hinton &amp; Salakhutdinov, 2006;</ref><ref type="bibr" target="#b6">Hinton et al., 2012a;</ref><ref type="bibr" target="#b4">Graves et al., 2013)</ref>. Objectives may also have other sources of noise than data subsampling, such as dropout <ref type="bibr" target="#b7">(Hinton et al., 2012b)</ref> regularization. For all such noisy objectives, efficient stochastic optimization techniques are required. The focus of this paper is on the optimization of stochastic objectives with high-dimensional parameters spaces. In these cases, higher-order optimization methods are ill-suited, and discussion in this paper will be restricted to first-order methods.</p><p>We propose Adam, a method for efficient stochastic optimization that only requires first-order gradients with little memory requirement. The method computes individual adaptive learning rates for different parameters from estimates of first and second moments of the gradients; the name Adam is derived from adaptive moment estimation. Our method is designed to combine the advantages of two recently popular methods: AdaGrad <ref type="bibr" target="#b2">(Duchi et al., 2011)</ref>, which works well with sparse gradients, and RMSProp <ref type="bibr" target="#b19">(Tieleman &amp; Hinton, 2012)</ref>, which works well in on-line and non-stationary settings; important connections to these and other stochastic optimization methods are clarified in section 5. Some of Adam's advantages are that the magnitudes of parameter updates are invariant to rescaling of the gradient, its stepsizes are approximately bounded by the stepsize hyperparameter, it does not require a stationary objective, it works with sparse gradients, and it naturally performs a form of step size annealing.</p><p>Algorithm 1: Adam, our proposed algorithm for stochastic optimization. See section 2 for details, and for a slightly more efficient (but less clear) order of computation. g 2 t indicates the elementwise square g t g t . Good default settings for the tested machine learning problems are α = 0.001, β 1 = 0.9, β 2 = 0.999 and = 10 −8 . All operations on vectors are element-wise. With β t 1 and β t 2 we denote β 1 and β 2 to the power t. Require: α: Stepsize Require: β 1 , β 2 ∈ [0, 1): Exponential decay rates for the moment estimates Require: f (θ): Stochastic objective function with parameters θ Require: θ 0 : Initial parameter vector m 0 ← 0 (Initialize 1 st moment vector) v 0 ← 0 (Initialize 2 nd moment vector) t ← 0 (Initialize timestep) while θ t not converged do</p><formula xml:id="formula_0">t ← t + 1 g t ← ∇ θ f t (θ t−1 ) (Get gradients w.r.t. stochastic objective at timestep t) m t ← β 1 • m t−1 + (1 − β 1 ) • g t (Update biased first moment estimate) v t ← β 2 • v t−1 + (1 − β 2 ) • g 2 t (Update biased second raw moment estimate) m t ← m t /(1 − β t 1 ) (Compute bias-corrected first moment estimate) v t ← v t /(1 − β t 2 ) (Compute bias-corrected second raw moment estimate) θ t ← θ t−1 − α • m t /( √ v t + ) (Update parameters) end while return θ t (Resulting parameters)</formula><p>In section 2 we describe the algorithm and the properties of its update rule. Section 3 explains our initialization bias correction technique, and section 4 provides a theoretical analysis of Adam's convergence in online convex programming. Empirically, our method consistently outperforms other methods for a variety of models and datasets, as shown in section 6. Overall, we show that Adam is a versatile algorithm that scales to large-scale high-dimensional machine learning problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">ALGORITHM</head><p>See algorithm 1 for pseudo-code of our proposed algorithm Adam. Let f (θ) be a noisy objective function: a stochastic scalar function that is differentiable w.r.t. parameters θ. We are interested in minimizing the expected value of this function, E[f (θ)] w.r.t. its parameters θ. With f 1 (θ), ..., , f T (θ) we denote the realisations of the stochastic function at subsequent timesteps 1, ..., T . The stochasticity might come from the evaluation at random subsamples (minibatches) of datapoints, or arise from inherent function noise. With g t = ∇ θ f t (θ) we denote the gradient, i.e. the vector of partial derivatives of f t , w.r.t θ evaluated at timestep t.</p><p>The algorithm updates exponential moving averages of the gradient (m t ) and the squared gradient (v t ) where the hyper-parameters β 1 , β 2 ∈ [0, 1) control the exponential decay rates of these moving averages. The moving averages themselves are estimates of the 1 st moment (the mean) and the 2 nd raw moment (the uncentered variance) of the gradient. However, these moving averages are initialized as (vectors of) 0's, leading to moment estimates that are biased towards zero, especially during the initial timesteps, and especially when the decay rates are small (i.e. the βs are close to 1). The good news is that this initialization bias can be easily counteracted, resulting in bias-corrected estimates m t and v t . See section 3 for more details.</p><p>Note that the efficiency of algorithm 1 can, at the expense of clarity, be improved upon by changing the order of computation, e.g. by replacing the last three lines in the loop with the following lines:</p><formula xml:id="formula_1">α t = α • − β t 2 /(1 − β t 1 ) and θ t ← θ t−1 − α t • m t /( √ v t +ˆ ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">ADAM'S UPDATE RULE</head><p>An important property of Adam's update rule is its careful choice of stepsizes. Assuming = 0, the effective step taken in parameter space at timestep t is</p><formula xml:id="formula_2">∆ t = α • m t / √ v t .</formula><p>The effective stepsize has two upper bounds:</p><formula xml:id="formula_3">|∆ t | ≤ α • (1 − β 1 )/ √ − β 2 in the case (1 − β 1 ) &gt; √ − β 2 , and |∆ t | ≤ α</formula><p>otherwise. The first case only happens in the most severe case of sparsity: when a gradient has been zero at all timesteps except at the current timestep. For less sparse cases, the effective stepsize will be smaller. When</p><formula xml:id="formula_4">(1 − β 1 ) = √ − β 2 we have that | m t / √ v t | &lt; 1 therefore |∆ t | &lt; α.</formula><p>In more common scenarios, we will have that m t /</p><formula xml:id="formula_5">√ v t ≈ ±1 since |E[g]/ E[g 2 ]| ≤ 1.</formula><p>The effective magnitude of the steps taken in parameter space at each timestep are approximately bounded by the stepsize setting α, i.e., |∆ t | α. This can be understood as establishing a trust region around the current parameter value, beyond which the current gradient estimate does not provide sufficient information. This typically makes it relatively easy to know the right scale of α in advance. For many machine learning models, for instance, we often know in advance that good optima are with high probability within some set region in parameter space; it is not uncommon, for example, to have a prior distribution over the parameters. Since α sets (an upper bound of) the magnitude of steps in parameter space, we can often deduce the right order of magnitude of α such that optima can be reached from θ 0 within some number of iterations. With a slight abuse of terminology, we will call the ratio m t / √ v t the signal-to-noise ratio (SN R). With a smaller SNR the effective stepsize ∆ t will be closer to zero. This is a desirable property, since a smaller SNR means that there is greater uncertainty about whether the direction of m t corresponds to the direction of the true gradient. For example, the SNR value typically becomes closer to 0 towards an optimum, leading to smaller effective steps in parameter space: a form of automatic annealing. The effective stepsize ∆ t is also invariant to the scale of the gradients; rescaling the gradients g with factor c will scale m t with a factor c and v t with a factor c 2 , which cancel out:</p><formula xml:id="formula_6">(c • m t )/( √ c 2 • v t ) = m t / √ v t .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">INITIALIZATION BIAS CORRECTION</head><p>As explained in section 2, Adam utilizes initialization bias correction terms. We will here derive the term for the second moment estimate; the derivation for the first moment estimate is completely analogous. Let g be the gradient of the stochastic objective f , and we wish to estimate its second raw moment (uncentered variance) using an exponential moving average of the squared gradient, with decay rate β 2 . Let g 1 , ..., g T be the gradients at subsequent timesteps, each a draw from an underlying gradient distribution g t ∼ p(g t ). Let us initialize the exponential moving average as v 0 = 0 (a vector of zeros). First note that the update at timestep t of the exponential moving average</p><formula xml:id="formula_7">v t = β 2 • v t−1 + (1 − β 2 ) • g 2 t (</formula><p>where g 2 t indicates the elementwise square g t g t ) can be written as a function of the gradients at all previous timesteps:</p><formula xml:id="formula_8">v t = (1 − β 2 ) t i=1 β t−i 2 • g 2 i (1)</formula><p>We wish to know how E[v t ], the expected value of the exponential moving average at timestep t, relates to the true second moment E[g 2 t ], so we can correct for the discrepancy between the two. Taking expectations of the left-hand and right-hand sides of eq. <ref type="formula">1</ref>:</p><formula xml:id="formula_9">E[v t ] = E (1 − β 2 ) t i=1 β t−i 2 • g 2 i (2) = E[g 2 t ] • (1 − β 2 ) t i=1 β t−i 2 + ζ (3) = E[g 2 t ] • (1 − β t 2 ) + ζ<label>(4)</label></formula><p>where ζ = 0 if the true second moment E[g 2 i ] is stationary; otherwise ζ can be kept small since the exponential decay rate β 1 can (and should) be chosen such that the exponential moving average assigns small weights to gradients too far in the past. What is left is the term (1 − β t</p><p>2 ) which is caused by initializing the running average with zeros. In algorithm 1 we therefore divide by this term to correct the initialization bias.</p><p>In case of sparse gradients, for a reliable estimate of the second moment one needs to average over many gradients by chosing a small value of β 2 ; however it is exactly this case of small β 2 where a lack of initialisation bias correction would lead to initial steps that are much larger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONVERGENCE ANALYSIS</head><p>We analyze the convergence of Adam using the online learning framework proposed in <ref type="bibr">(Zinkevich, 2003)</ref>. Given an arbitrary, unknown sequence of convex cost functions f 1 (θ), f 2 (θ),..., f T (θ). At each time t, our goal is to predict the parameter θ t and evaluate it on a previously unknown cost function f t . Since the nature of the sequence is unknown in advance, we evaluate our algorithm using the regret, that is the sum of all the previous difference between the online prediction f t (θ t ) and the best fixed point parameter f t (θ * ) from a feasible set X for all the previous steps. Concretely, the regret is defined as:</p><formula xml:id="formula_10">R(T ) = T t=1 [f t (θ t ) − f t (θ * )]<label>(5)</label></formula><p>where</p><formula xml:id="formula_11">θ * = arg min θ∈X T t=1 f t (θ).</formula><p>We show Adam has O( √ T ) regret bound and a proof is given in the appendix. Our result is comparable to the best known bound for this general convex online learning problem. We also use some definitions simplify our notation, where g t ∇f t (θ t ) and g t,i as the i th element. We define g 1:t,i ∈ R t as a vector that contains the i th dimension of the gradients over all iterations till t, g 1:</p><formula xml:id="formula_12">t,i = [g 1,i , g 2,i , • • • , g t,i ]. Also, we define γ β 2 1 √</formula><p>β2 . Our following theorem holds when the learning rate α t is decaying at a rate of t − 1 and first moment running average coefficient β 1,t decay exponentially with λ, that is typically close to 1, e.g. 1 − 10 −8 . Theorem 4.1. Assume that the function f t has bounded gradients, ∇f</p><formula xml:id="formula_13">t (θ) 2 ≤ G, ∇f t (θ) ∞ ≤ G ∞ for all θ ∈ R d and distance between any θ t generated by Adam is bounded, θ n − θ m 2 ≤ D, θ m − θ n ∞ ≤ D ∞ for any m, n ∈ {1, ..., T }, and β 1 , β 2 ∈ [0, 1) satisfy β 2 1 √ β2 &lt; 1. Let α t = α √ t</formula><p>and β 1,t = β 1 λ t−1 , λ ∈ (0, 1). Adam achieves the following guarantee, for all T ≥ 1.</p><formula xml:id="formula_14">R(T ) ≤ D 2 2α(1 − β 1 ) d i=1 T v T,i + α(1 + β 1 )G ∞ (1 − β 1 ) √ − β 2 (1 − γ) 2 d i=1 g 1:T,i 2 + d i=1 D 2 ∞ G ∞ √ − β 2 2α(1 − β 1 )(1 − λ) 2</formula><p>Our Theorem 4.1 implies when the data features are sparse and bounded gradients, the summation term can be much smaller than its upper bound</p><formula xml:id="formula_15">d i=1 g 1:T,i 2 &lt;&lt; dG ∞ √ T and d i=1 T v T,i &lt;&lt; dG ∞ √</formula><p>T , in particular if the class of function and data features are in the form of section 1.2 in <ref type="bibr" target="#b2">(Duchi et al., 2011)</ref>. Their results for the expected value E[ d i=1 g 1:T,i 2 ] also apply to Adam. In particular, the adaptive method, such as Adam and Adagrad, can achieve O(log d √ T ), an improvement over O( √ dT ) for the non-adaptive method. Decaying β 1,t towards zero is important in our theoretical analysis and also matches previous empirical findings, e.g. <ref type="bibr" target="#b18">(Sutskever et al., 2013)</ref> suggests reducing the momentum coefficient in the end of training can improve convergence.</p><p>Finally, we can show the average regret of Adam converges, Corollary 4.2. Assume that the function f t has bounded gradients, ∇f</p><formula xml:id="formula_16">t (θ) 2 ≤ G, ∇f t (θ) ∞ ≤ G ∞ for all θ ∈ R d and distance between any θ t generated by Adam is bounded, θ n − θ m 2 ≤ D, θ m − θ n ∞ ≤ D ∞ for any m, n ∈ {1, ..., T }.</formula><p>Adam achieves the following guarantee, for all T ≥ 1.</p><formula xml:id="formula_17">R(T ) T = O( 1 √ T )</formula><p>This result can be obtained by using Theorem 4.1 and</p><formula xml:id="formula_18">d i=1 g 1:T,i 2 ≤ dG ∞ √ T . Thus, lim T →∞ R(T ) T = 0.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATED WORK</head><p>Optimization methods bearing a direct relation to Adam are RMSProp <ref type="bibr" target="#b19">(Tieleman &amp; Hinton, 2012;</ref><ref type="bibr" target="#b3">Graves, 2013)</ref> and AdaGrad <ref type="bibr" target="#b2">(Duchi et al., 2011)</ref>; these relationships are discussed below. Other stochastic optimization methods include vSGD <ref type="bibr" target="#b16">(Schaul et al., 2012)</ref>, AdaDelta <ref type="bibr" target="#b21">(Zeiler, 2012)</ref> and the natural Newton method from <ref type="bibr" target="#b14">Roux &amp; Fitzgibbon (2010)</ref>, all setting stepsizes by estimating curvature from first-order information. The Sum-of-Functions Optimizer (SFO) (Sohl-Dickstein et al., 2014) is a quasi-Newton method based on minibatches, but (unlike Adam) has memory requirements linear in the number of minibatch partitions of a dataset, which is often infeasible on memory-constrained systems such as a GPU. Like natural gradient descent (NGD) <ref type="bibr" target="#b0">(Amari, 1998)</ref>, Adam employs a preconditioner that adapts to the geometry of the data, since v t is an approximation to the diagonal of the Fisher information matrix <ref type="bibr" target="#b12">(Pascanu &amp; Bengio, 2013)</ref>; however, Adam's preconditioner (like AdaGrad's) is more conservative in its adaption than vanilla NGD by preconditioning with the square root of the inverse of the diagonal Fisher information matrix approximation.</p><p>RMSProp: An optimization method closely related to Adam is RMSProp <ref type="bibr" target="#b19">(Tieleman &amp; Hinton, 2012)</ref>. A version with momentum has sometimes been used <ref type="bibr" target="#b3">(Graves, 2013)</ref>. There are a few important differences between RMSProp with momentum and Adam: RMSProp with momentum generates its parameter updates using a momentum on the rescaled gradient, whereas Adam updates are directly estimated using a running average of first and second moment of the gradient. RMSProp also lacks a bias-correction term; this matters most in case of a value of β 2 close to 1 (required in case of sparse gradients), since in that case not correcting the bias leads to very large stepsizes and often divergence, as we also empirically demonstrate in section 6.4.</p><p>AdaGrad: An algorithm that works well for sparse gradients is AdaGrad <ref type="bibr" target="#b2">(Duchi et al., 2011)</ref>. Its basic version updates parameters as</p><formula xml:id="formula_19">θ t+1 = θ t − α • g t / t i=1 g 2 t .</formula><p>Note that if we choose β 2 to be infinitesimally close to 1 from below, then lim</p><formula xml:id="formula_20">β2→1 v t = t −1 • t i=1 g 2 t .</formula><p>AdaGrad corresponds to a version of Adam with β 1 = 0, infinitesimal (1 − β 2 ) and a replacement of α by an annealed version</p><formula xml:id="formula_21">α t = α • t −1/2 , namely θ t − α • t −1/2 • m t / lim β2→1 v t = θ t − α • t −1/2 • g t / t −1 • t i=1 g 2 t = θ t − α • g t / t i=1 g 2 t .</formula><p>Note that this direct correspondence between Adam and Adagrad does not hold when removing the bias-correction terms; without bias correction, like in RMSProp, a β 2 infinitesimally close to 1 would lead to infinitely large bias, and infinitely large parameter updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTS</head><p>To empirically evaluate the proposed method, we investigated different popular machine learning models, including logistic regression, multilayer fully connected neural networks and deep convolutional neural networks. Using large models and datasets, we demonstrate Adam can efficiently solve practical deep learning problems.</p><p>We use the same parameter initialization when comparing different optimization algorithms. The hyper-parameters, such as learning rate and momentum, are searched over a dense grid and the results are reported using the best hyper-parameter setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">EXPERIMENT: LOGISTIC REGRESSION</head><p>We evaluate our proposed method on L2-regularized multi-class logistic regression using the MNIST dataset. Logistic regression has a well-studied convex objective, making it suitable for comparison of different optimizers without worrying about local minimum issues. The stepsize α in our logistic regression experiments is adjusted by 1/ √ t decay, namely α t = α √ t that matches with our theoratical prediction from section 4. The logistic regression classifies the class label directly on the 784 dimension image vectors. We compare Adam to accelerated SGD with Nesterov momentum and Adagrad using minibatch size of 128. According to <ref type="figure" target="#fig_0">Figure 1</ref>, we found that the Adam yields similar convergence as SGD with momentum and both converge faster than Adagrad.</p><p>As discussed in <ref type="bibr" target="#b2">(Duchi et al., 2011)</ref>, Adagrad can efficiently deal with sparse features and gradients as one of its main theoretical results whereas SGD is low at learning rare features. Adam with 1/ √ t decay on its stepsize should theoratically match the performance of Adagrad. We examine the sparse feature problem using IMDB movie review dataset from <ref type="bibr" target="#b10">(Maas et al., 2011)</ref>. We pre-process the IMDB movie reviews into bag-of-words (BoW) feature vectors including the first 10,000 most frequent words. The 10,000 dimension BoW feature vector for each review is highly sparse. As suggested in <ref type="bibr" target="#b20">(Wang &amp; Manning, 2013)</ref>, 50% dropout noise can be applied to the BoW features during training to prevent over-fitting. In figure 1, Adagrad outperforms SGD with Nesterov momentum by a large margin both with and without dropout noise. Adam converges as fast as Adagrad. The empirical performance of Adam is consistent with our theoretical findings in sections 2 and 4. Similar to Adagrad, Adam can take advantage of sparse features and obtain faster convergence rate than normal SGD with momentum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">EXPERIMENT: MULTI-LAYER NEURAL NETWORKS</head><p>Multi-layer neural network are powerful models with non-convex objective functions. Although our convergence analysis does not apply to non-convex problems, we empirically found that Adam often outperforms other methods in such cases. In our experiments, we made model choices that are consistent with previous publications in the area; a neural network model with two fully connected hidden layers with 1000 hidden units each and ReLU activation are used for this experiment with minibatch size of 128.</p><p>First, we study different optimizers using the standard deterministic cross-entropy objective function with L 2 weight decay on the parameters to prevent over-fitting. The sum-of-functions (SFO) method (Sohl-Dickstein et al., 2014) is a recently proposed quasi-Newton method that works with minibatches of data and has shown good performance on optimization of multi-layer neural networks. We used their implementation and compared with Adam to train such models. <ref type="figure">Figure 2</ref> shows that Adam makes faster progress in terms of both the number of iterations and wall-clock time. Due to the cost of updating curvature information, SFO is 5-10x slower per iteration compared to Adam, and has a memory requirement that is linear in the number minibatches.</p><p>Stochastic regularization methods, such as dropout, are an effective way to prevent over-fitting and often used in practice due to their simplicity. SFO assumes deterministic subfunctions, and indeed failed to converge on cost functions with stochastic regularization. We compare the effectiveness of Adam to other stochastic first order methods on multi-layer neural networks trained with dropout noise. <ref type="figure">Figure 2</ref> shows our results; Adam shows better convergence than other methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">EXPERIMENT: CONVOLUTIONAL NEURAL NETWORKS</head><p>Convolutional neural networks (CNNs) with several layers of convolution, pooling and non-linear units have shown considerable success in computer vision tasks. Unlike most fully connected neural nets, weight sharing in CNNs results in vastly different gradients in different layers. A smaller learning rate for the convolution layers is often used in practice when applying SGD. We show the effectiveness of Adam in deep CNNs. Our CNN architecture has three alternating stages of 5x5 convolution filters and 3x3 max pooling with stride of 2 that are followed by a fully connected layer of 1000 rectified linear hidden units (ReLU's). The input image are pre-processed by whitening, and  dropout noise is applied to the input layer and fully connected layer. The minibatch size is also set to 128 similar to previous experiments.</p><p>Interestingly, although both Adam and Adagrad make rapid progress lowering the cost in the initial stage of the training, shown in <ref type="figure">Figure 3</ref> (left), Adam and SGD eventually converge considerably faster than Adagrad for CNNs shown in <ref type="figure">Figure 3 (right)</ref>. We notice the second moment estimate v t vanishes to zeros after a few epochs and is dominated by the in algorithm 1. The second moment estimate is therefore a poor approximation to the geometry of the cost function in CNNs comparing to fully connected network from Section 6.2. Whereas, reducing the minibatch variance through the first moment is more important in CNNs and contributes to the speed-up. As a result, Adagrad converges much slower than others in this particular experiment. Though Adam shows marginal improvement over SGD with momentum, it adapts learning rate scale for different layers instead of hand picking manually as in SGD.  <ref type="figure">Figure 4</ref>: Effect of bias-correction terms (red line) versus no bias correction terms (green line) after 10 epochs (left) and 100 epochs (right) on the loss (y-axes) when learning a Variational Auto-Encoder (VAE) <ref type="bibr" target="#b8">(Kingma &amp; Welling, 2013)</ref>, for different settings of stepsize α (x-axes) and hyperparameters β 1 and β 2 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">EXPERIMENT: BIAS-CORRECTION TERM</head><p>We also empirically evaluate the effect of the bias correction terms explained in sections 2 and 3. Discussed in section 5, removal of the bias correction terms results in a version of RMSProp (Tieleman &amp; Hinton, 2012) with momentum. We vary the β 1 and β 2 when training a variational autoencoder (VAE) with the same architecture as in <ref type="bibr" target="#b8">(Kingma &amp; Welling, 2013</ref>) with a single hidden layer with 500 hidden units with softplus nonlinearities and a 50-dimensional spherical Gaussian latent variable. We iterated over a broad range of hyper-parameter choices, i.e. β 1 ∈ [0, 0.9] and β 2 ∈ [0.99, 0.999, 0.9999], and log 10 (α) ∈ [−5, ..., −1]. Values of β 2 close to 1, required for robustness to sparse gradients, results in larger initialization bias; therefore we expect the bias correction term is important in such cases of slow decay, preventing an adverse effect on optimization.</p><p>In <ref type="figure">Figure 4</ref>, values β 2 close to 1 indeed lead to instabilities in training when no bias correction term was present, especially at first few epochs of the training. The best results were achieved with small values of (1 − β 2 ) and bias correction; this was more apparent towards the end of optimization when gradients tends to become sparser as hidden units specialize to specific patterns. In summary, Adam performed equal or better than RMSProp, regardless of hyper-parameter setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXTENSIONS</head><p>7.1 ADAMAX In Adam, the update rule for individual weights is to scale their gradients inversely proportional to a (scaled) L 2 norm of their individual current and past gradients. We can generalize the L 2 norm based update rule to a L p norm based update rule. Such variants become numerically unstable for large p. However, in the special case where we let p → ∞, a surprisingly simple and stable algorithm emerges; see algorithm 2. We'll now derive the algorithm. Let, in case of the L p norm, the stepsize at time t be inversely proportional to v</p><formula xml:id="formula_22">1/p t , where: v t = β p 2 v t−1 + (1 − β p 2 )|g t | p (6) = (1 − β p 2 ) t i=1 β p(t−i) 2 • |g i | p<label>(7)</label></formula><p>Algorithm 2: AdaMax, a variant of Adam based on the infinity norm. See section 7.1 for details.</p><p>Good default settings for the tested machine learning problems are α = 0.002, β 1 = 0.9 and β 2 = 0.999. With β t 1 we denote β 1 to the power t. Here, (α/(1 − β t 1 )) is the learning rate with the bias-correction term for the first moment. All operations on vectors are element-wise. Require: α: Stepsize Require: β 1 , β 2 ∈ [0, 1): Exponential decay rates Require: f (θ): Stochastic objective function with parameters θ Require: θ 0 : Initial parameter vector m 0 ← 0 (Initialize 1 st moment vector) u 0 ← 0 (Initialize the exponentially weighted infinity norm) t ← 0 (Initialize timestep) while θ t not converged do</p><formula xml:id="formula_23">t ← t + 1 g t ← ∇ θ f t (θ t−1 ) (Get gradients w.r.t. stochastic objective at timestep t) m t ← β 1 • m t−1 + (1 − β 1 ) • g t (Update biased first moment estimate) u t ← max(β 2 • u t−1 , |g t |) (Update the exponentially weighted infinity norm) θ t ← θ t−1 − (α/(1 − β t 1 )) • m t /u t (Update parameters) end while return θ t (Resulting parameters)</formula><p>Note that the decay term is here equivalently parameterised as β p 2 instead of β 2 . Now let p → ∞, and define u t = lim p→∞ (v t ) 1/p , then:</p><formula xml:id="formula_24">u t = lim p→∞ (v t ) 1/p = lim p→∞ (1 − β p 2 ) t i=1 β p(t−i) • |g i | p 1/p (8) = lim p→∞ (1 − β p 2 ) 1/p t i=1 β p(t−i) 2 • |g i | p 1/p (9) = lim p→∞ t i=1 β (t−i) 2 • |g i | p 1/p (10) = max β t−1 2 |g 1 |, β t−2 2 |g 2 |, . . . , β 2 |g t−1 |, |g t |<label>(11)</label></formula><p>Which corresponds to the remarkably simple recursive formula:</p><formula xml:id="formula_25">u t = max(β 2 • u t−1 , |g t |)<label>(12)</label></formula><p>with initial value u 0 = 0. Note that, conveniently enough, we don't need to correct for initialization bias in this case. Also note that the magnitude of parameter updates has a simpler bound with AdaMax than Adam, namely: |∆ t | ≤ α.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">TEMPORAL AVERAGING</head><p>Since the last iterate is noisy due to stochastic approximation, better generalization performance is often achieved by averaging. Previously in Moulines &amp; Bach (2011), Polyak-Ruppert averaging <ref type="bibr" target="#b13">(Polyak &amp; Juditsky, 1992;</ref><ref type="bibr" target="#b15">Ruppert, 1988)</ref> has been shown to improve the convergence of standard SGD, whereθ t = 1 t n k=1 θ k . Alternatively, an exponential moving average over the parameters can be used, giving higher weight to more recent parameter values. This can be trivially implemented by adding one line to the inner loop of algorithms 1 and 2:θ t ← β 2 •θ t−1 + (1 − β 2 )θ t , withθ 0 = 0. Initalization bias can again be corrected by the estimator θ t =θ t /(1 − β t 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We have introduced a simple and computationally efficient algorithm for gradient-based optimization of stochastic objective functions. Our method is aimed towards machine learning problems with large datasets and/or high-dimensional parameter spaces. The method combines the advantages of two recently popular optimization methods: the ability of AdaGrad to deal with sparse gradients, and the ability of RMSProp to deal with non-stationary objectives. The method is straightforward to implement and requires little memory. The experiments confirm the analysis on the rate of convergence in convex problems. Overall, we found Adam to be robust and well-suited to a wide range of non-convex optimization problems in the field machine learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">ACKNOWLEDGMENTS</head><p>This paper would probably not have existed without the support of Google Deepmind. We would like to give special thanks to Ivo Danihelka, and Tom Schaul for coining the name Adam. Thanks to Kai Fan from Duke University for spotting an error in the original AdaMax derivation. Experiments in this work were partly carried out on the Dutch national e-infrastructure with the support of SURF Foundation. Diederik Kingma is supported by the Google European Doctorate Fellowship in Deep Learning.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">APPENDIX</head><p>10.1 CONVERGENCE PROOF Definition 10.1. A function f :</p><formula xml:id="formula_26">R d → R is convex if for all x, y ∈ R d , for all λ ∈ [0, 1], λf (x) + (1 − λ)f (y) ≥ f (λx + (1 − λ)y)</formula><p>Also, notice that a convex function can be lower bounded by a hyperplane at its tangent. Lemma 10.2. If a function f :</p><formula xml:id="formula_27">R d → R is convex, then for all x, y ∈ R d , f (y) ≥ f (x) + ∇f (x) T (y − x)</formula><p>The above lemma can be used to upper bound the regret and our proof for the main theorem is constructed by substituting the hyperplane with the Adam update rules.</p><p>The following two lemmas are used to support our main theorem. We also use some definitions simplify our notation, where g t ∇f t (θ t ) and g t,i as the i th element. We define g 1:t,i ∈ R t as a vector that contains the i th dimension of the gradients over all iterations till t, g 1:</p><formula xml:id="formula_28">t,i = [g 1,i , g 2,i , • • • , g t,i ]</formula><p>Lemma 10.3. Let g t = ∇f t (θ t ) and g 1:t be defined as above and bounded, g</p><formula xml:id="formula_29">t 2 ≤ G, g t ∞ ≤ G ∞ . Then, T t=1 g 2 t,i t ≤ 2G ∞ g 1:T,i 2</formula><p>Proof. We will prove the inequality using induction over T.</p><p>The base case for T = 1, we have g 1,i ≤ 2G ∞ g 1,i 2 . For the inductive step,</p><formula xml:id="formula_30">T t=1 g 2 t,i t = T −1 t=1 g 2 t,i t + g 2 T,i T ≤ 2G ∞ g 1:T −1,i 2 + g 2 T,i T = 2G ∞ g 1:T,i 2 2 − g 2 T + g 2 T,i T From, g 1:T,i 2 2 − g 2 T,i + g 4 T ,i g1:T,i 2 2 ≥ g 1:T,i 2 2 − g 2</formula><p>T,i , we can take square root of both side and have,</p><formula xml:id="formula_31">g 1:T,i 2 2 − g 2 T,i ≤ g 1:T,i 2 − g 2 T,i g 1:T,i 2 ≤ g 1:T,i 2 − g 2 T,i T G 2 ∞</formula><p>Rearrange the inequality and substitute the g 1:T,i 2 2 − g 2 T,i term,</p><formula xml:id="formula_32">G ∞ g 1:T,i 2 2 − g 2 T + g 2 T,i T ≤ 2G ∞ g 1:T,i 2</formula><p>Published as a conference paper at ICLR 2015</p><formula xml:id="formula_33">Lemma 10.4. Let γ β 2 1 √ β2 . For β 1 , β 2 ∈ [0, 1) that satisfy β 2 1 √ β2 &lt; 1 and bounded g t , g t 2 ≤ G, g t ∞ ≤ G ∞ , the following inequality holds T t=1 m 2 t,i t v t,i ≤ 1 − γ 1 √ 1 − β 2 g 1:T,i 2</formula><p>Proof. Under the assumption, √</p><formula xml:id="formula_34">1−β t 2 (1−β t 1 ) 2 ≤ 1</formula><p>(1−β1) 2 . We can expand the last term in the summation using the update rules in Algorithm 1,</p><formula xml:id="formula_35">T t=1 m 2 t,i t v t,i = T −1 t=1 m 2 t,i t v t,i + 1 − β T 2 (1 − β T 1 ) 2 ( T k=1 (1 − β 1 )β T −k 1 g k,i ) 2 T T j=1 (1 − β 2 )β T −j 2 g 2 j,i ≤ T −1 t=1 m 2 t,i t v t,i + 1 − β T 2 (1 − β T 1 ) 2 T k=1 T ((1 − β 1 )β T −k 1 g k,i ) 2 T T j=1 (1 − β 2 )β T −j 2 g 2 j,i ≤ T −1 t=1 m 2 t,i t v t,i + 1 − β T 2 (1 − β T 1 ) 2 T k=1 T ((1 − β 1 )β T −k 1 g k,i ) 2 T (1 − β 2 )β T −k 2 g 2 k,i ≤ T −1 t=1 m 2 t,i t v t,i + 1 − β T 2 (1 − β T 1 ) 2 (1 − β 1 ) 2 T (1 − β 2 ) T k=1 T β 2 1 √ β 2 T −k g k,i 2 ≤ T −1 t=1 m 2 t,i t v t,i + T T (1 − β 2 ) T k=1 γ T −k g k,i 2</formula><p>Similarly, we can upper bound the rest of the terms in the summation.</p><formula xml:id="formula_36">T t=1 m 2 t,i t v t,i ≤ T t=1 g t,i 2 t(1 − β 2 ) T −t j=0 tγ j ≤ T t=1 g t,i 2 t(1 − β 2 ) T j=0 tγ j</formula><p>For γ &lt; 1, using the upper bound on the arithmetic-geometric series, t tγ t &lt; 1 (1−γ) 2 :</p><formula xml:id="formula_37">T t=1 g t,i 2 t(1 − β 2 ) T j=0 tγ j ≤ 1 (1 − γ) 2 √ − β 2 T t=1 g t,i 2 √ t Apply Lemma 10.3, T t=1 m 2 t,i t v t,i ≤ 2G ∞ (1 − γ) 2 √ − β 2 g 1:T,i 2</formula><p>To simplify the notation, we define γ</p><formula xml:id="formula_38">β 2 1 √</formula><p>β2 . Intuitively, our following theorem holds when the learning rate α t is decaying at a rate of t − 1 2 and first moment running average coefficient β 1,t decay exponentially with λ, that is typically close to 1, e.g. 1 − 10 −8 . Theorem 10.5. Assume that the function f t has bounded gradients, ∇f t (θ) 2 ≤ G, ∇f t (θ) ∞ ≤ G ∞ for all θ ∈ R d and distance between any θ t generated by Adam is bounded, θ n − θ m 2 ≤ D, θ m − θ n ∞ ≤ D ∞ for any m, n ∈ {1, ..., T }, and β 1 , β 2 ∈ [0, 1) satisfy</p><formula xml:id="formula_39">β 2 1 √ β2 &lt; 1. Let α t = α √ t</formula><p>and β 1,t = β 1 λ t−1 , λ ∈ (0, 1). Adam achieves the following guarantee, for all T ≥ 1.</p><formula xml:id="formula_40">R(T ) ≤ D 2 2α(1 − β 1 ) d i=1 T v T,i + α(β 1 + 1)G ∞ (1 − β 1 ) √ − β 2 (1 − γ) 2 d i=1 g 1:T,i 2 + d i=1 D 2 ∞ G ∞ √ − β 2 2α(1 − β 1 )(1 − λ) 2</formula><p>Proof. Using Lemma 10.2, we have,</p><formula xml:id="formula_41">f t (θ t ) − f t (θ * ) ≤ g T t (θ t − θ * ) = d i=1 g t,i (θ t,i − θ * ,i )</formula><p>From the update rules presented in algorithm 1,</p><formula xml:id="formula_42">θ t+1 = θ t − α t m t / v t = θ t − α t − β t 1 β 1,t √ v t m t−1 + (1 − β 1,t ) √ v t g t</formula><p>We focus on the i th dimension of the parameter vector θ t ∈ R d . Subtract the scalar θ * ,i and square both sides of the above update rule, we have,</p><formula xml:id="formula_43">(θ t+1,i − θ * ,i ) 2 =(θ t,i − θ * ,i ) 2 − 2α t − β t 1 ( β 1,t v t,i m t−1,i + (1 − β 1,t ) v t,i g t,i )(θ t,i − θ * ,i ) + α 2 t ( m t,i v t,i ) 2</formula><p>We can rearrange the above equation and use Young's inequality, ab ≤ a 2 /2 + b 2 /2. Also, it can be shown that v t,i = t j=1 (1 − β 2 )β t−j 2 g 2 j,i / 1 − β t 2 ≤ g 1:t,i 2 and β 1,t ≤ β 1 . Then</p><formula xml:id="formula_44">g t,i (θ t,i − θ * ,i ) = (1 − β t 1 ) v t,i 2α t (1 − β 1,t ) (θ t,i − θ * ,t ) 2 − (θ t+1,i − θ * ,i ) 2 + β 1,t (1 − β 1,t ) v 1 t−1,i √ α t−1 (θ * ,i − θ t,i ) √ α t−1 m t−1,i v 1 t−1,i + α t (1 − β t 1 ) v t,i 2(1 − β 1,t ) ( m t,i v t,i ) 2 ≤ 1 2α t (1 − β 1 ) (θ t,i − θ * ,t ) 2 − (θ t+1,i − θ * ,i ) 2 v t,i + β 1,t 2α t−1 (1 − β 1,t ) (θ * ,i − θ t,i ) 2 v t−1,i + β 1 α t−1 2(1 − β 1 ) m 2 t−1,i v t−1,i + α t 2(1 − β 1 ) m 2 t,i v t,i</formula><p>We apply Lemma 10.4 to the above inequality and derive the regret bound by summing across all the dimensions for i ∈ 1, ..., d in the upper bound of f t (θ t ) − f t (θ * ) and the sequence of convex functions for t ∈ 1, ..., T :</p><formula xml:id="formula_45">R(T ) ≤ d i=1 1 2α 1 (1 − β 1 ) (θ 1,i − θ * ,i ) 2 v 1,i + d i=1 T t=2 1 2(1 − β 1 ) (θ t,i − θ * ,i ) 2 ( v t,i α t − v t−1,i α t−1 ) + β 1 αG ∞ (1 − β 1 ) √ 1 − β 2 (1 − γ) 2 d i=1 g 1:T,i 2 + αG ∞ (1 − β 1 ) √ 1 − β 2 (1 − γ) 2 d i=1 g 1:T,i 2 + d i=1 T t=1 β 1,t 2α t (1 − β 1,t ) (θ * ,i − θ t,i ) 2 v t,i</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Logistic regression training negative log likelihood on MNIST images and IMDB movie reviews with 10,000 bag-of-words (BoW) feature vectors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :Figure 3 :</head><label>23</label><figDesc>Training of multilayer neural networks on MNIST images. (a) Neural networks using dropout stochastic regularization. (b) Neural networks with deterministic cost function. We compare with the sum-of-functions (SFO) optimizer (Sohl-Dickstein et al., 2014) Convolutional neural networks training cost. (left) Training cost for the first three epochs. (right) Training cost over 45 epochs. CIFAR-10 with c64-c64-c128-1000 architecture.</figDesc></figure>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>From the assumption, θ t − θ * 2 ≤ D, θ m − θ n ∞ ≤ D ∞ , we have:</p><p>We can use arithmetic geometric series upper bound for the last term:</p><p>Therefore, we have the following regret bound:</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Natural gradient works efficiently in learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Amari</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shun-Ichi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="251" to="276" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Recent advances in deep learning for speech research at microsoft</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jinyu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jui-Ting</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kaisheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Seide</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Seltzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zweig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Geoff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Xiaodong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Adaptive subgradient methods for online learning and stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Duchi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elad</forename><surname>Hazan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoram</forename><surname>Singer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="2121" to="2159" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Generating sequences with recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Graves</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1308.0850</idno>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Speech recognition with deep recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohamed</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2013 IEEE International Conference on</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="6645" to="6649" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reducing the dimensionality of data with neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Salakhutdinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">313</biblScope>
			<biblScope unit="issue">5786</biblScope>
			<biblScope unit="page" from="504" to="507" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Deep neural networks for acoustic modeling in speech recognition: The shared views of four research groups</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><forename type="middle">E</forename><surname>Dahl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mohamed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jaitly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Navdeep</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Senior</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vanhoucke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Patrick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tara</forename><forename type="middle">N</forename><surname>Sainath</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Signal Processing Magazine</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="82" to="97" />
			<date type="published" when="2012" />
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Improving neural networks by preventing co-adaptation of feature detectors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nitish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Salakhutdinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ruslan</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1207.0580</idno>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Auto-Encoding Variational Bayes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Diederik</forename><forename type="middle">P</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Max</forename><surname>Welling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 2nd International Conference on Learning Representations (ICLR)</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Imagenet classification with deep convolutional neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in neural information processing systems</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1097" to="1105" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Learning word vectors for sentiment analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">L</forename><surname>Maas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">E</forename><surname>Daly</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">T</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Potts</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2011" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="142" to="150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Non-asymptotic analysis of stochastic approximation algorithms for machine learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Moulines</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francis</forename><forename type="middle">R</forename><surname>Bach</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="451" to="459" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Revisiting natural gradient for deep networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Razvan</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1301.3584</idno>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Acceleration of stochastic approximation by averaging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Boris</forename><forename type="middle">T</forename><surname>Polyak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Juditsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Anatoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Control and Optimization</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="838" to="855" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A fast natural newton method</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><forename type="middle">L</forename><surname>Roux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">W</forename><surname>Fitzgibbon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th International Conference on Machine Learning (ICML-10)</title>
		<meeting>the 27th International Conference on Machine Learning (ICML-10)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="623" to="630" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Efficient estimations from a slowly convergent robbins-monro process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Ruppert</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
		</imprint>
		<respStmt>
			<orgName>Cornell University Operations Research and Industrial Engineering</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Schaul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sixin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1206.1106</idno>
		<title level="m">No more pesky learning rates</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fast large-scale optimization by unifying stochastic gradient and quasi-newton methods</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sohl-Dickstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Jascha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Poole</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ganguli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Surya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st International Conference on Machine Learning (ICML-14)</title>
		<meeting>the 31st International Conference on Machine Learning (ICML-14)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="604" to="612" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the importance of initialization and momentum in deep learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ilya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Martens</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>James</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Dahl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><surname>Hinton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th International Conference on Machine Learning (ICML-13)</title>
		<meeting>the 30th International Conference on Machine Learning (ICML-13)</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1139" to="1147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Lecture 6.5 -RMSProp, COURSERA: Neural Networks for Machine Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tieleman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Hinton</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Fast dropout training</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sida</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th International Conference on Machine Learning (ICML-13)</title>
		<meeting>the 30th International Conference on Machine Learning (ICML-13)</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="118" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Zinkevich, Martin. Online convex programming and generalized infinitesimal gradient ascent</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><forename type="middle">D</forename><surname>Zeiler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Adadelta</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1212.5701</idno>
	</analytic>
	<monogr>
		<title level="m">An adaptive learning rate method</title>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
