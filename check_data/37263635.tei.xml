<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Church&apos;s Thesis and Functional Programming</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Turner</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Middlesex University</orgName>
								<address>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Church&apos;s Thesis and Functional Programming</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The earliest statement of Church&apos;s Thesis, from Church (1936) p356 is We now define the notion, already discussed, of an effectively calculable function of positive integers by identifying it with the notion of a recursive function of positive integers (or of a lambdadefinable function of positive integers).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>The phrase in parentheses refers to the apparatus which Church had developed to investigate this and other problems in the foundations of mathematics: the calculus of lambda conversion. Both the Thesis and the lambda calculus have been of seminal influence on the development of Computing Science. The main subject of this article is the lambda calculus but I will begin with a brief sketch of the emergence of the Thesis.</p><p>The epistemological status of Church's Thesis is not immediately clear from the above quotation and remains a matter of debate, as is explored in other papers of this volume. My own view, which I will state but not elaborate here, is that the thesis is empirical because it relies for its significance on a claim about what can be calculated by mechanisms. This becomes clearer in Church's restatement of the thesis the following year, after he had seen Turing's paper, see below. For a fuller discussion see <ref type="bibr">Hodges (this volume)</ref>.</p><p>Three definitions of the effectively computable functions of the natural numbers (non-negative integers, hereafter N ), developed nearly contemporaneously in the early to mid 1930's, turned out to be equivalent. <ref type="bibr">Church (1936, quoted above)</ref> showed that his own theory of lambda definable functions yielded the same functions on N k → N as the recursive functions of Herbrand and Gödel <ref type="bibr" target="#b14">[Herbrand 1932</ref><ref type="bibr">, Gödel 1934</ref>. This was proved independently by <ref type="bibr" target="#b19">Kleene (1936)</ref>.</p><p>A few months later <ref type="bibr" target="#b38">Turing (1936)</ref> introduced his concept of logical computing machine (LCM) -a finite automaton with an unbounded tape divided into squares, on which it could move left or right and read or write symbols from a finite alphabet, in accordance with a specified state transition table. A central result of the paper is the existence of a universal LCM, which can emulate the behaviour of any LCM whose description is written on its tape. In an appendix Turing shows that the numeric functions computable by his machines coincide with the lambda-definable ones.</p><p>In his review of <ref type="bibr">Turing's paper, Church (1937)</ref> writes there is involved here the equivalence of three different notions: computability by a Turing machine, general recursiveness . . . and lambdadefinability . . . The first has the advantage of making the identification with effectiveness in the ordinary sense evident immediately . . . The second and third have the advantage of suitability for embodiment in a system of symbolic logic.</p><p>The Turing machine led, about a decade later, to the Turing/von-Neumann computer -a realization in electronics of Turing's universal machine, with the important optimization that (an initial portion of) the tape is replaced by a random access store. The concept of a programming language didn't yet exist in 1936, but the second and third notions were eventually to provide the basis of what we now know as functional programming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">The Halting Theorem</head><p>All three notions of computability involve partiality in an essential way. General recursion schemas yield the partial recursive functions, which may for some values of their arguments fail to produce a result. We will write their type as N k → N . We have N = N ∪ {⊥} where the undefined value ⊥ represents non-termination 1 . The recursive functions are the subset that are everywhere defined. That this subset is not recursively enumerable is shown by a use of Cantor's diagonalization argument . Since the partial recursive functions are recursively enumerable it follows that the property of being total (for a partial recursive function) is not recursively decidable.</p><p>By a separate argument it can be shown that the property for a partial recursive function of being defined at a specified value of its input vector is also not in general recursively decidable. Similarly, Turing machines may not halt and lambda-terms may have no normal form; and these properties are not, respectively, Turing-computable or lambda-definable, as is shown in each case by a simple argument involving self-application.</p><p>Thus of perhaps equal importance with Church's Thesis and which emerges from it is the Halting Theorem: given an arbitrary computation whose result is of type N we cannot in general decide if it is ⊥. What is actually proven, e.g. of the halts predicate on Turing machines, is that it is not <ref type="bibr">Turing-computable</ref> The idea of treating non-termination as a peculiar kind of value, ⊥, is more recent and was not current at the time of Church and Turing's foundational work.</p><p>2 The proof is purely constructive and doesn't depend on Church's Thesis: any effective enumeration, h, of computable functions in N → N is incomplete -it lacks f (n) = h(n)(n)+1.</p><p>(equiv not lambda-definable etc). It is by an appeal to Church's Thesis that we pass from this to the assertion that halting is not effectively decidable.</p><p>The three convergent notions (to which others have since been added) identify an apparently unique, effectively enumerable, class of functions of type N k → N corresponding to what is computable by finite but unbounded means. Church's identification of this class with effective calculability amounts to the conjecture that this is the best we can do.</p><p>In the case of the Turing machine the unbounded element is the tape (it is initially blank, save for a finite segment but provides an unlimited working store). In the case of the lambda calculus it is the fact that there is no limit to the intermediate size to which a term may grow during the course of its attempted reduction to normal form. In the case of recursive functions it is the minimalization operation, which searches for the smallest n N on which a specified recursive function takes the value 0.</p><p>The Halting Theorem tells us that unboundedness of the kind needed for computational completeness is effectively inseparable from the possibility of nontermination.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Lambda Calculus</head><p>Of the various convergent notions of computability Church's lambda calculus is distinguished by its combination of simplicity with remarkable expressive power.</p><p>The lambda calculus was conceived as part of a larger theory, including logical operators such as implication, intended as an alternative foundation for mathematics based on functions rather than sets. This gave rise to paradoxes, including a version of the Russell paradox. What remained with the propositional part stripped out is a consistent theory of pure functions, of which the first systematic exposition is <ref type="bibr" target="#b4">Church (1941)</ref> 3 .</p><p>In the sketch given here we use for variables lower case letters: a, b, c • • • x, y, z and as metavariables denoting terms upper case letters: A, B, C • • •. The abstract syntax of the lambda calculus has three productions. A term is one of variable e.g. x application AB abstraction λx.A</p><p>In the last case λx. is a binder and free occurrences of x in A become bound . A term in which all variables are bound is said to be closed otherwise it is open. The motivating idea is that closed term represent functions. The intended meaning of AB is the application of function A to argument B while λx.A is the function which for input x returns A. Terms which are the same except for renaming of bound variables are not distinguished, thus λx.x and λy.y are the same, identity function.</p><p>In his monograph Church defines two slightly differing calculi called λI and λK, of these λK is now regarded as canonical and is what we sketch here.</p><p>In writing terms we freely use parentheses to remove ambiguity. We further adopt the conventions that application is left-associative and that the scope of a binder extends as far to the right as possible. For example f g h means (f g)h and λx.λy.Ba means λx.(λy.(Ba)).</p><p>The calculus has only one essential rule, which shows how to substitute an argument into the body of a function: In general there are many ways of reducing a term, since it or one of its reducts may contain multiple redexes. The normal order theorem gives a sequential procedure, normal order reduction, which is guaranteed to reach the normal form if there is one. Note that normal order reduction substitutes arguments into function bodies without first reducing any redexes inside the argument, which amounts to lazy evaluation.</p><formula xml:id="formula_0">(β) (λx.A)B → β [B/x]A</formula><p>A closed term of pure 6 λ-calculus is called a combinator . Note that any normalizing closed term of pure λ-calculus must reduce to an abstraction. Some combinators with their conventional names are:</p><formula xml:id="formula_1">S = λx.λy.λz.xz(yz) K = λx.λy.x I = λx.x B = λx.λy.λz.x(yz) C = λx.λy.λz.xzy</formula><p>It is evident that λ-calculus has a rich collection of functions, including functions of higher type, that is whose arguments and/or results are functions, but since (at least closed) terms can denote only functions and never ground objects it remains to show how to represent data such as the natural numbers. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>etc. • • •</head><p>To understand this representation for numbers note the effect of applying a Church numeral to function f and object a:</p><formula xml:id="formula_2">0f a ⇔ a 1f a ⇔ f a 2f a ⇔ f (f a) 3f a ⇔ f (f (f a))</formula><p>The numbers are thus represented as iterators. It is now straightforward to define the arithmetic operations, for example + = λm.λn.λa.λb.ma(nab) × = λm.λn.λa.λb.m(na)b predecessor and subtraction are a little trickier, see <ref type="bibr" target="#b4">Church (1941)</ref>. We also need a way to branch on 0:</p><formula xml:id="formula_3">zero = λa.λb.λn.n(Kb)a</formula><p>We have</p><formula xml:id="formula_4">zero A B N ⇔ A, N ⇔ 0 ⇔ B, N ⇔ n + 1</formula><p>The master-stroke, which shows every recursive function to be λ-definable is to find a universal fixpoint operator, that is a term Y with the property that for any term F ,</p><formula xml:id="formula_5">Y F ⇔ F (Y F )</formula><p>There are many such terms, of which the simplest is due to H.B.Curry.</p><formula xml:id="formula_6">Y = λf.(λx.f (xx))(λx.f (xx))</formula><p>The reader may satisfy himself that we have Y F ⇔ F (Y F ) as required.</p><p>The beauty of λ-definability as a theory of computation is that it gives not only -assuming Church's Thesis -all computable functions of type N → N but also those of higher type of any finite degree, such as (</p><formula xml:id="formula_7">N → N ) → N , (N → N ) → (N → N ) and so on.</formula><p>Moreover we are not limited to arithmetic. The idea behind the Church numerals is very general and allows any data type -pairs, lists, trees and so on -to be represented in a purely functional way. Each datum is encoded as a function that captures its elimination operation, that is the way in which information is extracted from it during computation. It is also possible to represent codata, such as infinite lists, infinitary trees and so on.</p><p>Part of the simplicity of the calculus lies in its considering only functions of a single argument. This is no real restriction since it is a basic result of set theory that for any sets A, B, the function spaces (A × B) → C and A → (B → C) are isomorphic. Replacing the first by the second is called Currying 7 . We have made implicit use of this idea all along, e.g. + is curried addition.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Solvability and non-strictness</head><p>A non-normalizing term is by no means necessarily useless. An example is Y , which has no normal form but can produce one when applied to another term. On the other hand (λx.xx)(λx.xx) is irredeemable -there is no term and no sequence of terms to which it can be applied and yield a normal form.</p><p>Definition: a term T is SOLVABLE if there are terms A , An important result, due to Corrado Böhm, is that a term is solvable if and only if it can be reduced to head normal form:</p><formula xml:id="formula_8">• • • , A k for some k ≥ 0 such that T A 1 • • • A k is</formula><formula xml:id="formula_9">λx 1 • • • λx n .x k A 1 • • • A m 7</formula><p>After H.B.Curry, although the idea was first used in <ref type="bibr" target="#b32">Schönfinkel (1924)</ref>.</p><p>the variable x k is called the head and if the term is closed must be one of the</p><formula xml:id="formula_10">x 1 • • • x n .</formula><p>If a term is solvable normal order reduction will reduce it to HNF in a finite number of steps. See <ref type="bibr">Barendregt (1984)</ref>.</p><p>All unsolvable terms are equally useless, so we can think of them as being equivalent and introduce a special term ⊥ to represent them. This gives us an extension of ⇔ for which we will use ≡. The two fundamental properties of ⊥, which follow from the definitions of unsolvability and head normal form, are:</p><formula xml:id="formula_11">⊥ A ≡ ⊥ (1) λx.⊥ ≡ ⊥<label>(2)</label></formula><p>Introducing ⊥ allows an ordering relation to be defined on terms with ⊥ as least element and a stronger equivalence relation using limits which is studied in domain theory (see later). We make one further remark here. Definition: a term A is STRICT if</p><formula xml:id="formula_12">A ⊥ ≡ ⊥</formula><p>and non-strict otherwise. A strict function thus has ⊥ for a fixpoint and applying Y to it will produce ⊥. So non-strict functions play an essential role in the theory of λ-definability -without them we could not use Y to encode recursion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Combinatory Logic</head><p>Closely related to λ-calculus is combinatory logic, originally due to <ref type="bibr" target="#b32">Schönfinkel (1924)</ref> and subsequently explored by H.B.Curry. This has meagre apparatus indeed -just application and a small collection of named combinators. These are defined by stating their reduction rule. In the minimal version we have two combinators, defined as follows</p><formula xml:id="formula_13">S x y z ⇒ x z(y z) K x y ⇒ x</formula><p>here x, y, z are metavariables standing for arbitrary terms and are used to state the reduction rules. Combinatory logic terms have no variables and are built using only constants and application:, e.g. K(SKK). A central result, perhaps one of the strangest in all of logic, is that every λ-definable function can be written using only S and K. Here is a start</p><formula xml:id="formula_14">I = SKK</formula><p>The proof is by considering application to an arbitrary term. We have</p><formula xml:id="formula_15">SKKx ⇒ Kx(Kx) ⇒ x as required.</formula><p>The definitive study of combinatory logic and its relationship to lambda calculus is <ref type="bibr">Curry &amp; Feys (1958)</ref>. There are several algorithms for transcribing λ-terms to combinators and for convenience most of these use besides S, K, additional combinators such as B, C, I etc.</p><p>It would seem that only a dedicated cryptologist would choose to write other than very small programs directly in combinatory logic. However, <ref type="bibr" target="#b40">Turner (1979a)</ref> describes compilation to combinators as an implementation method for a high-level functional programming language. This required finding a translation algorithm, described in <ref type="bibr" target="#b41">Turner (1979b)</ref>, that produces compact combinator code when translating expressions containing many nested λ-abstractions. The attraction of the method is that combinator reduction rules are much simpler than β-reduction, each requiring only a few machine instructions, allowing a fast interpreter to be constructed which carries out normal order reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The paradox</head><p>It is easy to see why the original versions of λ-calculus and combinatory logic, which included properly logical notions, led to paradoxes. (Curry calls these theories illative.) The untyped theory is too powerful, because of the fixpoint combinator, Y . Suppose N is a term denoting logical negation. We have</p><formula xml:id="formula_16">Y N ⇔ N (Y N )</formula><p>which is the Russell paradox. Even minimal logic, which lacks negation, becomes inconsistent in the presence of Y -implication is sufficient to generate the paradox, see <ref type="bibr">Barendregt (1984)</ref> p575. Because of this Y is sometimes called Curry's paradoxical combinator .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Typed λ-calculi</head><p>The λ-calculus of <ref type="bibr" target="#b4">Church (1941)</ref> is untyped : it allows the promiscuous application of any term to any other, so types arise only in the interpretation of terms. In a typed λ-calculus the rules of term formation embody some theory of types. Only terms which are well-typed according to the theory are permitted. The rules for β reduction remain unchanged, as does the Church-Rosser Theorem. Most type systems disallow self-application, as in (λx.xx), preventing the formation of a fixpoint combinator like Curry's Y . Typed λ-calculi fall into two main groups depending on what is done about this (i) Add an explicit fixpoint construction to the calculus -for example a polymorphic constant Y of type schema (α → α) → α, with reduction rule Y H ⇒ H(Y H). This allows general recursion at every type and thus retains the computational completeness of untyped λ.</p><p>(ii) In the other kind of typed λ-calculus there is no fixpoint construct and every term is normalizing. This brings into play a fundamental isomorphism between programming and logic: the Propositions-as-Types principle.</p><p>This gives two apparently very different models of functional programming, which we discuss in the next two sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Lazy Functional Programming</head><p>Imperative programming languages, from the earliest such as FORTRAN and COBOL which emerged in the 1950's to current "object-oriented" ones such as C++ and Java have certain features in common. Their basic action is the assignment command, which changes the content of a location in memory and they have an explicit flow of control by which these state changes are ordered. This reflects more or less directly the structure of the Turing/von Neumann computer, as a central processing unit operating on a passive store. Backus (1978) calls them "von Neumann languages". Functional 8 programming languages offer a radical alternative -they are descriptive rather than imperative, have no assignment command and no explicit flow of control -sub-computations are ordered only partially, by data dependency.</p><p>The claimed merits of functional programming -in conciseness, mathematical tractability, potential for parallel execution -have been argued in many places so we will not dwell on them here. Nor will we go into the history of the concept, other than to say that the basic ideas go back over four decades, see in particular the important early papers of <ref type="bibr" target="#b21">McCarthy (1960)</ref>, <ref type="bibr" target="#b20">Landin (1966)</ref> -and that for a long period functional programming was mainly practised in imperative languages with functional subsets (LISP, Scheme, Standard ML).</p><p>The disadvantages of functional programming within a language that includes imperative features are two. First, you are not forced to explore the limits of the functional style, since you can escape at will into an imperative idiom. Second, the presence of side effects, exceptions etc., even if they are rarely used , invalidate important theorems on which the benefits of the style rest.</p><p>The λ-calculus is the most natural candidate for functional programming: it is computationally complete in the sense of Church's Thesis, it includes functions of higher type and it comes with a theory of λ-conversion that provides a basis for reasoning about program transformation, correctness of evaluation mechanisms and so on. The notation is a little spartan for most tastes but it was shown long ago by Peter Landin that the dish can be sweetened by adding a sprinkling of syntactic sugar .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Efficient Normal Order Reduction</head><p>The Normal Order Theorem tells us that an implementation of λ-calculus on a sequential machine should use normal order reduction , otherwise it may fail to find the normal form of a normalizing term. This requires that arguments be substituted unevaluated into function bodies as we noted earlier. In general this will produce multiple copies of the argument, requiring any redexes it contains to be reduced multiple times. For λ-calculus-based functional programming to be a viable technology it is necessary to have an efficient way of handling this.</p><p>A key step was the invention of normal graph reduction, by <ref type="bibr" target="#b44">Wadsworth (1971)</ref>. In this scheme the term is held as a directed acyclic graph, and the result of β-reduction is that a single copy of the argument is retained, with the function body containing multiple pointers to it. As a consequence any redexes in the argument are reduced at most once.</p><p>Turner adapted this idea to graph reduction on S, K, I, etc. combinators, allowing a much simpler abstract machine. In Turner's scheme the graph may be cyclic, permitting a more compact representation of recursion. The reduction rule for the Y combinator, Y H ⇒ H (Y H), creates a loop in the graph, increasing the amount of sharing. The combinators are a target code for a compiler for compilation from a high level functional language. Initially this was SASL <ref type="bibr" target="#b39">(Turner 1976</ref>) and in later incarnations of the system, Miranda.</p><p>While using a set of combinators fixed in advance is a good solution if graph reduction is to be carried out by an interpreter, if the final target of compilation is to be native code on conventional hardware it is advantageous to use the λabstractions present (explicitly or implicitly) in the program source as the combinators whose reduction rules are to be implemented. This requires a sourceto-source transformation called λ-lifting, <ref type="bibr" target="#b16">Hughes (1983)</ref>, <ref type="bibr" target="#b18">Johnsson (1985)</ref>. This method was first used in the compiler of LML, a lazy version of the functional subset of ML, written by Lennart Augustsson &amp; Thomas Johnsson at Chalmers University in Sweden, around 1984. Their model for mapping graph reduction onto conventional hardware, the G machine, has since been further refined, leading to the optimized model of Simon Peyton <ref type="bibr" target="#b29">Jones (1992)</ref>.</p><p>Thus over a period of two decades normal order functional languages have been implemented with increasing efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Miranda</head><p>Miranda is a functional language designed by David Turner in 1983-6 and is a sugaring of a typed λ-calculus with a universal fixpoint operator. There are no explicit λ's -instead we have function definition by equations and local definitions with where. The insight that one can have λ-calculus without λ goes back to Peter <ref type="bibr" target="#b20">Landin (1966)</ref> and his ISWIM notation. Neither is the user required to mark recursive definitions as such -the compiler analyses the call graph and inserts Y where it is required.</p><p>The use of normal order reduction (aka lazy evaluation) and non-strict functions has a very pervasive effect. It supports a more mathematical style of programming, in which infinite data structures can be described and used and, which is most important, permits communicating processes and input/output to be programmed in a purely functional manner.</p><p>Miranda is based on the earlier lazy functional language SASL <ref type="bibr" target="#b39">(Turner, 1976</ref>) with the addition of the system of polymorphic strong typing of <ref type="bibr" target="#b26">Milner (1978)</ref>. For an overview of Miranda see <ref type="bibr" target="#b42">Turner (1986)</ref>.</p><p>Miranda doesn't use Church numerals for its arithmetic -modern computers have fast fixed and floating point arithmetic units and it would be perverse not to take advantage of them. Arithmetic operations on unbounded size integers and 64bit floating point numbers are provided as primitives.</p><p>In place of the second order representation of data used within the pure untyped lambda calculus we have algebraic type definitions. For example bool ::= False | True nat ::= Zero | Suc nat tree ::= Leaf nat | Fork tree tree</p><p>Introducing new data types in this way is in fact better than using second order impredicative definitions for two reasons: you get clearer and more specific type error messages if you misuse them -and each algebraic type comes with a principle of induction which can be read off from the definition. The analysis of data is by pattern matching, for example The type specification of flatten is optional as the compiler is able to deduce this; ++ is list concatenation.</p><p>There is a rich vocabulary of standard functions for list processing, map, filter, foldl, foldr, etc. and a notation, called list comprehension that gives concise expression to a useful class of iterations.</p><p>Miranda was widely used for teaching and for about a decade following its initial release by Research Software Ltd in 1985-6 provided a de facto standard for pure functional programming, being taken up by over 200 universities. The fact that it was interpreted rather than compiled limited its use outside education, but several significant industrial projects were successfully undertaken using Miranda, see for example <ref type="bibr" target="#b22">Major et. al. (1991)</ref> and <ref type="bibr" target="#b28">Page &amp; Moe (1993)</ref>.</p><p>Haskell, a successor language designed by a committee, includes many extensions, of which the most important are type classes and monadic input-output. The language remains purely functional, however. For a detailed description see S. L. Peyton <ref type="bibr" target="#b30">Jones (2003)</ref>. Available implementations of Haskell include, besides an interpreter suitable for educational use, native code compilers. This makes Haskell a viable choice for production use in a range of areas.</p><p>The fact that people are able to write large programs for serious applications in a language, like Miranda or Haskell, that is essentially a sugaring of λ-calculus is in itself a vindication of Church's Thesis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Domain Theory</head><p>The mathematical theory which explains programming languages with general recursion is Scott's domain theory.</p><p>The typed λ-calculus looks as though it ought to have a set-theoretic model, in which types denote sets and λ-abstractions denote functions. But the fixpoint operator Y is problematic. It is not the case in set theory that every function f A → A has a fixpoint in A.</p><p>There is second kind of fixpoint to be explained, at the level of types. We can define recursive algebraic data types, like (we are here using Miranda notation):</p><p>big ::= Leaf nat | Node (big -&gt; big)</p><p>This appears to require a set with the property</p><formula xml:id="formula_17">Big ∼ = N + (Big → Big)</formula><p>which is impossible on cardinality grounds. Dana Scott's domain theory solves both these problems. A domain is a complete partial order: a set with a least element, ⊥, representing non-termination, and limits of ascending chains (or more generally of directed sets). The function space A → B for domains A, B, is defined to contain just the continuous functions from A to B and this is itself a domain. Continuous means preserving limits. The continuous functions are also monotonic (= order preserving).  <ref type="bibr" target="#b33">Scott (1976)</ref> or <ref type="bibr" target="#b0">Abramsky &amp; Jung (1994)</ref>. This includes that there is a non-trivial domain D ∞ with</p><formula xml:id="formula_18">D ∞ ∼ = D ∞ → D ∞</formula><p>providing a semantic model for Church's untyped λ-calculus.</p><p>Domain theory was originally developed to underpin denotational semantics, Christopher Strachey's project to formalize semantic descriptions of real programming languages using a typed λ-calculus as the metalanguage (see <ref type="bibr" target="#b35">Strachey, 1967</ref><ref type="bibr" target="#b36">, Strachey &amp; Scott, 1971</ref>). Strachey's semantic equations made frequent use of Y to explain control structures such as loops and also required recursive type equations to account for the domains of the various semantic functions. It was during Scott's collaboration with Strachey in the period around 1970 that domain theory emerged.</p><p>Functional programming in non-strict languages like Miranda and Haskell is essentially programming directly in the metalanguage of denotational semantics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computability at higher types, revisited</head><p>Dana Scott once remarked that λ-calculus is only an algebra, not a calculus. With domain theory and proofs using limits we get a genuine calculus, allowing many new results.</p><p>Studying a typed functional language with arithmetic, <ref type="bibr" target="#b31">Plotkin (1977)</ref> showed that if we consider functions of higher type where we allow inputs as well as outputs to be ⊥, there are computable functions which are not λ-definable. Using domain B where B = {T rue, F alse}, two examples are:</p><formula xml:id="formula_19">Or B → B → B where Or x y is T rue if either x or y is T rue Exists (N → B) → B where Exists f is T rue when ∃i N.f i = T rue</formula><p>This complete or parallel Or must interleave two computations, since either of its inputs may be ⊥. Exists is a multi-way generalization.</p><p>What we get from untyped λ-calculus, or a typed calculus with N and general recursion, are the sequential functions. To get all computable partial functions at every type we must add primitives expressing interleaving or concurrency. In fact just the two above are sufficient.</p><p>This becomes important for programming with exact real numbers, an active area of research. Martin <ref type="bibr" target="#b9">Escardo (1996)</ref> shows that a λ-calculus with a small number of primitives including Exists can express every computable function of analysis, including those of higher type, e.g. differentiation and integration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Strong Functional Programming</head><p>There is an extended family of typed λ-calculi, all without Y or any other method of expressing general recursion, in which every term is normalizing. The family includes simply typed λ-calculus -this is a family in itself <ref type="bibr">Girard's system F (1971)</ref>, also known as the second order λ-calculus (we consider here the Church-style or explicitly typed version)</p><p>Coquand &amp; Huet's calculus of constructions <ref type="bibr">(1988)</ref> Martin-Löf's intuitionist theory of types <ref type="bibr">(1973)</ref> In a change of convention we will use upper case letters A, B, C • • • for types and lower case letters a, b, c • • • for terms, reserving x, y, z, for λ-calculus variables (this somewhat makeshift convention will be adequate for a short discussion). In addition to the usual conversion and reduction relations, ⇔, ⇒, these theories have a judgement of well-typing, written a : A which says that term a has type A (which may or may not be unique).</p><p>All the theories share the following properties:</p><p>Church-Rosser If a ⇔ b there is a term c such that a ⇒ c and b ⇒ c.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Decidability of well-typing</head><p>This what is meant by saying that a programming language or formalism is strongly typed (aka staticly typed).</p><p>Strongly normalizing Every well-typed term is normalizing and every reduction sequence terminates in a normal form.</p><p>Uniqueness of normal forms Immediate from Church-Rosser.</p><p>Decidability of ⇔ on well-typed terms From the two previous properties -reduce both sides to normal form and see if they are equal.</p><p>Note that decidability of the well typing judgment, a : A, is not the same as type inference. The latter means that given an a we can find an A with a : A, or determine that there isn't one. The simply typed λ-calculus has type inference (in fact with most general types) but none of the stronger theories do. The first two properties in the list are shared with other well-behaved typed functional calculi, including those with general recursion. So the distinguishing property here is strong normalization. Programming in a language of this kind has important differences from the more familiar kind of functional programming. For want of any hitherto agreed name, we can call it strong functional programming 12 .</p><p>An obvious difference is that all evaluations terminate 13 , so we do not have to worry about ⊥. It is clear that such a language cannot be computationally complete -there will be always-terminating computable functions it cannot express (and one of these will be the interpreter for the language itself). It should not be inferred that a strongly normalizing language must therefore be computationally weak. Even simple typed lambda calculus, equipped with N as a base type and primitive recursion, can express every recursive function of arithmetic whose totality is provable in first order number theory (a result due to <ref type="bibr" target="#b12">Gödel, 1958)</ref>. A proposed elementary functional programming system along these lines, but including codata as well as data, is discussed in <ref type="bibr">Turner (2004)</ref>.</p><p>A less obvious but most striking consequence of strongly normalization is a new and unexpected interface between λ-calculus and logic. We show how this works by considering the simplest calculus of this class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Propositions-as-Types</head><p>The simply typed λ-calculus (STLC) has for its types the closure under → of a set of base types, which we will leave unspecified. As before we use A, B, C • • • as variables ranging over types. We can associate with each closed term a type schema, for example λx.</p><p>x :</p><formula xml:id="formula_20">A → A</formula><p>The function λx.x has many types but they are all instances of A → A, which is its most general type. A congruence first noticed by Curry in the 1950's is that the types of closed terms in STLC correspond to tautologies of intuitionist propositional logic, if we read → as implication, e.g. A → A is a tautology. The correspondence is exact, for example A → B is not a tautology and neither can we make any closed term of this type. Further, the most general types of the combinators s = λx.λy.λz.xz(yz) and k = λx.λy.x are</p><formula xml:id="formula_21">s : ((A → (B → C)) → ((A → B) → (A → C)) k : A → (B → A)</formula><p>and these formulae are the two standard axioms for the intuitionist theory of implication: every other tautology in → can be derived from them by modus ponens. What is going on here?</p><p>Let us look at the rules for forming well-typed terms of simply typed λ. On the left 14 we have the rule for abstraction, on the right that for application. If we look only at the types and ignore the terms, these are the introduction and elimination rules for implication in a natural deduction system. So naturally, the formulae we can derive using these rules are all and only the tautologies of the intuitionist theory of implication . In the logical reading, the terms on the left of the colons provide witnessing information -they record how the formula on the right was proved. The judgement a : A thus has two readings -that term a has type A, but also that proof-object or witness a proves proposition A.</p><p>The correspondence readily extends to the other connectives of propositional logic by adding some more type constructors to SLTC besides →. The type of pairs, cartesian product, A × B, corresponds to the conjunction A ∧ B. The disjoint union type, A ⊕ B, corresponds to the disjunction A ∨ B. The empty type corresponds to the absurd (or False) proposition, which has no proof. This Curry-Howard isomorphism between types and propositions is jointly attributed to <ref type="bibr" target="#b8">Curry (1958)</ref> and to W. <ref type="bibr" target="#b17">Howard (1969)</ref>, who showed how it extended to all the connectives of intuitionist logic including the quantifiers. It is at the same time an isomorphism between terminating programs and constructive (or intuitionistic) proofs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Constructive Theory of Types</head><p>Per Martin-Löf (1973) formalizes a proposed foundational language for constructive mathematics based on the isomorphism. The Intuitionist (or Constructive) Theory of Types is at one and the same time a higher order logic and a theory of types, providing for constructive mathematics what for classical mathematics is done by set theory. It provides a unified notation in which to write functions, types, propositions and proofs.</p><p>Unlike the constructive set theory of <ref type="bibr" target="#b27">Myhill (1975)</ref>, Martin-Löf type theory includes a principle of choice (not as an axiom, it is provable within the theory). It seems that the source of the non-constructivities of set theory is not the choice principle, which for Martin-Löf is constructively valid, but the axiom of separation, a principle which is noticeably absent from type theory 17 .</p><p>Constructive type theory is both a theory of constructive mathematics and a strongly typed functional programming language. Verifying the validity of proofs is the same process as type checking. Martin-Lof (1982) writes I do not think that the search for high level programming languages that are more and more satisfactory from a logical point of view can stop short of anything but a language in which all of constructive mathematics can be expressed.</p><p>There exist by now a number of different versions of the theory, including several computer-based implementations, of which perhaps the longest established is NuPRL <ref type="bibr" target="#b5">(Constable et al. 1986</ref>).</p><p>An alternative impredicative theory, also based on the Curry-Howard isomorphism, is <ref type="bibr">Coquand and Huet's Calculus of Constructions (1988)</ref> which provides the basis for the COQ proof system developed at INRIA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Type Theory with Partial Types</head><p>Being strongly normalizing, constructive type theory cannot be computationally complete. Moreover we might like to reason about partial functions and general recursion using this powerful logic. Is it possible to somehow unify type theory with a constructive version of Dana Scott's domain theory?</p><p>In his PhD thesis Scott F. <ref type="bibr" target="#b34">Smith (1989)</ref> investigated adding partial types to the type theory of NuPRL. The idea can be sketched briefly as follows. For each ordinary type T there is a partial type T of T -computations, whose elements include those of T and a divergent element, ⊥. For partial types (only) there is a fixpoint operator, f ix : (T → T ) → T . This allows the definition of general recursive functions.</p><p>The constructive account of partial types is significantly different from the classical account given by domain theory. For example we cannot assert ∀x : T . x T ∨ x = ⊥ because constructively this implies an effective solution to the halting problem for T . A number of intriguing theorems emerge. Certain non-computability results can be established absolutely, that is independently of Church's Thesis, see <ref type="bibr" target="#b6">Constable &amp; Smith (1988)</ref> 18 . Further, the logic of the host type theory is altered so that it is no longer compatible with classical logic -some instances of the law of the excluded middle, of the form ∀x.P (x)∨¬P (x) can be disproved.</p><p>To recapture domain theory requires something more than T and f ix, namely a second order fixpoint operator, F IX, that solves recursive equations in partial types. As far as the present author is aware, noone has yet shown how to do this within the logic of type theory. This would unify the two theories of functional programming. Among other benefits it would allow us to give within type theory a constructive account of the denotational semantics of recursive programming languages.</p><p>Almost certainly relevant here is Paul Taylor's Abstract Stone Duality (2002), a computational approach to topology. The simplest partial type is Sierpinski space, Σ, which has only one point other than ⊥. This plays a special role in Taylor's theory: the open sets of a space X are the functions in X → Σ and can be written as λ-terms. ASD embraces both traditional spaces like the reals and Scott domains (topologically these are non-Hausdorff spaces).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>CONCLUSION</head><p>Church's Thesis played a founding role in computing theory by providing a single notion of effective computability. Without this foundation we might have been stuck with a plethora of notions of computability depending on computer architecture, programming language etc.: we might have Motorola-computable versus Intel-computable, Java-computable versus C-computable and so on.</p><p>The λ-calculus, which Church developed during the period of convergence from which the Thesis emerged, has influenced almost every aspect of the development of programming and programming languages. It is the basis of functional programming, which after a long infancy is entering adulthood as a practical alternative to traditional ad-hoc imperative programming languages. Many important ideas in mainstream programming languages -recursion, procedures as parameters, linked lists and trees, garbage collectors -came by cross fertilization from functional programming. Moreover the main schools of both operational and denotational semantics are λ-calculus based and amount to using functional programming to explain other programming systems.</p><p>The original project from whose wreckage by paradox λ-calculus survived, to unify logic with an account of computable functions, appears to have been reborn in unexpected form, via the propositions-as-types paradigm. Further exciting developments undoubtedly lie ahead and ideas from Church's λ-calculus will continue to be central to them.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Here are the Church numerals 0 = λa.λb.b 1 = λa.λb.ab 2 = λa.λb.a(ab) 3 = λa.λb.a(a(ab))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>flatten :: tree -&gt; [nat] flatten (Leaf n) = [n] flatten (Fork x y) = flatten x ++ flatten y</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>For a complete partial order, D, each monotonic function f D → D has a least fixed point, ∞ n=0 f n ⊥. A plain set, like N can be turned into a domain by adding ⊥, to get N . Further, domain equations, like D ∼ = N + (D × D), D ∼ = N + (D → D) and so on, all have solutions. The details can be found in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Rosser Theorem If A ⇔ B there is a term C such that A ⇒ C and B ⇒ C. An immediate consequence of this is that the normal form of a normalizing term is unique .</figDesc><table><row><cell>Here [B/x]A means substitute B for free occurrences of x in A. The smallest</cell></row><row><cell>reflexive, symmetric, transitive, substitutive relation on terms including → β ,</cell></row><row><cell>written ⇔, is Church's notion of λ−conversion. If we omit symmetry from the</cell></row><row><cell>definition we get an oriented relation, written ⇒, called reduction.</cell></row><row><cell>An instance of the left hand side of rule β is called a redex . A term containing</cell></row><row><cell>no redex is said to be in normal form. A term which is convertible to one in</cell></row><row><cell>normal form is said to be normalizing. There are non-normalizing terms, of</cell></row><row><cell>which perhaps the simplest is (λx.xx)(λx.xx). We have the cyclic</cell></row><row><cell>(λx.xx)(λx.xx) → β (λx.xx)(λx.xx)</cell></row><row><cell>as the only available step.</cell></row><row><cell>The two most important technical results are</cell></row><row><cell>Church-Normal Order Theorem Stated informally: the normal form of a normaliz-</cell></row><row><cell>ing term can be found by repeatedly reducing its leftmost redex 5 .</cell></row><row><cell>To see the significance of the normal order theorem consider the term</cell></row><row><cell>(λy.z)((λx.xx)(λx.xx))</cell></row><row><cell>We have</cell></row><row><cell>(λy.z)((λx.xx)(λx.xx)) → β z</cell></row><row><cell>which is the normal form. But if we try to reduce the argument ((λx.xx)(λx.xx))</cell></row><row><cell>to normal form first, we get stuck in an endless loop.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>normalizing. Thus Y is solvable because we have for example</figDesc><table /><note>Y (λx.λy.y) ⇔ (λy.y) whereas (λx.xx)(λx.xx) is unsolvable.</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">This means unique up to changes of bound variable, of course. In case of nested redexes, leftmost is usually defined as leftmost-outermost, although the theorem will still hold if we take leftmost-innermost.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6">Pure means using only variables and no proper constants, as λ-calculus is presented here.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8">We here use functional to mean what some call purely functional, an older term for this is applicative, yet another term which includes other mathematically based models, such as logic programming, is declarative.9 The phrase syntactic sugar is due to Strachey, as are other evocative terms and concepts in programming language theory.10 Except where prior analysis of the program shows it can be avoided, a process known as strictness analysis.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="11">The one-point domain, with ⊥ for its only element, if allowed, would be a trivial solution.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12">Another possible term is "total functional programming", although this has the disadvantage of encouraging the unfortunate term "total function" (redundant because it is part of the definition function that it is everywhere defined on its domain).13 This seems to rule out indefinitely proceeding processes, such as an operating system, but we can include these by allowing codata and corecursion, see egTurner (2004).</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="14">The left hand rule says that if from assumption x : A we can derive b : B then we can derive what is under the line.The classical theory of implication includes additional tautologies dependant on the law of the excluded middle -the leading example is ((A → B) → A) → A, Pierce's law.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="16">Note that<ref type="bibr" target="#b13">Goodman &amp; Myhill's (1978)</ref> proof that Choice implies Excluded Middle makes use of an instance of the Axiom of Separation. The title should be Choice + Separation implies Excluded Middle.The frequent proposals to "improve" CTT by adding a subtyping constructor should therefore be viewed with suspicion.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="18">The paper misleadingly claims that among these is the Halting Theorem, which would be remarkable. What is in fact proved is the extensional halting theorem, which is already provable in domain theory, trivially from monotonicity. The real Halting Theorem is intensional, in that the halting function whose existence is to be disproved is allowed access to the internal structure of the term, by being given its Gödel number.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">† Miranda is a trademark of Research Software Limited.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Domain theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Abramsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Jung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Logic in Computer Science</title>
		<editor>S. Abramsky, D. M. Gabbay, T. Maibaum</editor>
		<imprint>
			<publisher>OUP</publisher>
			<date type="published" when="1994" />
			<biblScope unit="volume">III</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Barendregt The Lambda Calculus: Its Syntax and Semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">P</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1984" />
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An Unsolvable Problem of Elementary Number Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Journal of Mathematics</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="345" to="363" />
			<date type="published" when="1936" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">On computable numbers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal of Symbolic Logic</title>
		<imprint>
			<date type="published" when="1936-03" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="42" to="43" />
		</imprint>
	</monogr>
	<note>Review of A M Turing</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">The calculi of lambda conversion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Church</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1941" />
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Implementing Mathematics with the Nuprl Proof Development System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Constable</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computational Foundations of Basic Recursive Function Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">L</forename><surname>Constable</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
		<idno>TR 88-904</idno>
		<ptr target="http://www.nuprl.org" />
	</analytic>
	<monogr>
		<title level="m">Proceedings 3rd IEEE Symposium on Logic in Computer Science</title>
		<editor>Cornell Dept CS</editor>
		<meeting>3rd IEEE Symposium on Logic in Computer Science</meeting>
		<imprint>
			<date type="published" when="1988-03" />
			<biblScope unit="page" from="360" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">The Calculus of Constructions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Coquand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Huet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="95" to="120" />
		</imprint>
	</monogr>
	<note>Information and Computation</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">B</forename><surname>Curry</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Feys Combinatory Logic</title>
		<imprint>
			<biblScope unit="volume">I</biblScope>
			<date type="published" when="1958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Real PCF extended with existential is universal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Escardo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">; A</forename><surname>Edalat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jourdan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Mccusker</surname></persName>
		</author>
		<ptr target="http://www.cs.bham.ac.uk/∼mhe/papers/" />
	</analytic>
	<monogr>
		<title level="m">Proceedings 3rd Workshop on Theory and Formal Methods</title>
		<meeting>3rd Workshop on Theory and Formal Methods</meeting>
		<imprint>
			<publisher>IC Press</publisher>
			<date type="published" when="1996-04" />
			<biblScope unit="page" from="13" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Une extension de l&apos;interpretation fonctionnelle de Gödel a l&apos;analyse et son application a l&apos;elimination des coupures dans l&apos;analyse et la theorie des types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J.-Y</forename><surname>Girard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 2nd Scandinavian Logic Symposium</title>
		<editor>J. F. Fenstad</editor>
		<meeting>2nd Scandinavian Logic Symposium<address><addrLine>North-Holland; Jean-Yves Girard, Yves Lafont</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1971" />
			<biblScope unit="page" from="63" to="92" />
		</imprint>
	</monogr>
	<note>A modern treatment of System F can be</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Lecture notes taken by Kleene and Rosser at the Institute for Advanced Study</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gödel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Undecidable</title>
		<editor>M. Davis</editor>
		<meeting><address><addrLine>Raven, New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1965" />
		</imprint>
	</monogr>
	<note>On Undecidable Propositions of Formal Mathematical Systems</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">On a hitherto unutilized extension of the finitary standpoint</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Gödel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dialectica</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="280" to="287" />
			<date type="published" when="1958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Choice Implies Excluded Middle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">D</forename><surname>Goodman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Myhill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Zeit. Logik und Grundlagen der Math</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page">461</biblScope>
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Sur la non-contradiction de l&apos;arithmetique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Herbrand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Journal fur die reine und angewandte Mathematik</title>
		<imprint>
			<date type="published" when="1932" />
			<biblScope unit="volume">166</biblScope>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Did Church and Turing have a thesis about machines?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Hodges</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>this collection</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">The Design and Implementation of Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hughes</surname></persName>
		</author>
		<idno>PRG-40</idno>
		<imprint>
			<date type="published" when="1983-09" />
		</imprint>
		<respStmt>
			<orgName>University of Oxford ; Published by Oxford University Computing Laboratory Programming Research Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Monograph</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Essays on Combinatory Logic, Lambda Calculus and Formalism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Howard</surname></persName>
		</author>
		<editor>Seldin and Hindley</editor>
		<imprint>
			<date type="published" when="1969" />
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
	<note>The Formulae as Types Notion of Construction</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Lambda Lifting: Transforming Programs to Recursive Equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Johnsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings IFIP Conference on Functional Programming Languages and Computer Architecture</title>
		<meeting>IFIP Conference on Functional Programming Languages and Computer Architecture<address><addrLine>Nancy, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1985-09" />
			<biblScope unit="volume">201</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Lambda-Definability and Recursiveness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C</forename><surname>Kleene</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Duke Mathematical Journal</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="340" to="353" />
			<date type="published" when="1936" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Next 700 Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Landin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="157" to="165" />
			<date type="published" when="1966-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Recursive Functions of Symbolic Expressions and their Computation by Machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mccarthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="184" to="195" />
			<date type="published" when="1960" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Combination of Symbolic and Numerical Computation for Three-Dimensional Modelling of RNA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Major</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Turcotte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SCIENCE</title>
		<imprint>
			<biblScope unit="volume">253</biblScope>
			<biblScope unit="page" from="1255" to="1260" />
			<date type="published" when="1991-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">An Intuitionist Theory of Types -Predicative Part</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Martin-Löf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic Colloquium 1973</title>
		<editor>Rose and Shepherdson</editor>
		<imprint>
			<publisher>North Holland</publisher>
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Martin-Löf</surname></persName>
		</author>
		<title level="m">Proceedings of the Sixth International Congress for Logic, Methodology and Philosophy of Science</title>
		<editor>Cohen, Los, Pfeiffer &amp; Podewski) North Holland</editor>
		<meeting>the Sixth International Congress for Logic, Methodology and Philosophy of Science</meeting>
		<imprint>
			<date type="published" when="1982" />
			<biblScope unit="page" from="153" to="175" />
		</imprint>
	</monogr>
	<note>Also in Mathematical Logic and Programming Languages</note>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hoare &amp; Shepherdson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Prentice Hall</publisher>
			<biblScope unit="page" from="167" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A Theory of Type Polymorphism in Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="348" to="375" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Constructive set theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Myhill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="347" to="382" />
			<date type="published" when="1975-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Experience with a large scientific application in a functional language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rex</forename><forename type="middle">L</forename><surname>Page</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">D</forename><surname>Moe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">proceedings ACM Conference on Functional Programming Languages and Computer Architecture</title>
		<meeting>ACM Conference on Functional Programming Languages and Computer Architecture<address><addrLine>Copenhangen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">L</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peyton</forename><surname>Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="127" to="202" />
			<date type="published" when="1992-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">This and other information about Haskell can be</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">L</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peyton</forename><surname>Jones</surname></persName>
		</author>
		<ptr target="http://haskell.org" />
	</analytic>
	<monogr>
		<title level="m">Haskell 98 language and libraries: the Revised Report</title>
		<imprint>
			<date type="published" when="2003-01" />
			<biblScope unit="volume">13</biblScope>
		</imprint>
		<respStmt>
			<orgName>Cambridge University Press</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">LCF considered as a programming language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="233" to="255" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Über die Bausteine der mathematischen Logik&quot; translated as</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Moses</forename><surname>Schönfinkel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">van Heijenoort From Frege to Gödel -a source book in mathematical logic 1879-1931</title>
		<meeting><address><addrLine>Harvard</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1924" />
		</imprint>
	</monogr>
	<note>On the Building Blocks of mathematical logic</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Data Types as Lattices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dana</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="522" to="587" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Partial Objects in Type Theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><forename type="middle">F</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
		<respStmt>
			<orgName>Cornell University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Fundamental Concepts in Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Strachey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">originally notes for an International Summer School on computer programming</title>
		<meeting><address><addrLine>Copenhagen</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1967-08" />
			<biblScope unit="volume">13</biblScope>
		</imprint>
	</monogr>
	<note>Higher-Order and Symbolic Computation. this entire issue is dedicated in memory of Strachey</note>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Toward a mathematical semantics for computer languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dana</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Strachey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971-04" />
		</imprint>
		<respStmt>
			<orgName>Oxford University Programming Research Group Technical Monograph PRG-6</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Abstract Stone Duality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Taylor</surname></persName>
		</author>
		<ptr target="http://www.cs.man.ac.uk/∼pt/ASD/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title level="m" type="main">On computable numbers with an application to the Entscheidungsproblem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Turing</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1936" />
			<publisher>Proceedings London Mathematical Society</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="544" to="546" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">SASL Language Manual</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976-12" />
			<biblScope unit="volume">43</biblScope>
		</imprint>
		<respStmt>
			<orgName>St. Andrews University, Department of Computational Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">A New Implementation Technique for Applicative Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Software-Practice and Experience</title>
		<imprint>
			<date type="published" when="1979-01" />
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="31" to="49" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Another Algorithm for Bracket Abstraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Symbolic Logic</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="267" to="270" />
			<date type="published" when="1979-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">This and other information about Miranda † can be</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
		<ptr target="http://miranda.org.uk" />
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Notices</title>
		<imprint>
			<date type="published" when="1986-12" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="158" to="166" />
		</imprint>
	</monogr>
	<note>An Overview of Miranda</note>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Total Functional Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Universal Computer Science</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="751" to="768" />
			<date type="published" when="2004-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">The Semantics and Pragmatics of the Lambda Calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">P</forename><surname>Wadsworth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1971" />
		</imprint>
		<respStmt>
			<orgName>Oxford University Programming Research Group</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">D.Phil. Thesis</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
