<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Training recurrent networks online without backtracking</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2015-11-20">20 Nov 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Ollivier</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corentin</forename><surname>Tallec</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Charpiat</surname></persName>
						</author>
						<title level="a" type="main">Training recurrent networks online without backtracking</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2015-11-20">20 Nov 2015</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1507.07680v2[cs.NE]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We introduce the &quot;NoBackTrack&quot; algorithm to train the parameters of dynamical systems such as recurrent neural networks. This algorithm works in an online, memoryless setting, thus requiring no backpropagation through time, and is scalable, avoiding the large computational and memory cost of maintaining the full gradient of the current state with respect to the parameters. The algorithm essentially maintains, at each time, a single search direction in parameter space. The evolution of this search direction is partly stochastic and is constructed in such a way to provide, at every time, an unbiased random estimate of the gradient of the loss function with respect to the parameters. Because the gradient estimate is unbiased, on average over time the parameter is updated as it should. The resulting gradient estimate can then be fed to a lightweight Kalman-like filter to yield an improved algorithm. For recurrent neural networks, the resulting algorithms scale linearly with the number of parameters. Small-scale experiments confirm the suitability of the approach, showing that the stochastic approximation of the gradient introduced in the algorithm is not detrimental to learning. In particular, the Kalman-like version of NoBackTrack is superior to backpropagation through time (BPTT) when the time span of dependencies in the data is longer than the truncation span for BPTT. The prediction^may not live in the same set as. Often,^encodes a probability distribution over the possible values of , and the loss is the logarithmic loss ℓ = − log^().</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Consider the problem of training the parameters of a dynamical system over a variable ℎ ∈ R subjected to the evolution equation ℎ( + 1) = (ℎ( ), ( ), )</p><p>where is a fixed function of ℎ and of an input signal ( ), depending on parameters . The goal is online minimization of a loss function ∑︀ ℓ (^( ), ( )) between a desired output ( ) at time and a prediction 1 ( ) = (ℎ( ), )</p><p>computed from ℎ( ) and additional parameters .</p><p>A typical example we have in mind is a recurrent neural network, with activities ( ) := sigm(ℎ ( )) and evolution equation ℎ ( + 1) = + ∑︀ ( ) + ∑︀ ( ), with parameter = ( , , ) , , . If the full target sequence ( ) ∈[0; ] is known in advance, one strategy is to use the backpropagation through time algorithm (BPTT, see e.g. <ref type="bibr" target="#b3">[Jae02]</ref>) to compute the gradient of the total loss := ∑︀ =0 ℓ with respect to the parameters and , and use gradient descent on and .</p><p>However, if the data ( + 1) arrive one at a time in a streaming fashion, backpropagation through time would require making a full backward computation from time + 1 to time 0 after each new data point becomes available. This results in an Ω( 2 ) complexity and in the necessity to store past states, inputs, and outputs. A possible strategy is to only backtrack by a finite number of time steps <ref type="bibr" target="#b3">[Jae02]</ref> rather than going back all the way to = 0. But this provides biased gradient estimates and may impair detection of time dependencies with a longer range than the backtracking time range.</p><p>By contrast, methods which are fully online are typically not scalable. One strategy, known as real-time recurrent learning (RTRL) in the recurrent network community, 2 maintains the full gradient of the current state with respect to the parameters:</p><formula xml:id="formula_2">( ) := ℎ( )<label>(3)</label></formula><p>which satisfies the evolution equation ( + 1) = (ℎ( ), ( ), ) ℎ ( ) + (ℎ( ), ( ), )</p><p>(by differentiating (1)). Knowing ( ) allows to minimize the loss via a stochastic gradient descent on the parameters , namely, 3 ← − ℓ ⊤</p><p>with learning rate . Indeed, the latter quantity can be computed from and from the way the predictions depend on ℎ( ), via the chain rule</p><formula xml:id="formula_5">ℓ = ℓ ( (ℎ( ), ), ( )) ℎ ( )<label>(6)</label></formula><p>However, the full gradient ( ) is an object of dimension dim ℎ × dim . This prevents computing or even storing ( ) for moderately largedimensional dynamical systems, such as recurrent neural networks.</p><p>2 This amounts to applying forward automatic differentiation. <ref type="bibr">3</ref> We use the standard convention for Jacobian matrices, namely, / is the matrix with entries / . Then the chain rule writes = . This makes the derivatives ℓ / into row vectors so that gradient descent is ← − ( ℓ / ) ⊤ .</p><p>Algorithms using a Kalman filter on also 4 rely on this derivative ℓ (see <ref type="bibr" target="#b2">[Hay04,</ref><ref type="bibr" target="#b3">Jae02]</ref> for the case of recurrent networks). So any efficient way of estimating this derivative can be fed, in turn, to a Kalman-type algorithm.</p><p>Algorithms suggested to train hidden Markov models online (e.g., <ref type="bibr" target="#b1">[Cap11]</ref>, based on expectation-maximization instead of gradient descent) share the same algebraic structure and suffer from the same problem.</p><p>1 The NoBackTrack algorithm</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">The rank-one trick: an expectation-preserving reduction</head><p>We propose to build an approximation˜( ) of ( ) with a more sustainable algorithmic cost;˜( ) will be random with the property E˜( ) = ( ) for all . Then the stochastic gradient (5) based on˜( ) will introduce noise, but no bias, on the learning of : the average change in after a large number of time steps will reflect the true gradient direction. (This is true only if the noises on˜( ) at different times are sufficiently decorrelated. This is the case if the dynamical system (1) is sufficiently ergodic.) Such unbiasedness does not hold, for instance, if the gradient estimate is simply projected onto the nearest small-rank or diagonal plus small-rank approximation. <ref type="bibr">5</ref> The construction of an unbiased˜is based on the following "rank-one trick".</p><p>Proposition 1 (Rank-one trick). Given a decomposition of a matrix as a sum of rank-one outer products, = ∑︀ ⊤ , and independent uniform random signs ∈ {−1, 1}, theñ</p><formula xml:id="formula_6">:= ( ∑︀ ) (︁ ∑︀ )︁ ⊤<label>(7)</label></formula><p>satisfies E˜=</p><formula xml:id="formula_7">∑︁ ⊤ = (8)</formula><p>that is,˜is an expectation-preserving rank-one approximation of . Moreover, one can minimize the variance of˜by taking advantage of additional degrees of freedom in this decomposition, namely, one may first replace and with and / for any ∈ R * . The choice of which yields minimal variance of˜is when the norms of and become equal, namely, = √︀ ‖ ‖ / ‖ ‖.</p><p>One may use Kalman filtering either on alone or on the pair ( , ℎ). In the first case, ℓ is explicitly needed. In the second case, all the information about how influences the current state ℎ( ) is contained in the covariance between and ℎ, which the algorithm must maintain, and which is as costly as maintaining ( ) above. <ref type="bibr">5</ref> We tried such methods first, with less satisfying results. In practice, consecutive projections tend to interact badly and reduce too much the older contributions to the gradient.</p><p>The proof of the first statement is immediate. The statement about minimizing variance is proven in Appendix A. Minimizing variance thanks to is quite important in practice, see Section 1.3.</p><p>The rank-one trick also extends to tensors of arbitrary order; this may be useful in more complex situations. <ref type="bibr">6</ref> The rank-one reduction˜depends, not only on the value of , but also on the way is decomposed as a sum of rank-one terms. In the applications to recurrent networks below, there is a natural such choice. 7</p><p>We use this reduction operation at each step of the dynamical system, to build an approximation˜of . A key property is that the evolution equation (4) satisfied by is affine, so that if˜( ) is an unbiased estimate of ( ), then (ℎ( ), ( ), ) ℎ˜( ) + (ℎ( ), ( ), ) is an unbiased estimate of ( + 1). This leads to the NoBackTrack algorithm (Euclidean version) described in Algorithm 1. At each step, this algorithm maintains an approximation of as˜=¯¯⊤ +</p><formula xml:id="formula_8">∑︁ ⊤ (9)</formula><p>where is the -th basis vector in space ℎ, and := ⊤ are sparse vectors.</p><p>To understand this structure, say that˜( − 1) =¯¯⊤ is a rank-one unbiased approximation of ( − 1). Then the evolution equation <ref type="formula" target="#formula_3">4</ref>for yields</p><formula xml:id="formula_9">(︁ ℎ )︁ (︁¯¯⊤)︁ + = (︁ ℎ¯)︁¯⊤ + ∑︀</formula><p>as an approximation of˜( ). This new approximation is not rank-one any more, but it can be used to perform a gradient step on , and then reduced to a rank-one approximation before the next time step.</p><p>Note that handling is usually cheap: in many situations, only a small subset of the parameter directly influences each component ℎ ( + 1) given ℎ( ), so that for each component of the state space, has few non-zero components. For instance, for a recurrent neural network with activities <ref type="bibr">6</ref> The most symmetric way to do this is to use complex roots of unity, for instance,</p><formula xml:id="formula_10">∑︀ ⊗ ⊗ = E Re (︁ ( ∑︀ )( ∑︀ )( ∑︀ ) )︁</formula><p>where each is taken independently at random among {1, e ±2 /3 }. This involves complex numbers but there is no need to complexify the original dynamical system (1). Another, complex-free possibility is to apply the rank-one trick recursively to tensors of smaller order, for instance,</p><formula xml:id="formula_11">∑︀ ⊗ ⊗ ⊗ = ∑︀ ( ⊗ ) ⊗ ( ⊗ ) = E [︁ ( ∑︀ ⊗ )( ∑︀ ⊗ ) ]︁</formula><p>and then apply independent rank-one decompositions in turn to ∑︀ ⊗ and to ∑︀ ⊗ . 7 The rank-one trick may also be performed using random Gaussian vectors, namely = E[ ( ⊤ Σ −1 )] with = (0, Σ). This version does not depend on a chosen decomposition of , but depends on a choice of Σ. Variance can be much larger in this case: for instance, if = ⊤ is actually rank-one, then ( )( ⊤ ) = ⊤ so that the rank-one trick with random signs is exact, whereas the Gaussian version yields ( ⊤ Σ −1 ) ⊤ which is correct only in expectation. This case is particularly relevant because we are going to apply a reduction at each time step, thus working on objects that stay close to rank-one. The generalization to tensors is also more cumbersome in the Gaussian case. After the reduction step of Algorithm 1,¯may be interpreted as a "search direction" in parameter space , while¯is an estimate of the effect on the current state ℎ( ) of changing in the direction¯. The search directionē volves stochastically, but not fully at random, over time, so that on averagē¯⊤ is a fair estimate of the actual influence of the parameter . Note that in Algorithm 1, the non-recurrent output parameters are trained according to their exact gradient. The rank-one trick is used only for the recurrent part of the system. By construction, at each step of Algorithm 1, the quantity˜:=¯¯⊤+ ∑︀ ⊤ satisfies E˜= ℎ( ) . However, since the value of changes along the algorithm, we must be careful about the meaning of this statement. Intuitively, this derivative with respect to is taken along the actual trajectory of parameters realized by the algorithm.</p><p>More formally, let = ( 0 , . . . , , . . .) be any sequence of parameters. Let be any function depending on this sequence , such as the state of the system at time (all functions considered below will depend only on a finite initial segment of ). Define + := ( 0 + , . . . , + , . . .) and say that has derivative with respect to if ( + ) = ( ) + + ( 2 ) for small .</p><p>Thanks to this convention, the evolution equation (4) for the evolution of ( ) holds for any sequence of parameters , with ( ) defined as ℎ( ) . The following statement is then easily proved by induction.</p><p>Proposition 2 (Unbiased rank-one gradient estimate for dynamical systems). At each time step , the quantity˜:=¯¯⊤ + ∑︀ ⊤ from Algorithm 1 is an unbiased estimate of the gradient of the state of the system with respect to the parameter:</p><formula xml:id="formula_12">E˜= ℎ( ) (19)</formula><p>where is the sequence of parameters produced by the algorithm.</p><p>In particular, for learning rates tending to 0, the parameter evolves slowly so that the derivative ℎ( ) is close to a derivative with respect to the current value of the parameter. Thus, in this regime, ℎ( ) tends to ℎ( ) , and since˜is an unbiased estimate of , the situation gets closer and closer to an ordinary stochastic gradient descent if is small. Presumably Parameters: ℎ(0) (initial state), 0 , 0 (initial value of the internal and output parameters), (learning rate scheme); Data: ( ) (input signal), ( ) (output signal); Maintains: ℎ( ) (current state), , (internal and output parameters),¯(column vector of size dim ℎ),¯(column vector of size dim ), (sparse column vectors of size dim ) for = 1, . . . , dim ℎ.</p><p>Initialization: ← 0 , ← 0 ,¯← 0,¯← 0, ← 0; for = 0 to end-of-time do Observation step: Compute prediction^( ) = (ℎ( ), ) from current state ℎ( ). Observe ( ) and incur loss ℓ (^( ), ( )). Update step: Compute derivative of loss with respect to output parameters, ℓ = ℓ ( (ℎ( ), ), ( )) , and update output parameters:</p><formula xml:id="formula_13">← − ℓ ⊤ (10)</formula><p>Compute derivative of loss with respect to current state,</p><formula xml:id="formula_14">← ℓ ( (ℎ( ), ), ( )) ℎ<label>(11)</label></formula><p>Update internal parameters :</p><formula xml:id="formula_15">← − ( )¯− ∑︀<label>(12)</label></formula><p>(this is a gradient step ← − (˜) ⊤ using the current gradient estimate˜from (9)). </p><formula xml:id="formula_16">← (ℎ( ), ( ), ) ℎ¯( 16) ← (ℎ( ), ( ), ) ⊤ (17) ← + 1<label>(18)</label></formula><p>end Algorithm 1: NoBackTrack algorithm, Euclidean version.</p><p>this happens whenever the learning rate is small enough for not to change too much within a time range corresponding to a "forgetting time" of the dynamical system, although more work is needed here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Feeding the gradient estimate to an extended Kalman filter</head><p>The Euclidean version of the NoBackTrack algorithm presented in Algorithm 1 is not enough to obtain good performance fast. Online estimation often yields best results when using filters from the Kalman family. We refer to <ref type="bibr" target="#b2">[Hay04,</ref><ref type="bibr" target="#b3">Jae02]</ref> for a discussion of Kalman filtering applied to recurrent neural networks. Kalman-based approaches rely on a covariance matrix estimate ( ) on . After observing ( ), the parameter gets adjusted via 8</p><formula xml:id="formula_17">← − ( ) ℓ ⊤ (20)</formula><p>where the derivative of the loss with respect to is computed, as above, via the product of the derivative of the loss with respect to the current state ℎ( ), and the derivative ( ) = ℎ( ) . Maintaining a full covariance matrix on is usually too costly. However, having a good approximation of ( ) is not as critical as having a good approximation of ℓ . Indeed, given an unbiased approximation of ℓ , any symmetric positive definite matrix ( ) which changes slowly enough in time will yield an unbiased trajectory for .</p><p>Thus, we will use more aggressive matrix reduction techniques on ( ), such as block-diagonal (as in <ref type="bibr" target="#b2">[Hay04]</ref>) or quasi-diagonal [Oll15a] approximations. In our setting, the main point of using the covariance matrix is to get both a sensible scaling of the learning rate for each component of , and reparametrization-invariance properties <ref type="bibr" target="#b4">[Oll15a]</ref>.</p><p>In Kalman filtering, in the case when the "true" underlying parameter in the extended Kalman filter is constant, it is better to work with the inverse covariance matrix ( ) := ( ) −1 , and the extended Kalman filter on can be rewritten as</p><formula xml:id="formula_18">( ) ← ( − 1) +^⊤^(21) ← − ( ) −1 ℓ ⊤<label>(22)</label></formula><p>where^is the prediction at time , where both^and ℓ can be computed from ℎ( ) via the chain rule if ( ) = ℎ( ) is known, and where is the Indeed, in standard Kalman filter notation, one has = ⊤ , so that for the quadratic loss ℓ = 1 (^− ) ⊤ −1 (^− ) (log-loss of a Gaussian model with coraviance matrix ), the Kalman update for is equivalent to ← − ( ) ℓ ⊤ .</p><p>Fisher information matrix of^as a probability distribution on . (For exponential families this is just the Hessian − 2 l of the loss with respect to the prediction). This is the so-called information filter, because ( ) approximates the Fisher information matrix on given the observations up to time . This is basically a natural gradient descent on .</p><p>This approach is summarized in Algorithm 2, which we describe more loosely since matrix approximation schemes may depend on the application.</p><p>Algorithm 2 uses a decay factor (1− ) on the inverse covariance matrices to limit the influence of old computations made with outdated values of . The factor also controls the effective learning rate of the algorithm, since, in line with Kalman filtering, we have not included a learning rate for the update of (namely, = 1): the step size is adapted via the magnitude of . For = 0, grows linearly so that step size is (1/ ). Moreover, we have included a regularization term Λ for matrix inversion; in the Bayesian interpretation of Kalman filtering this corresponds to having a Gaussian prior on the parameters with inverse covariance matrix Λ. This is important to avoid fast divergence in the very first steps.</p><p>In practice we have used = (1/ √ ) and Λ = (dim ℎ). Id. The simplest and fastest way to approximate the Fisher matrix in Algorithm 2 is the outer product approximation (see discussion in <ref type="bibr" target="#b4">[Oll15a]</ref>), which we have used in the experiments below. Namely, we simply use ← l ⊤ l so that the updates to and simplify and become rank-one outer product updates using the gradient of the loss, namely, ← (1 − ) + ℓ ⊤ ℓ and likewise for . Here the derivative ℓ is estimated from the current gradient estimate˜.</p><p>For the matrix reductions, we have used a block-wise quasi-diagonal reduction as in <ref type="bibr" target="#b4">[Oll15a]</ref>. This makes the cost of handling the various matrices linear in the number of parameters. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Examples</head><formula xml:id="formula_19">← FisherApprox(^, )<label>(23)</label></formula><p>Compute derivative of prediction and of loss with respect to output parameters,^and ℓ . Update inverse covariance matrix of output parameters :</p><formula xml:id="formula_20">← (1 − ) + MatrixReduce (︃^⊤^)︃<label>(24)</label></formula><p>and update output parameters:</p><formula xml:id="formula_21">← − ( + Λ ) −1 ℓ ⊤<label>(25)</label></formula><p>Compute derivativeĥ of prediction with respect to current state ℎ( ). Update inverse covariance matrix of internal parameters :</p><formula xml:id="formula_22">← (1 − ) + MatrixReduce (︃˜⊤ĥ ⊤ĥ˜)︃<label>(26)</label></formula><p>and update internal parameters :</p><formula xml:id="formula_23">← − ( + Λ ) −1<label>(27)</label></formula><p>where := ( )¯− ∑︀ is the update of from Algorithm 1. Reduction step: Same as in Algorithm 1, but the norms used to compute¯and are derived from −1 (cf. Appendix B). Transition step: Same as in Algorithm 1. end Algorithm 2: NoBackTrack algorithm, Kalman version. 9</p><p>are not used, amount tō</p><formula xml:id="formula_24">+1 = (1 − ) (¯+ ∑︀ ( ) ) (29) +1 =¯+ ∑︀ ( )<label>(30)</label></formula><p>with the ( ) independent at each step . The resulting estimate of ℎ( )/ is unbiased, but its variance grows linearly with time. Indeed, the dynamics of¯is stationary thanks to the factor (1 − ), but the dynamics of¯is purely additive so that is just a -dimensional random walk. On the other hand, if rescaling by is used, then both¯and¯get rescaled by √ 1 − at each step, 9 so that their dynamics becomes stationary and variance does not grow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Recurrent neural networks.</head><p>The next example is a standard recurrent neural network (RNN). The state of the system is the set of pre-activation values ℎ ( ), and the activities are ( ) := (ℎ ( )) where is some activation function such as tanh or sigmoid. The recurrent dynamics of ℎ is</p><formula xml:id="formula_25">ℎ ( + 1) = ∑︁ → (ℎ ( )) + ∑︁ ( )<label>(31)</label></formula><p>in which ℎ( ), ℎ( + 1) ∈ R , ( ) → are a set of weights defining a graph on nodes, and ( ) ( , ) are the input weights. 10 The parameter is = ( , ). We hereby omit the output part of the network, 11 as it is of no use to analyze the estimation of ℎ( )/ .</p><p>(We have chosen the pre-activation values ℎ, rather than the activities = (ℎ), as the state of the system. This results in simpler expressions, especially for the input weights .)</p><p>Thus, the function defining the dynamical system for the variable ℎ is (31). The derivatives of are immediately computed as / = (ℎ ), / = , / ℎ = ′ (ℎ ), and all other derivatives are 0.</p><p>Algorithm 1 maintains, after the reduction step, an approximation ℎ( ) ≈ ( )¯( ) ⊤ . We can decompose¯( ) = (¯( ),¯( )) into the components corresponding to the internal and input weights of the parameter = ( , ), so that</p><formula xml:id="formula_26">ℎ ( ) ≈¯( )¯( ) (32) ℎ ( ) ≈¯( )¯( ).<label>(33)</label></formula><p>Proof: By induction one has¯=¯after the reduction step and¯= (1 − )¯after the transition step, and¯= 1/ √ − . 10 Biases are omitted; they can be treated by the inclusion of an always-activated united By plugging the values of the partial derivatives of into Algorithm 1, we find the following update equations for the value of¯,¯and¯right after the reduction step:¯(</p><formula xml:id="formula_27">+ 1) =¯∑︁ → ′ (ℎ ( ))¯( ) + (34) ( + 0) =¯( ) + (ℎ ( ))<label>(35)</label></formula><formula xml:id="formula_28">( + 1) =¯( ) + ( )<label>(36)</label></formula><p>where the are independent symmetric binary random variables, taking values ±1 with probability 1</p><p>. Any non-zero choice of leads to an unbiased estimation, though the values are to be optimized as mentioned above.</p><p>Applying this update has the same algorithmic cost as implementing one step (31) of the recurrent network itself.</p><p>Leaky recurrent neural networks. To capture long-term dependencies, in the experiments below we also use a leaky RNN, obtained via the addition of a direct feedback term: Multilayer recurrent neural networks. Let us now treat the case of a multilayer recurrent neural network with dynamics</p><formula xml:id="formula_29">ℎ ( + 1) = ℎ ( ) + ∑︁ ( ) +</formula><formula xml:id="formula_30">ℎ (1) ( + 1) = (1) ( ( ), ℎ (1) ( ), 1 )<label>(39)</label></formula><formula xml:id="formula_31">ℎ (2) ( + 1) = (2) ( ( ), ℎ (1) ( + 1), ℎ (2) ( ), )<label>(40)</label></formula><p>. . . (41)</p><formula xml:id="formula_32">ℎ ( ) ( + 1) = ( ) ( ( ), ℎ ( −1) ( + 1), ℎ ( ) ( ), )<label>(42)</label></formula><p>where each layer ℎ ( ) and ( ) define an RNN as in (31) above. Directly applying the rank-one approximation to the function = ( (1) , (2) , . . . , ( ) ) would be cumbersome: since the activity of a neuron of the -th layer at time + 1 depends on all parameters from the previous − 1 layers, the derivative / is not sparse. To cope with this, a natural approach is to treat the dynamics in a "rolling" fashion and apply the rank-one approximation at each layer in turn. Formally, this amounts to defining the following model</p><formula xml:id="formula_33">ℎ (1) ( + 1) = (1) (˜( ),h (1) ( ), 1 )<label>(43)</label></formula><p>ℎ (2) ( + 2) = (2) (˜( + 1),h (2) ( + 1), 2 ) (44) . . .</p><p>(45)</p><formula xml:id="formula_34">ℎ ( ) ( + ) = ( ) (˜( + − 1),h ( ) ( + − 1), )<label>(46)</label></formula><p>with˜( ) := (⌊ / ⌋), and where states not explicitly appearing in these equations stay unchanged (ℎ ( ) ( + ) = ℎ ( ) ( + − 1) for ̸ = ). Thus, the transition function explicitly depends on time (more precisely, on time modulo the number of layers), and is sparse at each step. Indeed, at each step, applying the transition function amounts to applying one of the ( ) to the corresponding layer, and leaving the other layers unchanged. Thus the derivative of ( ) with respect to any , ̸ = , is zero; this leaves only the gradient of ( ) wrt to be dealt with, and Algorithm 1 or 2 can be applied at little cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Extensions</head><p>Rank-reductions. A first obvious extension is to use higher-rank reductions. The simplest way to achieve this is to take several independent random rank-one¯¯⊤ reductions in (7) and average them. Note that (Algorithm 1) has to be evaluated only once in this case. It might be slightly more efficient to first split the parameter components into blocks (e.g., at random) so that the -th term¯⊤ only involves parameters from the -th block: indeed, applying the evolution equation for preserves this structure so this requires less memory for storage of the¯.</p><p>Algorithms similar to RTRL. Other algorithms have been proposed that have the same structure and shortcomings as real-time recurrent learning, for instance, the online EM algorithm for hidden Markov models from <ref type="bibr" target="#b1">[Cap11]</ref>. In principle, the approach presented here can be extended to such settings. </p><p>which can be discretized as ℎ( + ) = ℎ( ) + (ℎ( ), ( ), ). Thus this is analogous to the discrete-time case via = Id + , and Algorithm 1 may be applied to this discretization.</p><p>When performing the rank-one reduction (7), the scaling by = √︀ ‖ ‖ / ‖ ‖ is important in this case: it ensures that both¯and¯change by ( √ ) times a random quantity at each step. This is the expected correct scaling for a continuous-time stochastic evolution equation, corresponding to the increment of a Wiener process during a time interval . (Without scaling by , there will be no well-defined limit as → 0, because¯would change by (1) at each step ← + , while¯would evolve by times a centered random quantity so that it would be constant in the limit.) Further work is needed to study this continuous-time limit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Experiments</head><p>We report here a series of small-scale experiments on text prediction tasks. The experiments focus on two questions: First, does learning using the rank-one approximation˜accurately reflect learning based on the actual gradient computed exactly via RTRL, or is the noise introduced in this method detrimental to learning? Second, how does this approach compare to truncated backpropagation through time?</p><p>We used the RNN or leaky RNN models described above to predict a sequence of characters ( ) in a finite alphabet , given the past observations ( ) = ( ) for 1 − 1. At each time, the network outputs a probability distribution on the next character ; explicitly, the output at time is^( ) ∈ R defined bŷ</p><formula xml:id="formula_36">( ) := + ∑︁ ( )<label>(48)</label></formula><p>for each ∈ , with parameters = ( , ) , . The output^= (^) ∈ defines a probability distribution on via a softmax^( ) :=∑︀ ∈^, and the loss function is the log-loss on prediction of the next character, ℓ := − log 2^( ) ( ( )). The internal and output parameters and are trained according to Algorithms 1 and 2. We used three datasets. The first is a "text" representing synthetic music notation with several syntactic, rhythmic and harmonic constraints (Example 3 from <ref type="bibr" target="#b5">[Oll15b]</ref>). The data was a file of length ≈ 10 5 characters, after which the signal cycled over the same file. The second dataset is the classical example, synthesized by repeatedly picking an integer at random in some interval, then outputting a series of 's followed by a line break, then 's and another line break. This model tests the ability of a learning algorithm to learn precise timing and time dependencies. The third example is the full set of Shakespeare's works, obtained from Project Gutenberg. 12 The file is roughly 5.10 6 characters long.</p><p>The benchmarks included are gzip, a standard non-online compression algorithm, and context tree weighting (CTW) <ref type="bibr" target="#b0">[BEYY04]</ref>, a more advanced online text compression algorithm, as well as the actual entropy rate of the generative model for synthetic music and . The code used in the experiments is available at http://www.yann-ollivier. org/rech/code/nobacktrack/code_nobacktrack_exp.tar.gz Euclidean NoBackTrack. We first study whether the low rank approximation in the Euclidean version of NoBackTrack impacts the gradient descent. For this first set of experiments, we use a fully connected RNN with 20 units, as described above, on the synthetic music example. We compared RTRL, Euclidean rank-one NoBackTrack, and Euclidean NoBackTrack using ranktwo and rank-ten reductions (obtained by averaging two or ten independent rank-one reductions, as discussion in Section 1.4).</p><p>The results are summed up in <ref type="figure" target="#fig_5">Figure 1</ref> and <ref type="figure" target="#fig_6">Figure 2</ref>. All the models were trained using the same learning rate = 1/ √ for <ref type="figure" target="#fig_5">Figure 1</ref> and = 0.03/ √</p><p>for <ref type="figure" target="#fig_6">Figure 2</ref>. The various algorithms were run for the same amount of time. This is reflected in the different curve lengths for the different algorithms; in particular, the curve for RTRL is much shorter, reflecting its higher computational cost. (Note the log scale on the axis: RTRL is roughly 20 times slower with 20 units.)</p><p>The impact of stochasticity of the low-rank approximation when using large learning rates is highlighted on <ref type="figure" target="#fig_5">Figure 1</ref>: Euclidean NoBackTrack with a large learning rate displays instabilities, even when increasing the rank of the approximation.</p><p>Smaller learning rates allow the algorithm to cope with this, as the noise in the gradients is averaged out over longer time spans. This is illustrated in <ref type="figure" target="#fig_6">Figure 2</ref>, in which the trajectories of Euclidean NoBackTrack track those of RTRL closely even with a rank-two approximation.</p><p>Kalman NoBackTrack. Next, we report the results of the Kalman version of NoBackTrack on the same experimental setup. A quasi-diagonal outer product (QDOP) approximation <ref type="bibr" target="#b4">[Oll15a]</ref> of the full Kalman inverse covariance matrix is used, to keep complexity low.</p><p>We compare the low-rank approximations to RTRL. To make the comparison clear, for RTRL we also use a quasi-diagonal (QDOP) approximation of the Kalman filtering algorithm on top of the exact gradient computed by RTRL. Learning rates were set to 1 and all algorithms were run for the same amount of time.</p><p>The use of the QDOP-approximated Kalman inverse covariance appears to fully fix the unstable behaviour. Overall, low-rank approximations appear to be roughly on par with QDOP RTRL. There is no obvious gain, on this particular example, in using higher-rank approximations.</p><p>Still, on this particular task and with this particular network size, none of the RNN algorithms (including BPTT reported below) match the performance of Context Tree Weighting. RNNs beat CTW on this task if trained using a non-online, Riemannian gradient descent <ref type="bibr" target="#b5">[Oll15b]</ref> (analogous to using the Kalman inverse covariance). So this is arguably an effect of imperfect online RNN training.</p><p>Kalman NoBackTrack and truncated BPTT. Our next set of experiments aims at comparing Kalman NoBackTrack to truncated BPTT, with truncation 13 parameter = 15. As BPTT truncates the full gradient by</p><p>In the version of BPTT used here, the algorithm does not backtrack by steps at every time step ; rather, it waits for steps between and + , then backtracks by steps and collects all gradients in this interval. Otherwise, truncated BPTT would be times slower, which was unacceptable for our experiments. removing dependencies at distances longer than the truncation parameter, we expect Kalman NoBackTrack to learn better models on datasets presenting long term correlations.</p><p>The two algorithms are first compared on the synthetic music dataset, with the same experimental setup as above, for the same amount of time, with a learning rate = 1/ √ for truncated BPTT and = 1/ √ for Kalman NoBackTrack. 14 The results are shown in <ref type="figure" target="#fig_9">Figure 4</ref>.</p><p>On this example, truncated BPTT perfoms better than Kalman NoBack-Track, even though the two algorithms display broadly comparable performance. Noticeably, RTRL and truncated BPTT are roughly on par here, with truncated BPTT slightly outperforming RTRL in the end: apparently, maintaining long term dependencies in gradient calculations does not improve learning in this synthetic music example.</p><p>Next, to compare NoBackTrack and truncated BPTT on their specific ability to learn precise middle and long term dependencies, we present experiments on the example. This will clearly illustrate the biased nature of the gradients computed by truncated BPTT.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The</head><p>[ ; ] dataset is synthesized by sequentially picking a number between and uniformly at random, then outputting a series of 's followed by a line break, then 's and another line break. The true entropy rate is log 2 ( − +1) + +2 in this example. 15 A roughly 10 6 character long input sequence was synthesized, using [ ; ] = [1; 32].</p><p>As standard RNN models do not seem to be able to deal with this example, whatever the training algorithm, we used a leaky RNN 16 as presented in Section 1.3, again with 20 fully connected units. All the algorithms used a learning rate of 1/ √ . The results are reported on <ref type="figure" target="#fig_10">Figure 5</ref>, which also includes the entropy rate of the exact model and the (twice larger) entropy rate of an model with independent and . Kalman NoBackTrack clearly outperforms truncated BPTT on this dataset. This was to be expected, as the typical time range of the temporal dependencies exceeds the truncation range for BPTT, so that the   Keeping track of the long term dependencies is key here, and RTRL outperforms all the algorithms epochwise, though it is still penalized by its high complexity. Truncated BPTT is unable to learn the full dependencies between 's and 's, and ends up closer to the entropy of an model with independent values of and (presumably, it still manages to learn the blocks where is short). At some point the learning curve of truncated BPTT appears not to decrease anymore and even goes slightly up, which is consistent with a biased gradient estimate.</p><p>On the other hand, Kalman NoBackTrack seems to be mostly successful in learning the dependencies. This is confirmed by visual inspection of the output of the learned model. The small remaining gap between the true model and the learned model could be related to incomplete training, or to an imperfect modelling of the exact uniform law for ∈ [ ; ].</p><p>Finally, we report performance of truncated BPTT and Kalman NoBack-Track on Shakespeare's works. The same 20-unit RNN model is used, again with all algorithms run for the same amount of time using the same learning rate 1/ √ . The curves obtained are displayed in <ref type="figure" target="#fig_11">Figure 6</ref>. On this example, RTRL, truncated BPTT, and Kalman NoBackTrack Indeed,˜= ∑︀ ⊤ so, by bilinearity of the Hilbert-Schmidt scalar product, E ⃦ ⃦˜⃦ ⃦ 2 HS = E</p><formula xml:id="formula_37">⟨︀˜|˜⟩︀ HS = E ∑︁ ⟨ | ⟩ ⟨ | ⟩<label>(50)</label></formula><p>Since E = 0 and E( ) = 0 for ̸ = , the only cases to consider are:</p><p>1. = and = and ̸ = : contribution ∑︀ ∑︀ ̸ = ‖ ‖ 2 ‖ ‖ The first and fourth contributions add up to ( ∑︀ ‖ ‖ 2 )( ∑︀ ‖ ‖ 2 ). This proves (49).</p><p>Let us minimize variance over the degrees of freedom given by ⊤ = ( )( / ) ⊤ . does not change the last contribution to E ⃦ ⃦˜⃦ ⃦ 2 HS in (49), neither does it change the expectation E˜= , so to minimize the variance we only have to minimize the first term ( ∑︀ ‖ ‖ 2 )( ∑︀ ‖ ‖ 2 ). Applying the scaling, this term becomes</p><formula xml:id="formula_38">( ∑︁ ‖ ‖ 2 2 )( ∑︁ ‖ ‖ 2 / 2 )<label>(51)</label></formula><p>and, by differentiation with respect to a single , one checks that this is minimal for ∝ √︀ ‖ ‖ / ‖ ‖ (︀ (˜− 1˜⊤ ) −1 )︀ 1/4</p><p>(64)</p><p>The particular structure of (if approximated by, e.g., a block-diagonal matrix) and of˜=¯¯⊤ + ∑︀ ⊤ make these computations efficient. Note that even with the approximations above,˜is still an unbiased estimate of . Indeed, any choice of has this property; we are simply approximating the optimal which minimizes the variance of˜.</p><p>In practice, small regularization terms are included in the denominator of every division and inversion to avoid numerical overflow.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>(</head><label></label><figDesc>) := sigm(ℎ ( )) and evolution equation ℎ ( + 1) = + ∑︀ ( ) + ∑︀ ( ), the derivative of ℎ ( + 1) with respect to the parameter = ( , , ) only involves the parameters , , of unit . In such situations, the total cost of computing and storing all the 's is of the same order as the cost of computing ℎ( + 1) itself. See Section 1.3 for details on this example.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Reduction step: Draw independent uniform random signs = ±1. Let be the -th basis vector in state space. Computē := √︀ ‖¯‖ / ‖¯‖ and := √︀ ‖ ‖ / ‖ ‖ for each . Updatē ←¯¯+ ∑︀ Observe new value of input signal ( ) and compute next state ℎ( + 1) = (ℎ( ), ( ), ). Update estimate˜:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Let us show how Algorithm 1 works out on explicit examples.The importance of norm rescaling. Let us first consider a simple dynamical system which illustrates the importance of rescaling the norms bȳ and . Let 0 &lt; &lt; 1 and consider the systemℎ( + 1) = (1 − )ℎ( ) +(28)with both ℎ and in R . This quickly converges towards / . We have/ ℎ = (1 − ) Id and / = Id and so / ⊤ = , the -th basis vector. Then the reduction and transition steps in Algorithm 1, if the scalings Parameters: ℎ(0) (initial state), 0 , 0 (initial value of the parameters), 0 &lt; 1 (covariance decay parameter scheme), Λ and Λ (inverse covariance matrix of the prior on the parameters); Maintains: Same as Algorithm 1, plus a representation of matrices and allowing for efficient inversion; Subroutines: A matrix reduction method MatrixReduce( ) which only evaluates a small number of entries of its argument and returns an approximation of that can be inverted efficiently; A routine FisherApprox(^, ) which returns either a positive definite approximation of the Fisher information matrix of^as a probability distribution on , or a positive definite approximation of the Hessian − 2 l 2 of the loss with respect to the prediction. Initialization: as in Algorithm 1, and ← 0, ← 0; for = 0 to end-of-time do Observation step: as in Algorithm 1. Update step: Compute approximate Fisher information matrix w.r.t.^:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>for all . (See<ref type="bibr" target="#b3">[Jae02]</ref> for similar models.) This feedback term reduces the impact of the vanishing gradient issue and keeps a longer memory of past inputs.This only changes the derivative of with respect to ℎ , which becomes / ℎ = ′ (ℎ ) + . Consequently the update rules (35)-(36) for and¯are unchanged, while the update of¯becomes( + 1) =¯¯( ) +¯∑︁ → ′ (ℎ ( ))¯( ) +(38)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 1 :</head><label>1</label><figDesc>Average log-loss (bits per character) on synthetic music as a function of the number of characters read, for an RNN with 20 units trained with the Euclidean version of the NoBackTrack algorithm for different rank values and RTRL, with learning rate = 1/ √ , benchmarked against the true model entropy rate, gzip, and CTW.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 2 :</head><label>2</label><figDesc>Average log-loss (bits per character) on synthetic music as a function of the number of characters read, for an RNN with 20 units trained with the Euclidean version of the NoBackTrack algorithm for different rank values, and with RTRL, with learning rate = 0.03/ √ , benchmarked against the true model entropy rate, gzip, and CTW.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>These learning rates have different meanings for Kalman NoBackTrack and truncated BPTT, and are not directly comparable.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 3 :</head><label>3</label><figDesc>Average log-loss (bits per character) on synthetic music as a function of the number of characters read, for an RNN with 20 units trained with the Kalman/QDOP version of the NoBackTrack algorithm for different rank values and Kalman/QDOP RTRL, benchmarked against the true model entropy rate, gzip, and CTW.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 4 :</head><label>4</label><figDesc>Average log-loss (bits per character) on synthetic music as a function of the number of characters read, for an RNN with 20 units trained with the Kalman/QDOP version of the NoBackTrack algorithm for different rank values, Euclidean RTRL, and truncated BPTT, benchmarked against the true model entropy rate, gzip, and CTW.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 5 :</head><label>5</label><figDesc>Average log-loss (bits per character) on the [1,32] dataset, as a function of the number of characters read, for a leaky RNN with 20 units, trained with a Kalman/QDOP version of the NoBackTrack algorithm, RTRL, and BPTT.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 6 :</head><label>6</label><figDesc>Average log-loss (bits per character) on Shakespeare's works as a function of the number of characters read, for an RNN with 20 units trained with the QDOP version of the NoBackTrack algorithm for different rank values, Euclidean RTRL and truncated BPTT, benchmarked against gzip and CTW. approximated gradients computed by truncated BPTT are significantly biased.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>2 2 .</head><label>2</label><figDesc>= and = and ̸ = : contribution ∑︀ ∑︀ ̸ = ⟨ | ⟩ ⟨ | ⟩ 3. = and = and ̸ = : same contribution as the previous one 4</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>To obtain the variance of˜, we just subtract the square norm of E˜= , which is</figDesc><table><row><cell>and</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>=</cell><cell cols="2">√︃</cell><cell cols="3">‖ ‖ ‖ ‖</cell><cell>=</cell><cell>( ⊤ −1 ) 1/4</cell></row><row><cell cols="12">(mutliplying all 's by a common factor does not change the result). So, after</cell></row><row><cell cols="3">optimal scaling,</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>(︃</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>)︃</cell><cell>(︃</cell><cell>)︃</cell></row><row><cell></cell><cell></cell><cell>=</cell><cell cols="2">∑︁</cell><cell></cell><cell cols="2">√︀</cell><cell cols="4">‖ ‖ / ‖ ‖</cell><cell>⊗</cell><cell>∑︁</cell><cell>√︀</cell><cell>‖ ‖ / ‖ ‖</cell><cell>(53)</cell></row><row><cell cols="12">Consequently, after scaling, the first term in the variance of˜in (49) becomes</cell></row><row><cell>( ∑︀</cell><cell cols="11">‖ ‖ ‖ ‖) 2 . The second term in (49) does not change.</cell></row><row><cell></cell><cell cols="11">Thus, after optimal scaling we find</cell></row><row><cell></cell><cell>E</cell><cell cols="3">⃦ ⃦˜⃦ ⃦ 2 HS =</cell><cell cols="2">(︃ ∑︁</cell><cell cols="5">)︃ 2 ‖ ‖ ‖ ‖</cell><cell>+ 2</cell><cell>∑︁ ∑︁</cell><cell>⟨ | ⟩ ⟨ |</cell><cell>⟩</cell><cell>(54)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell≯ =</cell></row><row><cell></cell><cell cols="2">‖ ‖ 2 HS =</cell><cell cols="2">⃦ ⃦ ⃦ ⃦ ⃦ ∑︁</cell><cell></cell><cell cols="3">⊤ ⃦ 2 ⃦ ⃦ HS ⃦ ⃦</cell><cell>=</cell><cell cols="2">∑︁</cell><cell>⃦ ⃦ ⊤ ⃦ ⃦ 2 HS +</cell><cell≯ = ∑︁ ∑︁ ⟨︀</cell><cell>⊤ |</cell><cell>⊤ ⟩︀</cell><cell>HS</cell><cell>(55)</cell></row><row><cell cols="12">(by bilinearity of the Hilbert-Schmidt scalar product)</cell></row><row><cell></cell><cell></cell><cell>=</cell><cell>∑︁</cell><cell cols="2">‖ ‖</cell><cell cols="5">2 ‖ ‖ 2 +</cell><cell>∑︁ ∑︁</cell><cell>⟨ | ⟩ ⟨ |</cell><cell>⟩</cell><cell>(56)</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell≯ =</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="0">with 0 ( ) ≡ 1.11  The experiments below use a softmax output with output parameters , see Section 2.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="12">www.gutenberg.org</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="15">Indeed, log 2 ( − + 1) bits are needed to encode the value of in each block (this is the entropy of a uniform distribution on { , . . . , }), and the average value of is ( + )/2 so that the average length of an block, including the two newline symbols, is 2 × ( + )/2 + 2.16 The parameter of the LRNN can be learned, but this sometimes produces numerical instabilities unless cumbersome changes of variables are introduced. We just initialized to a random value separately for each unit and kept it fixed.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Acknowledgments. The authors would like to thank Hugo Larochelle for his helpful questions that resulted in several clarifications of the text.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>with various ranks all have a similar performance; it is not clear whether the differences on <ref type="figure">Figure 6</ref> are statistically significant. This proves, once more, that the stochasticity and rank reduction inherent to NoBackTrack are not detrimental to learning, and allow it to keep up with exact gradient algorithms.</p><p>All RNN algorithms have a significantly worse performance than CTW on this example, thus proving that a 20-unit RNN does not accurately model Shakespeare's works.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion.</head><p>We have introduced an algorithm that computes a stochastic, provably unbiased estimate of the derivative of the current state of a dynamical system with respect to its parameters, in a fully online fashion. For recurrent neural networks, the computational cost of this algorithm is comparable to that of running the network itself. Previously known algorithms were either not fully online or had a significantly higher computational cost.</p><p>In our experiments, this algorithm appears as a practical alternative to truncated backpropagation through time, especially in its Kalman version, while the Euclidean version requires smaller learning rates. The (unbiased) noise and rank reduction introduced in the gradient approximation do not appear to prevent learning. The interest of NoBackTrack with respect to truncated BPTT depends on the situation at hand, especially on the scale of time dependencies in the data (which results in biased gradient estimates for BPTT), and on whether the storage of past states and past data required by truncated BPTT is acceptable or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Variance of the rank-one trick</head><p>Keep the notation of Proposition 1 and let ‖•‖ be a Euclidean norm on the vector space in which the and live. To measure the variance of˜we use the Hilbert-Schmidt norm ⃦ ⃦˜⃦ ⃦ 2 HS := Tr(˜⊤˜). This norm satisfies ⃦ ⃦ ⊤ ⃦ ⃦ HS = ‖ ‖ ‖ ‖, and </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Invariant norms derived from the Kalman covariance</head><p>Algorithm 2 is built to offer invariance properties (a Kalman filter over a variable is invariant by affine reparameterization of , for instance). However, this only holds if the norms ‖¯‖, ‖¯‖, ‖ ‖, ‖ ‖, used to compute the scaling factors¯= √︀ ‖¯‖ / ‖¯‖ and = √︀ ‖ ‖ / ‖ ‖, are themselves reparameterization-invariant. This can be achieved if we decide to choose the scalings as to minimize the variance of˜computed in the (Mahalanobis) norm defined by the covariance matrix of and of ℎ appearing in the Kalman filter.</p><p>Let be the covariance matrix of obtained in the Kalman filter; in Algorithm 2, is approximated by ≈ −1 . Any linear form on , such as¯and , can be given a norm by and its inverse ℎ := −1 ℎ can be used to define a norm for a tangent vector at state ℎ via ‖ ‖</p><p>which is also reparametrization-invariant. (We use −1 for the norm of and ℎ for the norm of because is a tangent vector (covariant) at point ℎ, while is a linear form (contravariant) at point .) However, handling of full covariance matrices would be too costly. In Algorithm 2, the inverse covariance of is already an approximation (diagonal, quasi-diagonal...) via MatrixReduce. Moreover, here we only have access to an approximation˜of . Thus, we simply replace with˜in the definition of ℎ , and use a diagonal reduction. This leads to ℎ ≈ Diag(˜− 1˜⊤ ) and</p><p>where as usual˜is the gradient approximation given by (9). The diagonal reduction is necessary if˜is low-rank, since˜− 1˜⊤ will be low-rank as well, and thus non-invertible.</p><p>Then the scaling factors¯and can finally be computed as = √︃ ‖¯‖ ‖¯‖ = (¯⊤ −1¯)1/4</p><p>(︀∑︀ (˜− 1˜⊤ ) −1¯2 )︀ 1/4</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">On prediction using variable order markov models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ron</forename><surname>Begleiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ran</forename><surname>El-Yaniv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Golan</forename><surname>Yona</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="page" from="385" to="421" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Online EM algorithm for hidden Markov models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olivier</forename><surname>Cappé</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Graph. Statist</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="728" to="749" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Kalman filtering and neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Haykin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Tutorial on training recurrent neural networks, covering BPTT, RTRL, EKF and the &apos;&apos;echo state network&apos;&apos; approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Herbert</forename><surname>Jaeger</surname></persName>
		</author>
		<idno>159</idno>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
		<respStmt>
			<orgName>German National Research Center for Information Technology</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Riemannian metrics for neural networks I: feedforward networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Ollivier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Inference</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="108" to="153" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Riemannian metrics for neural networks II: recurrent networks and learning symbolic data sequences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Ollivier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information and Inference</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="154" to="193" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
