<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mining High-Speed Data Streams</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pedro</forename><surname>Domingos</surname></persName>
							<email>pedrod@cs.washington.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Dept. of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">University of Washington</orgName>
								<address>
									<postBox>Box 352350</postBox>
									<postCode>98195-2350</postCode>
									<settlement>Seattle</settlement>
									<region>WA</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoff</forename><surname>Hulten</surname></persName>
							<email>ghulten@cs.washington.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Dept. of Computer Science &amp; Engineering</orgName>
								<orgName type="institution">University of Washington</orgName>
								<address>
									<postBox>Box 352350</postBox>
									<postCode>98195-2350</postCode>
									<settlement>Seattle</settlement>
									<region>WA</region>
									<country key="US">U.S.A</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Mining High-Speed Data Streams</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>H.2.8 [Database Management]: Database Applicationsdata mining</term>
					<term>I.2.6 [Artificial Intelligence]: Learningconcept learning</term>
					<term>I.5.2 [Pattern Recognition]: Design Methodology-classifier design and evaluation Decision trees, Hoeffding bounds, incremental learning, diskbased algorithms, subsampling</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Many organizations today have more than very large databases; they have databases that grow without limit at a rate of several million records per day. Mining these continuous data streams brings unique opportunities, but also new challenges. This paper describes and evaluates VFDT, an anytime system that builds decision trees using constant memory and constant time per example. VFDT can incorporate tens of thousands of examples per second using off-the-shelf hardware. It uses Hoeffding bounds to guarantee that its output is asymptotically nearly identical to that of a conventional learner. We study VFDT&apos;s properties and demonstrate its utility through an extensive set of experiments on synthetic data. We apply VFDT to mining the continuous stream of Web access data from the whole University of Washington main campus.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Knowledge discovery systems are constrained by three main limited resources: time, memory and sample size. In traditional applications of machine learning and statistics, sample size tends to be the dominant limitation: the computational resources for a massive search are available, but carrying out such a search over the small samples available (typically less than 10,000 examples) often leads to overfitting or "data dredging" (e.g., <ref type="bibr" target="#b21">[22,</ref><ref type="bibr" target="#b15">16]</ref>). Thus overfitting avoidance becomes the main concern, and only a fraction of the available computational power is used <ref type="bibr" target="#b2">[3]</ref>. In contrast, in many (if not most) present-day data mining applications, the bottleneck is time and memory, not examples. The latter are typically in over-supply, in the sense that it is impossible with current KDD systems to make use of all of them within the available computational resources. As a result, most of the available examples go unused, and underfitting may result: enough data to model very complex phenomena is available, but inappropriately simple models are produced because we are unable to take full advantage of the data. Thus the development of highly efficient algorithms becomes a priority.</p><p>Currently, the most efficient algorithms available (e.g., <ref type="bibr" target="#b16">[17]</ref>) concentrate on making it possible to mine databases that do not fit in main memory by only requiring sequential scans of the disk. But even these algorithms have only been tested on up to a few million examples. In many applications this is less than a day's worth of data. For example, every day retail chains record millions of transactions, telecommunications companies connect millions of calls, large banks process millions of ATM and credit card operations, and popular Web sites log millions of hits. As the expansion of the Internet continues and ubiquitous computing becomes a reality, we can expect that such data volumes will become the rule rather than the exception. Current data mining systems are not equipped to cope with them. When new examples arrive at a higher rate than they can be mined, the quantity of unused data grows without bounds as time progresses. Even simply preserving the examples for future use can be a problem when they need to be sent to tertiary storage, are easily lost or corrupted, or become unusable when the relevant contextual information is no longer available. When the source of examples is an open-ended data stream, the notion of mining a database of fixed size itself becomes questionable.</p><p>Ideally, we would like to have KDD systems that operate continuously and indefinitely, incorporating examples as they arrive, and never losing potentially valuable information. Such desiderata are fulfilled by incremental learning methods (also known as online, successive or sequential methods), on which a substantial literature exists. However, the available algorithms of this type (e.g., <ref type="bibr" target="#b19">[20]</ref>) have significant shortcomings from the KDD point of view. Some are reasonably efficient, but do not guarantee that the model learned will be similar to the one obtained by learning on the same data in batch mode. They are highly sensitive to example ordering, potentially never recovering from an unfavorable set of early examples. Others produce the same model as the batch version, but at a high cost in efficiency, often to the point of being slower than the batch algorithm. This paper proposes Hoeffding trees, a decision-tree learning method that overcomes this trade-off. Hoeffding trees can be learned in constant time per example (more precisely, in time that is worst-case proportional to the number of attributes), while being nearly identical to the trees a conventional batch learner would produce, given enough examples. The probability that the Hoeffding and conventional tree learners will choose different tests at any given node decreases exponentially with the number of examples. We also describe and evaluate VFDT, a decision-tree learning system based on Hoeffding trees. VFDT is I/O bound in the sense that it mines examples in less time than it takes to input them from disk. It does not store any examples (or parts thereof) in main memory, requiring only space proportional to the size of the tree and associated sufficient statistics. It can learn by seeing each example only once, and therefore does not require examples from an online stream to ever be stored. It is an anytime algorithm in the sense that a ready-to-use model is available at any time after the first few examples are seen, and its quality increases smoothly with time.</p><p>The next section introduces Hoeffding trees and studies their properties. We then describe the VFDT system and its empirical evaluation. The paper concludes with a discussion of related and future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">HOEFFDING TREES</head><p>The classification problem is generally defined as follows. A set of N training examples of the form (x, y) is given, where y is a discrete class label and x is a vector of d attributes, each of which may be symbolic or numeric. The goal is to produce from these examples a model y = f (x) that will predict the classes y of future examples x with high accuracy. For example, x could be a description of a client's recent purchases, and y the decision to send that customer a catalog or not; or x could be a record of a cellular-telephone call, and y the decision whether it is fraudulent or not. One of the most effective and widely-used classification methods is decision tree learning <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b14">15]</ref>. Learners of this type induce models in the form of decision trees, where each node contains a test on an attribute, each branch from a node corresponds to a possible outcome of the test, and each leaf contains a class prediction. The label y = DT (x) for an example x is obtained by passing the example down from the root to a leaf, testing the appropriate attribute at each node and following the branch corresponding to the attribute's value in the example. A decision tree is learned by recursively replacing leaves by test nodes, starting at the root. The attribute to test at a node is chosen by comparing all the available attributes and choosing the best one according to some heuristic measure. Classic decision tree learners like ID3, C4.5 and CART assume that all training examples can be stored simultaneously in main memory, and are thus severely limited in the number of examples they can learn from. Disk-based decision tree learners like SLIQ <ref type="bibr" target="#b9">[10]</ref> and SPRINT <ref type="bibr" target="#b16">[17]</ref> assume the examples are stored on disk, and learn by repeatedly reading them in sequentially (effectively once per level in the tree). While this greatly increases the size of usable training sets, it can become prohibitively ex-pensive when learning complex trees (i.e., trees with many levels), and fails when datasets are too large to fit in the available disk space.</p><p>Our goal is to design a decision tree learner for extremely large (potentially infinite) datasets. This learner should require each example to be read at most once, and only a small constant time to process it. This will make it possible to directly mine online data sources (i.e., without ever storing the examples), and to build potentially very complex trees with acceptable computational cost. We achieve this by noting with Catlett <ref type="bibr" target="#b1">[2]</ref> and others that, in order to find the best attribute to test at a given node, it may be sufficient to consider only a small subset of the training examples that pass through that node. Thus, given a stream of examples, the first ones will be used to choose the root test; once the root attribute is chosen, the succeeding examples will be passed down to the corresponding leaves and used to choose the appropriate attributes there, and so on recursively. <ref type="bibr" target="#b0">1</ref> We solve the difficult problem of deciding exactly how many examples are necessary at each node by using a statistical result known as the Hoeffding bound (or additive Chernoff bound) <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b8">9]</ref>. Consider a real-valued random variable r whose range is R (e.g., for a probability the range is one, and for an information gain the range is log c, where c is the number of classes). Suppose we have made n independent observations of this variable, and computed their mean r. The Hoeffding bound states that, with probability 1 − δ, the true mean of the variable is at least r − , where</p><formula xml:id="formula_0">= R 2 ln(1/δ) 2n<label>(1)</label></formula><p>The Hoeffding bound has the very attractive property that it is independent of the probability distribution generating the observations. The price of this generality is that the bound is more conservative than distribution-dependent ones (i.e., it will take more observations to reach the same δ and ). Let G(Xi) be the heuristic measure used to choose test attributes (e.g., the measure could be information gain as in C4.5, or the Gini index as in CART). Our goal is to ensure that, with high probability, the attribute chosen using n examples (where n is as small as possible) is the same that would be chosen using infinite examples. Assume G is to be maximized, and let Xa be the attribute with highest observed G after seeing n examples, and X b be the second-best attribute. Let ∆G = G(Xa) − G(X b ) ≥ 0 be the difference between their observed heuristic values. Then, given a desired δ, the Hoeffding bound guarantees that Xa is the correct choice with probability 1 − δ if n examples have been seen at this node and ∆G &gt; . <ref type="bibr" target="#b1">2</ref> In other words, if the ob-served ∆G &gt; then the Hoeffding bound guarantees that the true ∆G ≥ ∆G − &gt; 0 with probability 1 − δ, and therefore that Xa is indeed the best attribute with probability 1 − δ. This is valid as long as the G value for a node can be viewed as an average of G values for the examples at that node, as is the case for the measures typically used. Thus a node needs to accumulate examples from the stream until becomes smaller than ∆G. (Notice that is a monotonically decreasing function of n.) At this point the node can be split using the current best attribute, and succeeding examples will be passed to the new leaves. This leads to the Hoeffding tree algorithm, shown in pseudo-code in <ref type="table" target="#tab_0">Table 1</ref>.</p><p>The counts n ijk are the sufficient statistics needed to compute most heuristic measures; if other quantities are required, they can be similarly maintained. Pre-pruning is carried out by considering at each node a "null" attribute X ∅ that consists of not splitting the node. Thus a split will only be made if, with confidence 1−δ, the best split found is better according to G than not splitting. The pseudo-code shown is only for discrete attributes, but its extension to numeric ones is immediate, following the usual method of allowing tests of the form "(Xi &lt; xij)?," and computing G for each allowed threshold xij. The sequence of examples S may be infinite, in which case the procedure never terminates, and at any point in time a parallel procedure can use the current tree HT to make class predictions. If d is the number of attributes, v is the maximum number of values per attribute, and c is the number of classes, the Hoeffding tree algorithm requires O(dvc) memory to store the necessary counts at each leaf. If l is the number of leaves in the tree, the total memory required is O(ldvc). This is independent of the number of examples seen, if the size of the tree depends only on the "true" concept and is independent of the size of the training set. (Although this is a common assumption in the analysis of decision-tree and related algorithms, it often fails in practice. Section 3 describes a refinement to the algorithm to cope with this.)</p><p>A key property of the Hoeffding tree algorithm is that it is possible to guarantee under realistic assumptions that the trees it produces are asymptotically arbitrarily close to the ones produced by a batch learner (i.e., a learner that uses all the examples to choose a test at each node). In other words, the incremental nature of the Hoeffding tree algorithm does not significantly affect the quality of the trees it produces. In order to make this statement precise, we need to define the notion of disagreement between two decision trees. Let P (x) be the probability that the attribute vector (loosely, example) x will be observed, and let I(.) be the indicator function, which returns 1 if its argument is true and 0 otherwise.</p><formula xml:id="formula_1">Definition 1.</formula><p>The extensional disagreement ∆e between two decision trees DT1 and DT2 is the probability that they will produce different class predictions for an example:</p><formula xml:id="formula_2">∆e(DT1, DT2) = x P (x)I[DT1(x) = DT2(x)]</formula><p>Consider that two internal nodes are different if they contain different tests, two leaves are different if they contain different class predictions, and an internal node is different is a set of discrete attributes, G(.) is a split evaluation function, δ is one minus the desired probability of choosing the correct attribute at any given node. Output: HT is a decision tree.</p><p>Procedure HoeffdingTree (S, X, G, δ) Let HT be a tree with a single leaf l1 (the root). Let X1 = X ∪ {X ∅ }. Let G1(X ∅ ) be the G obtained by predicting the most frequent class in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>For each class y k</head><p>For each value xij of each attribute Xi ∈ X Let n ijk (l1) = 0. For each example (x, y k ) in S Sort (x, y) into a leaf l using HT . For each xij in x such that Xi ∈ X l Increment n ijk (l). Label l with the majority class among the examples seen so far at l. If the examples seen so far at l are not all of the same class, then Compute G l (Xi) for each attribute Xi ∈ X l − {X ∅ } using the counts n ijk (l). Let Xa be the attribute with highest G l . Let X b be the attribute with second-highest G l . Compute using Equation 1.</p><formula xml:id="formula_3">If G l (Xa) − G l (X b ) &gt; and Xa = X ∅ , then</formula><p>Replace l by an internal node that splits on Xa.</p><p>For each branch of the split Add a new leaf lm, and let Xm = X − {Xa}. Let Gm(X ∅ ) be the G obtained by predicting the most frequent class at lm. For each class y k and each value xij of each attribute Xi ∈ Xm − {X ∅ } Let n ijk (lm) = 0. Return HT . from a leaf. Consider also that two paths through trees are different if they differ in length or in at least one node.</p><p>Definition 2. The intensional disagreement ∆i between two decision trees DT1 and DT2 is the probability that the path of an example through DT1 will differ from its path through DT2:</p><formula xml:id="formula_4">∆i(DT1, DT2) = x P (x)I[Path1(x) = Path2(x)]</formula><p>where Pathi(x) is the path of example x through tree DTi.</p><p>Two decision trees agree intensionally on an example iff they are indistinguishable for that example: the example is passed down exactly the same sequence of nodes, and receives an identical class prediction. Intensional disagreement is a stronger notion than extensional disagreement, in the sense that ∀DT 1 ,DT 2 ∆i(DT1, DT2) ≥ ∆e(DT1, DT2).</p><p>Let p l be the probability that an example that reaches level l in a decision tree falls into a leaf at that level. To simplify, we will assume that this probability is constant, i.e., ∀ l p l = p, where p will be termed the leaf probability. This is a realistic assumption, in the sense that it is typically approximately true for the decision trees that are generated in practice. Let HT δ be the tree produced by the Hoeffding tree algorithm with desired probability δ given an infinite sequence of examples S, and DT * be the asymptotic batch decision tree induced by choosing at each node the attribute with true greatest G (i.e., by using infinite examples at each node). Let E[∆i(HT δ , DT * )] be the expected value of ∆i(HT δ , DT * ), taken over all possible infinite training sequences. We can then state the following result. Theorem 1. If HT δ is the tree produced by the Hoeffding tree algorithm with desired probability δ given infinite examples <ref type="table" target="#tab_0">(Table 1)</ref>, DT * is the asymptotic batch tree, and p is the leaf probability, then E[∆i(HT δ , DT * )] ≤ δ/p.</p><p>Proof. For brevity, we will refer to intensional disagreement simply as disagreement. Consider an example x that falls into a leaf at level l h in HT δ , and into a leaf at level </p><formula xml:id="formula_5">l d in DT * . Let l = min{l h , l d }. Let PathH (x) = (N H 1 (x), N H 2 (x), . . . , N H l (x)) be x's path through HT δ up to level l, where N H i (x)</formula><formula xml:id="formula_6">(l h = l d ) is included in P (N H l (x) = N D l (x)|I l−1 )</formula><p>, because if the two paths have different lengths then one tree must have a leaf where the other has an internal node. Then, omitting the dependency of the nodes on x for brevity,</p><formula xml:id="formula_7">P (PathH (x) = PathD(x)) = P (N H 1 = N D 1 ∨ N H 2 = N D 2 ∨ . . . ∨ N H l = N D l ) = P (N H 1 = N D 1 |I0) + P (N H 2 = N D 2 |I1) + . . . +P (N H l = N D l |I l−1 ) = l i=1 P (N H i = N D i |Ii−1) ≤ l i=1 δ = δl<label>(2)</label></formula><p>Let HT δ (S) be the Hoeffding tree generated from training sequence S. Then E[∆i(HT δ , DT * )] is the average over all infinite training sequences S of the probability that an example's path through HT δ (S) will differ from its path through DT * :</p><formula xml:id="formula_8">E[∆i(HT δ , DT * )] = S P (S) x P (x) I[PathH(x) = PathD(x)] = x P (x) P (PathH (x) = PathD(x)) = ∞ i=1 x∈L i P (x) P (PathH(x) = PathD(x))<label>(3)</label></formula><p>where Li is the set of examples that fall into a leaf of DT * at level i. According to Equation 2, the probability that an example's path through HT δ (S) will differ from its path through DT * , given that the latter is of length i, is at most δi (since i ≥ l). Thus</p><formula xml:id="formula_9">E[∆i(HT δ , DT * )] ≤ ∞ i=1 x∈L i P (x)(δi) = ∞ i=1 (δi) x∈L i P (x)<label>(4)</label></formula><p>The sum x∈L i P (x) is the probability that an example x will fall into a leaf of DT * at level i, and is equal to (1 − p) i−1 p, where p is the leaf probability. Therefore</p><formula xml:id="formula_10">E[∆i(HT δ , DT * )] ≤ ∞ i=1 (δi)(1 − p) i−1 p = δp ∞ i=1 i(1 − p) i−1 = δp ¡ ∞ i=1 (1 − p) i−1 + ∞ i=2 (1 − p) i−1 + • • • + ∞ i=k (1 − p) i−1 + • • • ¢ = δp £ 1 p + 1 − p p + • • • + (1 − p) k−1 p + • • • ¤ = δ ¥ 1 + (1 − p) + • • • + (1 − p) k−1 + • • • ¦ = δ ∞ i=0 (1 − p) i = δ p<label>(5)</label></formula><p>This completes the demonstration of Theorem 1. § An immediate corollary of Theorem 1 is that the expected extensional disagreement between HT δ and DT * is also asymptotically at most δ/p (although in this case the bound is much looser). Another corollary (whose proof we omit here in the interests of space) is that there exists a subtree of the asymptotic batch tree such that the expected disagreement between it and the Hoeffding tree learned on finite data is at most δ/p. In other words, if δ/p is small then the Hoeffding tree learned on finite data is very similar to a subtree of the asymptotic batch tree. A useful application of Theorem 1 is that, instead of δ, users can now specify as input to the Hoeffding tree algorithm the maximum expected disagreement they are willing to accept, given enough examples for the tree to settle. The latter is much more meaningful, and can be intuitively specified without understanding the workings of the algorithm or the Hoeffding bound. The algorithm will also need an estimate of p, which can easily be obtained (for example) by running a conventional decision tree learner on a manageable subset of the data. How practical are these bounds? Suppose that the best and second-best attribute differ by 10% (i.e., /R = 0.1). Then, according to Equation 1, ensuring δ = 0.1% requires 380 examples, and ensuring δ = 0.0001% requires only 345 additional examples. An exponential improvement in δ, and therefore in expected disagreement, can be obtained with a linear increase in the number of examples. Thus, even with very small leaf probabilities (i.e., very large trees), very good agreements can be obtained with a relatively small number of examples per node. For example, if p = 0.01%, an expected disagreement of at most 1% can be guaranteed with 725 examples per node. If p = 1%, the same number of examples guarantees a disagreement of at most 0.01%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">THE VFDT SYSTEM</head><p>We have implemented a decision-tree learning system based on the Hoeffding tree algorithm, which we call VFDT (Very Fast Decision Tree learner). VFDT allows the use of either information gain or the Gini index as the attribute evaluation measure. It includes a number of refinements to the algorithm in <ref type="table" target="#tab_0">Table 1</ref>:</p><formula xml:id="formula_11">Ties.</formula><p>When two or more attributes have very similar G's, potentially many examples will be required to decide between them with high confidence. This is presumably wasteful, because in this case it makes little difference which attribute is chosen. Thus VFDT can optionally decide that there is effectively a tie and split on the current best attribute if ∆G &lt; &lt; τ , where τ is a user-specified threshold.</p><p>G computation. The most significant part of the time cost per example is recomputing G. It is inefficient to recompute G for every new example, because it is unlikely that the decision to split will be made at that specific point. Thus VFDT allows the user to specify a minimum number of new examples nmin that must be accumulated at a leaf before G is recomputed. This effectively reduces the global time spent on G computations by a factor of nmin, and can make learning with VFDT nearly as fast as simply classifying the training examples. Notice, however, that it will have the effect of implementing a smaller δ than the one specified by the user, because examples will be accumulated beyond the strict minimum required to choose the correct attribute with confidence 1 − δ. (This increases the time required to build a node, but our experiments show that the net effect is still a large speedup.) Because δ shrinks exponentially fast with the number of examples, the difference could be large, and the δ input to VFDT should be correspondingly larger than the target.</p><p>Memory. As long as VFDT processes examples faster than they arrive, which will be the case in all but the most demanding applications, the sole obstacle to learning arbitrarily complex models will be the finite RAM available. VFDT's memory use is dominated by the memory required to keep counts for all growing leaves. If the maximum available memory is ever reached, VFDT deactivates the least promising leaves in order to make room for new ones. If p l is the probability that an arbitrary example will fall into leaf l, and e l is the observed error rate at that leaf, then p l e l is an upper bound on the error reduction achievable by refining the leaf. p l e l for a new leaf is estimated using the counts at the parent for the corresponding attribute value. The least promising leaves are considered to be the ones with the lowest values of p l e l . When a leaf is deactivated, its memory is freed, except for a single number required to keep track of p l e l . A leaf can then be reactivated if it becomes more promising than currently active leaves. This is accomplished by, at regular intervals, scanning through all the active and inactive leaves, and replacing the least promising active leaves with the inactive ones that dominate them.</p><p>Poor attributes. Memory usage is also minimized by dropping early on attributes that do not look promising. As soon as the difference between an attribute's G and the best one's becomes greater than , the attribute can be dropped from consideration, and the memory used to store the corresponding counts can be freed.</p><p>Initialization. VFDT can be initialized with the tree produced by a conventional RAM-based learner on a small subset of the data. This tree can either be input as is, or over-pruned to contain only those nodes that VFDT would have accepted given the number of examples at them. This can give VFDT a "head start" that will allow it to reach the same accuracies at smaller numbers of examples throughout the learning curve.</p><p>Rescans. VFDT can rescan previously-seen examples. This option can be activated if either the data arrives slowly enough that there is time for it, or if the dataset is finite and small enough that it is feasible to scan it multiple times. This means that VFDT need never grow a smaller (and potentially less accurate) tree than other algorithms because of using each example only once.</p><p>The next section describes an empirical study of VFDT, where the utility of these refinements is evaluated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EMPIRICAL STUDY 4.1 Synthetic data</head><p>A system like VFDT is only useful if it is able to learn more accurate trees than a conventional system, given similar computational resources. In particular, it should be able to use to advantage the examples that are beyond a conventional system's ability to process. In this section we test this empirically by comparing VFDT with C4.5 release 8 <ref type="bibr" target="#b14">[15]</ref> on a series of synthetic datasets. Using these allows us to freely vary the relevant parameters of the learning process. In order to ensure a fair comparison, we restricted the two systems to using the same amount of RAM. This was done by setting VFDT's "available memory" parameter to 40MB, and giving C4.5 the maximum number of examples that would fit in the same memory (100k examples). <ref type="bibr" target="#b2">3</ref> VFDT used information gain as the G function. Fourteen concepts were used for comparison, all with two classes and 100 binary attributes. The concepts were created by randomly generating decision trees as follows. At each level after the first three, a fraction f of the nodes was replaced by leaves; the rest became splits on a random attribute (that had not been used yet on a path from the root to the node being considered). When the decision tree reached a depth of 18, all the remaining growing nodes were replaced with leaves. Each leaf was randomly assigned a class. The size of the resulting concepts ranged from 2.2k leaves to 61k leaves with a median of 12.6k. A stream of training examples was then generated by sampling uniformly from the instance space, and assigning classes according to the target tree. We added various levels of class and attribute noise to the training examples, from 0 to 30%. <ref type="bibr" target="#b3">4</ref> (A noise level of n% means that each class/attribute value has a probability of n% of being reassigned at random, with equal probability for all values, including the original one.) In each run, 50k separate examples were used for testing. C4.5 was run with all default settings. We ran our experiments on two Pentium 6/200 MHz, one Pentium II/400 MHz, and one Pentium III/500 MHz machine, all running Linux. <ref type="figure" target="#fig_2">Figure 1</ref> shows the accuracy of the learners averaged over all the runs. VFDT was run with δ = 10 −7 , τ = 5%, nmin = 200, no leaf reactivation, and no rescans. VFDTboot is VFDT bootstrapped with an over-pruned version of the tree produced by C4.5. C4.5 is more accurate than VFDT up to 25k examples, and the accuracies of the two systems are similar in the range from 25k to 100k examples (at which point C4.5 is unable to consider further examples). Most significantly, VFDT is able to take advantage of the examples after 100k to greatly improve accuracy (88.7% for VFDT and 88.8% for VFDT-boot, vs. 76.5% for C4.5). C4.5's early advantage comes from the fact it reuses examples to make decisions on multiple levels of the tree it is inducing, while VFDT uses each example only once. As expected, VFDT-boot's initialization lets it achieve high accuracy more quickly than without it. However, VFDT-boot's performance is surprising in that its accuracy is much higher than C4.5's at 100k examples, when VFDT-boot has not seen any examples that C4.5 did not. An explanation for this is that many of the experiments reported in <ref type="figure" target="#fig_2">Figure 1</ref> contained noise, and, as Catlett <ref type="bibr" target="#b1">[2]</ref> showed, over-pruning can be very effective at reducing overfitting in noisy domains. <ref type="figure" target="#fig_3">Figure 2</ref> shows the average number of nodes in the trees induced by each of the learners. Notice that VFDT and VFDT-boot induce trees with similar numbers of nodes, and that both achieve greater accuracy with far fewer nodes than C4.5. This suggests that using VFDT can substantially increase the comprehensibility of the trees induced relative to C4.5. It also suggests that VFDT is less prone than C4.5 to overfitting noisy data.      <ref type="figure" target="#fig_6">Figure 4</ref> shows how the algorithms compare on six concepts of varying size. <ref type="bibr" target="#b4">5</ref> All the training sets had 10% noise. As before, C4.5's results are for learning on 100k examples, while VFDT and VFDT-boot's are for 20 million. Both versions of VFDT do better than C4.5 on every concept size considered. However, contrary to what we would expect, as concept size increases the relative benefit seems to remain approximately constant for VFDT and VFDT-boot. Looking deeper, we find that with 20 million examples VFDT and VFDT-boot induce trees with approximately 9k nodes regardless of the size of the underlying concept. This suggests that they would take good advantage of even more training examples.</p><p>We carried out all runs without ever writing VFDT's training examples to disk (i.e., generating them on the fly and passing them directly to VFDT). For time comparison purposes, however, we measured the time it takes VFDT to read examples from the (0.25, 0.10, 25209, 12605) data set from disk on the Pentium III/500 MHz machine. VFDT takes 5752 seconds to read the 20 million examples, and 625 seconds to process them. In other words, learning time is about an order of magnitude less than input time. On the same runs, C4.5 takes 36 seconds to read and process 100k examples, and VFDT takes 47 seconds.</p><p>Finally, we generated 160 million examples from the (0.25, 0.10, 25209, 12605) concept. <ref type="figure" target="#fig_7">Figure 5</ref> compares VFDT and C4.5 on this data set. VFDT makes progress over the entire data set, but begins to asymptote after 10 million examples; the final 150 million examples contribute 0.58% to accuracy. VFDT took 9501 seconds to process the examples (excluding I/O) and induced 21.9k leaves. In the near future we plan to carry out similar runs with more complex concepts and billions of examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Lesion studies</head><p>We conducted a series of lesion studies to evaluate the effectiveness of some of the components and parameters of the VFDT system. <ref type="figure" target="#fig_9">Figure 6</ref> shows the accuracy of the learners on the (0.25, 0.00, 25209, 12605) data set. It also shows a slight modification to the VFDT-boot algorithm, where the tree produced by C4.5 is used without first over-pruning it. All versions of VFDT were run with δ = 10 −7 , τ = 5%, nmin = 200, no leaf reactivation, and no rescans. C4.5 does better without noise than with it, but VFDT is still able to use additional data to significantly improve accuracy. VFDT-boot with the "no over-prune" setting is initially better than the over-pruning version, but does not make much progress and is eventually overtaken. We hypothesize that this is because it has difficulty overcoming the poor low-confidence decisions C4.5 made near its leaves.</p><p>In the remainder of the lesion studies VFDT was run on the (0.25, 0.10, 25209, 12605) data set with δ = 10 −7 , τ = 5%, nmin = 200, no leaf reactivation, and no rescans. We evaluated the effect of disabling ties, so that VFDT does not make any splits until it is able to identify a clear winner. <ref type="bibr" target="#b4">5</ref> The concept (0.15, 0.10, 74449, 37225) turned out to be atypically easy, and is not included in the graph to avoid obscuring the trend. The observed accuracies for this concept were: C4.5 -83.1%; VFDT -89.0%; VFDT-boot -89.7%.    We conducted two runs, holding all parameters constant except that the second run never split with a tie. Without ties VFDT induced a tree with only 65 nodes and 72.9% accuracy, compared to 8k nodes and 86.9% accuracy with ties. VFDT-boot without ties produced 805 nodes and 83.3% accuracy, compared to 8k nodes and 88.5% accuracy with ties. We also carried out two runs holding all parameters constant except nmin, the number of new examples that must be seen at a node before G's are recomputed. The first run recomputed G every 200 examples (nmin = 200), and the second did it for every example (nmin = 1). Doing the G computations for every example, VFDT gained 1.1% accuracy and took 3.8 times longer to run. VFDT-boot lost 0.9% accuracy and took 3.7 times longer. Both learners induced about 5% more nodes with the more frequent G computations. We then carried out two runs holding all parameters but VFDT's memory limit constant. The first run was allowed 40 MB of memory; the second was allowed 80 MB. VFDT and VFDT-boot both induced 7.8k more nodes with the additional memory, which improved VFDT's accuracy by 3.0% and VFDT-boot's by 3.2%. Finally, we carried out two runs holding all parameters but δ constant. The first run had a delta of 10 −2 , and the second had a delta of 10 −7 . With the lower δ, VFDT and VFDT-boot both induced about 30% fewer nodes than with the higher one. VFDT's accuracy was 2.3% higher and VFDT-boot's accuracy was 1.0% higher with the lower δ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Web data</head><p>We are currently applying VFDT to mining the stream of Web page requests emanating from the whole University of Washington main campus. The nature of the data is described in detail in <ref type="bibr" target="#b22">[23]</ref>. In our experiments so far we have used a one-week anonymized trace of all the external web accesses made from the university campus. There were 23,000 active clients during this one-week trace period, and the entire university population is estimated at 50,000 people (students, faculty and staff). The trace contains 82.8 million requests, which arrive at a peak rate of 17,400 per minute. The size of the compressed trace file is about 20 GB. <ref type="bibr" target="#b5">6</ref> Each request is tagged with an anonymized organization ID that associates the request with one of the 170 organizations (colleges, departments, etc.) within the university. One purpose this data can be used for is to improve Web caching. The key to this is predicting as accurately as possible which hosts and pages will be requested in the near future, given recent requests. We applied decisiontree learning to this problem in the following manner. We split the campus-wide request log into a series of equal time slices T0, T1, . . . , Tt, . . . ; in the experiments we report, each time slice is an hour. For each organization O1, O2, . . . , Oi, . . . , O170 and each of the 244k hosts appearing in the logs H1, . . . , Hj, . . . , H 244k , we maintain a count of how many times the organization accessed the host in the time slice, Cijt. We discretize these counts into four buckets, representing "no requests," "1 -12 requests," "13 -25 requests" and "26 or more requests." Then for each time slice and host accessed in that time slice (Tt, Hj ) we generate an example with attributes t mod 24, C1,jt, . . . , Cijt, .  and class 1 if Hj is requested in time slice Tt+1 and 0 if it is not. This can be carried out in real time using modest resources by keeping statistics on the last and current time slices Ct−1 and Ct in memory, only keeping counts for hosts that actually appear in a time slice (we never needed more than 30k counts), and outputting the examples for Ct−1 as soon as Ct is complete. Using this procedure we obtained a dataset containing 1.89 million examples, 61.1% of which were labeled with the most common class (that the host did not appear again in the next time slice).</p><p>Testing was carried out on the examples from the last day (276,230 examples). VFDT was run with δ = 10 −7 , τ = 5%, and nmin = 200. All runs were carried out on a 400 MHz Pentium machine. A decision stump (a decision tree with only one node) obtains 64.2% accuracy on this data. The decision stump took 1277 seconds to learn, and VFDT took 1450 seconds to do one pass over the training data (after being initialized with C4.5's over-pruned tree). The majority of this time (983 seconds) was spent reading data from disk. The bootstrap run of C4.5 took 2975 seconds to learn on a subsample of 74.5k examples (as many as would fit in 40 MB of RAM) and achieved 73.3% accuracy. Thus VFDT learned faster on 1.61 million examples than C4.5 did on 75k. We also used a machine with 1 GB of RAM to run C4.5 on the entire 1.61 million training examples; the run took 24 hours and the resulting tree was 75% accurate. <ref type="figure" target="#fig_10">Figure 7</ref> shows VFDT-boot's performance on this dataset, using 1 GB of RAM. We extended VFDT's run out to 4 million examples by rescanning. The x axis shows the number of examples presented to VFDT after the C4.5 bootstrap phase was complete. Accuracy improves steadily as more examples are seen. VFDT is able to achieve accuracy similar to C4.5's in a small fraction of the time. Further, C4.5's memory requirements and batch nature will not allow it to scale to traces much larger than a week, while VFDT can easily incorporate data indefinitely. The next step is to apply VFDT to predicting page requests from a given host. We also plan to address issues related to time-changing behavior and then set VFDT running permanently, learning and relearning as dictated by the data stream.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RELATED WORK</head><p>Previous work on mining large databases using subsampling methods includes the following. Catlett <ref type="bibr" target="#b1">[2]</ref> proposed several heuristic methods for extending RAM-based batch decisiontree learners to datasets with up to hundreds of thousands of examples. Musick, Catlett and Russell <ref type="bibr" target="#b12">[13]</ref> proposed and tested (but did not implement in a learner) a theoretical model for choosing the size of subsamples to use in comparing attributes. Maron and Moore <ref type="bibr" target="#b8">[9]</ref> used Hoeffding bounds to speed selection of instance-based regression models via cross-validation (see also <ref type="bibr" target="#b11">[12]</ref>). Gratch's Sequential ID3 <ref type="bibr" target="#b5">[6]</ref> used a statistical method to minimize the number of examples needed to choose each split in a decision tree. (Sequential ID3's guarantees of similarity to the batch tree were much looser than those derived here for Hoeffding trees, and it was only tested on repeatedly sampled small datasets.) Gehrke et al.'s BOAT <ref type="bibr" target="#b4">[5]</ref> learned an approximate tree using a fixed-size subsample, and then refined it by scanning the full database. Provost et al. <ref type="bibr" target="#b13">[14]</ref> studied different strategies for mining larger and larger subsamples until accuracy (apparently) asymptotes. In contrast to systems that learn in main memory by subsampling, systems like SLIQ <ref type="bibr" target="#b9">[10]</ref> and SPRINT <ref type="bibr" target="#b16">[17]</ref> use all the data, and concentrate on optimizing access to disk by always reading examples (more precisely, attribute lists) sequentially. VFDT combines the best of both worlds, accessing data sequentially and using subsampling to potentially require much less than one scan, as opposed to many. This allows it to scale to larger databases than either method alone. VFDT has the additional advantages of being incremental and anytime: new examples can be quickly incorporated as they arrive, and a usable model is available after the first few examples and then progressively refined.</p><p>As mentioned previously, there is a large literature on incremental learning, which space limitations preclude reviewing here. The system most closely related to ours is Utgoff's <ref type="bibr" target="#b19">[20]</ref> ID5R (extended in <ref type="bibr" target="#b20">[21]</ref>). ID5R learns the same tree as ID3 (a batch method), by restructuring subtrees as needed. While its learning time is linear in the number of examples, it is worst-case exponential in the number of attributes. On the simple, noise-free problems it was tested on, it was much slower than ID3; noise would presumably aggravate this. Thus ID5R does not appear viable for learning from high-speed data streams.</p><p>A number of efficient incremental or single-pass algorithms for KDD tasks other than supervised learning have appeared in recent years (e.g., clustering <ref type="bibr" target="#b3">[4]</ref> and association rule mining <ref type="bibr" target="#b18">[19]</ref>). A substantial theoretical literature on online algorithms exists (e.g., <ref type="bibr" target="#b7">[8]</ref>), but it focuses on weak learners (e.g., linear separators), because little can be proved about strong ones like decision trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">FUTURE WORK</head><p>We plan to shortly compare VFDT with SPRINT/SLIQ. VFDT may outperform these even in fully disk-resident datasets, because it can learn in less than one scan while the latter require multiple scans, and the dominant component of their cost is often the time required to read examples from disk multiple times. VFDT's speed and anytime character make it ideal for interactive data mining; we plan to also study its application in this context (see <ref type="bibr" target="#b17">[18]</ref>). Other directions for future work include: further developing the application of VFDT to Web log data; studying other applications of VFDT (e.g., intrusion detection); using nondiscretized numeric attributes in VFDT; studying the use of post-pruning in VFDT; further optimizing VFDT's computations (e.g., by recomputing G's exactly when we can tell that the current example may cause the Hoeffding bound to be reached); using adaptive δ's; studying the use of an example cache in main memory to speed induction by reusing examples at multiple levels; comparing VFDT to ID5R and other incremental algorithms; adapting VFDT to learn evolving concepts in time-changing domains; adapting VFDT to learning with imbalanced classes and asymmetric misclassification costs; adapting VFDT to the extreme case where even the final decision tree (without any stored sufficient statistics) does not fit in main memory; parallelizing VFDT; applying the ideas described here to other types of learning (e.g., rule induction, clustering); etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">CONCLUSION</head><p>This paper introduced Hoeffding trees, a method for learning online from the high-volume data streams that are increasingly common. Hoeffding trees allow learning in very small constant time per example, and have strong guarantees of high asymptotic similarity to the corresponding batch trees.</p><p>VFDT is a high-performance data mining system based on Hoeffding trees. Empirical studies show its effectiveness in taking advantage of massive numbers of examples. VFDT's application to a high-speed stream of Web log data is under way.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>is the node that x goes through at level i in HT δ , and similarly for PathD(x), x's path through DT * . If l = l h then N H l (x) is a leaf with a class prediction, and similarly for N D l (x) if l = l d . Let Ii represent the proposition "PathH(x) = PathD(x) up to and including level i," with I0 = True. Notice that P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 4</head><label>3</label><figDesc>shows how the algorithms respond to noise. It compares four runs on the same concept (with 12.6k leaves), but with increasing levels of noise added to the training examples. C4.5's accuracy reports are for training sets with 100k examples, and VFDT and VFDT-boot's are for training sets of 20 million examples. VFDT's advantage compared to C4.5 increases with the noise level. This is further evidence that use of the Hoeffding bound is an effective pruning method. The exact concepts used were, in the form (f , noise level, #nodes, #leaves): (0.15, 0.10, 74449, 37225), (0.15, 0.10, 13389, 6695), (0.17, 0.10, 78891, 39446), (0.17, 0.10, 93391, 46696), (0.25, 0.00, 25209, 12605), (0.25, 0.20, 25209, 12605), (0.25, 0.30, 25209, 12605), (0.25, 0.00, 15917, 7959), (0.25, 0.10, 31223, 15612), (0.25, 0.15, 16781, 8391), (0.25, 0.20, 4483, 2242), (0.28, 0.10, 122391, 61196), (0.28, 0.10, 6611, 3306), (0.25, 0.10, 25209, 12605). The last set of parameters was also used as the basis for the lesion studies reported below.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>Accuracy as a function of the number of training examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Tree size as a function of the number of training examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Accuracy as a function of the noise level.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>Accuracy as a function of the complexity of the true concept.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>VFDT trained on 160 million examples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6 :</head><label>6</label><figDesc>Effect of initializing VFDT with C4.5 with and without over-pruning.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Performance on Web data.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>The Hoeffding tree algorithm.</figDesc><table><row><cell>Inputs: S</cell><cell>is a sequence of examples,</cell></row><row><cell>X</cell><cell></cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">We assume the examples are generated by a stationary stochastic process (i.e., their distribution does not change over time). If the examples are being read from disk, we assume that they are in random order. If this is not the case, they should be randomized, for example by creating a random index and sorting on it.<ref type="bibr" target="#b1">2</ref> In this paper we assume that the third-best and lower attributes have sufficiently smaller gains that their probability of being the true best choice is negligible. We plan to lift this assumption in future work. If the attributes at a given node are (pessimistically) assumed independent, it simply involves a Bonferroni correction to δ<ref type="bibr" target="#b10">[11]</ref>.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">VFDT occasionally grew slightly beyond 40MB because the limit was only enforced on heap-allocated memory. C4.5 always exceeded 40MB by the size of the unpruned tree.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6">This log is from May 1999. Traffic in May 2000 was double this size; a one-week log was approximately 50 GB compressed.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This research was partly funded by an NSF CAREER award to the first author.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Classification and Regression Trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Breiman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Friedman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Olshen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Stone</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1984" />
			<pubPlace>Wadsworth, Belmont, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Megainduction: Machine Learning on Very Large Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Catlett</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<pubPlace>Sydney, Australia</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Basser Department of Computer Science, University of Sydney</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Overfitting and undercomputing in machine learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">G</forename><surname>Dietterich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computing Surveys</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="326" to="327" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Incremental clustering for mining in a data warehousing environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ester</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Kriegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wimmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fourth International Conference on Very Large Data Bases</title>
		<meeting>the Twenty-Fourth International Conference on Very Large Data Bases<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="323" to="333" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">BOAT: optimistic decision tree construction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gehrke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Ganti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Ramakrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W.-L</forename><surname>Loh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1999 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 1999 ACM SIGMOD International Conference on Management of Data<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Sequential inductive learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gratch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirteenth National Conference on Artificial Intelligence</title>
		<meeting>the Thirteenth National Conference on Artificial Intelligence<address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="779" to="786" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Probability inequalities for sums of bounded random variables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hoeffding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the American Statistical Association</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="13" to="30" />
			<date type="published" when="1963" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Learning quickly when irrelevant attributes abound: A new linear-threshold algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Littlestone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="285" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Hoeffding races: Accelerating model selection search for classification and function approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Maron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Neural Information Processing Systems 6</title>
		<editor>J. D. Cowan, G. Tesauro, and J. Alspector</editor>
		<meeting><address><addrLine>San Mateo, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">SLIQ: A fast scalable classifier for data mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mehta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rissanen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth International Conference on Extending Database Technology</title>
		<meeting>the Fifth International Conference on Extending Database Technology<address><addrLine>Avignon, France</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="18" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Simultaneous Statistical Inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">G</forename><surname>Miller</surname><genName>Jr</genName></persName>
		</author>
		<imprint>
			<date type="published" when="1981" />
			<publisher>Springer</publisher>
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
	<note>2nd edition</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient algorithms for minimizing cross validation error</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Moore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Conference on Machine Learning</title>
		<meeting>the Eleventh International Conference on Machine Learning<address><addrLine>New Brunswick, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="190" to="198" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Decision theoretic subsampling for induction on large databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Musick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Catlett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Russell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth International Conference on Machine Learning</title>
		<meeting>the Tenth International Conference on Machine Learning<address><addrLine>Amherst, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="212" to="219" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Efficient progressive sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Provost</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Oates</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fifth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>the Fifth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Quinlan</surname></persName>
		</author>
		<title level="m">C4.5: Programs for Machine Learning</title>
		<meeting><address><addrLine>San Mateo, CA</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Oversearching and layered search in empirical learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">R</forename><surname>Quinlan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Cameron-Jones</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence</title>
		<meeting>the Fourteenth International Joint Conference on Artificial Intelligence<address><addrLine>Montréal, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="1019" to="1024" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">SPRINT: A scalable parallel classifier for data mining</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Shafer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mehta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Conference on Very Large Databases</title>
		<meeting>the Twenty-Second International Conference on Very Large Databases<address><addrLine>Mumbai, India</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="544" to="555" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Anytime exploratory data analysis for massive data sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Smyth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wolpert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third International Conference on Knowledge Discovery and Data Mining</title>
		<meeting>the Third International Conference on Knowledge Discovery and Data Mining<address><addrLine>Newport Beach, CA</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="54" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Sampling large databases for association rules</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Toivonen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Conference on Very Large Data Bases</title>
		<meeting>the Twenty-Second International Conference on Very Large Data Bases<address><addrLine>Mumbai, India</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="134" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Incremental induction of decision trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Utgoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="161" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">An improved algorithm for incremental induction of decision trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Utgoff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Conference on Machine Learning</title>
		<meeting>the Eleventh International Conference on Machine Learning<address><addrLine>New Brunswick, NJ</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="318" to="325" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">OPUS: An efficient admissible algorithm for unordered search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">I</forename><surname>Webb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Artificial Intelligence Research</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="431" to="465" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Organization-based analysis of Web-object sharing and caching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wolman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Voelker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Cardwell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Landray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Pinnel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Karlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Levy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second USENIX Conference on Internet Technologies and Systems</title>
		<meeting>the Second USENIX Conference on Internet Technologies and Systems<address><addrLine>Boulder, CO</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
