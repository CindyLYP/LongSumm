<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Static Verification Framework for Message Passing in Go using Behavioural Types</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Lange</surname></persName>
							<email>j.s.lange@kent.ac.uk</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Ng</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernardo</forename><surname>Toninho</surname></persName>
							<email>b.toninho@imperial.ac.uk</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
							<email>n.yoshida@imperial.ac.uk</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">University of Kent</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">Imperial College London</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="institution">Imperial College London</orgName>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="institution">Imperial College London</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Static Verification Framework for Message Passing in Go using Behavioural Types</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3180155.3180157</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The Go programming language has been heavily adopted in industry as a language that efficiently combines systems programming with concurrency. Go&apos;s concurrency primitives, inspired by process calculi such as CCS and CSP, feature channel-based communication and lightweight threads, providing a distinct means of structuring concurrent software. Despite its popularity, the Go programming ecosystem offers little to no support for guaranteeing the correctness of message-passing concurrent programs. This work proposes a practical verification framework for message passing concurrency in Go by developing a robust static analysis that infers an abstract model of a program&apos;s communication behaviour in the form of a behavioural type, a powerful process calculi typing discipline. We make use of our analysis to deploy a model and termination checking based verification of the inferred behavioural type that is suitable for a range of safety and liveness properties of Go programs, providing several improvements over existing approaches. We evaluate our framework and its implementation on publicly available real-world Go code. CCS CONCEPTS • Theory of computation → Verification by model checking; Type theory; Process calculi; • Software and its engineering → Model checking; Automated static analysis; Software verification; Concurrent programming languages;</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Modern programming languages have evolved with the ever increasing need for highly available, interactive software services, providing programmers with frameworks that facilitate the development of such intricate communicating systems. Amongst these languages, the Go programming language created at Google in 2007 targets the development of concurrent software systems by integrating channel-based concurrency and lightweight threads as distinctive language features, greatly inspired by advances in formal languages for concurrency theory known as process calculi <ref type="bibr" target="#b41">[43]</ref>. Go enables programmers to write statically-typed concurrent software, and has been used successfully in a range of industrial settings such as Uber <ref type="bibr" target="#b43">[45]</ref> and Dropbox's infrastructure <ref type="bibr" target="#b13">[15]</ref>, the Docker <ref type="bibr">[14]</ref> software container platform, the Kubernetes <ref type="bibr" target="#b25">[27]</ref> cluster manager, among others <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b39">41]</ref>.</p><p>However, beyond its simple static type system, Go provides fairly few assurances on the correctness of concurrent code. At compile time, Go only enforces that messages exchanged via communication channels adhere to the declared channel payload types, providing no way of detecting common concurrency errors such as deadlocks or undelivered messages. At runtime, Go offers only a toy global deadlock detector. This is in sharp contrast with the rich body of work on process calculi-based verification, where a plethora of typebased and logic-based techniques enable reasoning about safety and liveness properties of interactive systems.</p><p>Given the foundations of Go's message-passing concurrency in process calculi, our work aims to bridge the divide between the foundations and programming practices by applying modern process calculi based verification techniques to real-world Go concurrent programming. Concretely, we propose a static verification framework for concurrency and message-passing communication using concurrent behavioural types <ref type="bibr" target="#b22">[24]</ref>, which have been developed extensively in concurrency theory since the early 90s.</p><p>To achieve this, we crucially address the substantial conceptual gap that exists between a formal mathematical language (a process calculus) and a general purpose programming language with concurrency features. Our approach analyses general Go source code and distills from programs behavioural types that serve as a faithful model of its message-passing concurrent behaviour. Our behavioural types consist of a simplified form of concurrent processes which are reminiscent of Concurrent Communicating Systems (CCS) <ref type="bibr" target="#b32">[34]</ref> or Communicating Sequential Processes (CSP) <ref type="bibr" target="#b20">[22]</ref> (which inspired the design of the Go language). Given such a formally grounded model, we may then apply a range of process calculi oriented verification techniques to Go. Specifically, we convert Go source code into a static single assignment (SSA) form which provides a fine-grained view of the concurrency primitives used in programs in a quasi-functional form <ref type="bibr" target="#b1">[2]</ref>, enabling our behavioural type inference. We then employ model checking and terminationchecking techniques to automatically verify safety and liveness properties such as deadlock-freedom and communication safety.</p><p>A significant advantage of our approach over previous works <ref type="bibr" target="#b28">[30,</ref><ref type="bibr" target="#b34">36,</ref><ref type="bibr" target="#b38">40]</ref> is that our inference procedure covers a much larger part of the Go language allowing for the automatic extraction of an accurate model of a program's concurrency-related features, resulting in a more precise analysis with reduced numbers of false alarms and undetected errors. Our integration with a general purpose model checker also enables us to modularly verify arbitrary safety and liveness properties, over the more single-minded nature of previously proposed techniques, as well as take advantage of advances in model checking to provide better performance scaling. Concurrent Programming in Go. We provide an overview of the Go programming language with an emphasis on the challenges of concurrent programming and how our verification framework can check for common concurrency errors in programs.</p><p>Go is a language with message-passing concurrency features and lightweight threads (known as goroutines). The key feature of Go's concurrency primitives is the predominance of channelbased communication over shared memory based communication amongst threads. In Go, a channel consists of a (typed) buffer that can be used by an arbitrary number of threads for read and write operations. Channels are synchronous by default (i.e. blocking on reads and writes) but can be made asynchronous by specifying a buffer size during channel creation. Asynchronous channels provide non-blocking sends while the buffer is not full.</p><p>We introduce the Go programming language with the program in <ref type="figure" target="#fig_0">Figure 1</ref> which implements a producer/consumer concurrent pattern with two producers and one consumer thread, communicating over a pair of synchronous channels. The producer code (lines 1-6) is written as a function that takes as a parameter a channel ch that can carry payloads of type int. A producer merely sends an integer value over the given communication channel ch (written ch &lt;-i in Go, where i is the value to be sent) a predetermined number of times (encoded as a for loop) and then closes the channel, signalling that no further values are to be sent.</p><p>The consumer code (lines 7-14) is specified as a function taking two channels ch1 and ch2 (one per producer). The cons function consists of a common Go idiom known as a for-select loop: a potentially infinite loop (the parameterless for on line 8) containing a selective communication construct (line 9). The behaviour of select is such that the consumer waits for an input on either ch1 or ch2 (inputs in Go are written &lt;-ch). Whenever communication is available, the appropriate case is selected. The consumer prints the received integer from either producer. Despite the channels being closed by the producers, the consumer's inputs still succeed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Go</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Source code</head><p>Inference Go SSA</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Behavioural types</head><p>Model Checker mCRL2 <ref type="bibr" target="#b9">[10]</ref> Termination Checker KITTeL <ref type="bibr" target="#b15">[17]</ref> Figure 2: The Godel Checker <ref type="bibr" target="#b29">[31]</ref> workflow.</p><p>Finally, the program entry point (main in lines 15-20) sets up the producers and consumer by creating the two synchronous channels ch1 and ch2 (line 16), spawning two producers in parallel (achieved by the go prefix to the function calls, which creates a goroutine that runs in parallel with the main program executing the prod function) and then running the cons function.</p><p>Common concurrency errors in Go. We describe common errors in channel-based Go programming, as well as limitations of Go's built-in runtime detector: Channel safety errors: Once a channel is closed, receive actions always succeed (receiving messages in-flight or a default value for the payload type), but all send and close actions performed on the channel raise a runtime error. Hence, channels should be closed at most once and no message should be sent on closed channels. Global deadlocks: The Go runtime contains a global deadlock detector that signals a runtime error when all goroutines in a program are stuck (i.e. deadlocked). However it is often the case that when certain libraries are imported (such as the commonly used net library for networking) the global deadlock detector is silently disabled <ref type="bibr" target="#b4">[5]</ref>, i.e. all global deadlocks are just ignored. Partial deadlocks: It is often the case that a program's communication cannot progress despite some of its goroutines not being stuck. This is known as a partial deadlock or as a failure of liveness. For instance, the cons function above is being executed with the wrong channels (ch1 twice instead of ch1 and ch2), due to a programmer error. Running the program results in a system that is not live, since the second producer is not interacting with the consumer -the outputs are never matched with their respective inputs. Since only a subset of the goroutines are stuck, these errors cannot be detected by the Go runtime.</p><p>A static verification framework for Go. This paper proposes a static analysis toolchain dubbed Godel Checker <ref type="bibr" target="#b29">[31]</ref>, which can automatically detect safety and liveness errors in real-world Go programs. The workflow is presented in <ref type="figure">Figure 2</ref>, consisting of three layers: given a Go program we first perform (1) behavioural type inference (detailed in § 3) that extracts a behavioural type model for the program ( § 2). In this stage, we use the SSA (static single assignment) package from the Go project and apply a control flow analysis to obtain behavioural types. We then apply (2) a model checking tool, mCRL2 <ref type="bibr" target="#b9">[10]</ref>, to the extracted behavioural types ( § 4). This enables us to check types with a finite state-space (i.e. finite control) for the absence of global deadlocks, as well as several Go specific safety properties (including channel safety). Finally, to pinpoint potentially problematic loops and accurately detect partial deadlocks, we augment our approach with a termination analysis for loops in the original Go source code using a term-rewriting based tool, KITTeL <ref type="bibr" target="#b15">[17]</ref> ( § 5). We show benchmarks for (publicly available) Go programs and compare with existing tools ( § 6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BEHAVIOURAL TYPES FOR GO</head><p>This section introduces behavioural types <ref type="bibr" target="#b22">[24]</ref> for concurrent Go (which are infered as an abstract model of Go -see § 3) and their relationship with Go programs, following our previous work in <ref type="bibr" target="#b28">[30]</ref>.</p><p>Behavioural types are a typing discipline in which types express the possible actions of a program in a fine-grained way <ref type="bibr" target="#b22">[24]</ref>. When applied to communication and concurrency, behavioural types act as an abstract specification of all communication actions that may be performed in a program. Moreover, behavioural types are an executable specification. They have a natural operational meaning and evolve throughout program execution.</p><p>The syntax of types is given below, it extends the types defined in <ref type="bibr" target="#b28">[30]</ref> with general sequencing. The types abstract away data elements, singling out the concurrency specific features such as spawning of threads (i.e. goroutines), creation of communication channels, send and receive actions, and selective communication.</p><formula xml:id="formula_0">α u | u | τ T {t i (ỹ i ) = T i } i ∈I in S T , S α;T | T ; S | T ⊕ S | {α i ;T i } i ∈I | (T | S) | 0 | (new n a);T | close u;T | t⟨ũ⟩ | ⌊a⌋ n k | a ⋆</formula><p>Communication is specified with the α prefix, where α can be u, denoting a send on channel u, u, denoting the dual receive action on channel u and τ , denoting a silent internal step (u is either a constant channel or a variable). T ; S models the sequential composition of T and S. The construct close u signals that channel u is to be closed. We represent conditional branching with the T ⊕ S construct, denoting a non-deterministic internal choice between T and S. Thus, our type level analogue of conditional branching does not depend on data but rather simulates the ability to take either branch of a conditional through a non-deterministic step. We model Go's selective communication with {α i ;T i } i ∈I . The construct waits for the availability of one of the α i communication actions. When some action α j becomes available, it is executed and the communication evolves to behaviour T j (discarding the other options). When more than one communication action is available, one is chosen non-deterministically. Since τ actions are always available to fire, we can use a τ action in a select construct to model timeouts or default behaviours when no other actions are available. The parallel composition construct T | S denotes the parallel execution of T and S; the construct 0 denotes no behaviour.</p><p>Channels in Go are synchronous buffers by default, but may also be created with a bound, achieving asynchronous communication. Send actions are non-blocking until the number of messages in the buffer reaches the bound and, dually, receive actions on empty buffers are blocking until a message is available. (new n a);T denotes the creation of a channel a (with a bound n) which can be used locally in T . If the bound n is set to 0, then a is a synchronous channel. We often write (new a);T for (new 0 a);T and assume that the scope of a extends as far to the right as possible.</p><p>Construct t⟨ũ⟩ denotes a function call with parameterũ. We often identify a listũ with its underlying set and write x ∈ũ if x is a element ofũ. We use the following two runtime constructs to define the semantics of types in § 4: ⌊a⌋ n k represents a communication channel at a (where n is the maximum capacity of the queue and k is the current number of messages in it) and a ⋆ represents a closed channel a. The type of a program, sometimes written {t i (ỹ i ) = T i } i ∈I in S, is a set of (potentially mutually recursive) definitions T i with a distinguished program entry point S. Recursive definitions can be parameterised by communication channels and represent the goroutines that are executed in the program. For each type definition t i (ỹ i ) = T i we assume that the free names of T i are included inỹ i . Example 2.1 (Type for Consumer-Producer and their Properties). The behavioural type for the program of <ref type="figure" target="#fig_0">Figure 1</ref> is given below. prod(ch) = ch; prod⟨ch ⟩ ⊕ close ch cons(ch1, ch2) = {ch1; cons ⟨ch1, ch2⟩, ch2; cons⟨ch1, ch2⟩ } main() = (new ch1, ch2); (prod⟨ch1⟩ | prod ⟨ch2⟩ | cons ⟨ch1, ch1⟩)</p><p>in main ⟨⟩ Definition prod(ch) specifies the type for the Producer function, while cons(ch1, ch2) stands for the type of the Consumer function, and main⟨⟩ is the type of the program entry point (i.e. the main function). Notice how the imperative control structures are transformed into recursive definitions and the data elements are erased. For instance, the type prod specifies the behaviour of performing an internal choice (denoted by the ⊕ construct) between sending on ch and recursing or closing the channel ch and terminating.</p><p>Given that behavioural types act as a form of executable specifications, it is natural to consider properties of types in terms of their executions, as well as their relationship with program properties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Behavioural Properties of Types</head><p>The property of global deadlock-freedom (GDF) entails that if a communication action is available to fire, the type can always make progress, meaning that a type as a whole is never globally stuck. For instance, the type main in Example 2.1 satisfies GDF since the communication actions in subcomponents prod⟨ch1⟩ and cons⟨ch1, ch1⟩ can always make progress, despite the fact that actions in prod⟨ch2⟩ are always stuck.</p><p>The property of liveness, also known as partial deadlock freedom, is strictly stronger than GDF, given that every live type is also GDF. It states that all communications that can become enabled in a type can always eventually fire. For instance, replacing the call to cons⟨ch1, ch1⟩ with cons⟨ch1, ch2⟩ makes the type main⟨⟩ in Example 2.1 satisfy liveness. We note that in the presence of internal choice (i.e. conditional branching), liveness requires that communication actions in both branches must eventually succeed, but when facing external choice (i.e. the select construct), only branches that can be selected are required to eventually succeed. For instance, the following single-producer variant of main⟨⟩ also satisfies liveness even though the ch2 branch in the select construct can never be taken: (new ch1, ch2); (prod⟨ch1⟩ | cons⟨ch1, ch2⟩).</p><p>In § 4, we formally define the above properties, as well as other properties that are verified in our work, in the modal µ-calculus.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Relationship between Types and Programs</head><p>In our analysis, a conditional is abstracted as a non-deterministic choice between the two alternative behaviours present in the then The type for the function send (lines 1-6) is send(c) = c; send⟨c⟩ ⊕ send⟨c⟩. Similarly, the type for recv (line 9) is recv(c) = c; recv⟨c⟩. The type for the program above is deemed live since the then branch of the conditional in send can always eventually be reached through recursion, ensuring that the inputs in recv are matched. However, in the program the then branch of the conditional can never be reached and so the inputs in recv cannot succeed. This example is symptomatic of a mismatch between type and program liveness in the presence of infinite executions that flow through a conditional. Note that it is not the case that the simple existence of non-termination makes the liveness analysis unsound <ref type="bibr">[30, § 5]</ref>. For instance, for the example in § 1, type liveness implies program liveness, despite the presence of non-termination, since there is no communication contingent on a data-dependent test.</p><p>In § 5, we address this issue by deploying a lightweight termination analysis of iterative behaviour in our framework.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>BEHAVIOURAL TYPE INFERENCE</head><p>We detail one of the main contributions of our work: the development and formalisation of a procedure that infers, whenever possible, behavioural types from Go source code. The inference consists of two key steps: (1) the conversion of Go source code to </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">From Go source code to SSA IR</head><p>The ssa package <ref type="bibr" target="#b3">[4]</ref> represents source code in SSA form and provides a high-level API for manipulating Go source code programatically. Go programs are organised as packages which consist of package variables and functions (also definable within bodies of functions). Each function is transformed into a list of blocks of SSA instructions, with one block marked as the function entry point. <ref type="figure" target="#fig_2">Figure 3</ref> gives a graphical view of the SSA representation of the program in Listing 1. Each of the three Go functions main(), sendFn (), and recvVal() becomes a set of blocks (graphically, a dotted box represents the scope of the function). The last instruction of a block is always a control flow instruction ( i f , jump, or r e t u r n) connecting the block to its successors (if any). The successor relation is shown in the graph via edges connecting blocks within a function. There are also entry and return arrows for function entry and exit respectively, implicit from the SSA IR. <ref type="table">Table 1</ref> summarises the instructions of interest to our inference.</p><p>Communication instructions. Go's channel-based communication constructs are actual primitive language constructs. Thus, the key operations such as channel creation make(chan T), cf. line 2 from Listing 1, sending and receiving values over channels, ch &lt;-value and &lt;-ch respectively (lines 11 and 14), spawning of goroutines (go sendFn() in line 3), and closing channels, i.e. close operation (line 8), are all explicit in the SSA IR. As a result, identifying the channel operations that match with the corresponding behavioural types is straightforward.</p><p>Select instructions. Non-deterministic selective communication (select) also appears explicitly in the SSA representation but requires a more intricate representation. We illustrate the structure of the SSA representation of the select block from Listing 2 in <ref type="table">Table 1</ref>: Key SSA instructions used by our type inference. Store t1 into address t0 . We note that timeouts are implemented in Go as channels (e.g., t0) that receive a message after a predetermined time. This message is placed into the channel by the runtime and not by a user-level send. The statement t 2 = e x t r a c t t 1 #0 determines the index of the case which will be executed and stores it in t2. Block 0 ends with an if-then-else construct, which is the first of an if-then-else chain identifying which case of the select is to be executed depending on the value of t2. Blocks 2 and 4 represent the bodies of the first two cases, respectively. Block 5 contains the body of the default case (the default case is always the last block of the chain); if a select statement does not specify a default case, then this block contains a "panic" instruction which cannot be executed in normal circumstances. Finally, block represents the code that follows the select statement. Phi instructions. Another key SSA instruction is p h i [ B l k i : v i ] i ∈InEdges which is used to select between two or more variables when merging the control flow into one SSA block. An example of such an instruction is given in block of <ref type="figure" target="#fig_2">Figure 3</ref> where the instruction is used to select the value of variable t5 (the index of the for loop) depending on whether the predecessor of block 3 is block 0 or block 1. The former corresponds to the initialisation step of the loop (in which case the index is 0), the latter corresponds to an execution of the body of the loop.</p><formula xml:id="formula_1">p h i [ B l k i : v i ] i ∈InEdges Select v i if predecessor block is Blk i</formula><p>Conventions. Given an SSA statement s, e.g., t 0 = make chan i n t 0, the left-hand-side (LHS) is the part of the statement on the left of the = symbol (the variable t0). The key features of the SSA representation are that, within the scope of a function, all the LHS of the statements in the blocks of that function are </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Extracting type definition bodies</head><p>In Step (2) we soundly approximate, whenever possible, the communication behaviour of Go programs with the type language. First, for each SSA block n in each function fun(x), we generate a type signature of the form fun n (ỹ,t,ṽ) where: y is a subsequence ofx where each y inỹ is a channel parameter t is a list of channel variables that appear in the LHS of the statements in the predecessors of block n and do not appear in the LHS in block ñ v is a list of global channel variables (declared outside of function fun, e.g., package level variables). We store all signatures in an environment ∆ and write ∆(fun, n) for the signature of block n in function fun.</p><p>3.2.1 Core procedure: genFunction. We present the core algorithm, the genFunction procedure, which generates a type abstraction from an SSA block. The procedure takes five parameters: fun, the name of the function being considered; n, the identifier of the block; k, the line number within block n; ρ, the type we have constructed thus far; and Γ, a context which maps each channel variable name to its representative. function genFunction(fun, n, k, ρ, Γ) switch s ← statement at line k do case t = make chan T S do genFunction(fun, n, k+1, ρ ;</p><formula xml:id="formula_2">(new S t), Γ[t → t])</formula><p>case t = l o c a l chan T do genFunction(fun, n, k+1, ρ,</p><formula xml:id="formula_3">Γ[t → ⊥]) case t &lt;−v or &lt;− t or t '= &lt; − t do genFunction(fun, n, k+1, ρ ; mkPrefix Γ (s), Γ)</formula><p>case c l o s e ( t ) do genFunction(fun, n, k+1, ρ ; close Γ(t), Γ)</p><p>case r e t u r n do return ρ; 0 case jump i do return ρ ; mkJump Γ (fun, i) case i f _ g o t o i e l s e j do return ρ;</p><formula xml:id="formula_4">(mkJump Γ (fun, i) ⊕ mkJump Γ (fun, j))</formula><p>case s e l e c t b</p><formula xml:id="formula_5">[д 1 , . . . , д j ] do ρ c ← mkJump Γ (fun, n+1) for i in [1, . . . , j] do ρ i ← mkPrefix Γ (д i ) ρ ′ i ← mkJump Γ (fun, n+2 * i) if b = nonblocking then ρ d ← mkJump Γ (fun, n+1+2 * j) return {ρ i ; ρ ′ i ; ρ c } i ∈{1, . . ., j } ∪ {τ ; ρ d ; ρ c } else return {ρ i ; ρ ′ i ; ρ c } i ∈{1, . . ., j } case F (x ) or t =F (x ) do if t is a channel then abort else genFunction(fun, n, k +1, ρ; mkCall Γ (F,x ), Γ) case go F (x ) do ρ ′ ← genFunction(fun, n, k+1, •, Γ) return ρ; (mkCall Γ (F,x ) | ρ ′ ) case * t 0 = t 1 or t 0 = * t 1 do if t is a channel then genFunction(fun, n, k+1, ρ, Γ[t0 → Γ(t1)]) else genFunction(fun, n, k +1, ρ, Γ) case p h i [ B l k i : v i ] i ∈InEdges do if ∃i ∈ InEdges : v i is a channel then abort else genFunction(fun, n, k +1, ρ, Γ) otherwise do genFunction(fun, n, k +1, ρ, Γ) Algorithm 1: Pseudo-code of genFunction</formula><p>The context Γ is crucial in our development as Go allows channels to be aliased (i.e., several variables may contain a reference to the same channel) and channel variables to be overwritten, e.g., a channel variable may refer to different channels at different point of the execution of a program, or may be declared and only initialised at a later point. We keep track of aliased channels by assigning a unique representative to each newly created channel. We write Γ[t → t ′ ] for the context Γ where the mapping from t is updated to t ′ . We assume that Γ[t → t ′ ] is undefined if t ∈ dom(Γ) and Γ(t) ⊥ in order to disallow channel overwriting.</p><p>Algorithm for genFunction. Our algorithm relies on auxiliary (partial) functions for the translations from statements to types:</p><formula xml:id="formula_6">mkPrefix Γ (s)</formula><p>send/receive actions and select guards mkJump Γ (fun, j) jump statements mkCall Γ (fun,x) function calls</p><p>Each function uses context Γ to generate communication actions and type definition calls, respectively. Algorithm 1 gives the implementation of genFunction which iterates over the lines of block n in function fun and makes a case analysis depending on the structure of the statement s found at line k. The procedure returns a behavioural type or aborts whenever an invocation to auxiliary functions is undefined or when the algorithm reaches an "abort" statement, since in these cases we cannot guarantee a sound approximation of program behaviour. In particular, the algorithm aborts if a channel variable is overwritten (a new channel is assigned to it). Channel creation/declaration. If s is a channel creation statement, variable t becomes the representative name for this channel and we update the environment with Γ[t → t]. The SSA representation guarantees that t is unique in function fun. We create the corresponding new channel type construct and recursively call genFunction over the next line. If s is a channel declaration statement, we update the environment with Γ[t → ⊥]. Note that t can only be used after it is initialised. Send/receive. If s is a send or receive statement, we translate it to a type construct with a call to mkPrefix Γ (s), defined below:</p><formula xml:id="formula_7">mkPrefix Γ (s) =          u if s = t &lt;−v and Γ(t) = u u if s ∈ {&lt;− t , t '= &lt; − t } and Γ(t) = u τ if s = &lt;− t and t is a timeout channel</formula><p>Timeout channels are dedicated channels created at compile time to encode timeouts, they are never added in the context Γ.</p><p>Close is mapped to its respective type primitive, via context lookup. Return. We return the type built so far appended with the termination construct. Jump. We translate a jump statement into a type function call through the auxiliary function defined below, which uses the globally available signature environment (∆).</p><formula xml:id="formula_8">mkJump Γ (fun, j) =          fun j ⟨ỹ, Γ(t),ṽ⟩ if ∆(fun, j) = fun j (ỹ,t,ṽ)</formula><p>and ∀t ∈t : Γ(t) ⊥ ⊥ otherwise mkJump Γ (fun, j) models a jump to another block within the same enclosing function hence there is no need to rename the parameters nor the "global" variables from the function signature (since they are fixed within the scope of the function). Instead, the internally declared variables are replaced by their representatives using Γ.</p><p>The function mkJump Γ (fun, j) is undefined if any of thet arguments maps to an uninitialised channel in order to guarantee that these cannot be overwritten in the definition of fun. Theỹ andṽ arguments are assumed to be initialised by the parent function.</p><p>Conditional constructs are also translated straightforwardly using ⊕ and type definition call.</p><p>Select. If s is a s e l e c t construct then s is followed by a chain of blocks linked by if-then-else statements, which encode the branching structure of the select, as explained in § 3.1. The jump to the continuation of the select statement is stored in ρ c , while the guard and body of each case is stored into ρ i and ρ ′ i , respectively. If the select statement contains a default case (b = nonblocking), we additionally translate the last block of the chain into a type function call. The guard and body of each case is then appended with the </p><formula xml:id="formula_9">function genBody(fun, n) fun n (ỹ,t,ṽ) ← ∆(fun, n) Γ ← [x → x ] x ∈ỹ,t,ṽ return genFunction(fun, n, 0, •, Γ) function genEquations() return {∆(fun, n) = genBody(fun, n) | (fun, n) ∈ dom(∆)} in main 0 ⟨⟩</formula><formula xml:id="formula_10">mkCall Γ (fun,x) =         </formula><p>fun 0 ⟨Γ(x),ṽ⟩ if ∆(fun, 0) = fun 0 (ỹ,ṽ) and ∀x ∈x :</p><formula xml:id="formula_11">Γ(x) ⊥ ⊥ otherwise</formula><p>Note that the arguments are replaced by their representatives according to Γ and the function is undefined if any of them refers to an uninitialised channel.</p><p>Goroutines. If s spawns a new goroutine, we proceed similarly to the function call case but place the call in parallel with its continuation, which is computed through a call to genFunction, starting with an empty behavioural type (denoted by •).</p><p>Aliasing. If s stores a channel variable into another, we update the context with Γ[t0 → Γ(t1)] (which is undefined if Γ(t0) ⊥).</p><p>Phi. If s is a phi statement, we proceed only if it does not overwrite channels -we discuss how to lift this restriction in § 5. We skip all other statements as they do not pertain to communication or concurrency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.2.2</head><p>Top-level procedure: genEquations. Finally, we generate the body of type definitions using the genFunction procedure and thus obtain a set of recursive equations as required. Algorithm 2 gives the overall generation process. We iterate over each type signature (and therefore each SSA block) to generate a type implementation starting with a context Γ which is initialised to the identity function for each of the parameters. The algorithm returns a set of (possibly mutually recursive) type definitions, whose entry point is the program entry point, e.g., main 0 ⟨⟩.  The type's entry point is myselect 0 (c) and myselect 3 (t0) is unused. Note how each branch of the select consists of the sequential composition of a guard, a type function call corresponding to the body of the branch, and a call to the continuation myselect 1 ⟨t0⟩.</p><formula xml:id="formula_12">− −−− → a ⋆ a ⋆ a ⋆ − − → a ⋆ i ∈ {1, 2} T 1 ⊕ T 2 τ − → T i α j ;T j α j − − → T j j ∈ I {α i ;T i } i ∈I α j − − → T j T α − → T ′ T | S α − → T ′ | S T α − → T ′ T ; S α − → T ′ ; S 0; S τ − → S α ∈ {a, a ⋆ , a • } T α − → T ′ S β − → S ′ β ∈ { • a, a} T | S τ a − − → T ′ | S ′ T ≡ α T ′ T α − → T ′′ T ′ α − → T ′′ T {ã/x } α − → T ′ t(x) = T t⟨ã⟩ α − → T ′ T clo a − −−− → T ′ S clo a − −−− → S ′ T | S τ − → T ′ | S ′ k &lt; n ⌊a⌋ n k • a − − → ⌊a⌋ n k +1 k ≥ 1 ⌊a⌋ n k a • − − → ⌊a⌋ n k−1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MODEL CHECKING BEHAVIOURAL TYPES</head><p>We present our model checking based analysis of the finite control fragment of behavioural types. We proceed in three steps: (1) we generate a (finite) labelled transition system (LTS) for the types from a set of operational semantics rules; (2) we define properties of the states of the LTS in terms of the immediate actions behavioural types can take; and (3) we give safety and liveness properties expressed in the modal µ-calculus <ref type="bibr" target="#b26">[28]</ref>.</p><p>The notion of finite control has several definitions in the literature <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b10">11]</ref> but is generally understood to refer to having finitely many reachable states (possibly up-to some equivalence relation). Here we adopt the definition of finite control used by the mCRL2 toolchain <ref type="bibr" target="#b9">[10]</ref>: types cannot feature parallel composition or channel creation operators under recursion, which is a sufficient condition to guarantee a finite state space. For instance, types of the form t(x) = t⟨x⟩ | T or t(x) = (new a); t⟨a⟩ are not finite control as the former generates infinitely many instances of type t(x) while the latter generates infinitely many channels.</p><p>Semantics of types. Before proceeding to Step (1), i.e., the generation of a labelled transition system (LTS) from behavioural types, we introduce the semantics of types. The semantics follows  standard definitions from CCS and CSP, accounting for the constructs that are specific to the Go programming language. The labels, ranged over by α and β, have the form:</p><formula xml:id="formula_13">0;T ≡ T T | S ≡ S | T T | (T ′ | S) ≡ (T | T ′ ) | S T | 0 ≡ T T ≡ α T ′ ⇒ T ≡ T ′ (new</formula><formula xml:id="formula_14">α, β a | a | τ | τ a | clo a | clo a | a ⋆ | • a | a •</formula><p>and their meaning is given in <ref type="table" target="#tab_1">Table 2</ref>.</p><p>We assume types are in normal form, with all channel creations at the outermost top level. In a finite control setting we can always soundly rewrite types to satisfy this normal form using the equivalences defined in <ref type="figure" target="#fig_9">Figure 6</ref>. Thus, a program's type is always of the form:</p><formula xml:id="formula_15">{t i (ỹ i ) = T i } i ∈I in (new n 0 a 0 ) . . . (new n k a k ); t 0 ⟨⟩</formula><p>where the several T i contain no channel creations. We also make use of the following transition which initialises all the channels accordingly and write A for the set of all initialised channels:</p><formula xml:id="formula_16">{t i (ỹ i ) = T i } i ∈I in (new n 0 a 0 ) . . . (new n k a k ); t 0 ⟨⟩ τ − → {t i (ỹ i ) = T i } i ∈I in (t 0 ⟨⟩ | ⌊a 0 ⌋ n 0 0 | . . . | ⌊a k ⌋ n k 0 )</formula><p>We give the semantic rules for behavioural types in <ref type="figure" target="#fig_7">Figure 5</ref>, adapted from <ref type="bibr" target="#b28">[30]</ref>, where T α − → T ′ denotes that T reduces to T ′ by producing α, according to the rules in <ref type="figure" target="#fig_7">Figure 5</ref>. In the first line, the rules respectively model send, receive and silent actions. In the second line, the rules respectively model close actions, the closure of channel a and a closed buffer sending default values. In the third line, the rules respectively model a silent transition representing an internal choice and an external choice. The fourth line gives the standard rules for parallel and general sequencing. The rule in the fifth line models the synchronisation between a type or buffer firing a send-like action (i.e., a send action, a closed buffer, or a non-empty asynchronous buffer) and a receive action or a non-full buffer. The sixth line gives standard rules to deal with αequivalence and unfolding of definition calls. In the seventh line, the rules respectively model the synchronisation of a type and a buffer a to effectively close a, and the action of adding (resp. removing) an element in (resp. from) a buffer, where n is the capacity of the queue and k is the number of messages currently stored in the queue. We have omitted symmetric rules for parallel and synchronisations.</p><p>In Step (1), given a finite control type in normal form, we construct a finite labelled transition system which represents all possible executions of t 0 ⟨⟩, i.e., the entry point type under all the name restrictions. The LTS of t 0 ⟨⟩ is a tuple T = (S, t 0 ⟨⟩, − →, A) such that S is a set of states implicitly labelled by behavioural type terms (we often identify labels and states), t 0 ⟨⟩ ∈ S is the initial state, A ⊆ {τ } ∪ {τ a | a ∈ A} is the set of labels, and − →⊆ S × A × S is the transition relation T α − → T ′ where the label α can be either a silent move, i.e., τ , or a synchronisation over a channel, e.g., τ a .  Properties of behavioural type states. In Step (2), we define predicates over the state labels of the LTS defined above. This allows us to analyse what actions a given state (or type) can fire immediately. Concretely, we define a family of predicates of the form T ↓ o or T ↓õ which holds if T is ready to fire action o or one of the actions inõ, with o, o i ∈ {a, a, τ a , clo a, a ⋆ , • a, a • }. <ref type="table" target="#tab_1">Table 2</ref> explains the meaning of each label and <ref type="figure" target="#fig_10">Figure 7</ref> gives the defining rules of the predicates T ↓ o and T ↓õ . Essentially, T ↓ o if T is immediately ready to fire action o (with o τ ) andT ↓õ ifT contains an external choice which does not feature a branch guarded by τ (i.e., τ õ). We have, e.g., ¬(τ ;T ↓ o ) for any o and ¬( {τ ;T 1 , a;T 2 } ↓õ ) for anyõ, which is an important subtlety for defining accurate safety and liveness properties.</p><formula xml:id="formula_17">α i ↓ o i {α i ;T } i ∈ {1, ...,n } ↓ {o 1 ...o n } T ↓ o T ;T ′ ↓ o T ↓ a T ′ ↓ a or T ′ ↓ a ⋆ T | T ′ ↓ τ a T {ã/x } ↓ o t(x) = T t⟨ã⟩ ↓ o T ↓ a α i ↓ a T | {α i ; S i } i ∈I ↓ τ a T ↓ a or T ↓ a ⋆ α i ↓ a T | {α i ; S i } i ∈I ↓ τ a k &lt; n ⌊a⌋ n k ↓• a k ≥ 1 ⌊a⌋ n k ↓ a • T ↓ a T ′ ↓• a T | T ′ ↓ τ a T ↓ a • α i ↓ a T | {α i ; S i } i ∈I ↓ τ a T ↓ o T | T ′ ↓ o T ↓ o a fn(o) (new n a);T ↓ o T ↓ o T ≡ T ′ T ↓ o</formula><p>Liveness and safety properties. In Step (3), we encode liveness and channel properties (including those discussed in § 2.1) in the µ-calculus <ref type="bibr" target="#b26">[28]</ref> extended with the atomic propositions on state labels defined in Step <ref type="bibr" target="#b1">(2)</ref>.</p><p>A µ-calculus formula ϕ is interpreted on a pointed LTS, i.e., an LTS with a starting state T , we write T |= T ϕ if T satisfies ϕ in the LTS T . Namely, formula ⊤ holds for every T (while ⊥ never holds). The construct [α]ϕ is a modal operator that is satisfied if, for each α-derivative T ′ of T (i.e. T ′ is reachable from T by performing action α), the formula ϕ holds in T ′ . The dual modality is ⟨α⟩ϕ which holds if there is an α-derivative T ′ of T such that ϕ holds in T ′ . Construct ν x. ϕ (resp. µx. ϕ) is the standard greatest (resp. smallest) fixpoint operator (binding x in ϕ). The atomic proposition ↓ o (resp. ↓õ ) holds iff T ↓ o (resp. T ↓õ ). Given a set of actions A ⊆ A, we write [A]ϕ for α ∈A [α]ϕ and ⟨A⟩ϕ for α ∈A ⟨α⟩ϕ.</p><formula xml:id="formula_18">Ψ (ϕ) def = ν x. (ϕ ∧ [A]x) [Always] Φ (ϕ) def = µy. (ϕ ∨ ⟨A⟩y) [Eventually] ψ t def = ⟨A⟩⊤ [No terminal] ψ c def = µy. [A]y [No cycle] ψ д def = a ∈A (↓ a ∨ ↓ a =⇒ ⟨A⟩⊤) [No global deadlock] ψ l a def = a ∈A (↓ a ∨ ↓ a =⇒ Φ (⟨τ a ⟩⊤)) [Liveness (a)] ψ l b def = ã ∈ P(A) (↓ã =⇒ Φ (⟨{τ a | a ∈ã}⟩⊤)) [Liveness (b)] ψ s def = a ∈A (↓ a ⋆ =⇒ ¬(↓ a ∨ ↓ clo a )) [Channel safety] ψ e def = a ∈A (↓ a • =⇒ Φ (⟨τ a ⟩⊤))</formula><p>[Eventual reception] <ref type="figure">Figure 8</ref>: µ-calculus formulae.</p><p>We now describe several properties which can be verified using the model checker mCRL2 <ref type="bibr" target="#b9">[10]</ref>. Below we refer to the formulae given in <ref type="figure">Figure 8</ref>. Given a µ-calculus formula ϕ, formula Ψ (ϕ) holds if ϕ holds for all reachable states, while formula Φ (ϕ) holds if ϕ holds in some reachable state. Formula Ψ (ψ t ) holds if no terminal state is reachable in T , i.e., the behavioural types only exhibit infinite executions; dually formula ψ c holds if there are no cycles in T , this property is useful as it implies that liveness of types corresponds with liveness of programs (cf. § 2.2). Formula Ψ ψ д models the global deadlock-freedom property discussed in § 2.1, i.e., the formula holds if for each state T in T if T is ready to execute a send or receive action, then T has a successor. Formula Ψ ψ l a ∧ ψ l b models the liveness property (cf. § 2.1). It holds if for all state T in T (i) if T is ready to send/receive on a, there is always eventually a synchronisation on a (cf. ψ l a ), and (ii) if T has a select construct, which does not contain a τ -branch, there is always eventually a synchronisation over one of the channels guarding the construct (cf. ψ l b ). Formula Ψ (ψ s ) models the channel safety property, i.e., no send nor close action is executed on a channel that is already closed. Formula Ψ (ψ e ) models eventual reception, which guarantees that when a channel is not empty, the head of its buffer can eventually be consumed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION</head><p>We present the Godel Checker toolchain of <ref type="figure">Figure 2</ref> which consists of two core components: an inference tool and a type verifier.</p><p>Inference tool. The type inference tool implements the core algorithms described in § 3, with additional adjustments to support analysis of real world Go programs, which we discuss below. Uninitialised channels: Uninitialised channels (or nil channels) can be used in Go, but they always block on communication. To model this behaviour, we prefix any communication on an uninitialised channel with a (new a) construct (with a fresh). Composite data structures: Our tool supports channels that are stored in structs by flattening such constructs into several channels. We only support structures that store finitely many channels (e.g., arrays or linked-list of channels are not supported). Uniform representation of functions: A uniform representation of callable objects is used as an abstraction when obtaining the type signature of an SSA block. This allows us to support return values and closures by uniformly converting return values and closure binding as additional function parameters. Channels in phi instructions: We support SSA instructions to merge control flow ( p h i ) when they refer to channels by adding a parameter to the type definition of its enclosing block and modifying function calls accordingly.</p><p>Type verifier. The type verifier transforms the inferred behavioural types into an LTS and properties into µ-calculus formulae following the methodology in § 4 for the mCRL2 model checker, and also into input for the KiTTeL termination analyser. Model checking: Once a behavioural type has been inferred from Go source code, we translate it straightforwardly to the mCRL2 language <ref type="bibr" target="#b17">[19]</ref>. Before generating the µ-calculus formulae described in § 4, we analyse the model so to build the smallest formulae possible. Finally, we run the mCRL2 model checker for each formula and return the result to the user. Termination checking: To address the mismatch between types and programs detailed in § 2.2 we deploy a termination analysis of loops, using the KITTeL termination analyser <ref type="bibr" target="#b14">[16]</ref>. The tool targets C programs and is based on integer term rewriting. The choice of this particular analyser amounts to the syntax of Go being close to C, its usability and performance.</p><p>The analysis takes advantage of the inference procedure of § 3 to collect the locations and parameters of loops in a given program, which are then checked for termination. Our analysis checks that the loop parameters are enough to make each loop eventually terminate, regardless of the non-loop code within the loop itself. This enables us to pinpoint program locations where liveness of types may not entail the analogue property in the program -if the termination analysis identifies the program as terminating, the liveness properties on types and programs coincide <ref type="bibr">[30, § 5]</ref>.</p><p>The analysis generates all loops in the original Go program as a set of C functions, ignoring all other Go statements. Each C function (and thus, each loop) is then individually checked for termination. Since loops can be nested, our analysis takes this into account by replicating the nesting in the generated C functions. For instance, for the following code snippet, Statically unknown values in loop parameters (e.g. the parameter n of function f above) are generated as parameters of the respective C functions. This forces the termination checker to verify termination for all possible values of the unknown parameter. Such values can appear due to usages of function arguments, values contained in dynamic data structures or communicated data.</p><p>Our analysis relies on the following: loops in Go programs generate types with conditional branching combined with recursion; most programs use traditional imperative control flow features such as for loops, for-range loops (i.e. loops over a fixed finite data structure) and for-select loops (i.e. an infinite loop with a select that can break the loop -the Consumer function of <ref type="figure" target="#fig_0">Figure 1</ref>) instead of recursion; we assume that loop indices are not modified in loop bodies and that no goto-like constructs are used in a loop. Since the analysis only takes into account loop parameters, a loop that indefinitely blocks (e.g. due to communication) may be identified as terminating. However, if our analysis identifies the inferred types as live and the termination check validates the program, both termination and program liveness are guaranteed. <ref type="table" target="#tab_2">Table 3</ref> lists several benchmarks of our tool against other static deadlock detection tools for Go (a detailed comparison of these tools is given in § 7). The benchmarks were run with go1.8.3 on an 8-core Intel i7-3770 machine with 16GB RAM on a 64-bit Linux. The model checker we used was mCRL2 v201707.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EVALUATION</head><p>The results for Godel Checker are shown in columns 4-12. Column 4 shows the number of states in the input LTS as a measurement of the relative complexity of each program (proportional to the number of concurrency-related operations rather than the number of lines of code). Columns 5-8 shows the core formulae of <ref type="figure">Figure 8</ref> in § 4, i.e. no global deadlock (ψ д ), liveness (ψ l ), channel safety (ψ s ) and eventual reception (ψ e ). A ✓ mark means that the considered tool reports that the property holds. For example, in the case of Godel Checker, a ✓ mark under column ψ д means that the formula Ψ ψ д evaluates to true. In the case of GoInfer/Gong a ✓ mark under column Live means that the tool reports the program to be live, as defined in <ref type="bibr" target="#b28">[30]</ref>. A × mark indicates that the considered tool reports that the property in question does not hold. Columns 9-12 list the running time of Godel Checker, where Column 10 lists the inference time, Columns 10 and 11 are the model checking times for liveness, and both liveness and channel safety, respectively. The total run time can be obtained by adding Column 9 to Column 10 or 11. Unless otherwise stated, all times are in milliseconds. Column 12 (Term) shows the result of the termination check, which proves the termination of loops in the given program, or times out after 15s. A program that times out is conservatively assumed not to terminate.</p><p>Columns 13-14 pertain to the dingo-hunter tool from <ref type="bibr" target="#b34">[36]</ref>. The time includes both communicating finite state machine extraction and their analysis, but does not include building the global graph and only checks for liveness. Columns 15-16 pertain to the gopherlyzer tool <ref type="bibr" target="#b38">[40]</ref>, which only checks for global deadlockfreedom (most programs had to be manually adjusted in order to be accepted by this tool -see § 7 for the severe practical limitations of the tool). Columns 17-19 refer to the GoInfer/Gong tool from <ref type="bibr" target="#b28">[30]</ref>. The times include both type inference and analysis stages, which only accounts for liveness and channel safety checks. Most programs in <ref type="table" target="#tab_2">Table 3</ref> are taken either from other papers on the static verification of Go programs <ref type="bibr" target="#b28">[30,</ref><ref type="bibr" target="#b34">36,</ref><ref type="bibr" target="#b38">40]</ref> or from publicly available source code. Programs 7, and 15-22 are benchmarks introduced by this work. Programs that are unsupported by a tool are marked with n/a. <ref type="table" target="#tab_2">Table 3</ref> includes all the benchmarks from previous works, except for 3 non-finite control examples from <ref type="bibr" target="#b28">[30]</ref> which our tool cannot analyse (i.e., like sieve) and htcat from <ref type="bibr" target="#b34">[36]</ref> which is manually transformed to be supported by dingo-hunter.</p><p>Programs 1-7 are typical concurrent programs from the literature. The sieve program is not finite control (it spawns an infinite number of threads), thus it can only be analysed by GoInfer/Gong. Program 6 is a (three) dining philosophers program where the first fork can be released, while Program 7 is the traditional deadlocking version (Program 19 is as Program 6 but with 5 philosophers). dingo-hunter does not support Programs 6, 7, and 19 due to dynamically spawned goroutines, while gopherlyzer does not support them due to a nested select statement. GoInfer/Gong analyses them correctly, but is much slower than Godel Checker.</p><p>Programs 8-12 consist of idiomatic Go patterns which are all handled correctly and quickly by our tool. Program 13 is a publicly available program which is not live. Program 14 is an implementation of the alternating bit protocol. Program 15 is the Producer-Consumer example from § 1, which is not live. All tools were able to verify this simple program. Program 16 demonstrates the mismatch between type and program liveness, where the type is live but due to an erroneous loop the program does not terminate and causes a partial deadlock. The termination check identifies this as possibly non-terminating, while GoInfer/Gong incorrectly identifies it as live. Program 17 closes a channel twice which flags a violation of channel safety in Godel Checker and GoInfer/Gong. Interestingly, dingo-hunter detects a deadlock (a false alarm) due to its representation of channel closure as a message exchange, but not due to the double close. gopherlyzer also detects a deadlock incorrectly due to the same reason. Program 18 is a program that violates the eventual reception property by sending an asynchronous message that is never received -none of the earlier tools can detect this.</p><p>Programs 19-22 demonstrate the scalability of our approach. Program 22 is a concurrent data stream multiplexer, for handling multiple independent data streams in a single TCP connection. It consists of 16k lines of code of which only a small portion relate to concurrency (which is the case with common concurrent Go applications). The program is not natively finite control since it spawns request handlers as goroutines in a loop. Noting that request handlers do not interact with each other, we modified the program to handle requests sequentially and enable our analysis.</p><p>We note that while the execution time for small programs is slightly higher than the other tools (but still under 2 seconds), Godel Checker is a more general tool since it can verify arbitrary properties expressible in the µ-calculus and our precise inference allows us to reduce both the false alarms and, crucially, undetected liveness errors. The verification times also suffer from the initialisation of mCRL2 (the tool uses 3 binaries). In small programs the running times are generally dominated by this fact, which is the reason why the times are quite similar. This is amortised in programs with large state spaces (cf. second part of <ref type="table" target="#tab_2">Table 3)</ref>, where the efficiency of mCRL2 produces gains of several orders of magnitude over gopherlyzer and GoInfer/Gong while performing more detailed analyses. We note that a significant portion of the inference time is due to the translation into SSA by the ssa package.</p><p>Limitations. As explained in § 3, our inference does not support channel variable overwriting, i.e., we only support immutable channel variables. In addition, it does not support channels in dynamic data structures -such as arrays, slices (variable sized arrays) and dictionaries -or recursively defined data structures (e.g. linked lists). However, our tool ensures that such data structures do not contain channels and can be safely ignored, signalling an error otherwise. We also require channel buffer sizes to be statically known. While the inference is agnostic to the finite control limitation of the model checking tool, if a type is inferred successfully, it must be finite control in order for our type verifier to produce an output. We note that these limitations are also present in the other tools mentioned in this section (GoInfer/Gong supports infinite state systems by performing a bounded verification).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RELATED WORK AND CONCLUSION</head><p>Applying program analyses to real-world software. The errorprone nature of concurrent software has led to a plethora of works on automated verification of concurrency via program analysis. However, these works mostly target lock-based concurrency (such as those based on Java Pathfinder <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b19">21,</ref><ref type="bibr" target="#b36">38,</ref><ref type="bibr" target="#b42">44]</ref> or abstract interpretation <ref type="bibr" target="#b27">[29]</ref>) and so are of a fundamentally different nature than our work targetting message-based concurrency in Go. Verification of Go programs. Despite the young age of Go, it has received some attention from the research community. The work of <ref type="bibr" target="#b34">[36]</ref> is to the best of our knowledge the first to tackle static verification of Go programs. Their work uses multiparty session types <ref type="bibr" target="#b21">[23]</ref> and their connection to communicating automata <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b30">32]</ref> to check for liveness in Go by extracting communicating finite state machines from source code. However, their work cannot support dynamic spawning of goroutines (requiring all goroutines to be executing before any communication takes place) nor asynchrony. This severely limits the applicability of their work. Their analysis also does not cover many features of Go which results in crashes in the analysis, such as p h i instructions and uninitialised channels.</p><p>Using a form of regular expressions with a fork construct, the work of <ref type="bibr" target="#b38">[40]</ref> captures thread spawning in synchronous Go programs. Their analysis is extremely limited: it does not support asynchrony, closing channels nor selective communication with non-trivial case bodies. Moreover, their work uses the guru tool to manually obtain aliasing information in order to identify channels, and assumes that all functions can be inlined. As a result, their tool fails to analyse programs that cannot be trivially inlined -e.g. programs with aliased channel or repeated usages of the same function -ruling out most useful programs.</p><p>Our previous work <ref type="bibr" target="#b28">[30]</ref> infers behavioural types from Go code which are checked for liveness and safety properties using a technique akin to bounded symbolic execution. The GoInfer/Gong tool explicitly executes the type LTS which has scalability issues with large state spaces (see § 6) and is specialised for liveness and channel safety, whereas our tool can check for a much wider range of properties of interest (in general we can verify any property that can be represented as a µ-calculus formula). The type inference of <ref type="bibr" target="#b28">[30]</ref> (which was not formalised until this work) did not have full support for closures nor general sequencing, needed to accurately represent most imperative programming patterns. Behavioural types. There is a vast body of work on behavioural types for concurrency (see <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b22">24]</ref> for general surveys). The main contrast between our work and most of those in <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b22">24]</ref> is that we use behavioural types as a component in a larger analysis that can automatically check for a range of safety and liveness properties, instead of focusing solely on forms of deadlock-freedom. The work <ref type="bibr" target="#b6">[7]</ref> proposes a framework combining a behavioural type analysis with model checking. Their work uses the π -calculus as a source language and extracts CCS-like behavioural types based on <ref type="bibr" target="#b23">[25]</ref>, which can then be checked for properties written as an LTL formula. The main limitation of their work is the requirement of explicit type annotations in processes. Moreover, it is not clear how to represent our notions of global and partial deadlock-freedom (as well as channel safety) as a general LTL formula. LTL formulas can use "always" and "eventually" modalities to describe reachable states, but cannot mention specific communication actions which requires non-obvious encodings. Note that most previous works <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b22">24]</ref> are developed in the context of process calculi and are not applicable to a general purpose language.</p><p>Concluding remarks. We have presented a static verification framework for channel-based concurrency in Go which we have implemented in the Godel Checker tool. As shown in § 6, our inference procedure allows us to accurately cover a broader class of Go programs without the need for annotations or significant user input. By integrating our approach with a general purpose model checker, we are able to modularly verify arbitrary safety and liveness properties. Compared to other existing tools, our approach provides significantly better performance for larger programs, verifying more properties and with better outcomes in terms of both false alarms and, crucially, undetected liveness errors.</p><p>Given the general nature of our inference procedure, our framework is not necessarily limited to mCRL2, nor model checking techniques in general. For future work we plan to use other process calculi verification techniques such as <ref type="bibr" target="#b35">[37]</ref>, as well as other model checkers for concurrency such as <ref type="bibr" target="#b16">[18]</ref>. Also, the general idea for our inference can in principle be applied to other concurrency-centric languages that rely on some form of SSA-like intermediate representation. We plan to apply our techniques to the Erlang language via the Core Erlang <ref type="bibr" target="#b5">[6]</ref> intermediate representation. We also plan to address the OpenCL 2.0 heterogeneous programming framework <ref type="bibr" target="#b18">[20]</ref> which provides pipe objects (akin to Go channels) that are used for inter-kernel communications and are prone to deadlocks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>}Figure 1 :</head><label>1</label><figDesc>select { case x := &lt;-ch1 : print (x) // Either input from ch1 case x := &lt;-ch2 : print (x) // or input from ch2 } } } func main () { ch1 , ch2 := make ( chan int ) , make ( chan int ) go prod ( ch1 ) go prod ( ch2 ) cons ( ch1 , :: ch1 ) Partially deadlocked Producer-Consumer in Go.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>13 func 15 }</head><label>1315</label><figDesc>recvVal (c chan int ) int { 14 return &lt;-c // Receive from channel c Listing 1: A simple concurrent program in Go. and else branches. This coarse abstraction introduces a subtle interaction between non-terminating program behaviour and datadependent communication wrt. liveness [30, § 5] (we note that this issue does not affect GDF or Channel Safety). For instance, consider the following Go program: 1 func send (n int , c chan int ) { 2 if n %2 == 0 { // Conditional ( send if n is even )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>SSA IR built from Listing 1. a static single assignment (SSA) intermediate representation (IR), using the ssa package from the Go standard library; and (2) the extraction of the communication structure as behavioural types from SSA blocks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>1 Enter block 1 i f t 0 g o t o 1 e l s e 2</head><label>112</label><figDesc>make chan T S Create channel of type T and size S l o c a l chan T Declare channel of type T ch &lt;− v Send v to channel ch &lt;−ch Receive from channel ch s e l e c t b [&lt;− t0 , t1 &lt;−v ] Non-deterministic select c l o s e ( ch ) Close channel ch jump If t0 then enter block 1 else block 2 r e t u r n Exit function F ( ) Call function F go F ( ) Spawn F as goroutine * t 0 = t 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 .</head><label>4</label><figDesc>Listing 2 shows a simple function myselect(c) which consists of a select construct featuring three cases: the first is guarded by a receive action on channel c, the second is guarded by a timeout, and the last is the default case (executed if none of the other cases are ready to be executed). The SSA IR of myselect(c) consists of 6 blocks. Block 0 is the entry point of the function, containing the SSA instruction for select. Note that the instruction s e l e c t nonblocking [ &lt; − c , &lt; − t 0 ] contains only two cases. The default case is identified by the keyword nonblocking; if a select does not specify a default case its SSA representation becomes s e l e c t blocking [ &lt; − c , &lt; − t 0 ]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2 select { 3 case 9 } 10 } 2 / 4 / 5 /Figure 4 :</head><label>239102454</label><figDesc>func myselect ( c chan int ) { msg := &lt;-c : 4 print ( " received : " , msg ) 5 case &lt;-time . After ( time . Second ) : 6 print ( " timeout : ready in 1 s " ) 7 default : 8 print ( " default : always ready " ) Listing 2: A select statement in Go. t 0 = t i m e . A f t e r ( 3 : t i m e . D u r a t i o n ) t 1 = s e l e c t nonblocking [&lt;− c , &lt; − t 0 ] t 2 = e x t r a c t t 1 #0 / / c a s e i n d e x t 3 = t 2 == 0 i f t 3 g o t o 2 e l s e 3 0 t 4 = t 2 == 1 i f t g o t o 4 e l s e 5 3 / / r e c e i v e ( . . . ) jump 1 / t i m e o u t ( . . . ) jump 1 / d e f a u l t ( . . . ) jump 1 / c o n t . ( . . . ) r e t u r n 1 func myselect(c) return entry Simplified SSA IR built from Listing 2. pairwise distinct. Also, the static typing information is available for each statement. In addition, variables declared at the package level are initialised in a special init() function. Variables that are accessed by anonymous functions appear in the header of the SSA representation of that function as free variables.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Example 3 . 1 .</head><label>31</label><figDesc>Consider the Go program from Listing 1 and its SSA representation inFigure 3. The set of type definitions infered from this example is given below. main 0 () = (new t0); (sendFn 0 ⟨t0⟩ | recvVal 0 ⟨t0⟩; main 3 ⟨t0⟩) main 1 (t0) = main 3 ⟨t0⟩ main 2 (t0) = close t0; 0 main 3 (t0) = main 1 ⟨t0⟩ ⊕ main 2 ⟨t0⟩ sendFn 0 (c) = c; 0 recvVal 0 (c) = c; 0Note that the spawning of the goroutine sendFn(ch) becomes a parallel composition of the main thread with sendFn 0 ⟨t0⟩.Example 3.2. Consider the Go program from Listing 2 and its SSA representation in Figure 4. Its inferred type definitions are</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Semantics of types. given below. myselect 0 (c) = c; myselect 2 ⟨c⟩; myselect 1 ⟨c⟩, τ ; myselect 4 ⟨c⟩; myselect 1 ⟨c⟩, τ ; myselect 5 ⟨c⟩; myselect 1 ⟨c⟩ myselect i (c) = 0 for i ∈ {1, 2, 4, 5} myselect (c) = myselect 4 ⟨c⟩ ⊕ myselect 5 ⟨c⟩</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>n a); (new m b);T ≡ (new m b); (new n a);T (new n a); 0 ≡ 0 (new n a); a ⋆ ≡ 0 (new n a); ⌊a⌋ n k ≡ 0 T | (new n a)S ≡ (new n a)(T | S) (a fn(T ))</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6 :</head><label>6</label><figDesc>Structural congruence for types.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Barb predicates for types.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>1 4 } 5 }</head><label>45</label><figDesc>func f ( n int ) { 2 for i := 0; i &lt; n ; i ++ { 3 for j := 0; j &lt; 10; j ++ { ... } our tool generates a single C function f containing the two loops.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>(Predicate) labels</figDesc><table><row><cell>a / a</cell><cell>send / receive on channel a</cell></row><row><cell>τ a</cell><cell>synchronisation over a</cell></row><row><cell>τ</cell><cell>silent action</cell></row><row><cell cols="2">clo a / clo a request to close a / closing a a ⋆ channel a is closed • a / a • push / pop on buffer ã</cell></row><row><cell>o</cell><cell>waiting to synchronise over the actions inõ</cell></row><row><cell cols="2">a;T ↓ a close a;T ↓ clo a</cell></row><row><cell>a;T ↓ a</cell><cell>a ⋆ ↓ a</cell></row></table><note>⋆ ∀i ∈ {1, . . . , n} :</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Go programs verified by our framework and comparison with existing static deadlock detection tools.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Godel Checker</cell><cell></cell><cell></cell><cell></cell><cell cols="4">dingo-hunter [36] gopherlyzer [40]</cell><cell cols="3">GoInfer/Gong [30]</cell></row><row><cell></cell><cell>Programs</cell><cell cols="6">LoC # states ψ д ψ l ψ s ψ e</cell><cell>Infer</cell><cell cols="2">Live Live+CS</cell><cell>Term</cell><cell>Live</cell><cell cols="2">Time DF</cell><cell cols="3">Time Live CS</cell><cell>Time</cell></row><row><cell></cell><cell>mismatch [36]</cell><cell></cell><cell></cell><cell>×</cell><cell>×</cell><cell>✓</cell><cell>✓</cell><cell>620.7</cell><cell>996.8</cell><cell>996.7</cell><cell>✓</cell><cell>×</cell><cell>639.4</cell><cell>×</cell><cell>3956.4</cell><cell>×</cell><cell>✓</cell><cell>616.8</cell></row><row><cell>2</cell><cell>fixed [36]</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>624.4</cell><cell>996.5</cell><cell>996.3</cell><cell>✓</cell><cell>✓</cell><cell>603.1</cell><cell>✓</cell><cell>3166.3</cell><cell>✓</cell><cell>✓</cell><cell>601.0</cell></row><row><cell>3</cell><cell>fanin [36, 39]</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>631.1</cell><cell>996.2</cell><cell>996.2</cell><cell>✓</cell><cell>✓</cell><cell>608.9</cell><cell>✓</cell><cell>19.8</cell><cell>✓</cell><cell>✓</cell><cell>696.7</cell></row><row><cell>4</cell><cell>sieve [30, 36]</cell><cell></cell><cell>∞</cell><cell></cell><cell>n/a</cell><cell></cell><cell></cell><cell>-</cell><cell>-</cell><cell>-</cell><cell>n/a</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell>✓</cell><cell>✓</cell><cell>778.3</cell></row><row><cell>5</cell><cell>philo [40]</cell><cell>41</cell><cell></cell><cell>×</cell><cell>×</cell><cell>✓</cell><cell>✓</cell><cell>6.1</cell><cell>996.5</cell><cell>996.6</cell><cell>✓</cell><cell>×</cell><cell>34.2</cell><cell>×</cell><cell>27.0</cell><cell>×</cell><cell>✓</cell><cell>16.8</cell></row><row><cell>6</cell><cell>dinephil3 [13, 33]</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>645.2</cell><cell>996.4</cell><cell>996.3</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell>✓</cell><cell cols="2">✓ 13.2 min</cell></row><row><cell>7</cell><cell>starvephil3</cell><cell>47</cell><cell>3151</cell><cell>×</cell><cell>×</cell><cell>✓</cell><cell>✓</cell><cell>628.2</cell><cell>996.5</cell><cell>996.5</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell>×</cell><cell>✓</cell><cell>3.5 min</cell></row><row><cell>8</cell><cell>sel [40]</cell><cell></cell><cell>103</cell><cell>×</cell><cell>×</cell><cell>✓</cell><cell>✓</cell><cell>4.2</cell><cell>996.7</cell><cell>996.6</cell><cell>✓</cell><cell>×</cell><cell>15.3</cell><cell>×</cell><cell>13.0</cell><cell>×</cell><cell>✓</cell><cell>50.5</cell></row><row><cell>9</cell><cell>selFixed [40]</cell><cell>22</cell><cell>20</cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>4.0</cell><cell>996.3</cell><cell>996.4</cell><cell>✓</cell><cell>✓</cell><cell>14.9</cell><cell>✓</cell><cell>3168.3</cell><cell>✓</cell><cell>✓</cell><cell>13.1</cell></row><row><cell cols="2">10 jobsched [30]</cell><cell></cell><cell>43</cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>632.7</cell><cell>996.7</cell><cell>1996.1</cell><cell>✓</cell><cell>n/a</cell><cell>-</cell><cell>✓</cell><cell>4753.6</cell><cell>✓</cell><cell>✓</cell><cell>635.2</cell></row><row><cell cols="2">11 forselect [30]</cell><cell>42</cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>623.3</cell><cell>996.4</cell><cell>996.3</cell><cell>✓</cell><cell>✓</cell><cell cols="2">611.8 n/a</cell><cell>-</cell><cell>✓</cell><cell>✓</cell><cell>618.6</cell></row><row><cell cols="2">12 cond-recur [30]</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>4.0</cell><cell>996.2</cell><cell>996.2</cell><cell>✓</cell><cell>✓</cell><cell cols="2">9.4 n/a</cell><cell>-</cell><cell>✓</cell><cell>✓</cell><cell>14.7</cell></row><row><cell cols="2">13 concsys [42]</cell><cell></cell><cell></cell><cell>×</cell><cell>×</cell><cell>✓</cell><cell>✓</cell><cell>549.7</cell><cell>996.5</cell><cell>996.4</cell><cell>✓</cell><cell>n/a</cell><cell>-</cell><cell>×</cell><cell>5278.6</cell><cell>×</cell><cell>✓</cell><cell>521.3</cell></row><row><cell cols="2">14 alt-bit [30, 35]</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>634.4</cell><cell>996.3</cell><cell>996.3</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell>✓</cell><cell>✓</cell><cell>916.8</cell></row><row><cell cols="2">15 prod-cons</cell><cell></cell><cell></cell><cell>✓</cell><cell>×</cell><cell>✓</cell><cell>✓</cell><cell>4.1</cell><cell>996.4</cell><cell>1996.2</cell><cell>✓</cell><cell>×</cell><cell>10.1</cell><cell>×</cell><cell>30.1</cell><cell>×</cell><cell>✓</cell><cell>21.8</cell></row><row><cell cols="2">16 nonlive</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell>630.1</cell><cell>996.6</cell><cell cols="2">996.5 timeout</cell><cell>⊗</cell><cell cols="2">613.6 n/a</cell><cell>-</cell><cell>⊗</cell><cell>✓</cell><cell>613.8</cell></row><row><cell cols="2">17 double-close</cell><cell></cell><cell></cell><cell>✓</cell><cell>✓</cell><cell>×</cell><cell>✓</cell><cell>3.5</cell><cell>996.6</cell><cell>1996.6</cell><cell>✓</cell><cell>⊠</cell><cell>8.7</cell><cell>⊠</cell><cell>11.8</cell><cell>✓</cell><cell>×</cell><cell>9.1</cell></row><row><cell cols="2">18 stuckmsg</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>×</cell><cell>3.5</cell><cell>996.6</cell><cell>996.6</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell>✓</cell><cell>✓</cell><cell>7.6</cell></row><row><cell></cell><cell>dinephil5</cell><cell></cell><cell>∼1M</cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell cols="3">626.5 41.2 sec 41.4 sec</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell cols="2">timeout</cell><cell>&gt;48 hrs</cell></row><row><cell cols="2">20 prod3-cons3</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell cols="3">465.1 40.9 sec 40.9 sec</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell cols="2">timeout</cell><cell>&gt;48 hrs</cell></row><row><cell cols="2">21 async-prod-cons</cell><cell></cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell>✓</cell><cell cols="3">4.3 47.7 sec 89.4 sec</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell cols="2">timeout</cell><cell>&gt;48 hrs</cell></row><row><cell cols="2">22 astranet [26]</cell><cell>∼18k</cell><cell></cell><cell>✓</cell><cell cols="2">✓ ✓</cell><cell cols="4">✓ 2512.5 70.4 sec 75.0 sec</cell><cell>✓</cell><cell>n/a</cell><cell cols="2">-n/a</cell><cell>-</cell><cell>n/a</cell><cell></cell><cell>-</cell></row><row><cell></cell><cell>Column</cell><cell></cell><cell></cell><cell>5</cell><cell>6</cell><cell>7</cell><cell>8</cell><cell>9</cell><cell>10</cell><cell>11</cell><cell>12</cell><cell></cell><cell>14</cell><cell></cell><cell>16</cell><cell>17</cell><cell>18</cell><cell>19</cell></row></table><note>CS: Channel Safe, Term: Termination check, DF: Deadlock-free, timeout: Termination check timeout (likely does not terminate), ⊠: False Alarm, ⊗: Undetected liveness error.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The work is partially supported by the EPSRC (grants EP/K034413/1, EP/K011715/1, EP/L00058X/1, EP/N027833/1, and EP/N028201/1)</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Behavioral Types in Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Davide</forename><surname>Ancona</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viviana</forename><surname>Bono</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Bravetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joana</forename><surname>Campos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giuseppe</forename><surname>Castagna</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre-Malo</forename><surname>Deniélou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><forename type="middle">J</forename><surname>Gay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nils</forename><surname>Gesbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elena</forename><surname>Giachino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francisco</forename><surname>Einar Broch Johnsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Viviana</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabrizio</forename><surname>Mascardi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rumyana</forename><surname>Montesi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Neykova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Padovani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations and Trends in Programming Languages</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2-3</biblScope>
			<biblScope unit="page" from="95" to="230" />
			<date type="published" when="2017" />
			<publisher>Now Publishers Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Appel</surname></persName>
		</author>
		<idno type="DOI">10.1145/278283.278285</idno>
		<ptr target="https://doi.org/10.1145/278283.278285" />
	</analytic>
	<monogr>
		<title level="j">SSA is Functional Programming. SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="17" to="20" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Software model checking for distributed systems with selector-based, non-blocking communication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cyrille</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Masami</forename><surname>Hagiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Potter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshinori</forename><surname>Tanabe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franz</forename><surname>Weitl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitsuharu</forename><surname>Yamamoto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="169" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<ptr target="http://golang.org/x/tools/go/ssa" />
		<title level="m">The Go Authors. 2013. package ssa</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">go 1.5.1 linux/amd64 deadlock detection failed</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brad</forename><surname>Fitzpatrick</surname></persName>
		</author>
		<ptr target="https://github.com/golang/go/issues/12734" />
		<imprint>
			<date type="published" when="2015-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Core Erlang 1.0 language specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Carlsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Björn</forename><surname>Gustavsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erik</forename><surname>Johansson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Lindgren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sven-Olof</forename><surname>Nyström</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mikael</forename><surname>Pettersson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Virding</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
		<respStmt>
			<orgName>Information Technology Department, Uppsala University, Tech. Rep</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Types as models: model checking message-passing programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sagar</forename><surname>Chaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sriram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakob</forename><surname>Rajamani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rehof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="45" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Finite-Control Mobile Ambients</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Witold</forename><surname>Charatonik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><forename type="middle">D</forename><surname>Gordon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Marc</forename><surname>Talbot</surname></persName>
		</author>
		<idno type="DOI">10.1007/3-540-45927-8_21</idno>
		<ptr target="https://doi.org/10.1007/3-540-45927-8_21" />
	</analytic>
	<monogr>
		<title level="m">ESOP</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="295" to="313" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title/>
		<ptr target="https://coreos.com/" />
	</analytic>
	<monogr>
		<title level="j">CoreOS</title>
		<imprint>
			<date type="published" when="2017-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">An Overview of the mCRL2 Toolset and Its Recent Advances</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><forename type="middle">Friso</forename><surname>Sjoerd Cranen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Groote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Jeroen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Keiren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">M</forename><surname>Frank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erik</forename><forename type="middle">P</forename><surname>Stappers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wieger</forename><surname>De Vink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><forename type="middle">A C</forename><surname>Wesselink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Willemse</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-642-36742-7_15</idno>
		<ptr target="https://doi.org/10.1007/978-3-642-36742-7_15" />
		<imprint>
			<date type="published" when="2013" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="199" to="213" />
			<pubPlace>Berlin Heidelberg; Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Model Checking Mobile Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mads</forename><surname>Dam</surname></persName>
		</author>
		<idno type="DOI">10.1006/inco.1996.0072</idno>
		<ptr target="https://doi.org/10.1006/inco.1996.0072" />
	</analytic>
	<monogr>
		<title level="j">Information and Computation</title>
		<imprint>
			<biblScope unit="volume">129</biblScope>
			<biblScope unit="page" from="35" to="51" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre-Malo</forename><surname>Deniélou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Multiparty Session Types Meet Communicating Automata. In ESOP</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">7211</biblScope>
			<biblScope unit="page" from="194" to="213" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Cooperating sequential process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1965" />
			<biblScope unit="page" from="43" to="112" />
		</imprint>
	</monogr>
	<note type="report_type">Programming Languages</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Open Sourcing our Go Libraries</title>
		<ptr target="https://blogs.dropbox.com/tech/2014/07/open-sourcing-our-go-libraries/." />
		<imprint>
			<date type="published" when="2014-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Termination Analysis of C Programs Using Compiler Intermediate Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Falke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deepak</forename><surname>Kapur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carsten</forename><surname>Sinz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RTA</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Termination Analysis of Imperative Programs Using Bitvector Arithmetic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Falke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deepak</forename><surname>Kapur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carsten</forename><surname>Sinz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="261" to="277" />
			<pubPlace>Berlin Heidelberg; Berlin, Heidelberg</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">FDR3 -A Modern Refinement Checker for CSP</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Gibson-Robinson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandre</forename><surname>Boulgakov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">W</forename><surname>Roscoe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems (Lecture Notes in Computer Science)</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">8413</biblScope>
			<biblScope unit="page" from="187" to="201" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Modeling and Analysis of Communicating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Friso Groote</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad</forename><forename type="middle">Reza</forename><surname>Mousavi</surname></persName>
		</author>
		<ptr target="https://mitpress.mit.edu/books/modeling-and-analysis-communicating-systems" />
		<imprint>
			<date type="published" when="2014" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">The OpenCL Specification Version 2</title>
		<ptr target="https://www.khronos.org/registry/OpenCL/specs/opencl-2.0.pdf" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
		<respStmt>
			<orgName>Khronos OpenCL Working Group</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Model Checking JAVA Programs using</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Pressburger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">JAVA PathFinder. STTT</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="366" to="381" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Communicating Sequential Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tony</forename><surname>Hoare</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Multiparty Asynchronous Session Types</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kohei</forename><surname>Honda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Carbone</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL&apos;08. ACM</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1" to="67" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Foundations of Session Types and Behavioural Contracts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans</forename><surname>Hüttel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ivan</forename><surname>Lanese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Vasco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luís</forename><surname>Vasconcelos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Caires</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre-Malo</forename><surname>Carbone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dimitris</forename><surname>Deniélou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Mostrous</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">António</forename><surname>Padovani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emilio</forename><surname>Ravara</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><forename type="middle">Torres</forename><surname>Tuosto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gianluigi</forename><surname>Vieira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zavattaro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">3</biblScope>
			<date type="published" when="2016-04" />
		</imprint>
	</monogr>
	<note>36 pages</note>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A generic type system for the Pi-calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Atsushi</forename><surname>Igarashi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naoki</forename><surname>Kobayashi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">311</biblScope>
			<biblScope unit="page" from="121" to="163" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Biin</surname></persName>
		</author>
		<ptr target="https://github.com/zenhotels/astranet" />
	</analytic>
	<monogr>
		<title level="j">AstraNet</title>
		<imprint>
			<date type="published" when="2017-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Kubernetes: Production-Grade Container Orchestration</title>
		<ptr target="https://kubernetes.io/" />
	</analytic>
	<monogr>
		<title level="m">K8S 2017</title>
		<imprint>
			<date type="published" when="2017-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Results on the Propositional mu-Calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Dexter Kozen</surname></persName>
		</author>
		<idno type="DOI">10.1016/0304-3975(82)90125-6</idno>
		<ptr target="https://doi.org/10.1016/0304-3975(82" />
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="90125" to="90131" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Sound static deadlock analysis for C/Pthreads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Kroening</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Poetzl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Schrammel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Björn</forename><surname>Wachter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ASE</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="379" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Fencing off Go: Liveness and Safety for Channel-based Programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernardo</forename><surname>Toninho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<publisher>ACM</publisher>
			<biblScope unit="page" from="748" to="761" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernardo</forename><surname>Toninho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
		<ptr target="http://mrg.doc.ic.ac.uk/tools/godel-checker/" />
	</analytic>
	<monogr>
		<title level="j">Godel Checker</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">From Communicating Machines to Graphical Choreographies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Lange</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emilio</forename><surname>Tuosto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL. ACM</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="221" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Magee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Kramer</surname></persName>
		</author>
		<title level="m">Concurrency: State Models &amp; Java Programs</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>John Wiley &amp; Sons, Inc</publisher>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A Calculus of Communicating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robin</forename><surname>Milner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<date type="published" when="1980" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Communication and Concurrency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robin</forename><surname>Milner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>Prentice-Hall, Inc</publisher>
			<pubPlace>Upper Saddle River, NJ, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Static deadlock detection for concurrent go by global session graph synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Ng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nobuko</forename><surname>Yoshida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CC</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="174" to="184" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Deadlock and Lock Freedom in the Linear π -Calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Padovani</surname></persName>
		</author>
		<idno type="DOI">10.1145/2603088.2603116</idno>
		<ptr target="https://doi.org/10.1145/2603088.2603116" />
		<editor>CSL-LICS&apos;14, Thomas A. Henzinger and Dale Miller</editor>
		<imprint>
			<date type="published" when="2014" />
			<publisher>ACM Press</publisher>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="1" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Symbolic PathFinder: integrating symbolic execution with model checking for Java bytecode analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Corina</forename><forename type="middle">S</forename><surname>Pasareanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willem</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">H</forename><surname>Bushnell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jaco</forename><surname>Geldenhuys</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">C</forename><surname>Mehlitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neha</forename><surname>Rungta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Autom. Softw. Eng</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="391" to="425" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Go Concurrency Patterns: Pipelines and cancellation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sameer Ajmani</surname></persName>
		</author>
		<ptr target="https://blog.golang.org/pipelines" />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Static Trace-Based Deadlock Analysis for Synchronous Mini-Go</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Stadtmüller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Sulzmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Thiemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">APLAS</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="116" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Building a new router for GOV</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Stenning</surname></persName>
		</author>
		<ptr target="https://gdstechnology.blog.gov.uk/2013/12/05/building-a-new-router-for-gov-uk/" />
		<imprint>
			<date type="published" when="2017-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Collection of Golang concurrency patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stillwater</forename><surname>Supercomputing</surname></persName>
		</author>
		<ptr target="https://github.com/stillwater-sc/concurrency" />
		<imprint>
			<date type="published" when="2017-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<monogr>
		<title level="m" type="main">The Go Authors</title>
		<ptr target="https://golang.org/doc/effective_go.html" />
		<imprint>
			<date type="published" when="2017-06" />
		</imprint>
	</monogr>
	<note>Effective Go</note>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Model Checking Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willem</forename><surname>Visser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Klaus</forename><surname>Havelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><forename type="middle">P</forename><surname>Brat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seungjoon</forename><surname>Park</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Fifteenth IEEE International Conference on Automated Software Engineering, ASE</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="3" to="12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">How we built Uber engineering&apos;s highest query per second service using Go</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Wei</surname></persName>
		</author>
		<ptr target="https://eng.uber.com/go-geofence/" />
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
