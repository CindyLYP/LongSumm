<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Rank Ordered Autoencoders</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2016-05-05">5 May 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Bertens</surname></persName>
							<email>p.m.w.a.bertens@gmail.com</email>
						</author>
						<title level="a" type="main">Rank Ordered Autoencoders</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2016-05-05">5 May 2016</date>
						</imprint>
					</monogr>
					<idno type="arXiv">arXiv:1605.01749v1[cs.LG]</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>A new method for the unsupervised learning of sparse representations using autoencoders is proposed and implemented by ordering the output of the hidden units by their activation value and progressively reconstructing the input in this order. This can be done efficiently in parallel with the use of cumulative sums and sorting only slightly increasing the computational costs. Minimizing the difference of this progressive reconstruction with respect to the input can be seen as minimizing the number of active output units required for the reconstruction of the input. The model thus learns to reconstruct optimally using the least number of active output units. This leads to high sparsity without the need for extra hyperparameters, the amount of sparsity is instead implicitly learned by minimizing this progressive reconstruction error. Results of the trained model are given for patches of the CIFAR10 dataset, showing rapid convergence of features and extremely sparse output activations while maintaining a minimal reconstruction error and showing extreme robustness to overfitting. Additionally the reconstruction as function of number of active units is presented which shows the autoencoder learns a rank order code over the input where the highest ranked units correspond to the highest decrease in reconstruction error.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Autoencoders</head><p>Autoencoders are a common technique used for the unsupervised learning of representations of the underlying data <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b1">2,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b19">20,</ref><ref type="bibr" target="#b7">8]</ref>. Based on artificial neural networks they have as output target the given input, and must learn to reconstruct the input through some representation in the hidden layers. While standard autoencoders are effective at learning a representation that is smaller in dimensionality than the input, when the representation is over-complete, i.e. there are more hidden units than input units, a standard autoencoder can learn the identity function instead of meaningful features. To avoid this problem many techniques have been developed, most notably sparse autoencoders, which put an extra cost on the hidden layer to create sparse representation <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14]</ref> or restrict the number of allowed non-zero activations <ref type="bibr" target="#b15">[16]</ref> and denoising autoencoders which add noise to the input and try to reconstruct the original input from this noisy input <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b25">26]</ref>. These techniques require the autoencoder to learn more meaningful features that can describe the data instead of just copying the current input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Sparse coding</head><p>There have been several attempts at achieving sparse over-complete representations as they have many desirable properties over conventional dense codes <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b17">18,</ref><ref type="bibr" target="#b16">17]</ref>. A dense code is far more difficult to decode, as more units are required for decoding and each unit has less individual meaning. The code is also unlikely to be linearly separable which is an important property in learning representations. Dense codes have the problem of catastrophic forgetting as well, as all units get updated for each input, while in a sparse code only a small subset gets updated. Furthermore a sparse code allows for more efficient computation as less input units are required to compute the output. Still a too sparse code is also not optimal, as it results in less possible ways to encode the input and reduces the similarity between the representation and the inputs. Learning similarity between inputs is needed to not have to relearn many common features between them and to be able to compare inputs from their representation. One thus wants to strike a good balance between these such that each input is represented by a sparse subset of features, usually in the context of autoencoders this is done by setting a sparsity penalty on the hidden unit representation, this however adds an extra hyper-parameter to be learned and creates a tradeoff between sparsity and reconstruction error. An alternative is to select only the top k units for activation as was done in the k-sparse autoencoder paper <ref type="bibr" target="#b15">[16]</ref> but this suffers from a similar limitation as we have to specify a value for the hyperparameter k. Alternatively one could train on a small set of units that is incrementally updated which is what is done in the incremental autoencoder approach <ref type="bibr" target="#b27">[28]</ref>, where a small set of units is trained first and new units are added while also merging existing units. This however is an incremental approach and the units are not directly trainable in parallel and again adds extra hyperparameters for merging and adding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Ordered codes</head><p>Another related approach is based on learning ordered codes, one such example is the use of nested dropout <ref type="bibr" target="#b21">[22]</ref>, which is an extension of standard dropout <ref type="bibr" target="#b22">[23]</ref>. Where instead of dropping 50% of the hidden units at random, units are dropped in order such that units can depend on units before them while in standard drop-out this is not the case and each unit has to be mostly independent. This is done by selecting an index according to some exponential distribution and dropping all units after the index. In the paper one issue was that later units had the problem of being very likely to be dropped and therefore were difficult to train, to avoid this they fixed each of the units in order after they had been trained sufficiently. However this significantly increases training time and due to the fixed distribution on the output only strictly ordered codes can be learned which limits the number of possible ways to represent the input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">Objective</head><p>Some of the previous limitations of learning meaningful features in autoencoders is thus that they either require sequential computation that is difficult to parallellize, need some type of stochastic noise, or require extra hyperparameters for the sparsity level. Therefore the desired objective of this paper is to find the optimal weights of an autoencoder such that it is capable of reconstructing using a minimal number of output units without the need for a sparsity parameter or added noise and still remain easily parallelizable. We thus want to minimize the L 0 norm of the output units on the condition that the reconstruction error stays minimal. To formalize this means we want to minimize the following function:</p><formula xml:id="formula_0">E = ||x −x|| 2 + λ||y|| 0 = ||x − f (xW)W T )|| 2 + λ||f (xW)|| 0<label>(1)</label></formula><p>This objective function is not convex and not directly differentiable due to the L 0 norm and the unknown λ, in practice usually this objective function is changed to minimizing the L 1 norm and setting λ as an extra hyper parameter <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b3">4]</ref>. However we take a different approach, in order to try and solve this minimization problem a method is proposed and implemented based on ordering the output representation of a standard autoencoder by their output values and reconstructing from this representation progressively using a cumulative sum (also known as prefix sum, i.e. y i = i k=0 x k ). We would thus like to minimize the following function instead:</p><formula xml:id="formula_1">E = m j=0 j k=0 ||x −x ro m−k || 2 = m j=0 j k=0 ||x − m−k l=0ẍ ro l || 2<label>(2)</label></formula><p>Where m is the number of output units, andx ro m−k the progressive reconstruction using a cumulative sum over the rank ordered individual reconstructionsẍ ro l (ordered by the rank of output y from high to low). In this ordered cumulative sum domain the function does become directly optimizable (see also figure 1 and 2). The j k=0 ||x −x ro m−k || 2 term intuitively means that we would like to have the lowest reconstruction error left for low ranked units, and the highest error for high ranked units. If we take some arbitrary reconstruction error k at unit k we will have that m j=0 j k=0 m−k ≥ m j=0 j k=0 m−k−1 . This implies that units with a high ranking should learn to minimize the error as much as possible to ensure that the total error is as low as possible. If an error is left the sum of the cumulative sum of this error always increases proportional to the number of units that come after it (we take the reverse cumulative sum m − k), meaning the total error always increases. This means for example that the error vector [0.5, 0.2, 0.1] has an higher error than [0.5, 0.3, 0] (if we were to take simply the sum this would not be the case). Minimizing this function will therefore ensure that units with a high output (high ranking) will reconstruct most of the signal while successive units will reconstruct less and less. We not only implicitly minimize the ordered L 0 norm this way, i.e. In order to reconstruct a large part of the signal (and maximally reduce the error) the weights have to be large enough, this in turn means the output will increase, thus we implicitly learn to also increase the output of the high ranked units. It also means as we maximally decrease the error in high ranked units, units of lower rank will either have to be zero or have small weights which will decrease the output of the lower ranked units. So we can indirectly solve the actual desired objective function:</p><formula xml:id="formula_2">E = ||x −x)|| 2 + λ m j=0 j k=0 y ro m−k ≤ ||x −x)|| 2 + λ m j=0 j k=0 sign(y ro m−k ) = ||x −x)|| 2 + λ||y|| 0 + m−1 j=0 j k=0 sign(y ro m−k )<label>(3)</label></formula><p>by minimizing the progressive reconstruction instead (eq. 2) without having to know the sparsity parameter λ. The difference between eq. 1 and eq. 3 is only that instead of minimizing the L 0 norm we indirectly minimize a type of ordered L 0 norm. If we have that 0 ≤ y j ≤ 1 then 3 is the one has as many zeros as possible for lower ranked units, and should move as much of the output to the higher ranked units. This is identical to what eq. 2 is doing, meaning we can indeed indirectly solve eq. 3 by minimizing eq. 2. It is also clear that there is a relation between eq. 1 and eq. 3 through the L 0 norm term (taking the L 0 norm of any permuted vector, including the rank ordered vector, is the same as the L 0 norm of the original vector), while an exact mathematical derivation of whether the solutions of minimizing these equations are identical is outside the scope of this paper, we do show experimentally that we indeed achieve the expected sparsity on the output.</p><p>In the approach section we expand further upon this idea giving both algorithmic pseudo-code and justifications for the used technique. First the basic approach of minimizing the number of outputs required for reconstruction is presented. A custom derivative function is then also derived to help minimize the given objective function (eq. 2). Additionally details are given on algorithmic complexity and we expand upon the relation to rank order coding, PCA(principal component analysis) and nested dropout. In the experiment section the model is tested on patches of the CIFAR10 dataset by looking at learned features, reconstruction errors, convergence rates and sparsity levels. Finally we conclude with a summary of the results and present possible future extensions and improvements to the model.  x is the input, y the hidden representation, r n the normal individual reconstructions, a the indexes that would sort y, r c the progressive reconstruction, e x the error with respect to the real input and e y the back-propagated error at the hidden units.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Rank Ordered Autoencoders</head><p>In order to minimize the number of required outputs for reconstruction we can progressively, in order, reconstruct the input by the rank order of the output values. We can then compute the error with respect to this progressive reconstruction and minimize this error for each of the output units by using standard stochastic gradient descent and back-propagation (see also figure 2). Each unit thus tries to minimize the remaining reconstruction error left by previous units that are higher ranked, and we do this in parallel through the use of a cumulative sum. If this error becomes zero the error at the remaining units will also become zero resulting in the use of minimal output units for reconstruction. This way we can solve the problem of finding the set of weights that minimizes eq. 2 and also indirectly eq. 3. In the classical approach we would calculate the sum of the weights multiplied by the output values when doing the reconstruction, in this case we calculate the cumulative sum of the reconstruction ordered by their output ranks. This cumulative sum is capable of assigning an unique error to each unit dependent on their rank, while normal summation would 'blur' this error.</p><p>To illustrate the process (numpy like notation for convenience , which is dependent on both the error and output. This function causes hidden units to only be able to move towards 0 to both avoid dead units and minimize the number of active units. All other changes to the output is determined solely by the weight updates of the error at the input.</p><p>Instead of the standard rectified linear unit, the output is thresholded to 1 and the new activation function becomes f = min(1, max(0, y)) (TReLU), see <ref type="figure" target="#fig_4">figure 3</ref>. This is done to avoid potentially blowing up the output activation which would blow up the gradient and it is also a desirable property for potentially deeper networks to avoid exponentially increasing output. However since the summation is highly likely to exceed 1 we divide the output by the number of input units, if we assume each input unit is between 0 and 1 and each weight is approximately between -1 and 1 (in case of tied weights this is likely the case as reconstruction weights are close to actual input values) then the output will never actually exceed 1.</p><p>A different derivative is also used for the activation function (see <ref type="figure" target="#fig_4">figure 3)</ref>, instead of the real derivative, which is zero when y &lt; 0 and y &gt; 1, we use a maybe less mathematical rigorous but more sensible version that can avoid dead units. The standard derivative often leads to inactive dead units as the derivative is always zero for negative outputs so instead we derive the derivative from the movement of the units that we desire. We want to move inactive units up if required, this is the case when the error at that unit is still high meaning previous higher ranked units did not properly reconstruct and we should 'recruit' this unit. We also want to move active units down if required, meaning too many units are active and the reconstruction error is too high. Moving negative units more down wouldn't make sense as these were already zero and this would not improve the objective function and instead would merely destroy previously learned representations, similarly moving positive units more up is not desired as this is already done by the gradient calculated at the input. This thus reduces to the following desired derivative: f = (sign(error) = sign(output)). There is also no bias on the hidden units, instead the bias is assumed to be implicitly learned from the input. This is done because if a unit has to change its activation value it should be as a function of other units, which is implicitly contained within the input values, instead of as a function of a bias value.</p><p>As was mentioned in the introduction this approach of reconstruction and weight updating can be seen as a way of minimizing the ordered L 0 norm of the output representation while keeping the reconstruction error minimal. This is in stark contrast to the usual approach of learning sparse representations that set specific sparsity target values which try balance reconstruction with sparsity. In our case it is assumed that some units will actually increase reconstruction errors, as they likely represent features of different inputs adding them to the reconstruction increases the error, but too few units also increase the error as we have less units to represent the input (see <ref type="figure" target="#fig_2">figure 1</ref>). Thus we try to minimize the number of units while keeping the reconstruction error minimal. If the error increases the proposed update rule implicitly adds new units to be able to fix this error, while if there are too many units that increase the error the update rule will reduce this error by removing these units from the current reconstruction, this is achieved by the custom derivative function <ref type="figure" target="#fig_4">(Figure 3</ref>) and the rank ordered progressive reconstruction <ref type="figure" target="#fig_3">(Figure 2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Algorithmic complexity</head><p>The algorithmic complexity does not actually increase compared to standard auto-encoders. Since the forward pass is left unchanged the only additions are a sort on the outputs and a cumulative sum on the reconstruction. Let n be the number of input units, m be the number of output units, x the input, w the weight matrix and y j the output at unit j. Then the forward pass which is a matrix vector product becomes y j = The reconstruction complexity using the cumulative sum, r j,i = r j−1,i +y j •w ji , is O(n•m) which is the same as when taking the normal sum. Other computations are always standard element-wise products or summations never exceeding O(n • m) and thus overall algorithmic complexity remains unchanged. Memory complexity also remains the same, we do require to keep the cumulative sum however this does not increase the standard memory complexity as it is bound by the weight matrix O(n • m). For input vectors and output vectors the cumulative sum requires an extra m outputs resulting in a memory complexity of O(n • m), however it should be noted this only holds for input vectors, for input matrices when memory is no longer bounded by the weight matrix but by the input size, memory complexity does increase by a factor proportional to the matrix height (i.e. mini-batch size).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Computational efficiency using ordered sparsity</head><p>The induced sparsity combined with the ordered representation can further be exploited to increase computational efficiency and reduce memory requirements. As was mentioned before we are computing the cumulative sum over the output units which in the case of vectors does not increase the memory bound however when scaling up to using mini-batches this significantly increases memory requirements over standard matrix-matrix multiplications (increased by mini-batch size d). This increase in memory can somewhat be reduced by only reconstructing from the active units, if we assume only k active units, the increase in memory is only by a factor of k and so instead of a memory complexity of O(n • d • m) we get a complexity of O(n • d • k), since we learn extremely sparse representations this number can be much lower than the actual number of output units bringing it closer to the standard memory bound of O(n • d). Further more in potentially deeper architectures the ordered sparse output can be used to compute the forward pass on only these active units resulting, in case of using vectors, in a forward pass of O(n•k) instead of O(n•m). This allows for a very large number of hidden units while still keeping computational cost low.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Relation to PCA</head><p>If we look at this approach in a sequential way instead of the presented parallel approach it becomes easier to see the relation to PCA (principal component analysis). The relation between standard autoencoders and PCA is well known however ranked autoencoders make this relation much more clear. The highest ranked unit j gets reconstructed first, lets call this reconstruction x j which thus means we try to minimize ||x −x j || 2 then we add to this reconstruction the second highest ranked unit j + 1 which means we have to minimize ||(x −x j ) −x j+1 || 2 and we do this for each non-zero output unit. We thus subtract each component from the input, and learn the next component on the remainder, this is equivalent to performing PCA. However in contrast to PCA we have a non-linear output, so we are doing a type of conditional non-linear PCA. The non-linearity (ReLU) results in the selection of a subset of components, those that exceed zero, and weights each of the components by their output value. This means we can learn a much larger representations than PCA and we actually get components that are dependent on the input and only apply to some subset of the data instead of components that apply to all of the data. This allows for easier separability between inputs as we have a different subset of components for each input.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Relation to dropout</head><p>Another way to see this approach is as a deterministic version of nested dropout on the sorted output. Since we sort the output we can have an arbitrary output instead of requiring a strictly ordered representation as was the case in the original nested dropout paper <ref type="bibr" target="#b21">[22]</ref>, allowing different orders at the output allows for more possible ways to encode the input. While in standard dropout we have 2 m possible sub-models <ref type="bibr" target="#b22">[23]</ref>, in the case of nested dropout we only have m possible submodels. It is possible to compute all these m models in parallel with little overhead in memory as there is an order in the sub-models such that each model is dependent on the previous model. Computing these sub-models in parallel can be achieved using a cumulative sum as proposed in this paper. This potentially also still provides the overfitting robustness provided by dropout and since we additionally try and learn a representation of the data that uses as few non-zero components as possible, a type of minimum description length <ref type="bibr" target="#b11">[12]</ref>, it should make the approach extremely robust to overfitting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Relation to neuroscience and rank order coding</head><p>The idea of learning rank ordered representations is not new, and there have been many attempts in the past especially in the field of neuroscience <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b8">9]</ref>. However biologically realistic functions and mechanisms are commonly used and the continious value is usually discarded keeping only the rank information. Iterative methods are then employed to compute the outputs which are very difficult to parallelize making it much less practical. They also do not necessarily try to explicitly minimize the reconstruction error but instead use STDP (Spike time dependent plasticity) <ref type="bibr" target="#b6">[7]</ref> or similar like learning rules for learning the internal representation. This means that reconstructing from this model cannot always be done directly so there is less guarantee on the amount of information maintained by the representation.</p><p>The continuous value in the rank ordered autoencoder can actually be interpreted as the spike timing, instead of the classical assumption that it is the firing rate. High outputs 'fire' first and we get a progressive spike wave ordered by their spike timings, we then try to explicit learn to reconstruct from this ordered spike wave. Discarding the exact timing while robust to contrast variation also reduces the luminance information contained in these spike timings, so we can keep more information using continuous values instead of rank values with little increase in learning complexity. Spike timings are biologically more realistic than firing rates as the rapid processing of visual stimuli observed in the brain cannot be achieved with the limited firing rate of neurons <ref type="bibr" target="#b9">[10]</ref>. These type of rank order codes encode most of the information in the initial few spikes which allows for more rapid inference to be made when still only a few neurons have fired <ref type="bibr" target="#b23">[24]</ref>. This makes the rank ordered autoencoder biologically much more realistic than the standard feed-forward networks that do not take into account this order in the spike timings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experiment</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Method</head><p>In order to test the proposed approach we apply it to patches of the CIFAR10 2 dataset which consists of a set of 50000 training and 10000 test samples of natural images. The implementation was made in python using the standard numpy library. Currently only a CPU version is implemented however the approach is easily parrallizable and can be made to run efficiently on a GPU, at test time the rank ordered autoencoder is actually identical to the standard one, only the training is modified. The experiments were run on a i5-2500k CPU and run for 60 epochs. Each epoch consists of a random 7x7 patch extracted from each image in the dataset (for the test set we extract 5). Importantly there was no preprocessing done on the data (usually standardization and whitening is performed). This was avoided to evaluate the performance on unprocessed data, and it is assumed the autoencoder will actually extract the mean from the data in its first component.</p><p>The number of hidden units were set to 169, and weights between the encoder and decoder are tied. L2 norm clipping <ref type="bibr" target="#b18">[19]</ref> plus a learning rate was used for updating the weights. Norm clipping clips the norm of the gradient to not exceed a certain threshold, this allows for faster learning in the initial few epochs as the error is much higher for the higher ranked units. The initial norm clip was set to 0.1 and the learning rate to 1. The learning rate was reduced by 10% if the training error did not improve by more than 1% after an epoch, the norm clip was not changed. Only a training set and test set was used as no validation set was needed for tuning any hyper-parameters. The learning rate and norm clipping were tuned using only the training error.   Proggressive reconstruction <ref type="figure">Figure 8</ref>: Example of the rank ordered progressive reconstruction, the last filter (lower right corner) is overwritten with the actual current input. Each square represents the reconstruction using an additional output unit showing rapid convergence of toward the actual input using very few output units (only few units are actually active in the reconstruction, see also <ref type="figure" target="#fig_10">Figure 9</ref>).  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Learned filters sorted</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Discussion</head><p>We can see in figure 4 that we successfully learn meaningful edge and color filters over the data that are similar to previous approaches <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b5">6]</ref>. Notably though it is impossible to learn redundant features due to minimizing the progressive reconstruction. However there does appear to be an issue learning some of the lower ranked units that are rarely active which could potentially be due to numerical instability, i.e. the error becomes so small that we can no longer accurately compute the gradient, or merely because they occur so rarely. It is possible that training for more epochs will eventually stabilize these filters. In <ref type="figure">figure 5</ref> we see the expected extreme robustness to overfitting, the test error is nearly identical to the training error this is likely as mentioned before due to the learning of a representation that minimizes the number of active units required for reconstruction. <ref type="figure">Figure 6</ref> and 8 show that we can still achieve an extremely low reconstruction error with only few outputs, making the approach robust to a type of noise where lower ranked units are likely to be missing. It also allows for rapid inference using only the top k number of units. This means we have indeed learned a type of rank order code over the input. If we look at figure 7 we can observe that the derived hypothetical error surface (figure 1) indeed matches the real one. It additionally shows robustness to dropped inputs, even if some of the lower ranked inputs are dropped we can still reconstruct with a low error. Finally we obtain an extremely sparse output distribution (figure 9) that is peaked at 0 and has a very low variance. This type of distribution is commonly explicitly applied to learn sparse distributions, instead we have implicitly learned the distribution by minimizing eq.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusion</head><p>Looking at all the results it is clear we have achieved the desired objective of minimizing the ordered L 0 -norm on the output in eq. 3 by minimizing eq. 2 without setting the actual sparsity parameter λ, instead we have learned this parameter implicitly. This shows that the approach of progressive reconstruction by the sorted output is an effective way to learn sparse representations without requiring a sparsity hyperparamter. It is also easiliy parallelizable making it practical to use in a real world setting. The shown robustness to overfitting additionally allows for an easier way of online learning (streaming data), there is only one learning parameter which is the learning rate which can potentially be modified to also work in an online setting by for example making it dependent on the reconstruction error. We did observe some noisy low output values (figure 9) which maybe makes it desirable to have a different type of activation function <ref type="bibr" target="#b0">[1]</ref> that suppresses this noise and also normalizes high output values. One possible function for this could be a generalized logistic function, that has differentiable shape parameters. It would be interesting as well to see the networks performance on only ranking values instead of the actual output values. If this proves to be an easier task it could then be usefull to learn robustness to contrast variation by using an additional network that tries to learn the actual ranking values from the output values. Another possible extension is to apply a reverse rank ordered autoencoder on the input that learns to reconstruct the output progressively instead of the input (as mentioned in figure 1) this type of reconstruction could increase robustness to a type of input noise where lower ranked inputs are more likely to be missing. One of the remaining issues is that the error at the higher ranked units is much higher which makes learning more unstable, we used norm clipping to prevent some of this instability but this is not an optimal solution. In order for low ranked units to properly learn, the units that reconstruct before it have to be stable. This could potentially be achieved by some type of reinforcement on the weights, that strengthen weights as learning progress as a function of the output. This reinforcement value could then be multiplied by the gradient to reduce the gradient updating. Finally there are the more obvious extensions, which include stacking multiple rank ordered autoencoders to learn hierarchical representations <ref type="bibr" target="#b25">[26]</ref>, adding noise to the input and output to increase robustness and allow for denoising and generating samples <ref type="bibr" target="#b2">[3]</ref>. A GPU implementation using minibatches would increase computational efficiency and we could classify with an extra classification layer or by reconstructing the labels progressively.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>y ro m−k ), we also minimize the sum of the cumulative sum of the remaining non-zero components,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>y j ) = ||y|| 0 . Intuitively because of the property that m−k−1 , the minimum solution of eq.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1 :</head><label>1</label><figDesc>An illustration of a hypothetical reconstruction error surface as a function of number of active outputs and inputs, darker regions indicate higher errors and the units are sorted by their output value. In case of minimizing the number of active output units the progressive reconstruction causes all units to try and minimize the reconstruction error by moving horizontally, optimizing the number of units required to reconstruct. (We could also theoretically move vertically with a reverse rank ordered autoencoder and minimize the number of active input units required for reconstructing.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>The proposed approach for minimizing the number of outputs required to reconstruct the input.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>1 ): 1: calculate forward pass; y = f (xW) (standard matrix-vector multiplication) 2: argsort output; args = argsort(y) (high to low) 3: reconstruct from each unit; r = W * y (broadcasted multiplication) 4: reconstruct progressively in order; r[:, args] = f (cumsum(r[:, args], axis = 1)) 5: calculate error; e x = r − x (broadcasted subtraction) 6: backprop error; e y = sum(W • e x , axis = 0) (elementwise multiplication and sum) 7: multiply by derivative; e y = e y • f (y, e y ) 8: calculate gradient input; g x = e x * y (broadcasted multiplication) 9: calculate gradient output; g y = xe y (outer product) 10: update weights; W = W + (g x + g y ) -1.0 -0.7 -0.4 -0.1 0.2 0.5 0.8 1.1 1.4 1.7 The activation function used f = min(1, max(0, x)) (left) and the custom derivative of the activation function f = (sign(error) = sign(output)) (right)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>n</head><label></label><figDesc>i=0 x i • w ij which is simply O(n • m). It is known that sorting of m values can be efficiently done in O(m log(m)) time and since O(m log(m)) ≤ O(n•m) for n ≥ log(m) (which is highly likely as log 2 of e.g. 1024 hidden units is only 10) our complexity remains O(n•m).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>The learned filters (best seen in color), normalized between 0 and 1 and sorted by their average activation. Showing learned edge filters and color patches that become increasingly complex.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Reconstruction error (L 2 -norm)(left) over time, showing an initial rapid reduction in the error in just a few epochs stabilizing around 0.28, and objective function error (eq. 2)(right).There is notably no visible overfitting on the test set. The errors of the progressive reconstruction as a function of the sorted outputs over time. Showing an initial rapid reduction in error for the higher ranked units that gradually decreases for each successive epoch meaning that less and less units are required to achieve the same reconstruction error.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 7 :</head><label>7</label><figDesc>Example of the actual learned reconstruction error surface (thresholded at 1) for the input shown in figure 8. Note the similarity with figure 1, the absolute values of the raw output is taken for reconstruction to get an approximate idea of what the effect of negative output filters is on the reconstruction error.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Example of the output distribution for both the thresholded output (left) and raw output (right) for the input shown inFigure 8, showing extremely high sparsity and a sharp distribution centered around zero.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">'[]' indicate indexing, ':' is selecting all rows/cols at that location, and '[:, args]' is indexing the columns by the args vector. Broadcasting means if we have a matrix of shape (n,m) and vector of shape (n) we apply the operation to all columns of the matrix, and thus get an output of (n,m).</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">https://www.cs.toronto.edu/ kriz/cifar.html</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Learning Activation Functions to Improve Deep Neural Networks. ICLR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Forest</forename><surname>Agostinelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Hoffman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Sadowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre</forename><surname>Baldi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre</forename><surname>Baldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Autoencoders</surname></persName>
		</author>
		<title level="m">Unsupervised Learning, and Deep Architectures. ICML Unsupervised and Transfer Learning</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="37" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Generalized denoising autoencoders as generative models. Advances in Neural</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Alain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pascal</forename><surname>Vincent</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Decoding by Linear ProgrammingEmmanuel Candes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emmanuel</forename><surname>Candes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terence</forename><surname>Tao</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="4203" to="4215" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Convolutional sparse feature descriptor for object recognition in CIFAR-10</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francelino</forename><surname>Edigleison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paulo</forename><forename type="middle">Martins</forename><surname>Carvalho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Engel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings -2013 Brazilian Conference on Intelligent Systems, BRACIS 2013</title>
		<meeting>-2013 Brazilian Conference on Intelligent Systems, BRACIS 2013</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="131" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">An Analysis of Single-Layer Networks in Unsupervised Feature Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Coates</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ann</forename><surname>Arbor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew Y</forename><surname>Ng</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="215" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Network of integrate-and-fire neurons using Rank Order Coding B: spike timing dependant plasticity and emergence of orientation selectivity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arnaud</forename><surname>Delorme</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laurent</forename><surname>Perrinet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Thorpe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manuel</forename><surname>Samuelides</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neurocomputing</title>
		<imprint>
			<biblScope unit="issue">1-4</biblScope>
			<biblScope unit="page" from="539" to="584" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Why Does Unsupervised Pre-training Help Deep Learning ?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dumitru</forename><surname>Erhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aaron</forename><surname>Courville</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pascal</forename><surname>Vincent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="625" to="660" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Representing and decoding rank order codes using polychronization in a network of spiking neurons</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francesco</forename><surname>Galluppi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Furber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Joint Conference on Neural Networks</title>
		<meeting>the International Joint Conference on Neural Networks</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="943" to="950" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Rate coding versus temporal order coding: A theoretical approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacques</forename><surname>Gautrais</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Thorpe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BioSystems</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="57" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Willshaw model: Associative memory with sparse coding and low firing rates</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Golomb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Rubin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Sompolinsky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Physical Review A</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1843" to="1854" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A Tutorial Introduction to the Minimum Description Length Principle</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Grünwald</surname></persName>
		</author>
		<idno>ST/04. 2005</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Efficient Sparse coding algorithms. Advances in nerual infromation processing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Andrew</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ng Honglak Lee</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="801" to="808" />
			<pubPlace>Alexis Battle, Rajat Raina</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koray</forename><surname>Kavukcuoglu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Lecun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc'aurelio</forename><surname>Ranzato</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1010.3467</idno>
		<title level="m">Fast Inference in Sparse Coding Algorithms with Applications to Object Recognition</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="9" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Building high-level features using large scale unsupervised learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc'aurelio</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajat</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthieu</forename><surname>Monga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Devin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><forename type="middle">S</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew Y</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference in Machine Learning</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page">38115</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alireza</forename><surname>Makhzani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brendan</forename><surname>Frey</surname></persName>
		</author>
		<title level="m">Sparse Autoencoders. Iclr</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Sparse coding with an incomplete basis set: a strategy employed by V1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D J</forename><surname>B A Olshausen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Field</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Sparse coding of sensory inputs. Current opinion in neurobiology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Olshausen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Field</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="481" to="487" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">On the difficulty of training recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Razvan</forename><surname>Pascanu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomas</forename><surname>Mikolov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of The 30th International Conference on Machine Learning</title>
		<meeting>The 30th International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1310" to="1318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Unsupervised learning of invariant feature hierarchies with applications to object recognition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aurelio</forename><surname>Marc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fu Jie</forename><surname>Ranzato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">Lan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yann</forename><surname>Boureau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Lecun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Computer Society Conference on Computer Vision and Pattern Recognition</title>
		<meeting>the IEEE Computer Society Conference on Computer Vision and Pattern Recognition</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Contractive Auto-Encoders : Explicit Invariance During Feature Extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salah</forename><surname>Rifai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Muller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Icml</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="833" to="840" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning Ordered Representations with Nested Dropout</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Rippel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><forename type="middle">Prescott</forename><surname>Michael A Gelbart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Adams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Jmlr W&amp;Cp</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1746" to="1754" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Dropout : A Simple Way to Prevent Neural Networks from Overfitting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nitish</forename><surname>Srivastava</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><forename type="middle">E</forename><surname>Hinton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Krizhevsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ruslan</forename><surname>Salakhutdinov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1929" to="1958" />
			<date type="published" when="2014" />
			<publisher>JMLR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Rate coding versus temporal order coding: what the retinal ganglion cells tell the visual cortex</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rufin</forename><surname>Vanrullen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Thorpe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural computation</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1255" to="83" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Extracting and composing robust features with denoising autoencoders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pascal</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre-Antoine</forename><surname>Manzagol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th international conference on Machine learning</title>
		<meeting>the 25th international conference on Machine learning</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1096" to="1103" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Stacked Denoising Autoencoders: Learning Useful Representations in a Deep Network with a Local Denoising Criterion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pascal</forename><surname>Vincent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugo</forename><surname>Larochelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isabelle</forename><surname>Lajoie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pierre-Antoine</forename><surname>Manzagol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="3371" to="3408" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Generalized autoencoder: A neural network framework for dimensionality reduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yan</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yizhou</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Computer Society Conference on Computer Vision and Pattern Recognition Workshops</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="496" to="503" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Online Incremental Feature Learning with Denoising Autoencoders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guanyu</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kihyuk</forename><surname>Sohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Honglak</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research -Proceedings Track</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1453" to="1461" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
