<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Watching for Software Inefficiencies with Witch</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shasha</forename><surname>Wen</surname></persName>
							<email>swen@cs.wm.edu</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Byrne</surname></persName>
							<email>john.l.byrne@hpe.com</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
							<email>milind@scalablemachines.org</email>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">College of William</orgName>
								<address>
									<settlement>Mary</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">College of William and Mary</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff2">
								<orgName type="laboratory">Hewlett Packard Labs</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff3">
								<orgName type="laboratory">Baidu Research, USA and Scalable Machines Research</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Watching for Software Inefficiencies with Witch</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3173162.3177159</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Software inefficiency detection</term>
					<term>PMU</term>
					<term>debug registers</term>
					<term>sampling</term>
					<term>profiling</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Inefficiencies abound in complex, layered software. A variety of inefficiencies show up as wasteful memory operations. Many existing tools instrument every load and store instruction to monitor memory, which significantly slows execution and consumes enormously extra memory. Our lightweight framework, Witch, samples consecutive accesses to the same memory location by exploiting two ubiquitous hardware features: the performance monitoring units (PMU) and debug registers. Witch performs no instrumentation. Hence, witchcraft-tools built atop Witch-can detect a variety of software inefficiencies while introducing negligible slowdown and insignificant memory consumption and yet maintaining accuracy comparable to exhaustive instrumentation tools. Witch allowed us to scale our analysis to a large number of code bases. Guided by witchcraft, we detected several performance problems in important code bases; eliminating these inefficiencies resulted in significant speedups. CCS Concepts • General and reference → Performance; • Software and its engineering → Runtime environments; Application specific development environments;</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Large, layered, production software is complex due to a hierarchy of component libraries and sophisticated control flow. Even the high-performance computing (HPC) software achieves only 5-15% of peak performance on modern supercomputers <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b16">17,</ref><ref type="bibr" target="#b58">62]</ref>. Inefficiencies inherent in complex software <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b27">30,</ref><ref type="bibr" target="#b29">32,</ref><ref type="bibr" target="#b32">35,</ref><ref type="bibr" target="#b66">70,</ref><ref type="bibr" target="#b71">75,</ref><ref type="bibr" target="#b79">83,</ref><ref type="bibr" target="#b80">84</ref>] significantly contribute to this abysmal performance. Software inefficiencies may arise during design (e.g., inappropriate choice of algorithms and data-structures), implementation (e.g., developers' inattention to performance and use of heavyweight APIs), or translation (e.g., detrimental compiler optimizations and lack of tuning for an architecture).</p><p>Inefficiencies, whatever their origin, often manifest as computations whose results may not be used <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b64">68]</ref>, recomputation of already computed values <ref type="bibr" target="#b78">[82]</ref>, unnecessary data movement <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b33">36,</ref><ref type="bibr" target="#b44">48,</ref><ref type="bibr" target="#b46">50,</ref><ref type="bibr" target="#b77">81]</ref>, and excessive synchronization <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b73">77]</ref>. Inefficiencies involving the memory subsystem are particularly egregious because of limited bandwidth shared by multiple cores and high access latencies. Repeated initialization, register spill and restore on hot paths, lack of inlining hot functions, missed optimization opportunities due to aliasing, computing and storing already computed or sparingly changing values, and contention and false sharing <ref type="bibr" target="#b20">[22,</ref><ref type="bibr" target="#b40">44,</ref><ref type="bibr" target="#b42">46,</ref><ref type="bibr" target="#b43">47]</ref> (in multi-threaded codes), are some of the common prodigal uses of the memory subsystem. Although compiler literature is rich with optimization to eliminate inefficiencies, in practice, layers of abstractions, dynamic libraries, multi-lingual components, aggregate types, aliasing, and combinatorial explosion of execution paths handicap optimizing compilers in delivering top application performance. Additionally, algorithmic and data structural deficiencies also appear as useless memory operations <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b27">30,</ref><ref type="bibr" target="#b32">35,</ref><ref type="bibr" target="#b66">70,</ref><ref type="bibr" target="#b79">83,</ref><ref type="bibr" target="#b80">84]</ref>.</p><p>Coarse-grained profilers such as VTune <ref type="bibr">[27]</ref>, HPC-Toolkit <ref type="bibr" target="#b0">[1]</ref>, gprof <ref type="bibr" target="#b19">[21]</ref>, Oracle Solaris Studio <ref type="bibr" target="#b61">[65]</ref>, Oprofile <ref type="bibr" target="#b60">[64]</ref>, Perf <ref type="bibr" target="#b37">[40]</ref>, and CrayPAT <ref type="bibr" target="#b13">[14]</ref> identify execution "hotspots". They attribute measurements such as CPU cycles, stalls, arithmetic intensity, and cache misses, obtained from hardware performance monitoring units (PMUs) to ... if ( end of basic block ) ▶ memset ( last_set ,0 , regs -&gt; num * sizeof ( rtx ) ) ; } ... } Listing 1. Dead stores in SPEC CPU2006 gcc due to an inappropriate data structure. The function iterates over the basic blocks in a loop scanning for the registers used. Line 3 allocates and zero initializes a 16K-element 132KB array representing the virtual registers. The loop body accesses only a few (&lt;2) array elements since basic blocks are typically small. At the end of each basic block (Line 11) the code zero initializes the same array for the use in the next basic block. Line 11 is repeatedly involved in dead stores. the source code. On the positive side, they introduce little runtime overhead and do not materially perturb execution. On the negative side, hotspots fail to distinguish efficient vs. inefficient resource usage. The SPEC CPU2006 <ref type="bibr" target="#b68">[72]</ref> gcc code, shown in Listing 1, repeatedly zero initializes a 132KB array, most of which is already zero. None of these profilers detects this as wasted work. Ironically, a hotspot may have no further optimization scope (e.g., a highly optimized linear algebra library); and conversely, a code region acclaimed by a profiler with high arithmetic intensity (a goodness metric) may perform useless computations <ref type="bibr" target="#b78">[82]</ref>.</p><p>Fine-grained profilers such as DeadSpy <ref type="bibr" target="#b7">[8]</ref>, RedSpy <ref type="bibr" target="#b77">[81]</ref>, RVN <ref type="bibr" target="#b78">[82]</ref>, Toddler <ref type="bibr" target="#b55">[59]</ref>, and Cachetor <ref type="bibr" target="#b53">[57]</ref>, analyze dynamic instructions with specific objectives-detect useless computation or data movement. They can identify inefficiencies not detected by coarse-grained profilers. In Listing 1, they can pinpoint the source code location that re-initializes an already initialized array and quantify the wasted work. On the positive side, they offer visibility into wasted work. On the negative side, they significantly slow execution down (10-80×) and consume enormous (6-100×) extra memory.</p><p>Despite their effectiveness, the high overhead of finegrained inefficiency detection tools has kept them away from wide adoption. They have remained isolated to small research communities or performance experts. There is a need to make such tools more available to the developer community so that inefficiency detection can be made commonplace-run with each code check-in to isolate inefficiencies at the earliest.</p><p>We developed Witch-a lightweight inefficiencydetection framework-to address this issue. Witch combines the best of both worlds-low overhead of coarse-grained profilers and inefficiency detection of fine-grained profilers. Our key observation is that an important class of inefficiency detection schemes, explored previously via fine-grained profilers <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b44">48,</ref><ref type="bibr" target="#b77">81]</ref>, requires monitoring consecutive accesses to the same memory location. For example, detecting repeated initialization-a dead write <ref type="bibr" target="#b7">[8]</ref>-requires monitoring store after store without an intervening load to the same location.</p><p>Witch samples addresses accessed by a program using hardware PMUs. Witch intercepts the subsequent access(es) to the sampled memory locations using hardware debug registers. The result is (1) the ability to observe consecutive accesses to the same memory location to detect myriad inefficiencies, and <ref type="bibr" target="#b1">(2)</ref> no code or binary instrumentation and hence low overhead. We show the benefit of this concept by building various inefficiency-detection tools (witchcraft) atop Witch. There are various challenges in making it practical, which we detail and address in Section 4 and 5.</p><p>The idea generalizes to detect other kinds of inefficienciesupdating a location with a value already present at the location (aka silent store <ref type="bibr" target="#b33">[36,</ref><ref type="bibr" target="#b34">37]</ref>) and loading an unchanged value from memory that was previously loaded <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b55">59,</ref><ref type="bibr" target="#b67">71]</ref> (poor register usage). Sharing addresses sampled by one thread with another thread enables building Witch-based tools for multi-threaded programs. In this paper, we restrict ourselves to describing the Witch framework and three tools that detect inefficiencies in a thread of execution. We make the following contributions:</p><p>1. Develop a lightweight framework, Witch, suitable for a class of tools that requires observing a program's consecutive accesses to the same memory location. 2. Develop a sampling scheme to overcome hardware limitations, which works exceptionally well in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Develop inefficiency-detection tools atop Witch, which</head><p>are at least an order of magnitude faster than the state-ofthe-art exhaustive-instrumentation tools with the same capabilities. Our tools require negligible extra memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Overcome practical challenges in implementing these</head><p>tools and demonstrate the accuracy of our tools in comparison with the state-of-the-art.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Demonstrate the utility of our tools on large code bases</head><p>to pinpoint inefficiencies and show up to 10× speedup.</p><p>Section 2 covers the related work and motivates our work; Section 3 offers the background; Section 4 overviews the design of Witch; Section 5 and 6, respectively, describe implementation details of Witch and its client witchcraft tools; Section 7 performs evaluation, Section 8 explores case studies, and Section 9 offers our conclusions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work and Motivation</head><p>There is a vast literature in detecting and eliminating software inefficiencies. We classify these techniques into hardware and software approaches. The hardware approaches <ref type="bibr" target="#b33">[36,</ref><ref type="bibr" target="#b34">37,</ref><ref type="bibr" target="#b38">42,</ref><ref type="bibr" target="#b39">43,</ref><ref type="bibr" target="#b50">54,</ref><ref type="bibr" target="#b51">55,</ref><ref type="bibr" target="#b81">85]</ref> introduce new hardware components to detect and eliminate computations whose results are never used or elide memory operations that do not change the contents of their target memory cells. Our focus is on software approaches, which do not need any hardware modification.</p><p>Classic compiler optimizations such as value numbering <ref type="bibr" target="#b63">[67]</ref>, constant propagation <ref type="bibr" target="#b76">[80]</ref>, and common subexpression elimination <ref type="bibr" target="#b12">[13]</ref> eliminate several inefficiencies.</p><p>Recently, static analysis has been used in detecting performance bugs <ref type="bibr" target="#b54">[58,</ref><ref type="bibr" target="#b59">63]</ref>. Static analysis, typically, suffers from limitations related to aliasing, optimization scope, and input and context insensitivities. A thorough literature review of static analysis is not pertinent.</p><p>The dynamic analysis addresses the limitation of static analysis. Chabbi and Mellor-Crummey <ref type="bibr" target="#b7">[8]</ref> show that dead writes are a common symptom of myriad inefficiencies. Their tool, DeadSpy, tracks every memory operation to identify store operations that are never loaded (dead) before a subsequent store (kill) to the same location. DeadSpy associates pairs of instructions involved in a dead store (dead-kill pair) with their calling contexts and source code locations to guide manual optimizations. Using DeadSpy, the authors identify inefficiencies arising from inappropriate data structure choice, optimization inhibiting code shape, inattention to performance, and poor compiler code generation. They improve the performance of several systems by eliminating dead writes. DeadSpy's exhaustive monitoring typically introduces more than 28× slowdown and consumes more than 9× extra memory on average.</p><p>Wen et al. perform fine-grained monitoring to track symbolically equivalent <ref type="bibr" target="#b78">[82]</ref> and result-equivalent <ref type="bibr" target="#b77">[81]</ref> computations. Their tools detect inefficiencies in both CPU-and memory-bound operations. They detect inefficiencies arising from redundant computation, missed inlining opportunities, layers of abstractions, and redundant stores. With exhaustively monitoring, their tools incur 40-280× runtime overhead. By periodically enabling and disabling monitoring (bursty sampling <ref type="bibr" target="#b22">[24]</ref>), they bring it down to a manageable 12× slowdown and 9× memory bloat.</p><p>Toddler <ref type="bibr" target="#b55">[59]</ref> focuses on identifying repetitive memory load sequences across loop iterations at the cost of 10× slowdown. LDoctor <ref type="bibr" target="#b67">[71]</ref> reduces Toddler's overhead using a combination of ad-hoc sampling and static analysis techniques. However, it only analyzes a small number of suspicious loops identified by profiling, and hence does not work for systematically detecting inefficiencies in the whole program.</p><p>Unlike these approaches, Witch, without the need of any prior knowledge of the program, monitors fully optimized native binaries and all their dynamic dependencies and typically incurs negligible runtime overhead (&lt; 5%) and memory overhead (&lt; 5%). Witch is the first lightweight measurement framework that employs PMUs and hardware debug registers to detect program inefficiencies. Neither the inefficiency detection nor the use of PMUs or debug registers is novel in itself, but their combined application is.</p><p>Tools Based on Hardware Debug Registers: Erickson et al. <ref type="bibr" target="#b17">[18]</ref> use hardware debug registers <ref type="bibr" target="#b28">[31,</ref><ref type="bibr" target="#b47">51]</ref> to detect data races in the Windows kernel. Jiang et al. <ref type="bibr" target="#b26">[29]</ref> extend it to the Linux. They sample memory access instructions and set watchpoints to detect conflicting accesses. They use code breakpoints to intercept random instructions and use them to monitor memory accesses for a time window. Liu et al. <ref type="bibr" target="#b41">[45]</ref> developed DoubleTake, which uses debug registers to identify buffer overflow, use after free, and memory leaks. Pesterev et al. developed DProf <ref type="bibr" target="#b62">[66]</ref>, which combines PMU and hardware debug registers to capture the data flow across runtime objects. DProf suffers from limited debug registers; it runs a program multiple times to achieve higher coverage. These approaches focus on detecting the presence or absence of a bug; they are not concerned with quantifying the frequency of a bug or prioritizing the importance of a bug, which become necessary in performance analysis tools. Witch addresses these quantification and attribution problems necessary for performance tools.</p><p>Kasikci et al. <ref type="bibr" target="#b31">[34]</ref> describe a spatially unbiased sampling scheme to trace cold code for code coverage. In contrast, Witch develops a temporally unbiased sampling scheme to monitor memory locations. Kasikci et al. dynamically rewrite the first instruction of every basic block with the int 3 breakpoint instruction, which causes a trap; there is no hardware limit on how many blocks they can monitor. Breakpoints set in hot code regions drive their sampling, and they throttle too frequently trapping breakpoints. In contrast, Witch does not modify the binary (not even at runtime), it uses the PMU as its sampling engine, but it has to workaround the limited number of debug registers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Background and Terminology</head><p>In this section, we present the background necessary to understand Witch. Expert readers may skip this section.</p><p>Hardware Performance Monitoring Units (PMU): CPU's PMUs offer a programmable way to count hardware events such as loads, stores, CPU cycles, etc. A PMU can trigger an overflow interrupt once a threshold number of events accumulate. A profiler, running in the address space of the monitored program, can handle the interrupt and attribute the measurement "appropriately". We refer to a PMU counter overflow as a "sample".</p><p>Intel SandyBridge and its successors support Precise Event-Based Sampling (PEBS) <ref type="bibr" target="#b23">[25]</ref>. A PMU captures a snapshot of the user-visible register state including the program counter (PC) and the effective address (EA) accessed by the instruction on an event overflow. AMD Instruction-Based Sampling (IBS) <ref type="bibr" target="#b15">[16]</ref> and PowerPC Marked Event Sampling (MRK) <ref type="bibr" target="#b70">[74]</ref> offer commensurate capabilities.</p><p>Hardware Debug Registers: Hardware debug registers <ref type="bibr" target="#b28">[31,</ref><ref type="bibr" target="#b47">51]</ref> enable trapping the CPU execution for debugging when the PC reaches an address (breakpoint) or an instruction accesses a designated address (watchpoint). One can program debug registers with different addresses, widths, and conditions that will cause the CPU to trap on reaching the programmed conditions. Today's x86 processors have four debug registers. If used for the break-on-data-access (store, or load-or-store), on x86 processors, the trap occurs after the instruction execution. Hence, if a store instruction results in a trap, the contents of the target memory will contain the results of the store operation.</p><p>Linux Perf_events: Linux offers a standard interface to program and sample PMUs using the perf_event_open system call <ref type="bibr" target="#b36">[39]</ref> and the associated ioctl calls. The Linux kernel can deliver a signal to the thread whose PMU event overflows. The user code can mmap a circular buffer into which the kernel keeps appending the PMU data on each sample. Linux 2.6.33 and its successors incorporate the debug registers in the perf_event interface, however, the support has several limitations, which we discuss and fix in our work. We implement Witch on Intel processors with the PEBS facility. It is straightforward to extend Witch to work on AMD with IBS and PowerPC with MRK.</p><p>Call Path Profiling: Call path profiling <ref type="bibr" target="#b21">[23]</ref> is a profiling technique where runtime events (e.g., cache misses) are attributed to the full call path seen at the time of the event. Call path profiling offers insightful details in complex applications with deep call chains. The calling context of an event is a set of active procedure frames when the event happens. A calling context begins at a process or thread entry function such as main and ends at the instruction pointer (IP) of the instruction that triggers the event. The alternative, flat profiling, merely attributes events to the leaf function involved in the event, which introduces ambiguities when the same leaf function (e.g., memset) can be invoked from multiple contexts.</p><p>Terminology: A watchpoint is a software abstraction of a debug register to monitor a data access. An address is monitored if we set a watchpoint at that address. A watchpoint can be set to trap on write (W_TRAP) or trap on read-or-write (RW_TRAP). A watchpoint exception (aka trigger) is a synchronous CPU trap caused when an instruction accesses a monitored address. A PMU sample is a CPU interrupt caused when an event counter overflows. Both PMU samples and watchpoint exceptions are handled via the Linux signals.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Methodology and Design</head><p>We want to answer the following questions: 1) Do consecutive store operations to a memory location have an intervening load? 2) Do consecutive stores to a memory location store the same value? 3) Do consecutive loads from a memory location load the same value? 4) Is a cacheline accessed by one thread immediately accessed by another thread? Summary: PMU samples that include the effective address accessed in a sample provide the knowledge of the addresses accessed in an execution. Given this effective address, a hardware debug register allows us to keep an eye on (watch) a location and recognize what the program subsequently does to such location. Since the hardware can monitor a small number of locations at a time, reservoir sampling <ref type="bibr" target="#b75">[79]</ref> allows monitoring a subset of previously seen addresses without any temporal bias. Finally, we scale the measurements taken for a few monitored samples in a calling context to other unmonitored samples in the same calling context; the scaling is based on the observation that the code behavior in a calling context typically remains the same. Details: Precise PMU samples drive Witch. Client tools subscribe to PMU events of their choice. On each PMU sample, the client obtains the memory address M accessed in the sample. Clients subscribe to a watchpoint at the sampled address in the signal handler and continue their execution. <ref type="bibr" target="#b0">1</ref> When the program accesses M next time, a CPU trap happens. Witch handles the watchpoint exception, captures information associated with the trap, associates any information given by the client at the watchpoint subscribe time, and gives control to the client tool for appropriate actions.</p><p>We use our dead store detection tool-DeadCraft, shown in <ref type="figure">Figure 1</ref>-as a running example to illustrate our methodology. The ideas generalize to any tool built atop Witch. A store followed by another store to the same address is an instance of a dead store. A store followed by a load to the same address is not a dead store. A software instrumentation tool such as DeadSpy <ref type="bibr" target="#b7">[8]</ref> maintains a large shadow memory where it stores the last operation performed on each byte of the original program. A write→write transition in a shadow byte indicates an instance of a dead write.</p><p>A client may set a watchpoint at an address derived from the sampled address or any other address instead of the sampled address itself.</p><p>DeadCraft mimics the behavior of DeadSpy but on a subset of addresses seen in PMU samples. DeadCraft samples the PMU store events at a chosen frequency. Let the address accessed in a PMU sample be M and let the calling context where the sample happens be C wat ch . In the PMU overflow handler, Witch offers the triplet ⟨C wat ch , M, AccessType⟩ to DeadCraft. DeadCraft memorizes the tuple and in-turn asks Witch to set a RW_TRAP watchpointW at M. The normal execution continues. W traps when the program accesses M next time; we defer discussing another sample happening before the trap to Section 4.1. Let the address accessed in the trap be M and let its calling context be C t r ap . Witch handles the trap and offers the triplet ⟨C t r ap , M, AccessType⟩ to DeadCraft. If a load causes a trap, DeadCraft treats it as a useful operation and disables the watchpoint. If a store causes a trap, however, DeadCraft infers the store seen in the context C wat ch as a dead store. It attributes a "unit" of dead store to the calling context pair ⟨C wat ch , C t r ap ⟩.</p><p>Since dead stores can happen only on store instructions, and since every store instruction is sampled at a frequency proportional to its occurrence, transitively, we would detect dead writes at a frequency proportional to their occurrence, if we had infinite debug registers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Challenge with Samples Intervening Accesses</head><p>Hardware can monitor only a small number of addresses at a time since they have only a handful of debug registers. The scenario of two accesses to the same memory separated by a large distance, where many PMU samples occur in the intervening time, complicates matters.</p><p>Consider the dead store example in Listing 2. Assume the loop index variables i and j are in registers, the sampling period is 10K stores, and the number of debug register is one. A naive "replace the oldest watchpoint" scheme cannot detect any dead stores in this code. In such scheme, when the j loop begins, the only active watchpoint would be the last sampled address &amp;array[100K] in the i loop. The PMU continues delivering samples in the j loop. At j=10K, the scheme replaces the last watchpoint on &amp;array[100K] with &amp;array[10K], which would not be accessed again. At the end of the j loop not a single watchpoint would have triggered, and hence no dead store detected. The same problem exists for more than one debug register. A slightly smarter strategy is to flip a coin to decide whether or not to set a watchpoint on a sample. This strategy fails because the survival probability of an older sample becomes minuscule if a large number of samples happen between consecutive accesses to the same location. Listing 2. Long distance inefficiencies: All (say 4) watchpoints will be armed when sampling at 10K store in the first four samples taken in the i loop. A naive replacement will not trigger a single watchpoint due to many samples taken in the i loop before reaching the j loop. Witch ensures each sample equal probability to survive.</p><p>Monitoring a new sample may help detect a new, previously unseen problem whereas continuing to monitor an old, already-armed address may help detect a problem separated by many intervening operations. We should detect both. But, we do not know when in the future a watchpoint may trap, if at all. Our solution strikes a balance between new vs. old by being unbiased in choosing among the previously accessed addresses (reservoir sampling <ref type="bibr" target="#b75">[79]</ref>), and we rely on multiple such unbiased samples taken over a repetitive execution to capture both scenarios. We first show our approach for a single debug register and then generalize it for an arbitrary but finite number of debug registers.</p><p>On the first sample, S 1 , if the debug register is unarmed, Witch sets the watchpoint with 1.0 probability. The second sample, S 2 , replaces the previously armed watchpoint (sample S 1 ) with 1 /2 probability and installs itself. Thus, at the end of S 2 , both S 1 and S 2 have equal ( 1 /2) probability of being monitored. The third sample, S 3 , replaces the previously armed watchpoint with 1 /3 probability to install itself. Since the previously armed watchpoint is S 1 or S 2 with 1 /2 probability each, they each survive with 1 /3 probability. The k th sample S k since the last time a debug register was empty, replaces the previously armed watchpoint with /k probability. The previously armed watchpoint could be any one of {S 1 , S 2 , . . . , S k −1 } with 1 /k−1 probability each. At the end of k th sample, the probability of monitoring any sampled address S i , 1 ≤ i ≤ (k − 1) of the prior (k − 1) samples is:</p><formula xml:id="formula_0">Pr [monitoring S i ] =Pr [S i survived in S k−1 ] × Pr [ not retaining S k ] = 1 k − 1 × k − 1 k = 1 k = Pr [monitoring S k ]</formula><p>Any time a watchpoint traps and the client chooses to disarm the watchpoint, and the probability is reset to 1.0, which ensures that the immediately next sample is monitored. Naturally, if every watchpoint triggers before the next sample, we will monitor every address seen in every sample.</p><p>In a system with N debug registers, on a new sample, we populate any unused debug register as long as we find one. If no debug register is freed up in a window of N consecutive samples, there will be no room for the (N + 1) th sample. We install the sample S N +1 with N /N +1 probability. If the choice is to install S N +1 , we randomly choose one of the N debug registers and replace it with S N +1 . It follows that at the end of S N +1 , the probability of monitoring any sample</p><formula xml:id="formula_1">S i , 1 ≤ i ≤ N + 1, is N /N +1.</formula><p>The sample S k , k &gt; N , since the last time a debug register was empty, replaces one of the surviving N samples with N /k probability. It follows that at the end of S k , every sample has the same N /k probability of being monitored. Anytime when a watchpoint traps and the client chooses to disarm the watchpoint, the probability resets to 1.0. Our technique maintains only a count of previous samples-not a log of all previous samples-which needs O(1) memory.</p><p>Adversary Sample: If a "never-again-to-be-accessed" address α finds a place in a watchpoint, it can affect the subsequent samples. If no watchpoint has triggered for H samples when α is sampled, the expected number of samples before α will be replaced is 1.7H , which follows from the sum of harmonic series. The number of debug registers does not influence α.</p><p>The number of consecutive PMU samples that are not monitored form a "blindspot" window; the longer the window is, the larger the probability of missing bugs. In our experience, many software in practice often have very short windows. For example, in the SPEC CPU2006 <ref type="bibr" target="#b68">[72]</ref> reference benchmarks, on an Intel Haswell machine, we found the largest blind-spot to be, typically, extremely small (&lt; 0.02% of the total samples in a program), and the worst case was 0.5% of the total samples in the mcf benchmark.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Challenges with Proportional Attribution</head><p>Consider the code in Listing 3. For brevity, line numbers represent contexts. 25% PMU samples will be attributed to each of Line 3, 7, 8, and 11. If the outer loop executes 1K times and if the sampling period is 10K store operations, each of these lines will get approximately 10K PMU samples. The number of sampled dead writes should be 10K for each line pair ⟨3, 11⟩, ⟨11, 3⟩, ⟨7, 8⟩, and ⟨8, 7⟩. That is, 25% each. This expectation in quantification is not preserved with our sampling scheme because of a mixture of sparse monitoring (lines 3 and 11) and dense monitoring (lines 7 and 8). As soon as a watchpoint traps on Line 7, a debug register frees up; every subsequent PMU sample in the k loop will find a free debug register. Hence, there will be a disproportionately large number of dead writes recorded for the line pairs ⟨7, 8⟩ and ⟨8, 7⟩ compared to rest.</p><p>We solve this problem with a context-sensitive approximation. The code behavior is typically same in a calling context; hence, an observation made by monitoring an address accessed in a calling context can approximately represent other unmonitored samples occurring in the same calling context. If in a sequence of N samples occurring in a calling context C, only one sample is monitored through a debug register, we scale the observation made for the monitored sample by N to approximate the behavior of the remaining N − 1 unmonitored samples taken at C. In this scheme, in a sequence of ten PMU samples taken at line 3, only one is monitored through a debug register, and that address leads to a dead 1 for ( ... many iterations ...) { for ( int i = 1; i &lt;= 100 K ; i ++) { array [ i ] = 0; 4 } // p and q alias to the same location for ( int k = 1; k &lt;= 100 K ; k ++) { 7 * p = 0; // dead write 8 * q = 0; 9 } 10 for ( int j = 1; j &lt;= 100 K ; j ++) { 11 array [ j ] = 0; 12 } 13 } Listing 3. 100K stores in the i loop are dead by the overwriting j loop, but only a few watchpoints survive between these two loops. 100K writes to *p are also dead but trigger many more watchpoints at *q. Witch applies a proportional attribution heuristic by accounting the samples taken in a context. write with line 11, we scale and record number of dead writes between lines ⟨3, 11⟩ as ten.</p><p>Implementation: Every PMU sample increments a metric µ(C) in the calling context C where it happens. Another metric η(C) catches up with µ(C) each time a watchpoint set in C traps. Both metrics are initially zero. Assume we set a watchpoint W in calling context C watch , and it traps in a calling context, say C t r ap ; C t r ap can be C watch . µ(C) − η(C) ≥ 1 is the number of samples that W is representing. Assume the sampling period (threshold) is P. If the trapping instruction is a store with M-bytes of overlap over the monitored address range set in W , we approximate and attribute µ(C) − η(C) × P × M bytes of "waste" to the ordered pair ⟨C watch , C t r ap ⟩. Conversely, if the trapping instruction is a load with M-bytes of overlap over the monitored address range set in C watch , we approximate and attribute µ(C) − η(C) × P × M bytes of "use" to the ordered pair ⟨C watch , C t r ap ⟩. In either case, we update η(C) = µ(C). Both use and waste metrics are additive-they accumulate overtime for the attributions happening in the same calling context pairs. Thus, the total inefficiency (dead-writes) is:</p><formula xml:id="formula_2">D = i j waste in ⟨C i , C j ⟩ i j waste in ⟨C i , C j ⟩ + i j use in ⟨C i , C j ⟩<label>(1)</label></formula><p>The metric is similar to the "deadness" D metric described in <ref type="bibr" target="#b5">[6]</ref>; instead of deriving the metric by measuring every load and store, we are approximating. Equation 1 is an optional feature available for the clients of Witch; not all clients need this kind of proportional attribution.</p><p>In Listing 3, when a watchpoint traps for the first time on Line 11(= C t r ap ), and if there were 10 PMU samples accumulated at the source Line 3 (= C watch ), we attribute 10 × 10K × 4 bytes = 400K bytes of dead writes to the line pair ⟨3, 11⟩. This scheme allows the dead writes metric to catchup with the PMU samples, resulting in proportional attribution. Thus, even though we have very few watchpoints, we use PMU samples in a context to approximate the dead writes in that context. If multiple watchpoints were simultaneously set from the same calling context at different addresses, we proportionally distribute the samples among them. x are involved in dead writes in 3:2:1 ratio (50%:33%:17%), respectively. The sampling interval is 50K stores. Our proportional, context-sensitive scheme apportions dead writes in near perfect ratio. <ref type="figure" target="#fig_2">Figure 2</ref> shows Witch's attribution of dead writes in a more complex scenario, which perfectly matches our expectation of 50%:33%:17% dead writes to a:b:x. Without proportional attribution, we noticed a biased attribution of 5%:2%:93%. With random sampling, rather than our equal probability sampling, 100% samples get attributed to the line pair ⟨16, 17⟩.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Limitations</head><p>Witch employs Monte-Carlo experiments to approximately model real-world observations and suffers from the limitations of any sampling system. Insufficient samples can result in overestimation or underestimation. Witch cannot monitor register-to-register operations. Witch cannot hide the deficiencies of the underlying PMU used to drive its sampling: on some Intel architectures, sporadically, the shadow sampling effect <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b56">60]</ref> may hide a short latency store behind a long latency store. This behavior can bias the samples to favor long latency stores.</p><p>Witch can simultaneously monitor only as many memory locations as the number of debug registers. This physical constraint often is not a problem in practice as we show in our evaluation. However, an adversary may be able to construct a program where the effects of limited registers can be more pronounced.</p><p>Witch's context-sensitive attribution is an optional feature available for its tools. It approximates the behavior of one monitored sample in a context to many samples taken in the same context. If very few monitored samples in a context are used to approximate the behavior of a large number of samples with different traits in that context, it can result in noticeable overestimation or underestimation.</p><p>Like any profiler, our tools detect only dynamic instances of inefficiencies. False positives or false negatives can happen based on the kind of tools built atop Witch. A dead write detection tool has false negatives (can miss dead writes in an execution) but it has no false positives (all reported dead writes are dead writes). The performance benefit of using debug registers overweighs the downside of a small number of potential false negatives. Developer investigation or post-processing is necessary to make optimization choices-not all reported inefficiencies need be eliminated. Only high-frequency inefficiency spots are interesting; eliminating a long tail of insignificant inefficiencies that do not add up to a significant fraction is impractical and probably ineffective. Our investigation shows that only a few calling contexts contribute to most of the measured inefficiencies; for example, in SPEC CPU2006 benchmarks, fewer than five contexts, typically, contributed to over 90% of dead writes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Design and Implementation</head><p>We implement Witch in the open-source HPCToolkit <ref type="bibr" target="#b0">[1]</ref> performance analysis tools suite. HPCToolkit works on multilingual, multi-threaded, and multi-process, fully optimized applications on multiple programming models such as MPI and OpenMP. On a PMU sample, HPCToolkit's profiler, hpcrun, walks the sampled thread's call stack using an onthe-fly binary analysis technique and attributes the measurements to the sampled call path. hpcrun introduces negligible runtime overhead (∼3%) and consumes only a few megabytes of memory space for its metrics data when sampling at ∼200 samples/second/thread <ref type="bibr" target="#b72">[76]</ref>.</p><p>PMU Sampling: Although the clients of Witch can sample any precise PMU event to set a watchpoint, on Intel processors, typically, we use MEM_UOPS_RETIRED:ALL_STORES and MEM_UOPS_RETIRED:ALL_LOADS to drive PMU sampling. These events offer the address accessed in a sample.</p><p>Watchpoint Registration: Witch automatically discovers the number of hardware debug registers supported on the platform. When a client wants to monitor an address, Witch uses the Linux perf_event interface to register a watchpoint event. The event is a HW_BREAKPOINT perf event (a PERF_TYPE_SOFTWARE event category). Witch registers a signal handler to capture watchpoint exceptions that the Linux perf_event interface raises when the event overflows. Witch sets the sample_period to 1 for its HW_BREAKPOINT events, which ensures that the trap signal is delivered immediately after accessing the monitored address.</p><p>Precise PC of a Watchpoint: Some clients need the precise instruction pointer of the instruction triggering the watchpoint, for example, to distinguish a load from a store when a RW_TRAP watchpoint triggers. The BREAKPOINT event in Linux perf_event is not a PMU event and hence the Intel PEBS support, which otherwise provides the precise register state, is unavailable for a watchpoint. Although the watchpoint causes a trap immediately after the instruction execution, the PC seen in the signal handler context (contextPC) is one ahead of the actual PC (precisePC) that causes the trap. In the x86 variable instruction set ISA, it is non-trivial to derive the precisePC, even though it is just one instruction before the contextPC. A software solution is to find the function enclosing contextPC and disassemble every instruction till we reach the contextPC. This solution may fail with linear disassembly due to 1) data embedded in instruction and 2) missing function bounds <ref type="bibr" target="#b72">[76]</ref>. Furthermore, it can be time-consuming if the function body is large.</p><p>Our solution depends on the Last Branch Record (LBR) facility <ref type="bibr" target="#b23">[25]</ref> provided by Intel Nehalem and its successors, which is exposed through the Linux perf_event interface. LBR tracks taken branches throughout CPU execution and continuously records the &lt;from:to&gt; pairs of instruction pointers in a fixed-size in-CPU circular buffer. Witch exploits the LBR facility by modifying the perf_event implementation inside the Linux kernel. Linux perf_event already has the facility to construct the precise PC by disassembling the instructions starting from the "to" field of the last entry in the LBR until the disassembly reaches the contextPC. Disassembling a basic block is "feather light" compared to full function disassembly. We reuse this component with PERF_TYPE_SOFTWARE to construct the precisePC when a watchpoint trap event happens. The kernel makes the precisePC available to Witch's watchpoint exception handler in the ring buffer associated with the event on each watchpoint trap. This reduces ∼5% runtime overhead.</p><p>Fast Watchpoint Replacement: Witch requires frequently disabling a watchpoint, closing all the kernel resources (perf_event file descriptor and an mmaped ring buffer) associated with the watchpoint, and recreating the same for another watchpoint. We enhance the kernel perf_event ioctl interface with an additional flag PERF_EVENT_IOC_MODIFY_ATTRIBUTES. This flag allows perf_event users to update the address and the access length associated with an already installed watchpoint. As a result, the user code can continue to reuse all the kernel resources associated with the previous perf_event file descriptor. Although Witch is functionally correct without this support, we found it useful to optimize this use case (∼5% overhead reduction). This change is being contributed to the Linux kernel as of this writing.  Stack Addresses: Clients of Witch may set a watchpoint on the stack in one function that returns, and another function invocation may overwrite the previous stack frame. Such situation will cause the watchpoint to trap, and Witch has no problem for such normal call-return sequence. If there is a redundancy in a callee, e.g., write to a variable in a callee that is frequent not read before returning to the caller, Witch can easily detect it. Setting a watchpoint on the application stack address has a corner case. On a PMU sample, the profiler's overflow signal handler, by default, shares the same stack as the application thread. In <ref type="figure" target="#fig_4">Figure 3(a)</ref>, assume M is the sampled stack address. Assume we set a watchpoint at M. If the next PMU sample is taken with a shallower stack <ref type="figure" target="#fig_4">(Figure 3(b)</ref>), and the signal stack frame overwrites M; it spuriously triggers the watchpoint. Similarly, one watchpoint exception handler stack frame may trap another watchpoint.</p><p>We avoid this problem by establishing a separate signalhandler stack frame for both PMU signal handler and watchpoint exception handler using the Linux sigaltstack facility <ref type="bibr">[41]</ref>. The sigaltstack facility allows each thread in a process to define an alternate signal stack in a userdesignated memory region. We use alternate stack to handle PMU and watchpoint signals as shown in <ref type="figure" target="#fig_4">Figure 3(c)</ref>. All other signals continue to use the default stack unless specified otherwise by the application.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Witchcraft: Client Tools of Witch</head><p>We have already discussed the dead store detection client in the previous sections as a running example. In this section, we elaborate two more clients that use the Witch framework to pinpoint different kinds of inefficiencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">SilentCraft: Silent Store Detection</head><p>Updating a location with a value already present at the location is a silent store. Silent stores are useless since they do not change system state. Our prior work, RedSpy <ref type="bibr" target="#b77">[81]</ref>, shows that useless computations that store their results into memory often show up as silent stores. Here, we devise SilentCraft, a silent store detection client that mimics RedSpy.</p><p>SilentCraft samples PMU store events. On each PMU sample, SilentCraft remembers the contents (value) of the memory location accessed in the sampled address. SilentCraft, then, arms a W_TRAP watchpoint W . SilentCraft disregards the loads that may intervene between two store operations. Hence loads do not trigger a watchpoint trap. SilentCraft also associates the calling context C wat ch of the sample point with the watchpoint W .</p><p>The next store operation (say in context C t r ap ), overlapping the same memory address, triggers a watchpoint exception. SilentCraft obtains the precise PC and the address accessed in the watchpoint from Witch and compares the current contents of the memory location with the previously recorded value. The comparison is limited to the bytes that overlap between a) the sampled address and its access length and b) and trapped address and its access length. If all overlapping bytes are same, SilentCraft marks the calling context pair ⟨C wat ch , C t r ap ⟩ with proportional units of silent stores. Proportionality computation follows the previously discussed proportional attribution heuristic. To identify opportunities for approximate computation, for the floating-point operations, SilentCraft performs approximate equality check within a user-specified precision level. SilentCraft infers that a datum is a floating-point value by disassembling the instruction accessing the address.</p><p>SilentCraft quantifies the store redundancy R in an execution analogous to DeadCraft (Equation 1); two consecutive stores with unchanged values (approximately the same for floating point values) contribute to the "waste" and contribute to the "use" otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">LoadCraft: Load-after-load Detection</head><p>We developed a new tool-LoadCraft-that detects a load followed by another load from the same location where the value remains unchanged between the two loads. It ignores intervening stores to the same address that may change the value and revert it to the original value before a load. Not all load-load redundancies can be eliminated. Since machines have a small number of registers, they often spill values to memory to be read back later. Unfavorable algorithms and data structures often show up as load-load redundancies that shed light on domain-specific optimization opportunities.</p><p>LoadCraft samples PMU load events. The rest of the functionality is similar to that of SilentCraft, except that it requests a watchpoint for load access on the monitored location. Witch uses RW_TRAP because x86 machines do not offer a trap-on-load watchpoint. If a watchpoint triggers on a store operation, Witch merely drops it. LoadCraft quantifies the load redundancy L in an execution analogous to DeadCraft (Equation 1), where two consecutive loads with (approximately) unchanged values contribute to the "waste" and different values contribute to the "use".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Witchcrafts on Multi-threading</head><p>Debug registers and PMUs are per CPU core and virtualized for each software thread. All the previously discussed Witch tools work on multi-threaded codes; they, however, track intra-thread inefficiencies only. If a thread T 1 configures a watchpoint at address M, a trap occurs only in T 1 ; other threads remain unaffected whether they access M or not. Sharing addresses accessed by one thread with another thread allows building several tools for multi-threaded applications. Atop Witch, we have developed Feather <ref type="bibr" target="#b8">[9]</ref>-a tool to detect false sharing in parallel programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Discussion</head><p>Developers can only reason about inefficiencies at instruction, source line, or data-type granularities. Hence, in all tools we discussed, if a dynamic instruction writes M bytes, either all M bytes contribute to the inefficiency metric or none. In the three tools we developed, we made the following implementation decision: if the monitored element of a SIMD instruction instance is found to be wasteful (useful), we approximate that all elements in the SIMD instruction instance as wasteful (useful). Other tools are free to make a different choice.</p><p>Currently, Witch is implemented to work on the native code such as C/C++/Fortran applications. The basic idea extends to a managed language but requires runtime support to map JIT-generated instruction to the source code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Presentation</head><p>HPCToolkit maintains all sampled call paths in a compact calling context tree (CCT) format <ref type="bibr" target="#b1">[2]</ref>. HPCViewer, the graphical interface, enables navigating the CCT and the corresponding source code ordered by the monitored metrics. A topdown view shows a call path C starting from main to a leaf function with the breakdown of metrics at each level. Witch tools discussed here need to attribute metrics to calling context pairs ⟨C watch , C t r ap ⟩. Merely attributing a metric to two independent contexts loses the association between two related contexts during postmortem inspection. To maintain a correlation between a source context (e.g., dead) and target (killing) context, Witch appending a copy of the target calling context to a source calling context. For example, if a store in context main-&gt;A-&gt;B is overwritten by another store in context main-&gt;C-&gt;D, DeadCraft constructs a synthetic calling context: main-&gt;A-&gt;B-&gt;KILLED_BY-&gt;main-&gt;C-&gt;D. The dead write metrics will be attributed to the leaf of this call chain. These synthetic call chains make it easy to visually navigate the CCT and focus on top redundancy pairs. <ref type="figure" target="#fig_2">Figure 2</ref> in Section 4 depicts this scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation</head><p>We evaluate Witch on a 2-socket, 18-core Intel Xeon E5-2699 v3 (Haswell) CPU clocked at 2.30GHz running Linux 4.8.0. The machine has 128GB DDR3 RAM. Simultaneous multi-threading (SMT) facility is not used in our experiments. All experiments use GCC v5.4.1 tools with -O3 and profileguided optimization (PGO) to ensure the highest level of optimization. DeadCraft and SilentCraft use the PMU event MEM_UOPS_RETIRED:ALL_STORES whereas LoadCraft uses MEM_UOPS_RETIRED:ALL_LOADS. In our experiments, we use the nearest prime number for the shown sampling intervals, which is the recommended method in PMU sampling. The raw data from our experiments are available online <ref type="bibr" target="#b6">[7]</ref>.</p><p>Two aspects are critically important in evaluating Witch: accuracy and overhead compared to the exhaustive instrumentation techniques. We use SPEC CPU2006 reference benchmarks for this aspect of evaluation. Accuracy: For accuracy, we need to answer three questions: (1) how accurate are the results compared to exhaustive monitoring, (2) how does the accuracy vary with sampling rates, and (3) how stable are the sampled results from one run to another.</p><p>The quantitative metric of dead writes is the percent of dead stores D (bytes overwritten without reading) as described in Equation 1, which we compare against the groundtruth dead stores D from DeadSpy <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10]</ref>. We compare the percent of silent stores R from SilentCraft against the ground-truth exhaustive monitoring metric R from RedSpy <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b77">81]</ref>. No prior tool exists to compare against LoadCraft; hence we implemented an exhaustive load-load value redundancy detection tool called LoadSpy. We compare the percent of silent loads L from LoadCraft against the ground-truth exhaustive monitoring metric L from Load-Spy. RedSpy also performs redundancy detection in registers, which we disabled for our evaluation. To assess the accuracy of our sampling clients against the ground-truth, we disable the bursty sampling used by RedSpy. SilentCraft, LoadCraft, RedSpy, and LoadSpy use 1% precision when comparing floating point values. <ref type="figure" target="#fig_6">Figure 4</ref> compares the total redundancies found by different sampling vs. exhaustive monitoring tools. The error bars represent the metric values at different sampling rates for Witch tools, i.e., 100K (high), 500K, 1M, 5M, 10M, and 100M (low) events per PMU interrupt. Clearly, the sampling rate, when chosen with some care, does not significantly affect the results. The sampling tools are highly accurate in almost all cases. There are, however, some exceptions. DeadCraft and SilentCraft on hmmer and calculix suffer from shadow sampling effects <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b35">38,</ref><ref type="bibr" target="#b56">60]</ref>  <ref type="table" target="#tab_4">0   18   36   54   72   90   astar-1  astar-2  bwaves  bzip2-1  bzip2-2  bzip2-3  bzip2-4  bzip2-5  bzip2-6  cactusADM  calculix  dealII  gamess-1  gamess-2  gamess-3  gcc-1  gcc-2  gcc-3  gcc-4  gcc-5  gcc-6  gcc-7  gcc-8  gcc-9  GemsFDTD  gobmk-1  gobmk-2  gobmk-3  gobmk-4  gobmk-5  gromacs  h264ref-1  h264ref-2  h264ref-3  hmmer-1  hmmer-2  lbm  leslie3d  libquantum  mcf  milc  namd  omnetpp  perlbench-1  perlbench-2  perlbench-3  povray  sjeng  soplex-1  soplex-2</ref>   <ref type="table" target="#tab_4">0   18   36   54   72   90   astar-1  astar-2  bwaves  bzip2-1  bzip2-2  bzip2-3  bzip2-4  bzip2-5  bzip2-6  cactusADM  calculix  dealII  gamess-1  gamess-2  gamess-3  gcc-1  gcc-2  gcc-3  gcc-4  gcc-5  gcc-6  gcc-7  gcc-8  gcc-9  GemsFDTD  gobmk-1  gobmk-2  gobmk-3  gobmk-4  gobmk-5  gromacs  h264ref-1  h264ref-2  h264ref-3  hmmer-1  hmmer-2  lbm  leslie3d  libquantum  mcf  milc  namd  omnetpp  perlbench-1  perlbench-2  perlbench-3  povray  sjeng  soplex-1  soplex-2  sphinx  tonto</ref>   Error bars capture different sampling rates. Ground truth instrumentation data is unavailable for gobmk, sjeng, and Xalan since they ran out of memory. The benchmarks with multiple inputs (e.g., bzip2) appear multiple times with different numerical suffixes.</p><p>latency stores hide low latency stores. GemsFDTD, perlbench, and zeusmp have many small inefficiencies scattered all over the code, leading to inaccuracies in SilentCraft. We ran each benchmark 10 times at 5M sampling rate (not shown) and the maximum standard deviations were 2.27%, 1.89%, and 0.77% for DeadCraft, SilentCraft, and LoadCraft respectively, which proves the run-to-run sampling stability. lbm has ∼100% silent stores and silent loads, but it has negligible dead stores. lbm is a floating point code, which simulates incompressible fluids in 3D. One iteration updates the values in an array that are loaded in the next iteration. The difference between the values produced in adjacent iterations is less than our predefined 1% threshold. Hence, LoadCraft treats these loads as redundant ones. Similarly, SilentCraft treats the stores to be approximately the same.</p><p>To assess the effectiveness of reservoir sampling, we vary the number of debug registers from one to four and compare the redundancy metrics against the ground truth. <ref type="figure" target="#fig_7">Figure 5</ref> shows that the number of debug registers has little practical influence in DeadCraft on the quality of results except h264ref, which shows better results with four debug registers. The online compendium <ref type="bibr" target="#b6">[7]</ref> corroborates this observation on SilentCraft and LoadCraft.</p><p>To assess the effectiveness of our proportional attribution based on samples taken in a context, we compared the accuracy with and without this feature at different sampling <ref type="table" target="#tab_4">0   25   50   75   100   astar-1  astar-2  bwaves  bzip2-1  bzip2-2  bzip2-3  bzip2-4  bzip2-5  bzip2-6  cactus…  calculix  dealII  games…  games…  games…  gcc-1  gcc-2  gcc-3  gcc-4  gcc-5  gcc-6  gcc-7  gcc-8  gcc-9  GemsF…  gobmk-1  gobmk-2  gobmk-3  gobmk-4  gobmk-5  gromacs  h264re…  h264re…  h264re…  hmmer-1  hmmer-2  lbm  leslie3d  libqua…  mcf  milc  namd  omnetpp  perlbe…  perlbe…  perlbe…  povray  sjeng  soplex-1  soplex-2  sphinx  tonto</ref>  rates and also with different number of debug registers with all three tools (not shown); we also compared it against the ground truth. In general, the feature did not make significantly positive or negative impact. GemsFDTD and perl were exceptions, where having the feature improved the accuracy.</p><p>To further understand the accuracy, we compared the rank ordering and percentage contribution of the top N redundancy pairs between DeadSpy and DeadCraft; we chose N to add up to 90% of redundancy observed in execution. No single metric suffices to compare this type of complex data. We used edit distance and set difference of the top N contexts and also compared weights at each position. Our measurements <ref type="bibr" target="#b6">[7]</ref> show that only a handful of context pairs account for the majority of redundancies and their rank ordering and individual weights match the exhaustive monitoring. Overhead: <ref type="table">Table 1</ref> shows the runtime slowdown and memory bloat of sampling vs. exhaustive monitoring. Slowdown (memory bloat) is the ratio of the runtime (peak memory usage) under monitoring to the runtime (peak memory usage) of the corresponding native execution. We show the average values for the same benchmark with multiple inputs. We used the sampling period of one in 5M stores and one in 10M loads (since loads are more common), which we found to be highly effective. Two critical things to observe about the sampling tools are 1) their overheads are at least an order of magnitude less than the exhaustive instrumentation tools, and 2) they introduce negligible overhead. Deep recursive codes such as xalanbmk, sjeng, and gombk incur higher space and time overheads; and their instrumentation counterparts do not run to completion. Recursive codes with inefficiencies (e.g., SilentCraft on gobmk and LoadCraft on xalanbmk) exacerbate memory bloat due to large calling context trees. Codes with a very small memory footprint (e.g., povray) show higher memory bloat because of some basic pre-allocated data structures used in our tools.</p><p>LoadCraft has higher overhead compared to the other two tools since 1) loads are more common than stores, 2) a high fraction of loading the same value leads to more watchpoint traps and inefficiency reporting cost, 3) most PMU samples find a free debug register and incur the cost of arming it, and finally 4) LoadCraft sets the RW_TRAP watchpoint (x86 does not support break on load watchpoint), which triggers a spurious exception on a store. <ref type="table" target="#tab_4">Table 2</ref> shows the geometric mean and median of the slowdown and memory bloat at different sampling periods in SPEC CPU2006.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case Studies</head><p>The lightweight nature of Witch tools allowed us to apply it on an array of benchmark suites-SPEC CPU2006 <ref type="bibr" target="#b68">[72]</ref>, SPEC OMP2012 <ref type="bibr" target="#b69">[73]</ref>, NERSC Trinity <ref type="bibr" target="#b52">[56]</ref>, Rodinia <ref type="bibr" target="#b57">[61]</ref>, and STAMP [? ] and full applications-NWChem <ref type="bibr" target="#b74">[78]</ref>, Caffe <ref type="bibr" target="#b25">[28]</ref>, GNU Binutils [20], and Kallisto RNA sequencing <ref type="bibr" target="#b48">[52]</ref>. Table 3 summarizes the new performance bugs found by our tools (denoted by ✓ prefix) and confirms previously found performance issues <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b77">81]</ref>. In this section, we describe four case studies covering the analyses by the three Witch tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">NWChem-6.3</head><p>NWChem <ref type="bibr" target="#b74">[78]</ref> is a production computational chemistry package, which implements several quantum mechanics and molecular mechanics methods. NWChem consists of six million lines of code written primarily in Fortran and C and parallelized with MPI <ref type="bibr" target="#b49">[53]</ref>. We use the QM-CC aug-cc-pvdz input and eight MPI processes in our studies.</p><p>DeadCraft reports that more than 60% of memory stores are dead. <ref type="figure">Figure 6</ref> shows the full calling contexts of the top (94% contribution to total dead writes) dead and killing store pair in the call of function dfill, which zeroes the array work2. With the given input, calls to dfill repeat more than 200K times, resulting in writing 500GB data that are never used. With further analysis, we identified that the size of work2 was larger than necessary, and the zero initialization was unnecessary, leading to the dead and killing writes in the same location. We eliminate this unnecessary initialization, yielding a 1.43× speedup. This bug, which was hiding in the large code base, is now fixed. Witch incurs only 6% runtime overhead whereas the fine-grained profiler, DeadSpy, incurs &gt; 10× slowdown identifying the same problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.2">Caffe-1.0</head><p>We apply SilentCraft on the deep learning framework Caffe <ref type="bibr" target="#b25">[28]</ref>. We study the OpenMP C++ CPU version, which uses Intel MKL <ref type="bibr" target="#b24">[26]</ref> to parallelize its computation kernels. We use the CIFAR-10 dataset to train the CIFAR network with 0.9 momentum, 4e-3 weight decay, 1e-3 learning rate, 128 batch size. We run Caffe with eight threads.</p><p>SilentCraft attributes 25% of total memory stores as redundant in a loop nest belonging to a major computation kernel in pooling and normalization layers (Listing 4). The memory stores to the array bottom_diff (Line 8) account for 17% of total silent stores. A large portion of elements in  <ref type="bibr" target="#b68">[72]</ref> blocksort.c:mainGtU_init Poor code generation # (DS) 1.07× hmmer <ref type="bibr" target="#b68">[72]</ref> fast_algorithms.c:loop(119) No-vectorization (DS/SS) 1.28× h264ref <ref type="bibr" target="#b68">[72]</ref> mv-search.c:loop(394) Missed inlining (SL) 1.27× ✓povray <ref type="bibr" target="#b68">[72]</ref> csg.cpp:loop(248) Missed inlining (DS) 1.08× ✓Chombo <ref type="bibr" target="#b11">[12]</ref> PolytropicPhysicsF.ChF:(434) Inattention to perf. (DS) 1.07× ✓botsspar <ref type="bibr" target="#b69">[73]</ref> sparselu.c:fwd Redundant computation (SL) 1.15× ✓imagick <ref type="bibr" target="#b69">[73]</ref> magick_effect.c:loop(1482) Redundant computation (SL) 1.6× ✓SMB <ref type="bibr" target="#b52">[56]</ref> msgrate.c:cache_invalidate Redundant computation (SL) 1.47× backprop <ref type="bibr" target="#b57">[61]</ref> bpnn_adjust_weights Redundant computation (SS) 1.20× lavaMD <ref type="bibr" target="#b57">[61]</ref> kernel_cpu.c:loop(117) Redundant computation (SL) 1.66× ✓vacation <ref type="bibr">[? ]</ref> client.c:loop(198) Redundant computation (SL) 1.31× NWChem-6.3 <ref type="bibr" target="#b74">[78]</ref> tce_mo2e_trans.F(240) Useless initialization (DS/SS) 1.43× ✓Caffe-1.0 <ref type="bibr" target="#b25">[28]</ref> pooling_layer.cpp(289) Redundant computation (SS) 1.06× ✓Binutils-2.27 <ref type="bibr">[20]</ref> dwarf2.c(1561) Linear search algorithm (SL) 10× ✓Kallisto-0.43 <ref type="bibr" target="#b48">[52]</ref> KmerHashTable top_diff are zeroes; hence the same values overwrite the existing values in the same memory location of bottom_diff.</p><p>The iteration over all the elements of bottom_diff in the four-level nested loop amplifies the fraction of silent stores. We optimize this code by introducing a check for the value in top_diff. If it is a zero, we bypass a division, an addition, and a memory store. This optimization speeds up the pooling layer by 1.16× the normalization layers by 1.34×. We observe 1.03× speedup for the entire program. We further relax the join node call path of dead call path of kill <ref type="figure">Figure 6</ref>. The pair of dead and kill stores with full contexts reported by Witch's dead store client.</p><p>for ( int n = 0; n &lt; top [0] -&gt; num () ; ++ n ) { for ( int c = 0; c &lt; channels_ ; ++ c ) { 3 for ( int ph = 0; ph &lt; pooled_height_ ; ++ ph ) { for ( int pw = 0; pw &lt; pooled_width_ ; ++ pw ) { . check for the absolute value in top_diff with a small delta 1e-7 rather than 0. If it is smaller, we bypass the computation for approximate results. This optimization, with less than 2% accuracy loss, yields 1.16× and 2.23× speedups for the <ref type="bibr" target="#b0">1</ref>  pooling and normalization layers, respectively. The entire program obtains a 1.06× speedup.</p><p>8.3 GNU Binutils-2.27 GNU Binutils [20] is a collection of binary tools used by many binary analysis tools such as Pin <ref type="bibr" target="#b45">[49]</ref> and commandline tools such as objdump <ref type="bibr" target="#b18">[19]</ref>. Disassembling an object file containing many functions using objdump with -d -S -l flags (map assembly to symbol and source lines) is unusually slow. We profile objdump in binutils-2.27 with LoadCraft by disassembling the LULESH-2.0 <ref type="bibr" target="#b30">[33]</ref> binary, which contains many functions. LoadCraft identifies 96% of the loads in the program as loading the same value from the same location. The top contributor is the Line 5 (Listing 5) in the function lookup_address_in_function_table with 70% redundant loads attributed to it. The function performs a linear scan over the addresses covered by each line of each function, maintained as a linked list, looking for the best match for a given address range.</p><p>When repeatedly called for different addresses in an object file containing many functions linear search is a poor choice of algorithm. We replace the linked list with a sorted array and perform a binary search over it. This solution speeds up the execution by 10×. This problem is fixed in the latest binutils. Pinpointing that the code always loads the same values from the same location raised a red flag, clearly indicating an algorithmic deficiency.</p><p>8.4 SPEC OMP2012 367.imagick SPEC OMP2012 367.imagick <ref type="bibr" target="#b69">[73]</ref> is an OpenMP software to manipulate bitmap images. With the ref input and eight threads, LoadCraft reports that more than 99% of total memory loads are redundant and 85% of the redundant loads are associated with the loop nests shown in Listing 6.</p><p>The loop body has six memory loads for different fields of pixel and kernel_pixels. Each of the loads is often redundant with a load in a prior iteration. We find that the fields red, green, and blue of kernel_pixels[u] are mostly zeros. For optimization, we introduce a conditional check on kernel_pixels <ref type="bibr">[u]</ref>. If it is zero, we skip the computation, which saves a memory load from address k, a multiplication, and a memory load to the field of pixel. This optimization yields a 1.6× speedup. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.5">Discussion on Other Optimizations</head><p>Many algorithmic deficiencies show up as useless loads and stores. While hotspots may indicate where a large fraction of time is spent, they do not indicate the usefulness of the work. Such defects stand out when profiled with our tools.</p><p>We presented a subset of programs where we found inefficiencies using witchcraft. Kallisto-0.43 <ref type="bibr" target="#b48">[52]</ref> is an important RNA-sequencing software where LoadCraft found more than 98% redundant loads. The problem was a large, linear-probing hash-table with excessive hash collisions. We fixed Kallisto by reducing the load factor on the hash table and gained 4.1× speedup. Vacation is a STAMP [? ] transactional memory benchmark, where we found unnecessary calls to a hash-table lookup of an item that was already found in the previous line of the code. Memoizing the result of the previous lookup resulted in 1.3× speedup. The results from our tools showed us that SPEC CPU2006 lbm is an excellent candidate for approximate computing; we applied loop perforation <ref type="bibr" target="#b65">[69]</ref> to lbm and obtained 1.25x speedup with insignificant (7.7e-5%) accuracy loss.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusions</head><p>Fine-grained execution monitoring via binary instrumentation introduces heavy slowdown and memory bloat. Witch, open sourced at <ref type="bibr" target="#b6">[7]</ref>, is a lightweight monitoring framework, which employs PMU sampling in conjunction with hardware debug registers to monitor sampled memory addresses. We overcome the problem of limited hardware debug registers with a novel sampling technique. Witch-based tools show high measurement accuracy. Low overhead combined with rich contextual attribution makes our tools attractive to developers in pinpointing inefficiencies in large, complex, production software. We demonstrate the effectiveness of our tools by identifying inefficiencies in several complex, parallel software projects that were the subject of optimization for decades, and we tune them with the guidance from Witch to gain significant speedups.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>void loop_regs_scan ( struct loop * loop , ...) { ... ▶ last_set =( rtx *) xcalloc ( regs -&gt; num , sizeof ( rtx ) ) ; /* Scan the loop , recording register usage */ for ( each instruction in loop ) { ... if ( GET_CODE ( PATTERN ( insn ) ) == SET || ...) count_one_set (... , last_set ,...) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>1</head><label></label><figDesc>for ( int i = 1; i &lt;= 100 K ; i ++) { 2 array [ i ] = 0; 3 } 4 for ( int j = 1; j &lt;= 100 K ; j ++) { 5 array [ j ] = j ; 6 }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>a[] and b[] and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>(a) A PMU sample happens in a deeper call stack when B() is accessing address M; signal handler sets a watchpoint to monitor the address M. (b) A shallower application call stack, function A(), triggers another PMU sample, the signal handler is established in a location that overwrites M, triggering a spurious watchpoint. (c) An alternate signal stack for PMU signal handler and watchpoint signal handler solves the problem.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>Witch tools vs. instrumentation tools on SPEC CPU2006.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 .</head><label>5</label><figDesc>Comparison of dead writes with different number of debug registers. Error bars are for different (100K -100M) sampling intervals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>DeadCraft infers a dead write and attributes it to ⟨C watch , C t r ap ⟩.</figDesc><table><row><cell></cell><cell>Record and report</cell></row><row><cell></cell><cell>dead write in</cell></row><row><cell>DeadCraft: Dead write detection tool</cell><cell>&lt;Cwatch, Ctrap&gt; if trap was a store</cell></row><row><cell>&lt;Calling context</cell><cell></cell></row><row><cell cols="2">CPU Witch framework Monitor load and store to M Set RW watchpoint on address M Watchpoint trap when accessing M Linux perf_events interface 3 Cwatch, Figure 1. Detecting dead writes using Witch. The client, Precise PMU sample on a store 1 5 6 Legend: Signals Calls 2</cell></row><row><cell cols="2">DeadCraft, subscribes to the precise PMU store event with a de-</cell></row><row><cell cols="2">sired sample period. 1 ○ PMU counter overflows triggering an in-</cell></row><row><cell cols="2">terrupt. 2 ○ Witch handles the signal, extracts the calling context</cell></row><row><cell cols="2">(C watch ) of the interrupt and the address accessed (M), and offers</cell></row><row><cell cols="2">the triplet ⟨C watch , M, AccessType⟩ to DeadCraft. 3 ○ DeadCraft</cell></row><row><cell cols="2">asks Witch to monitor subsequent load or store to M. 4 ○ Witch</cell></row><row><cell cols="2">sets a watchpoint to monitor M, and the execution continues 5 ○</cell></row><row><cell cols="2">Program accesses M, which causes a CPU trap. 6 ○ Witch han-</cell></row><row><cell cols="2">dles the trap signal, extracts the calling context (C t r ap ), and of-</cell></row><row><cell cols="2">fers the triplet ⟨C t r ap , M, AccessType⟩ to DeadCraft. 7 ○ If the Ac-</cell></row><row><cell>cessType is a store,</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>The first sample happens in the i loop when accessing array[10K]. DeadCraft sets a watchpoint to monitor &amp;array[10K] since a debug register is available. The second sample happens when accessing array[20K]. Since the watchpoint armed for address &amp;array[10K] is still active, there is no room to monitor &amp;array[20K].</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 2 .</head><label>2</label><figDesc>DeadSpy 22.65 31.70 32.32 29.93 33.40 54.70 40.00 43.57 26.36 -26.95 59.67 52.01 28.86 31.70 27.87 21.69 14.61 22.18 37.80 71.91 71.13 -26.45 26.16 34.85 24.60 -19.95 32.48 30.82 DeadCraft 1.01 1.00 1.00 1.04 1.01 1.01 1.07 1.02 1.03 1.00 1.02 1.01 1.02 1.00 1.01 1.00 1.00 1.01 1.00 1.01 1.03 1.02 1.00 1.00 1.01 1.02 1.04 1.19 1.00 1.02 1.01 .40 6.27 5.84 8.53 14.70 8.20 32.26 6.12 -9.80 11.93 20.65 6.06 6.25 9.49 6.00 6.26 6.55 6.84 45.75 38.66 -17.54 7.48 16.76 6.70 -6.03 9.87 7.16 DeadCraft 1.03 1.01 1.02 1.00 1.07 1.01 1.30 1.03 1.00 2.06 1.38 1.30 1.62 1.01 1.07 1.11 1.00 1.01 1.14 1.04 1.02 2.56 1.09 1.05 1.15 1.64 1.01 5.36 1.02 1.23 1.05 RedSpy 16.33 17.62 23.75 45.64 26.17 23.60 33.00 200.07 41.24 -25.60 101.66 26.66 14.53 39.43 23.67 10.76 10.94 16.94 27.97 59.71 67.50 -23.60 16.46 29.32 33.00 -27.66 29.10 26.42 SilentCraft 1.01 1.01 1.00 1.05 1.01 1.00 1.05 1.03 1.02 1.00 1.02 1.02 1.03 1.00 1.01 1.03 1.00 1.00 1.02 1.01 1.04 1.03 1.00 1.02 1.00 1.01 1.04 1.13 1.00 1.02 1.01 .42 5.26 5.06 8.24 12.50 9.80 34.84 5.22 -10.08 9.95 15.57 5.15 5.46 6.35 5.08 5.31 5.97 6.42 67.76 51.87 -3.73 6.53 17.33 5.90 -5.20 8.58 6.16 SilentCraft 1.03 1.01 1.02 1.00 1.07 1.01 1.31 1.03 1.01 2.05 1.55 1.33 1.64 1.01 1.07 1.11 1.00 1.01 1.14 1.04 1.02 2.78 1.09 1.04 1.15 1.64 1.01 5.17 1.01 1.24 1.04 LoadSpy 30.00 87.70 53.00 123.00 75.30 81.30 100.00 51.80 69.60 -39.80 185.00 95.30 15.10 98.60 36.80 26.90 26.90 46.10 36.00 82.00 156.00 -31.20 60.10 54.10 81.90 -51.00 58.66 57.10 Geomean and median of slowdown and memory bloat of Witch tools at different sampling rates on SPEC CPU2006.</figDesc><table><row><cell></cell><cell cols="2">Benchmark</cell><cell>astar</cell><cell>bwaves</cell><cell>bzip2</cell><cell>cactusADM</cell><cell>calculix</cell><cell>dealII</cell><cell>gamess</cell><cell>gcc</cell><cell>GemsFDTD</cell><cell>gobmk</cell><cell>gromacs</cell><cell>h264ref</cell><cell>hmmer</cell><cell>lbm</cell><cell>leslie3d</cell><cell>libquantum</cell><cell>mcf</cell><cell>milc</cell><cell>namd</cell><cell>omnetpp</cell><cell>perlbench</cell><cell>povray</cell><cell>sjeng</cell><cell>soplex</cell><cell>sphinx3</cell><cell>tonto</cell><cell>wrf</cell><cell>xalancbmk</cell><cell>zeusmp</cell><cell>GeoMean</cell><cell>Median</cell></row><row><cell cols="3">Original Time (second)</cell><cell cols="2">139 303</cell><cell cols="4">64 371 635 246</cell><cell>50</cell><cell>24</cell><cell cols="4">297 71 317 138</cell><cell cols="7">160 342 215 173 221 458 318</cell><cell></cell><cell>65</cell><cell cols="8">101 367 86 423 408 312 158 360</cell></row><row><cell cols="9">Original Memory Usage (MB) 875 562 664 118 795</cell><cell>22</cell><cell cols="4">459 831 30 16</cell><cell>38</cell><cell>16</cell><cell cols="2">411 125</cell><cell cols="3">95 1677 681</cell><cell>48</cell><cell cols="2">171 400</cell><cell>7</cell><cell cols="3">176 279 44</cell><cell>36</cell><cell cols="3">695 421 512</cell></row><row><cell cols="3">Slowdown</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Dead</cell><cell cols="2">(times)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="4">store DeadSpy 6.47 6Silent Memory bloat (times) Slowdown (times)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="33">store 5.35 5Silent Memory bloat (times) RedSpy DeadCraft load GeoMean Time Space Slowdown overhead Overhead (times) LoadCraft 1.04 1.00 2.16 1.69 1.09 1.00 1.12 1.04 1.08 1.00 1.06 1.04 1.04 1.00 1.09 1.01 1.00 1.02 1.58 1.00 1.51 1.05 1.00 1.00 1.01 1.05 1.10 1.86 1.08 1.13 1.04 SilentCraft LoadCraft Time Space Time Space overhead Overhead overhead Overhead 100M 1.01 1.11 1.01 1.11 1.07 1.14 Memory LoadSpy 6.80 6.50 4.00 5.90 8.49 14.40 12.00 50.10 6.30 -12.60 18.40 23.90 6.20 4.90 50.20 6.09 6.40 6.80 8.20 184.001051.00 -13.20 9.30 36.70 5.20 -6.30 13.52 8.35 10M 1.01 1.17 1.01 1.17 1.16 1.27 bloat (times) LoadCraft 1.03 1.01 1.03 1.00 1.08 1.01 1.36 1.03 1.01 2.01 1.43 1.36 1.64 1.01 1.07 1.11 1.00 1.01 1.13 1.04 1.02 3.55 1.14 1.05 1.19 1.87 1.02 24.93 1.02 1.33 1.05 5M 1.02 1.21 1.02 1.22 1.21 1.35</cell></row><row><cell cols="33">Table 1. Runtime slowdown (×) and memory bloat (×) over native execution: Witch (DeadCraft, SilentCraft, LoadCraft) vs. exhaustive 1M 1.05 1.40 1.05 1.39 1.43 1.61</cell></row><row><cell cols="10">monitoring tools (DeadSpy, RedSpy, LoadSpy). 500K 1.08 1.50 1.08 1.50 1.74</cell><cell></cell><cell>1.74</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">GeoMean</cell><cell cols="2">DeadCraft</cell><cell></cell><cell></cell><cell cols="3">SilentCraft</cell><cell></cell><cell></cell><cell cols="3">LoadCraft</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">/Median</cell><cell>Slowdown</cell><cell cols="2">Memory bloat</cell><cell cols="2">Slowdown</cell><cell cols="3">Memory bloat</cell><cell cols="2">Slowdown</cell><cell cols="3">Memory bloat</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>(times)</cell><cell>(times)</cell><cell></cell><cell cols="2">(times)</cell><cell></cell><cell>(times)</cell><cell></cell><cell cols="2">(times)</cell><cell></cell><cell cols="2">(times)</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">100M</cell><cell>1.00/1.00</cell><cell cols="2">1.12/1.03</cell><cell cols="2">1.01/1.00</cell><cell></cell><cell cols="2">1.12/1.04</cell><cell cols="2">1.04/1.00</cell><cell></cell><cell cols="2">1.17/1.05</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>10M</cell><cell></cell><cell>1.01/1.01</cell><cell cols="2">1.19/1.05</cell><cell cols="2">1.01/1.00</cell><cell></cell><cell cols="2">1.19/1.04</cell><cell cols="2">1.13/1.04</cell><cell></cell><cell cols="2">1.33/1.05</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>5M</cell><cell></cell><cell>1.02/1.01</cell><cell cols="2">1.23/1.05</cell><cell cols="2">1.02/1.01</cell><cell></cell><cell cols="2">1.24/1.04</cell><cell cols="2">1.20/1.06</cell><cell></cell><cell cols="2">1.42/1.06</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>1M</cell><cell></cell><cell>1.05/1.03</cell><cell cols="2">1.40/1.05</cell><cell cols="2">1.06/1.03</cell><cell></cell><cell cols="2">1.39/1.04</cell><cell cols="2">1.48/1.27</cell><cell></cell><cell cols="2">1.66/1.07</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">500K</cell><cell>1.09/1.03</cell><cell cols="2">1.48/1.06</cell><cell cols="2">1.09/1.04</cell><cell></cell><cell cols="2">1.47/1.05</cell><cell cols="2">1.92/1.53</cell><cell></cell><cell cols="2">1.74/1.07</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="7">Benchmark Information program problem code</cell><cell></cell><cell cols="6">Witch Inefficiencies (Client)</cell><cell cols="2">WS  *</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="3">gcc [72]</cell><cell cols="4">cselib.c:cselib_init</cell><cell></cell><cell cols="8">Poor data structure (DS) 1.33×</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="2">bzip2</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 3 .</head><label>3</label><figDesc>DS means dead store, SS means silent store, SL means silent load. Performance improvement guided by Witch.</figDesc><table><row><cell>.h(131)</cell><cell>Poor hashing (SL)</cell><cell>4.1×</cell></row><row><cell>✓ newly found issues via Witch</cell><cell># used gcc-4.1.2</cell><cell></cell></row></table><note>* WS means whole-program speedup after problem elimination.+</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Silent stores to array bottim_diff in Caffe.</figDesc><table><row><cell></cell><cell>..</cell></row><row><cell cols="2">for ( int h = hstart ; h &lt; hend ; ++ h ) {</cell></row><row><cell>7</cell><cell>for ( int w = wstart ; w &lt; wend ; ++ w ) {</cell></row><row><cell>8 ▶</cell><cell>bottom_diff [ h * width_ + w ] +=</cell></row><row><cell></cell><cell>top_diff [ ph * pooled_width_ + pw ] /</cell></row><row><cell></cell><cell>pool_size ;</cell></row><row><cell>}}}}</cell><cell></cell></row><row><cell>...}}</cell><cell></cell></row><row><cell cols="2">Listing 4.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>bfd_boolean lookup_address_in_function_table ( struct comp_unit * unit , bfd_vma addr , ...) { 2 ... 3 for ( each_func = unit -&gt; function_table ; ...) { 4 for ( arange = &amp; each_func -&gt; arange ; ...) { 5 ▶ if ( addr &gt;= arange -&gt; low &amp;&amp; addr &lt; arange -&gt; high ) { 6 if (! best_fit || ... ) { Redundant loads in binutils-2.27 dwarf2.c file. Linear searches load same the values from same locations.</figDesc><table><row><cell>7</cell><cell>best_fit = each_func ;</cell></row><row><cell>8</cell><cell>best_fit_len = arange -&gt; high -arange -&gt; low ;</cell></row><row><cell>9</cell><cell>}}}}</cell></row><row><cell>10</cell><cell>. . .</cell></row><row><cell>11 }</cell><cell></cell></row><row><cell cols="2">Listing 5.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head></head><label></label><figDesc>for ( y =0; y &lt; ( ssize_t ) image -&gt; rows ; y ++) { for ( x =0; x &lt; ( ssize_t ) image -&gt; columns ; x ++) { for ( v =0; v &lt; ( ssize_t ) width ; v ++) { for ( u =0; u &lt; ( ssize_t ) width ; u ++) { ▶ pixel . red +=(* k ) * kernel_pixels [ u ]. red ; ▶ pixel . green +=(* k ) * kernel_pixels [ u ]. green ; ▶ pixel . blue +=(* k ) * kernel_pixels [ u ]. blue ; k ++; }}}} Listing 6. Redundant loads to different fields of structure pixel and array kernel_pixels in 367.imagick</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We thank the anonymous reviewers and our shepherd Shan Lu for the detailed comments on the paper. We appreciate the Ph.D. student Probir Roy from College of William and Mary for helping study Caffe 1.0. We also thank Dr. Aarthi Muthusamy for sketching the title Witch icon.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">HPCToolkit: Tools for Performance Analysis of Optimized Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Adhianto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Banerjee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fagan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Krentel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Marin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">R</forename><surname>Tallent</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Concurrency Computation : Practice Expererience</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="685" to="701" />
			<date type="published" when="2010-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Exploiting Hardware Performance Counters with Flow and Context Sensitive Profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Glenn</forename><surname>Ammons</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">R</forename><surname>Larus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting><address><addrLine>NY, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="85" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Interprocedural Load Elimination for Dynamic Optimization of Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Barik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sarkar</surname></persName>
		</author>
		<idno type="DOI">10.1109/PACT.2009.32</idno>
		<ptr target="https://doi.org/10.1109/PACT.2009.32" />
	</analytic>
	<monogr>
		<title level="m">18th International Conference on Parallel Architectures and Compilation Techniques</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="41" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Dynamic Dead-instruction Detection and Elimination</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Butts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guri</forename><surname>Sohi</surname></persName>
		</author>
		<idno type="DOI">10.1145/605397.605419</idno>
		<ptr target="https://doi.org/10.1145/605397.605419" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Conference on Architectural Support for Programming Languages and Operating Systems. 199-210</title>
		<meeting>the 10th International Conference on Architectural Support for Programming Languages and Operating Systems. 199-210</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Barrier Elision for Production Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wim</forename><surname>Lavrijsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Wibe De Jong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Costin</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Iancu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2688500.2688502</idno>
		<ptr target="https://doi.org/10.1145/2688500.2688502" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>the 20th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="109" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Call Paths for Pin Tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<idno type="DOI">10.1145/2544137.2544164</idno>
		<ptr target="https://doi.org/10.1145/2544137.2544164" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization. Article</title>
		<meeting>Annual IEEE/ACM International Symposium on Code Generation and Optimization. Article</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">76</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shasha</forename><surname>Wen</surname></persName>
		</author>
		<ptr target="https://github.com/WitchTools/Witch.git" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">DeadSpy: a tool to pinpoint program inefficiencies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mellor-Crummey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Symposium on Code Generation and Optimization</title>
		<meeting>the 10th International Symposium on Code Generation and Optimization</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="124" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Featherlight On-thefly False Sharing Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shasha</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
		</author>
		<idno type="DOI">10.1145/3178487.3178499</idno>
		<ptr target="https://doi.org/10.1145/3178487.3178499" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>the 23th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shasha</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
		</author>
		<ptr target="https://github.com/CCTLib/CCTLib." />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Taming Hardware Event Samples for FDO Compilation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dehao</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Neil</forename><surname>Vachharajani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Hundt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shih-Wei</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vinodha</forename><surname>Ramasamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Yuan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weimin</forename><surname>Zheng</surname></persName>
		</author>
		<idno type="DOI">10.1145/1772954.1772963</idno>
		<ptr target="https://doi.org/10.1145/1772954.1772963" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO &apos;10)</title>
		<meeting>the 8th Annual IEEE/ACM International Symposium on Code Generation and Optimization (CGO &apos;10)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="42" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Chombo Software Package for AMR Applications -Design Document</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Colella</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Graves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Keen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ligocki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Mc-Corquodale</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Modiano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schwartz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Td Sternberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van Straalen</surname></persName>
		</author>
		<idno>LBNL-6616E</idno>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
		<respStmt>
			<orgName>Lawrence Berkeley National Laboratory</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Eliminating redundancies in sum-of-product array computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Deitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bradford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lawrence</forename><surname>Chamberlain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Conference on Supercomputing</title>
		<meeting>the 15th International Conference on Supercomputing</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="65" to="77" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Cray Performance Analysis Tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luiz</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bill</forename><surname>Homer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dean</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Kaufmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heidi</forename><surname>Poxon</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-68564-7_12</idno>
		<ptr target="https://doi.org/10.1007/978-3-540-68564-7_12" />
	</analytic>
	<monogr>
		<title level="m">Tools for High Performance Computing</title>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="191" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Toward a new metric for ranking high performance computing systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jack</forename><surname>Dongarra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Heroux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sandia Report</title>
		<imprint>
			<biblScope unit="page">150</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Instruction-Based Sampling: A New Performance Analysis Technique for AMD Family 10h Processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">J</forename><surname>Drongowski</surname></persName>
		</author>
		<ptr target="https://pdfs.semanticscholar.org/5219/4b43b8385ce39b2b08ecd409c753e0efafe5.pdf." />
		<imprint>
			<date type="published" when="2007-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Potential of a modern vector supercomputer for practical applications: performance evaluation of SX-ACE</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryusuke</forename><surname>Egawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kazuhiko</forename><surname>Komatsu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shintaro</forename><surname>Momose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoko</forename><surname>Isobe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akihiro</forename><surname>Musa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hiroyuki</forename><surname>Takizawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hiroaki</forename><surname>Kobayashi</surname></persName>
		</author>
		<idno type="DOI">10.1007/s11227-017-1993-y</idno>
		<ptr target="https://doi.org/10.1007/s11227-017-1993-y" />
	</analytic>
	<monogr>
		<title level="j">The Journal of Supercomputing</title>
		<imprint>
			<date type="published" when="2017-03-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Effective Data-race Detection for the Kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Burckhardt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kirk</forename><surname>Olynyk</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=1924943.1924954" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;10). USENIX Association</title>
		<meeting>the 9th USENIX Conference on Operating Systems Design and Implementation (OSDI&apos;10). USENIX Association<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="151" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Free Software Foundation</title>
		<ptr target="https://sourceware.org/binutils/docs/binutils/objdump.html" />
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Gprof: A call graph execution profiler</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Susan</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><forename type="middle">B</forename><surname>Kessler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marshall</forename><forename type="middle">K</forename><surname>Mckusick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1982 SIG-PLAN Symposium on Compiler Construction</title>
		<meeting>the 1982 SIG-PLAN Symposium on Compiler Construction<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1982" />
			<biblScope unit="page" from="120" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Assessing cache false sharing effects by dynamic binary instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stephan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josef</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Weidendorfer</surname></persName>
		</author>
		<idno type="DOI">10.1145/1791194.1791198</idno>
		<ptr target="https://doi.org/10.1145/1791194.1791198" />
	</analytic>
	<monogr>
		<title level="m">WBIA &apos;09: Proceedings of the Workshop on Binary Instrumentation and Applications</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="26" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Call Path Profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">J</forename><surname>Hall</surname></persName>
		</author>
		<idno type="DOI">10.1145/143062.143147</idno>
		<ptr target="https://doi.org/10.1145/143062.143147" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th International Conference on Software Engineering (ICSE &apos;92)</title>
		<meeting>the 14th International Conference on Software Engineering (ICSE &apos;92)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="296" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Bursty tracing: A framework for low overhead temporal profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hirzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chilimbi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Workshop on Feedback-Directed and Dynamic Optimization</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="117" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Intel Microarchitecture Codename Nehalem Performance Monitoring Unit Programming Guide</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://software.intel.com/sites/default/files/m/5/2/c/f/1/30320-Nehalem-PMU-Programming-Guide-Core.pdf." />
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Intel</surname></persName>
		</author>
		<ptr target="https://software.intel.com/en-us/intel-mkl." />
		<title level="m">Intel Math Kernel Library (MKL)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yangqing</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evan</forename><surname>Shelhamer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Donahue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergey</forename><surname>Karayev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Long</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ross</forename><surname>Girshick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sergio</forename><surname>Guadarrama</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Darrell</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1408.5093</idno>
		<title level="m">Convolutional Architecture for Fast Feature Embedding</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">DRDDR: A Lightweight Method to Detect Data Races in Linux Kernel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunyun</forename><surname>Jiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tian</forename><surname>Xiao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tianwei</forename><surname>Sheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenguang</forename><surname>Chen</surname></persName>
		</author>
		<idno type="DOI">10.1007/s11227-016-1691-1</idno>
		<ptr target="https://doi.org/10.1007/s11227-016-1691-1" />
	</analytic>
	<monogr>
		<title level="j">The Journal of Supercomputing</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="1645" to="1659" />
			<date type="published" when="2016-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Understanding and Detecting Real-world Performance Bugs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoliang</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linhai</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaoming</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joel</forename><surname>Scherpelz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2254064.2254075</idno>
		<ptr target="https://doi.org/10.1145/2254064.2254075" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;12)</title>
		<meeting>the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;12)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="77" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Some Requirements for Architectural Support of Software Debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johnson</forename></persName>
		</author>
		<idno type="DOI">10.1145/800050.801837</idno>
		<ptr target="https://doi.org/10.1145/800050.801837" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS I)</title>
		<meeting>the First International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS I)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982" />
			<biblScope unit="page" from="140" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Catch Me if You Can: Performance Bug Detection in the Wild</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milan</forename><surname>Jovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><surname>Adamoli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Hauswirth</surname></persName>
		</author>
		<idno type="DOI">10.1145/2048066.2048081</idno>
		<ptr target="https://doi.org/10.1145/2048066.2048081" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2011 ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;11)</title>
		<meeting>the 2011 ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA &apos;11)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="155" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Exploring Traditional and Emerging Parallel Programming Models using a Proxy Application</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><surname>Karlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhinav</forename><surname>Bhatele</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Keasler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bradford</forename><forename type="middle">L</forename><surname>Chamberlain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zachary</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Riyaz</forename><surname>Haque</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Laney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Luke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Felix</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Richards</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Still</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">27th IEEE International Parallel &amp; Distributed Processing Symposium</title>
		<meeting><address><addrLine>Boston, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient Tracing of Cold Code via Bias-free Sampling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Baris</forename><surname>Kasikci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Candea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Erickson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madanlal</forename><surname>Musuvathi</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2643634.2643660" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 USENIX Conference on USENIX Annual Technical Conference (USENIX ATC&apos;14). USENIX Association, Berkeley</title>
		<meeting>the 2014 USENIX Conference on USENIX Annual Technical Conference (USENIX ATC&apos;14). USENIX Association, Berkeley<address><addrLine>CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="243" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Finding Latent Performance Bugs in Systems Implementations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Killian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthik</forename><surname>Nagaraj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salman</forename><surname>Pervez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Braud</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">W</forename><surname>Anderson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ranjit</forename><surname>Jhala</surname></persName>
		</author>
		<idno type="DOI">10.1145/1882291.1882297</idno>
		<ptr target="https://doi.org/10.1145/1882291.1882297" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighteenth ACM SIG-SOFT International Symposium on Foundations of Software Engineering (FSE &apos;10)</title>
		<meeting>the Eighteenth ACM SIG-SOFT International Symposium on Foundations of Software Engineering (FSE &apos;10)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="17" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">On the Value Locality of Store Instructions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Lepak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 27th International Symposium on Computer Architecture</title>
		<meeting>27th International Symposium on Computer Architecture</meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="182" to="191" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Silent Stores for Free</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><forename type="middle">M</forename><surname>Lepak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mikko</forename><forename type="middle">H</forename><surname>Lipasti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 33rd Annual ACM/IEEE International Symposium on Microarchitecture</title>
		<meeting>the 33rd Annual ACM/IEEE International Symposium on Microarchitecture<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="22" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Performance Analysis Guide for Intel Core i7 Processor and Intel Xeon 5500 processors, Version 1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Levinthal</surname></persName>
		</author>
		<ptr target="https://software.intel.com/sites/products/collateral/hpc/vtune/performance_analysis_guide.pdf." />
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Linux</surname></persName>
		</author>
		<ptr target="https://linux.die.net/man/2/perf_event_open." />
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Linux</surname></persName>
		</author>
		<ptr target="https://perf.wiki.kernel.org/index.php/Main_Page." />
		<title level="m">Linux Perf Tool</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Exceeding the Dataflow Limit via Value Prediction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mikko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">Paul</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shen</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=243846.243889" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th Annual ACM/IEEE International Symposium on Microarchitecture (MICRO 29)</title>
		<meeting>the 29th Annual ACM/IEEE International Symposium on Microarchitecture (MICRO 29)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="226" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Value Locality and Load Value Prediction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Mikko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">B</forename><surname>Lipasti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">Paul</forename><surname>Wilkerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Shen</surname></persName>
		</author>
		<idno type="DOI">10.1145/237090.237173</idno>
		<ptr target="https://doi.org/10.1145/237090.237173" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS VII)</title>
		<meeting>the Seventh International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS VII)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="138" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">False Sharing Analysis for Multithreaded Programs. Master&apos;s thesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chien-Lung</forename><surname>Liu</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
		<respStmt>
			<orgName>National Chung Cheng University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Dou-bleTake: Fast and Precise Error Detection via Evidence-based Dynamic Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tongping</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charlie</forename><surname>Curtsinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
		<idno type="DOI">10.1145/2884781.2884784</idno>
		<ptr target="https://doi.org/10.1145/2884781.2884784" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th International Conference on Software Engineering (ICSE &apos;16)</title>
		<meeting>the 38th International Conference on Software Engineering (ICSE &apos;16)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="911" to="922" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Cheetah: Detecting False Sharing Efficiently and Effectively</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tongping</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2854038.2854039</idno>
		<ptr target="https://doi.org/10.1145/2854038.2854039" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 International Symposium on Code Generation and Optimization (CGO &apos;16)</title>
		<meeting>the 2016 International Symposium on Code Generation and Optimization (CGO &apos;16)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Predator: Predictive False Sharing Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tongping</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename><surname>Tian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hu</forename><surname>Ziang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emery</forename><forename type="middle">D</forename><surname>Berger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 19th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP&apos;14)</title>
		<meeting>19th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPOPP&apos;14)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Pinpointing data locality bottlenecks with low overhead</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<idno type="DOI">10.1109/ISPASS.2013.6557169</idno>
		<ptr target="https://doi.org/10.1109/ISPASS.2013.6557169" />
	</analytic>
	<monogr>
		<title level="m">2013 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="183" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Pin: Building Customized Program Analysis Tools with Dynamic Instrumentation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chi-Keung</forename><surname>Luk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Muth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harish</forename><surname>Patil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Artur</forename><surname>Klauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoff</forename><surname>Lowney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Wallace</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vijay</forename><forename type="middle">Janapa</forename><surname>Reddi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kim</forename><surname>Hazelwood</surname></persName>
		</author>
		<idno type="DOI">10.1145/1065010.1065034</idno>
		<ptr target="https://doi.org/10.1145/1065010.1065034" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;05)</title>
		<meeting>the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;05)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="190" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Pinpointing and Exploiting Opportunities for Enhancing Data Reuse</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gabriel</forename><surname>Marin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mellor-Crummey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Intl. Symposium on Performance Analysis of Systems and Software (ISPASS &apos;08)</title>
		<meeting><address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="115" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Guidelines for Creating a Debuggable Processor</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">E</forename><surname>Mclear</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Scheibelhut</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tammaru</surname></persName>
		</author>
		<idno type="DOI">10.1145/800050.801833</idno>
		<ptr target="https://doi.org/10.1145/800050.801833" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS I)</title>
		<meeting>the First International Symposium on Architectural Support for Programming Languages and Operating Systems (ASPLOS I)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1982" />
			<biblScope unit="page" from="100" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<monogr>
		<title level="m" type="main">Near-optimal RNA-Seq quantification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pall</forename><surname>Melsted</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harold</forename><surname>Pimentel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lior</forename><surname>Pachter</surname></persName>
		</author>
		<ptr target="https://github.com/makaho/kallisto." />
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title level="m" type="main">MPI-2: Extensions to the Message Passing Interface Standard. Message Passing Interface Forum</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
	<note>Message Passing Interface Forum</note>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Doppelganger: A Cache for Approximate Computing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>San Miguel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jorge</forename><surname>Albericio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th International Symposium on Microarchitecture (MICRO-48)</title>
		<meeting>the 48th International Symposium on Microarchitecture (MICRO-48)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="50" to="61" />
		</imprint>
	</monogr>
	<note>Andreas Moshovos, and Natalie Enright Jerger</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Load Value Approximation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshua</forename><surname>San Miguel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mario</forename><surname>Badr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natalie</forename><forename type="middle">Enright</forename><surname>Jerger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-47)</title>
		<meeting>the 47th Annual IEEE/ACM International Symposium on Microarchitecture (MICRO-47)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="127" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nersc</surname></persName>
		</author>
		<ptr target="http://www.nersc.gov/users/computational-systems/cori/nersc-8-procurement/trinity-nersc-8-rfp/nersc-8-trinity-benchmarks/" />
		<title level="m">NERSC-8 / Trinity Benchmarks</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Cachetor: Detecting Cacheable Data to Remove Bloat</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khanh</forename><surname>Nguyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoqing</forename><surname>Xu</surname></persName>
		</author>
		<idno type="DOI">10.1145/2491411.2491416</idno>
		<ptr target="https://doi.org/10.1145/2491411.2491416" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering</title>
		<meeting>the 2013 9th Joint Meeting on Foundations of Software Engineering<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="268" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Caramel: Detecting and Fixing Performance Problems that Have Nonintrusive Fixes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adrian</forename><surname>Nistor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Po-Chun</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cosmin</forename><surname>Radoi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2818754.2818863" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 37th International Conference on Software Engineering</title>
		<meeting>the 37th International Conference on Software Engineering<address><addrLine>Piscataway, NJ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2015" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="902" to="912" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Toddler: Detecting performance problems via similar memory-access patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Nistor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
		<idno type="DOI">10.1109/ICSE.2013.6606602</idno>
		<ptr target="https://doi.org/10.1109/ICSE.2013.6606602" />
	</analytic>
	<monogr>
		<title level="m">35th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="562" to="571" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Establishing a Base of Trust with Performance Counters for Enterprise Workloads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrzej</forename><surname>Nowak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmad</forename><surname>Yasin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Avi</forename><surname>Mendelson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willy</forename><surname>Zwaenepoel</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=2813767.2813808" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 USENIX Conference on Usenix Annual Technical Conference (USENIX ATC &apos;15). USENIX Association</title>
		<meeting>the 2015 USENIX Conference on Usenix Annual Technical Conference (USENIX ATC &apos;15). USENIX Association<address><addrLine>Berkeley, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="541" to="548" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<ptr target="http://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Rodinia" />
		<title level="m">Rodinia benchmark suite</title>
		<imprint>
			<publisher>Accelerating_Compute-Intensive_Applications_with_Accelerators</publisher>
			<date type="published" when="2015" />
		</imprint>
		<respStmt>
			<orgName>University of Virginia</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Scientific Application Performance on Leading Scalar and Vector Supercomputing Platforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonid</forename><surname>Oliker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Canning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Carter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Shalf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stéphane</forename><surname>Ethier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of High Performance Computing Applications</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Static Detection of Asymptotic Performance Bugs in Collection Traversals</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oswaldo</forename><surname>Olivo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isil</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Calvin</forename><surname>Lin</surname></persName>
		</author>
		<idno type="DOI">10.1145/2737924.2737966</idno>
		<ptr target="https://doi.org/10.1145/2737924.2737966" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;15)</title>
		<meeting>the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;15)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="369" to="378" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">OProfile development team</title>
		<ptr target="http://oprofile.sourceforge.net." />
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title/>
		<ptr target="http://www.oracle.com/technetwork/server-storage/solarisstudio/overview/index.html" />
	</analytic>
	<monogr>
		<title level="j">Oracle Solaris Studio</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Locating Cache Performance Bottlenecks Using Data Profiling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aleksey</forename><surname>Pesterev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nickolai</forename><surname>Zeldovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">T</forename><surname>Morris</surname></persName>
		</author>
		<idno type="DOI">10.1145/1755913.1755947</idno>
		<ptr target="https://doi.org/10.1145/1755913.1755947" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th European Conference on Computer Systems (EuroSys &apos;10)</title>
		<meeting>the 5th European Conference on Computer Systems (EuroSys &apos;10)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="335" to="348" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Global Value Numbers and Redundant Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">K</forename><surname>Rosen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">N</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">K</forename><surname>Zadeck</surname></persName>
		</author>
		<idno type="DOI">10.1145/73560.73562</idno>
		<ptr target="https://doi.org/10.1145/73560.73562" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</title>
		<meeting>the 15th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="12" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">Architecture-Level Power Optimization-What Are the Limits?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">S</forename><surname>Seng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dean</forename><forename type="middle">M</forename><surname>Tullsen</surname></persName>
		</author>
		<ptr target="http://www.jilp.org/vol7/v7paper4.pdf" />
	</analytic>
	<monogr>
		<title level="j">J. Instruction-Level Parallelism</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Managing Performance vs. Accuracy Tradeoffs with Loop Perforation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stelios</forename><surname>Sidiroglou-Douskos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sasa</forename><surname>Misailovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Hoffmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Rinard</surname></persName>
		</author>
		<idno type="DOI">10.1145/2025113.2025133</idno>
		<ptr target="https://doi.org/10.1145/2025113.2025133" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering (ESEC/FSE &apos;11)</title>
		<meeting>the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering (ESEC/FSE &apos;11)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="124" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">Software Performance Antipatterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Connie</forename><forename type="middle">U</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Lloyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
		<idno type="DOI">10.1145/350391.350420</idno>
		<ptr target="https://doi.org/10.1145/350391.350420" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2Nd International Workshop on Software and Performance (WOSP &apos;00)</title>
		<meeting>the 2Nd International Workshop on Software and Performance (WOSP &apos;00)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="127" to="136" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Performance Diagnosis for Inefficient Loops</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 39th International Conference on Software Engineering (ICSE)</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<ptr target="http://www.spec.org/cpu2006" />
		<title level="m">SPEC Corporation. 2007. SPEC CPU2006 Benchmark Suite</title>
		<imprint>
			<date type="published" when="2007-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<monogr>
		<ptr target="https://www.spec.org/omp2012" />
		<title level="m">SPEC Corporation. 2015. SPEC OMP2012 Benchmark Suite</title>
		<imprint>
			<date type="published" when="2015-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<analytic>
		<title level="a" type="main">IBM POWER7 performance modeling, verification, and evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Srinivas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Sinharoy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Eickemeyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Raghavan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kunkel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Maron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Flemming</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Blanchard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Seshadri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">W</forename><surname>Kellington</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mericas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">E</forename><surname>Petruski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">R</forename><surname>Indukuru</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Reyes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM JRD</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="1" to="4" />
			<date type="published" when="2011-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<analytic>
		<title level="a" type="main">EntomoModel: Understanding and Avoiding Performance Anomaly Manifestations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stewart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Iyengar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yin</surname></persName>
		</author>
		<idno type="DOI">10.1109/MASCOTS.2010.10</idno>
		<ptr target="https://doi.org/10.1109/MASCOTS.2010.10" />
	</analytic>
	<monogr>
		<title level="m">2010 IEEE International Symposium on Modeling, Analysis and Simulation of Computer and Telecommunication Systems. 3-13</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<analytic>
		<title level="a" type="main">Binary Analysis for Measurement and Attribution of Program Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><forename type="middle">R</forename><surname>Tallent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">W</forename><surname>Fagan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 ACM PLDI</title>
		<meeting>the 2009 ACM PLDI<address><addrLine>NY, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="441" to="452" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<analytic>
		<title level="a" type="main">Analyzing Lock Contention in Multithreaded Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><forename type="middle">R</forename><surname>Tallent</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">M</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Allan</forename><surname>Porterfield</surname></persName>
		</author>
		<idno type="DOI">10.1145/1693453.1693489</idno>
		<ptr target="https://doi.org/10.1145/1693453.1693489" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>the 15th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="269" to="280" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">NWChem: A comprehensive and scalable opensource solution for large scale molecular simulations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Valiev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">J</forename><surname>Bylaska</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Govind</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kowalski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">P</forename><surname>Straatsma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">J J</forename><surname>Van Dam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nieplocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Apra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Windus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">A</forename><surname>De Jong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Physics Communications</title>
		<imprint>
			<biblScope unit="volume">181</biblScope>
			<biblScope unit="page" from="1477" to="1489" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<analytic>
		<title level="a" type="main">Random Sampling with a Reservoir</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jeffrey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Vitter</surname></persName>
		</author>
		<idno type="DOI">10.1145/3147.3165</idno>
		<ptr target="https://doi.org/10.1145/3147.3165" />
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Math. Softw</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="37" to="57" />
			<date type="published" when="1985-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Constant Propagation with Conditional Branches</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">Kenneth</forename><surname>Wegman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zadeck</surname></persName>
		</author>
		<idno type="DOI">10.1145/103135.103136</idno>
		<ptr target="https://doi.org/10.1145/103135.103136" />
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="181" to="210" />
			<date type="published" when="1991-04" />
		</imprint>
	</monogr>
	<note>TOPLAS)</note>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">RedSpy: Exploring Value Locality in Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shasha</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
		</author>
		<idno type="DOI">10.1145/3037697.3037729</idno>
		<ptr target="https://doi.org/10.1145/3037697.3037729" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)</title>
		<meeting>the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS &apos;17)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="47" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">Runtime Value Numbering: A Profiling Technique to Pinpoint Redundant Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shasha</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xu</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milind</forename><surname>Chabbi</surname></persName>
		</author>
		<idno type="DOI">10.1109/PACT.2015.29</idno>
		<ptr target="https://doi.org/10.1109/PACT.2015.29" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 International Conference on Parallel Architecture and Compilation (PACT) (PACT &apos;15)</title>
		<meeting>the 2015 International Conference on Parallel Architecture and Compilation (PACT) (PACT &apos;15)<address><addrLine>Washington, DC, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="254" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">Finding Low-utility Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guoqing</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Arnold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Atanas</forename><surname>Rountev</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edith</forename><surname>Schonberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gary</forename><surname>Sevitsky</surname></persName>
		</author>
		<idno type="DOI">10.1145/1806596.1806617</idno>
		<ptr target="https://doi.org/10.1145/1806596.1806617" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;10)</title>
		<meeting>the 31st ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI &apos;10)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="174" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Understanding Database Performance Inefficiencies in Real-world Web Applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cong</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junwen</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shan</forename><surname>Lu</surname></persName>
		</author>
		<idno type="DOI">10.1145/3132847.3132954</idno>
		<ptr target="https://doi.org/10.1145/3132847.3132954" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 ACM on Conference on Information and Knowledge Management (CIKM &apos;17)</title>
		<meeting>the 2017 ACM on Conference on Information and Knowledge Management (CIKM &apos;17)<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1299" to="1308" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<analytic>
		<title level="a" type="main">RFVP: Rollbackfree Value Prediction with Safe-to-approximate Loads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amir</forename><surname>Yazdanbakhsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gennady</forename><surname>Pekhimenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bradley</forename><surname>Thwaites</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hadi</forename><surname>Esmaeilzadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Onur</forename><surname>Mutlu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Todd C</forename><surname>Mowry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Architecture and Code Optimization (TACO)</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">62</biblScope>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
