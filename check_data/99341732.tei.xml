<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">BEAT: Asynchronous BFT Made Practical</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sisi</forename><surname>Duan</surname></persName>
							<email>sduan@umbc.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">UNC Chapel Hill</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
							<email>reiter@cs.unc.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">UNC Chapel Hill</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haibin</forename><surname>Zhang</surname></persName>
							<email>hbzhang@umbc.edu</email>
							<affiliation key="aff0">
								<orgName type="institution">UNC Chapel Hill</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">BEAT: Asynchronous BFT Made Practical</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1145/3243734.3243812</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>• Security and privacy → Systems security</term>
					<term>Distributed systems security</term>
					<term>• Computer systems organization → Reliability</term>
					<term>Availability</term>
					<term>Byzantine fault tolerance, BFT, asynchronous BFT, blockchain, robustness, threshold cryptography</term>
				</keywords>
			</textClass>
			<abstract>
				<p>We present BEAT, a set of practical Byzantine fault-tolerant (BFT) protocols for completely asynchronous environments. BEAT is flexible, versatile, and extensible, consisting of five asynchronous BFT protocols that are designed to meet different goals (e.g., different performance metrics, different application scenarios). Due to modularity in its design, features of these protocols can be mixed to achieve even more meaningful trade-offs between functionality and performance for various applications. Through a 92-instance, five-continent deployment of BEAT on Amazon EC2, we show that BEAT is efficient: roughly, all our BEAT instances significantly outperform, in terms of both latency and throughput, HoneyBad-gerBFT, the most efficient asynchronous BFT known.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>State machine replication (SMR) <ref type="bibr" target="#b63">[64,</ref><ref type="bibr" target="#b80">81]</ref> is a fundamental software approach to enabling highly available services in practical distributed systems and cloud computing platforms (e.g., Google's Chubby <ref type="bibr" target="#b19">[20]</ref> and Spanner <ref type="bibr" target="#b28">[29]</ref>, Apache ZooKeeper <ref type="bibr" target="#b52">[53]</ref>). Its Byzantine failure counterpart, Byzantine fault-tolerant SMR (BFT), has recently regained its prominence, as BFT has been regarded as the model for building permissioned blockchains where the distributed ledgers know each other's identities but may not trust one another. As an emerging technology transforming business models, there has been a large number of industry implementations of permissioned blockchains, including Hyperledger Fabric <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b86">87]</ref>, Hyperledger Iroha <ref type="bibr" target="#b55">[56]</ref>, R3 Corda <ref type="bibr" target="#b29">[30]</ref>, Tendermint <ref type="bibr">[88]</ref>, and many more. The Hyperledger umbrella <ref type="bibr" target="#b4">[5]</ref>, for instance, has become a global collaborative open-source project under the Linux Foundation, now with more than 250 members.</p><p>Asynchronous BFT protocols <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b69">70]</ref> are arguably the most appropriate solutions for building high-assurance and intrusiontolerant permissioned blockchains in wide-area (WAN) environments, as these asynchronous protocols are inherently more robust against timing and denial-of-service (DoS) attacks that can be mounted over an unprotected network such as the Internet. Asynchronous BFT ensures liveness of the protocol without depending on any timing assumptions, which is prudent when the network is controlled by an adversary. In contrast, partially synchronous BFT (e.g., PBFT <ref type="bibr" target="#b26">[27]</ref>) guarantees liveness only when the network becomes synchronous (i.e., satisfies timing assumptions). For instance, it was shown in <ref type="bibr" target="#b69">[70]</ref> that PBFT would achieve zero throughput against an adversarial asynchronous scheduler. Challenges and opportunities in adopting asynchronous permissioned blockchains. While a recent asynchronous BFT protocol, HoneyBadgerBFT <ref type="bibr" target="#b69">[70]</ref>, significantly improves prior asynchronous BFT protocols <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b20">21,</ref><ref type="bibr" target="#b22">23,</ref><ref type="bibr" target="#b69">70]</ref>, there are still significant pain points and challenges that prevent it from being used in practice. Meanwhile, there are also new opportunities for asynchronous BFT with the rise of blockchains. Performance (latency, throughput) issues. Compared to partially synchronous BFT protocols (e.g., PBFT <ref type="bibr" target="#b26">[27]</ref>), HoneyBadgerBFT has significantly higher latency and lower throughput, in part due to its use of expensive threshold cryptography (specifically, threshold encryption <ref type="bibr" target="#b9">[10]</ref> and threshold signatures <ref type="bibr" target="#b16">[17]</ref>). This is particularly visible in cases where each replica has limited computation power.</p><p>These limitations are further exacerbated by various engineering issues. For example, HoneyBadgerBFT was evaluated at only 80bit security and it will be even slower if implemented with nowstandard 128-bit security. Moreover, due to its use of an erasurecoding library zfec <ref type="bibr" target="#b91">[93]</ref>, HoneyBadgerBFT can only support Reed-Soloman codes (for which better alternatives exist) and at most 2 <ref type="bibr" target="#b7">8</ref> servers. No one-size-fits-all BFT. In partially synchronous environments, onesize-fits-all BFT protocols have been hard to achieve (as has been argued in various works, e.g., <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b58">59]</ref>). Indeed, a variety of partially synchronous BFT protocols <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b7">8,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b58">59]</ref> have been proposed to meet different needs. For instance, chain-based BFT protocols, such as Aliph-Chain <ref type="bibr" target="#b7">[8]</ref>, BChain <ref type="bibr" target="#b32">[33]</ref>, and Shuttle <ref type="bibr" target="#b88">[90]</ref>, favor throughput over latency. Q/U <ref type="bibr" target="#b0">[1]</ref> achieves fault-scalability that tolerates increasing numbers of faults without significantly decreasing performance. Zyzzyva <ref type="bibr" target="#b58">[59]</ref> and Aliph <ref type="bibr" target="#b7">[8]</ref> are hybrid protocols that have high performance in failure-free cases. Moreover, a large number of robust BFT protocols <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b27">28,</ref><ref type="bibr" target="#b89">91]</ref> aim to provide a trade-off between performance and liveness during attacks that affect the timing behavior of the network.</p><p>While robustness is natively achieved in asynchronous BFT, we still require different designs and trade-offs for different performance metrics. Unlike HoneyBadgerBFT, which was designed to optimize throughput only, BEAT aims to be flexible and versatile, providing protocol instances optimized for latency, throughput, bandwidth, or scalability (in terms of the number of servers). Append-only ledger vs. smart contracts. We advocate distinguishing two different classes of blockchain applications: append-only ledgers and on-chain smart contracts. The former corresponds to append-only, linearizable storage systems (hereinafter, BFT storage), and the latter corresponds to general SMR. While they share security requirements (agreement, total order of updates, liveness), general SMR requires each replica to maintain a copy of all service state to support contracts that operate on that state. In contrast, BFT storage may leverage erasure coding to reduce overall storage by allowing servers to keep only fragments. (See Sec. 3 for formal definitions.) Both of the applications are rather popular. Applications such as food safety <ref type="bibr" target="#b90">[92]</ref> and exchange of healthcare data <ref type="bibr" target="#b53">[54]</ref> are examples of append-only ledgers, while AI blockchain <ref type="bibr" target="#b85">[86]</ref> and financial payments <ref type="bibr" target="#b54">[55]</ref> fall into the category of requiring smart contracts. Internet of things (IoT) with blockchains may be of either type, depending on the applications: if one just uses blockchains to store and distribute IoT data to avoid the single point of failure that the clouds may have, then we just need the distributed ledger functionality; if one additionally uses blockchains to consume and analyze the data, then we will additionally need smart contracts.</p><p>BFT storage may be extended to support off-chain smart contracts run among clients (e.g., Hyperledger Fabric <ref type="bibr" target="#b6">[7]</ref>). While offchain smart contracts have many benefits (e.g., achieving some level of confidentiality, as argued in <ref type="bibr" target="#b6">[7]</ref>), they also have limitations: 1) they are less suited to running complex smart contract applications with power-and computation-restricted clients (e.g., IoT devices); 2) they require communication channels among clients; and 3) they do not support efficient cross-contract state update.</p><p>Some blockchain systems use BFT for building consensus ordering services (e.g., Hyperledger Fabric). We find that BFT storage may be used to model the consensus ordering service, and a more efficient BFT storage can lead to a more efficient ordering service.</p><p>When designing BEAT, we aimed to answer the following major question: Can we have asynchronous BFT storage that significantly outperforms asynchronous general SMR? Flexible read. Some applications benefit from flexible reading, i.e., reading just a portion of a data block as needed (instead of the whole block). For example, in a blockchain that stores video, a user may only want to read the first portion of the stored video. This can be challenging when we use erasure-coding as the underlying storage mechanism. BEAT aims to achieve flexible read with significantly reduced bandwidth. BEAT in a nutshell. We design, implement, and evaluate BEATa set of practical asynchronous BFT protocols that resolve the above challenges. First, BEAT leverages more secure and efficient cryptography support and more flexible and efficient erasure-coding support. Second, BEAT is flexible, versatile, and extensible; the BEAT family includes asynchronous BFT protocols that are designed to meet different needs. BEAT's design is modular, and it can be extended to provide many more meaningful trade-offs among functionality and performance. Third, BEAT is efficient. Roughly, all our BEAT instances significantly outperform, in terms of both latency and throughput, HoneyBadgerBFT.</p><p>The BEAT protocols. BEAT includes five BEAT instances (BEAT0-BEAT4). BEAT0, BEAT1, are BEAT2 are general SMR that can support both off-chain and on-chain smart contracts, while BEAT3 and BEAT4 are BFT storage that can support off-chain smart contracts only. We summarize the characteristics of the BEAT protocols in <ref type="table" target="#tab_1">Table 1</ref> as a series of improvements to HoneyBadgerBFT.</p><p>• BEAT0, our baseline protocol, incorporates a more secure and efficient threshold encryption <ref type="bibr" target="#b84">[85]</ref>, a direct instantiation of threshold coin-flipping <ref type="bibr" target="#b21">[22]</ref> (instead of using threshold signatures <ref type="bibr" target="#b16">[17]</ref>), and more flexible and efficient erasure-coding support. • BEAT1 additionally replaces an erasure-coded broadcast (AVID broadcast) <ref type="bibr" target="#b23">[24]</ref> used in HoneyBadgerBFT with a replicationbased broadcast (Bracha's broadcast <ref type="bibr" target="#b18">[19]</ref>). This helps reduce latency when there is low contention and the batch size is small. • BEAT2 opportunistically moves the encryption part of the threshold encryption to the client, further reducing latency. BEAT2 does so at the price of achieving a weaker liveness notion, but can be combined with anonymous communication networks to achieve full liveness. Asynchronous BFT with Tor networks has been demonstrated in HoneyBadgerBFT. BEAT2 additionally achieves causal order <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b78">79]</ref>, a rather useful property for many blockchain applications that process transactions in a "first come, first served" manner, such as stock trading and financial payments. • BEAT3 is a BFT storage system. While HoneyBadgerBFT, BEAT0, BEAT1, and BEAT2 use Byzantine reliable broadcast <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b23">24,</ref><ref type="bibr" target="#b66">67]</ref>, we find that replacing Byzantine reliable broadcast with a different and more efficient primitive -bandwidth-efficient asynchronous verifiable information dispersal (AVID-FP) <ref type="bibr" target="#b44">[45]</ref> (using fingerprinted cross-checksum) suffices to build a BFT storage. The bandwidth consumption in BEAT3 is information-theoretically optimal. To order transactions of size B, the communication complexity of BEAT3 is O(B), while the complexity for Hon-eyBadger and PBFT is O(nB) (where n is the total number of replicas). This improvement is significant, as it allows running BEAT in bandwidth-restricted environments, allows more aggressive batching, and significantly improves scalability. • BEAT4 further reduces read bandwidth. BEAT4 is particularly useful when it is common that clients frequently read only a fraction of stored transactions. We provide a generic framework to enable this optimization, and BEAT4 is a specific instantiation of the framework. Roughly, BEAT4 reduces the access overhead by 50% with around 10% additional storage overhead. To achieve this, we extend fingerprinted cross-checksums <ref type="bibr" target="#b44">[45]</ref> to handle partial read and to the case of pyramid codes <ref type="bibr" target="#b50">[51]</ref>, and we design a novel erasure-coded asynchronous verifiable information dispersal protocol with reduced read bandwidth (AVID-FP-Pyramid). Both techniques may be of independent interest. To our knowledge, all the erasure-coded systems against arbitrary failures in reliable distributed systems community <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b24">25,</ref><ref type="bibr" target="#b31">32,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b45">46]</ref>   systems using these codes work in synchronous environments only, and do not achieve any strong consistency goals even in the crash failure model (let alone Byzantine failures). It is our goal to blend these two disjoint communities and offer new insights to both, by designing novel Byzantine reliable broadcast and BFT protocols with reduced bandwidth. • BEAT's design is modular, and features of these protocols can be mixed to achieve even more meaningful trade-offs among functionalities, performance metrics, and concrete applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>The (subtle) differences between (BFT) SMR and (BFT) atomic registers. State machine replication <ref type="bibr" target="#b80">[81]</ref> is a general technique to provide a fault-tolerant services using a number of server replicas. It can support arbitrary operations, not just read and write. In SMR, the servers need to communicate with each other and run an interactive consensus protocol to keep the servers in the same state. Register specifications were introduced by Lamport in a series of papers <ref type="bibr" target="#b61">[62,</ref><ref type="bibr" target="#b64">65,</ref><ref type="bibr" target="#b65">66]</ref>, with atomic register as the strongest one. The notions of linearizability and wait-freedom for atomic registers were introduced by Herlihy and Wing <ref type="bibr" target="#b47">[48]</ref> and Herlihy <ref type="bibr" target="#b46">[47]</ref>, respectively. Atomic registers can only support reads and writes.</p><p>Atomic registers can be realized in asynchronous distributed systems with failures. However, state machine replication cannot be achieved in asynchronous environments <ref type="bibr" target="#b37">[38]</ref>, unless it uses randomization to circumvent this impossibility result. HoneyBadgerBFT and BEAT fall into this category.</p><p>BFT SMR is suitable for a number of permissioned blockchain applications (e.g., on-chain smart contracts), while atomic registers are more suitable to model data-centric and cloud storage applications. Comparison with erasure-coded Byzantine atomic registers. An active line of research studies erasure-coded Byzantine atomic registers, as erasure coding can be used to provide storage reduction and/or reduce bandwidth. Notable systems include Pasis <ref type="bibr" target="#b40">[41]</ref>, CT <ref type="bibr" target="#b24">[25]</ref>, M-PoWerStore <ref type="bibr" target="#b31">[32]</ref>, Loft <ref type="bibr" target="#b45">[46]</ref>, and AWE <ref type="bibr" target="#b5">[6]</ref>. These systems have rather different properties from BEAT storage (i.e., BEAT3 and BEAT4). Loft has the same communication complexity as BEAT storage, but it only achieves obstruction-freedom, vs. BEAT's (randomized) wait-freedom. AWE, Pasis, CT, and M-PoWerStore have larger communication complexity. Additionally, while AWE achieves waitfreedom, it relies on an architecture that separates storage from metadata and therefore may rely on more servers.</p><p>Erasure-code choice in BEAT4 (Or: Why pyramid codes?). As discussed in Section 1, an ingredient in BEAT is a novel adaptation of fingerprinted cross-checksums <ref type="bibr" target="#b44">[45]</ref> to accommodate pyramid codes. Pyramid codes and their derivatives have already been used in practice, although in a very different setting (data centers), and offer a significant performance boost <ref type="bibr" target="#b25">[26,</ref><ref type="bibr" target="#b50">51,</ref><ref type="bibr" target="#b51">52]</ref>. We leverage them here to reduce bandwidth costs for fragments that contain real data. Its close competitor, Xorbas codes <ref type="bibr" target="#b79">[80]</ref>, reduces bandwidth cost for both data and redundant fragments, though we do not leverage them here. We also do not choose the (more complex) derivatives of basic pyramid codes such as generalized pyramid codes <ref type="bibr" target="#b50">[51]</ref> and local reconstruction codes <ref type="bibr" target="#b51">[52]</ref> that offer maximal recoverability and improve the fault tolerance of basic pyramid codes. For our designed protocol, these codes offer even greater recoverability than we need and hence would be overkill. Weaver codes <ref type="bibr" target="#b42">[43]</ref>, HoVer codes <ref type="bibr" target="#b43">[44]</ref>, and Stepped Combination codes <ref type="bibr" target="#b41">[42]</ref> (belonging to LDPC codes) do not provide the bandwidth savings and flexibility that we need.</p><p>Another direction of research in code design is to read instead from more fragments (see <ref type="bibr" target="#b49">[50,</ref><ref type="bibr" target="#b57">58]</ref> and references therein), but less data from each. However, the bandwidth savings are only around 20%∼30%, much less than pyramid codes and its derivatives. In addition, these codes do not fit our setting where we assume a fixed number of servers may behave maliciously and we attempt to mask as many Byzantine servers as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SYSTEM AND THREAT MODEL</head><p>Timing assumptions. Distributed systems can be roughly divided into three categories according to their timing assumption: asynchronous, synchronous, or partially synchronous. An asynchronous system makes no timing assumptions on message processing or transmission delays. If there is a known bound on message processing delays and transmission delays, then the corresponding system is synchronous. The partial synchrony model <ref type="bibr" target="#b36">[37]</ref> lies in-between: messages are guaranteed to be delivered within a time bound, but the bound may be unknown to participants of the system.</p><p>In protocols for asynchronous systems, neither safety nor liveness can rely on timing assumptions. In contrast, a protocol built for a synchronous or partially synchronous system risks having its safety or liveness properties violated if the synchrony assumption on which it depends is violated. For this reason, protocols built for asynchronous systems are inherently more robust to timing and denial-of-service (DoS) attacks <ref type="bibr" target="#b69">[70,</ref><ref type="bibr" target="#b92">94]</ref>.</p><p>BFT SMR. We consider asynchronous Byzantine fault-tolerant state machine replication (BFT SMR) protocols, where f out of n replicas can fail arbitrarily (Byzantine failures) and a computationally bounded adversary can coordinate faulty replicas.</p><p>The replicas collectively implement the abstraction of a keyvalue store. A replica delivers operations, each submitted by some client. All operations must be deterministic functions of the keyvalue store contents. The client should be able to compute a final response to its submitted operation from the responses it receives from replicas. Correctness for a secure BFT SMR protocol is specified as follows. </p><formula xml:id="formula_0">m ′ 1 , m ′ 2 , • • • , m ′ s ′ , then m i = m ′ i for 1 ≤ i ≤ min(s, s ′ ). • Liveness:</formula><p>If an operation m is submitted to n− f correct replicas, then all correct replicas will eventually deliver m.</p><p>The liveness property has been referred to by other names, e.g., "fairness" in CKPS <ref type="bibr" target="#b20">[21]</ref> and SINTRA <ref type="bibr" target="#b22">[23]</ref>, and "censorship resilience" in HoneyBadgerBFT <ref type="bibr" target="#b69">[70]</ref>. We use them interchangeably.</p><p>We consider two types of BFT SMR services. BFT storage. A BFT storage service implements only read(key) and write(key, val) operations. The former should return to the client the current value for key in the key-value store, and the latter should update the value of key in the key-value store to val. General SMR. A general SMR service-which is our default concern, unless specified otherwise-supports operations that consist of arbitrary deterministic programs, or transactions, that operate on the key-value store.</p><p>To support operations that are arbitrary transactions, each replica will typically maintain the contents of the key-value store in its entirety. Then, total order and the determinism of transactions ensures that the key-value store contents remain synchronized at correct replicas (assuming they begin in the same state). BFT storage can be implemented in more space-efficient ways, e.g., with each replica storing only an erasure-coded fragment for the value of each key (e.g., <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b40">41,</ref><ref type="bibr" target="#b44">45,</ref><ref type="bibr" target="#b45">46]</ref>). Secure causal BFT protocols. One of the BEAT instances achieves causality, which we briefly recall as follows. Input causality prevents the faulty replicas from creating an operation derived from a correct client's but that is delivered (and so executed) before the operation from which it is derived. The problem of preserving input causality in BFT atomic broadcast protocols was first introduced by Reiter and Birman <ref type="bibr" target="#b78">[79]</ref>. The notion was later refined by Cachin et al. <ref type="bibr" target="#b20">[21]</ref> and recently generalized by Duan et al. <ref type="bibr" target="#b34">[35]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BUILDING BLOCKS</head><p>This section reviews the cryptographic and distributed systems building blocks for BEAT. Labeled threshold cryptosystems. We review robust labeled threshold cryptosystem (i.e., threshold encryption) <ref type="bibr" target="#b84">[85]</ref> where a public key is associated with the system and a decryption key is shared among all the servers. Syntactically, a (t, n) threshold encryption scheme ThreshEnc consists of the following algorithms.</p><p>A probabilistic key generation algorithm TGen takes as input a security parameter l, the number n of total servers, and threshold parameter t, and outputs (pk, vk, sk), where pk is the public key, vk is the verification key, and</p><formula xml:id="formula_1">sk = (sk 1 , • • • , sk n )</formula><p>is a list of private keys. A probabilistic encryption algorithm TEnc takes as input a public key pk, a message m, and a label lb, and outputs a ciphertext c. A probabilistic decryption share generation algorithm ShareDec takes as input a private key sk i , a ciphertext c, and a label lb, and outputs a decryption share σ . A deterministic share verification algorithm Vrf takes as input the verification key vk, a ciphertext c, a label lb, and a decryption share σ , and outputs b ∈ {0, 1}. A deterministic combining algorithm Comb takes as input the verification key vk, a ciphertext c, a label lb, a set of t decryption shares, and outputs a message m, or ⊥ (a distinguished symbol).</p><p>We require the threshold encryption scheme to be chosen ciphertext attack (CCA) secure against an adversary that controls up to t − 1 servers. We also require consistency of decryptions, i.e., no adversary that controls up to t − 1 servers can produce a ciphertext and two t-size sets of valid decryption shares (i.e., where Vrf returns b = 1 for each share) such that they yield different plaintexts.</p><p>For our purpose, we require a labeled threshold encryption scheme <ref type="bibr" target="#b84">[85]</ref>; threshold cryptosystems that do not support labels <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b17">18]</ref> are not suitable. Threshold PRF. We review threshold PRF (e.g., <ref type="bibr" target="#b21">[22]</ref>), where a public key is associated with the system and a PRF key is shared among all the servers. A (t, n) threshold PRF scheme for a function F consists of the following algorithms. A probabilistic key algorithm FGen takes as input a security parameter l, the number n of total servers, and threshold parameter t, and outputs (pk, vk, sk), where pk is the public key, vk is the verification key, and</p><formula xml:id="formula_2">sk = (sk 1 , • • • , sk n )</formula><p>is a list of private keys. A PRF share evaluation algorithm Eva takes a PRF input c, pk, and a private key sk i , and outputs a PRF share y i . A deterministic share verification algorithm Vrf takes as input the verification key vk, a PRF input c, and a PRF share y i , and outputs b ∈ {0, 1}. A deterministic combining algorithm FCom takes as input the verification key vk, x, and a set of t valid PRF shares, and outputs a PRF value y. <ref type="bibr" target="#b0">1</ref> We require the threshold PRF value to be unpredictable against an adversary that controls up to t − 1 servers. We also require the threshold PRF to be robust in the sense the combined PRF value for c is equal to F(c).</p><p>We can use a direct implementation of threshold PRF <ref type="bibr" target="#b21">[22]</ref> or can use build a threshold PRF using threshold signatures <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b82">83]</ref>. Erasure coding scheme. An (n, m) erasure coding scheme takes as input m data fragments and outputs n (n ≥ m) same-size coded fragments. This essentially captures the encode algorithm of an erasure code, but we (intentionally) leave the decode algorithm undefined.</p><p>An (n, m) erasure coding scheme is systematic if the n coded fragments contain the original m data fragments and д = n − m redundant fragments.</p><formula xml:id="formula_3">Let d i (i ∈ [1.</formula><p>.m]) denote the data fragments, and d i (i ∈ [m + 1..n]) denote the redundant fragments. We have</p><formula xml:id="formula_4">d i (i ∈ [1..n])</formula><p>to denote all the coded fragments.</p><p>Our syntactic description of threshold encryption and threshold PRF can be made more general and the algorithms are not necessarily non-interactive.</p><p>An (n, m) erasure coding scheme is maximum distance separable (MDS) <ref type="bibr" target="#b68">[69]</ref> if and only if all the data fragments can be recovered from any m-size subset of coded fragments.</p><p>A systematic (n, m) erasure coding scheme is linear if each redundant fragment</p><formula xml:id="formula_5">d i (i ∈ [m + 1..n])</formula><p>is a linear combination of the data fragments, i.e.,</p><formula xml:id="formula_6">d i = m j=1 b i j d j ,</formula><p>where b i j 's are coding coefficients. Basic pyramid codes. Huang et al. <ref type="bibr" target="#b50">[51]</ref> introduced (basic) pyramid codes to slightly trade space for access efficiency in erasure-coded storage systems. For practical parameters, the pyramid codes can reduce the access overhead by 50% with around 10% additional storage overhead, compared to MDS erasure codes.</p><p>Pyramid codes can be efficiently built from any (n, m) systematic and MDS code that tolerates arbitrary д = n − m erasures as defined above. Specifically, we divide the m data fragments into L equal-size 2 disjoint groups S l (l ∈ [1..L]), each of which contains m/L data fragments. Next, we keep д 1 out of д redundant fragments unchanged. These fragments are global redundant fragments. Then, for each group S l , we compute д 0 = д − д 1 group redundant fragments and add them to each group, where the j-th group redundant fragment, denoted d j,l , is a projection of the j-th redundant block d m+j in the original MDS code onto that group, i.e., d j,l is computed as d m+j except setting all the coding coefficients that do not correspond to S l to 0.</p><p>This yields an (m + д 0 L + д 1 , m) systematic and non-MDS code, which has m data fragments and д 0 L + д 1 redundant fragments, where each of group S l has д 0 group redundant fragments. It is important to note that new code is also linear.</p><p>We briefly describe two useful properties of the basic pyramid codes <ref type="bibr" target="#b50">[51]</ref>: (1) An (m + д 0 L + д 1 , m) pyramid code can tolerate arbitrary д = д 0 + д 1 erasures; (2) Each equal-size group S l is an (m/L + д 0 , m/L) MDS code. To decode a data fragment, first try from the group level. For each group S l , if the number of the unavailable fragments is less than д 0 , any unavailable fragments can be recovered. Otherwise, first recover all the unavailable fragments from the group level, and then move to global level. One may needs to compute the fragments in the original MDS code that correspond to group redundant fragments, and then uses the conventional decoding algorithm of an MDS code to recover unavailable fragments.  A central theorem in <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46]</ref> is that for an (n, m) systematic, MDS, and linear erasure coding scheme, no adversary A can produce two different sets of m fragments such that each fragment is consistent with fpcc for its index and they can be decoded into two different data blocks with non-negligible probability. Asynchronous verifiable information dispersal using fingerprinted cross-checksum. In an asynchronous verifiable information dispersal (AVID) protocol <ref type="bibr" target="#b23">[24]</ref>, a client disperses a block M to n servers (where at most f of them might be faulty). The clients can later retrieve the full block M through the servers. The verifiability of the protocol ensures that any two clients retrieve the same block.</p><formula xml:id="formula_7">d d 2 d 3 d 4 d 5 d 6 (9,6) MDS d 7-1 d 7 d 8 d 9 (10,6) Pyramid d 8 d 9 d 7-2 d d 2 d 3 d 4 d 5 d 6</formula><p>An (n, m)-asynchronous verifiable information dispersal scheme is a pair of protocols (disperse, retrieve) that satisfy the following with high probability:</p><p>• Termination: If a correct client initializes disperse(M), then all correct servers will eventually complete dispersal disperse(M). Cachin and Tessaro <ref type="bibr" target="#b23">[24]</ref> proposed an erasure-coded AVID, which we call AVID-CT, To broadcast a message M, the communication complexity of AVID-CT is O(n|M |).</p><p>AVID-FP <ref type="bibr" target="#b44">[45]</ref> is a bandwidth-efficient AVID using fingerprinted cross-checksum. In AVID-FP, given a block B to be dispersed, the dealer applies an (m, n) erasure coding scheme, where m ≥ f + 1 and n = m + 2f . Here f is the maximum number of Byzantine faulty servers that system can tolerate, and n is the total number of servers. Then it generates the corresponding fingerprinted crosschecksum for B with respect to the erasure coding scheme. Next, the client distributes the erasure-coded fragments and the same fingerprinted cross-checksum to the servers. Each server verifies the correctness of the fragment that it receives according to the fingerprinted cross-checksum and then, roughly speaking, leverages the (much smaller) fingerprinted cross-checksum in place of the fragment in the original AVID protocol. Different from AVID-CT, to disperse a message M, the communication complexity of AVID-FP is O(|M |). Byzantine reliable broadcast. Byzantine reliable broadcast (RBC), also known as the "Byzantine generals' problem," was first introduced by Lamport et al. <ref type="bibr" target="#b66">[67]</ref>. An asynchronous reliable broadcast protocol satisfies the following properties: Bracha's broadcast <ref type="bibr" target="#b18">[19]</ref>, one that assumes only authenticated channels, is a well-known implementation of Byzantine reliable broadcast. To broadcast a message M, its communication complexity is O(n 2 |M |). Cachin and Tessaro <ref type="bibr" target="#b23">[24]</ref> proposed both an erasurecoded AVID (AVID-CT, mentioned above) and an erasure-coded variant of Bracha's broadcast -AVID broadcast, which reduces the cost to O(n|M |) compared to that of Bracha's broadcast. Note that we explicitly distinguish among AVID-CT and AVID-FP (both of which are verifiable information dispersal protocols) and AVID broadcast (a RBC protocol).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">REVIEWING HONEYBADGERBFT</head><p>This section provides an overview of HoneyBadgerBFT and related primitives. We begin by introducing asynchronous common subset (ACS). Asynchronous common subset. HoneyBadgerBFT uses ACS <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b20">21]</ref>. Formally, an ACS protocol satisfies the following properties:</p><p>• Validity: If a correct server delivers a set V , then |V | ≥ n − f and V contains the inputs of at least n − 2f correct servers. • Agreement: If a correct server delivers a set V , then all correct servers deliver V . • Totality: If n− f correct servers submit an input, then all correct servers deliver an output.</p><p>ACS can trivially lead to asynchronous BFT: each server can propose a subset of transactions, and deliver the union of the transactions in the agreed-upon vector; sequence numbers can be then assigned to the agreed transactions using any predefined but fixed order.</p><p>HoneyBadgerBFT in a nutshell. HoneyBadgerBFT essentially follows Ben-Or et al. <ref type="bibr" target="#b13">[14]</ref>, which uses reliable broadcast (RBC) and asynchronous binary Byzantine agreement (ABA) to achieve ACS. HoneyBadgerBFT cherry-picks a bandwidth-efficient, erasurecoded RBC (AVID broadcast) <ref type="bibr" target="#b23">[24]</ref> and the most efficient ABA <ref type="bibr" target="#b71">[72]</ref> to realize ACS. Specifically, HoneyBadgerBFT uses Boldyreva's threshold signature <ref type="bibr" target="#b16">[17]</ref> to provide common coins for the randomized ABA protocol <ref type="bibr" target="#b71">[72]</ref>. HoneyBadgerBFT favors throughput over latency by aggressively batching client transactions. It was shown that HoneyBadgerBFT can outperform PBFT when the number of servers exceeds 16 in terms of throughput in WANs, primarily because HoneyBadgerBFT distributes the network load more evenly than PBFT <ref type="bibr" target="#b26">[27]</ref>. As illustrated in <ref type="figure">Figure 2</ref>, the HoneyBadgerBFT protocol is composed of two subprotocols/phases: RBC and ABA. In the RBC phase, each replica first proposes a set of transactions and uses reliable broadcast to disseminate its proposal to all other replicas. In the second phase, n concurrent ABA instances are used to agree on an n-bit vector b i for i ∈ [1..n], where b i indicates that if replica i's proposed transactions are included.</p><p>HoneyBadgerBFT proceeds in epochs. Let B be a batch size of client transactions. In each epoch, each replica will propose B/n transactions. Each epoch will commit Ω(B) transactions. To improve efficiency, HoneyBadgerBFT ensures that each replica proposes mostly disjoint sets of transactions. For this reason, it asks replicas to propose randomly selected transactions. To prevent adversary from censoring some particular transaction by excluding whichever replicas propose it, HoneyBadgerBFT requires replicas to use threshold encryption to encrypt transactions proposed to avoid censorship.</p><p>HoneyBadgerBFT contains four distributed algorithms: a threshold signature <ref type="bibr" target="#b16">[17]</ref> that provides common coins for ABA, an ABA protocol <ref type="bibr" target="#b71">[72]</ref> that has expected running time O(1) (completing within O(k) rounds with probability 1 − 2 −k ), a bandwidth-efficient reliable broadcast <ref type="bibr" target="#b23">[24]</ref>, and a threshold encryption <ref type="bibr" target="#b9">[10]</ref> to avoid censorship and achieve liveness.</p><p>Roughly, the reliable broadcast dominates the bandwidth and guides the selection of batch size. The threshold encryption scheme and the threshold signature scheme use expensive cryptographic operations, and they and the ABA dominate the latency of Honey-BadgerBFT.</p><p>While HoneyBadgerBFT is the most efficient asynchronous BFT protocol known, HoneyBadgerBFT favors throughput over other performance metrics (latency, bandwidth, scalability). For instance, HoneyBadgerBFT has rather high latency, which is particularly visible in local area networks (LANs) <ref type="bibr" target="#b87">[89]</ref>. This makes it difficult to work in latency-critical applications. Indeed, it is desirable to have asynchronous BFT protocols that are designed for different goals (different performance metrics, different application scenarios).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">BEAT0</head><p>This section describes BEAT0, our baseline protocol, that uses a set of generic techniques to improve HoneyBadgerBFT. Specifically, BEAT0 incorporates a more secure and efficient threshold encryption, a direct implementation of threshold coin flipping, and more flexible and efficient erasure-coding support. BEAT0 specification. Instead of using CPA/CCA-secure threshold encryption that does not support labels, BEAT0 leverages a CCAsecure, labeled threshold encryption <ref type="bibr" target="#b84">[85]</ref> to encrypt transactions while making the ciphertexts uniquely identifiable.</p><p>BEAT0 proceeds in epochs (i.e., rounds). Let r the current epoch number. Let n be the total number of replicas. Let ThreshEnc = (TGen, TEnc, ShareDec, Vrf, Comb) be a (f +1, n) labeled threshold encryption scheme. Let pk and vk be threshold encryption public key and verification key, respectively. Let sk i be the private key for replica i ∈ [1..n]. Let B be the batch size of BEAT0.</p><p>Each replica i ∈ [1..n] randomly selects a set T of transactions of size B/n. It then computes a labeled threshold encryption ciphertext (lb, c) $ ← TEnc pk (lb,T ) where lb = (r, i). Next, each replica submits the labeled ciphertexts to ACS as input. Each replica i, upon receiving some labeled threshold ciphertexts (r , j ′ , c) from some other replica j, does a sanity check to see if j = j ′ and if there is already a different triple for the same r and j before proceeding. Namely, each replica i only stores and processes one ciphertext from the same j and the same r , and will discard ciphertexts subsequently received for the same j and r .</p><p>After getting output from ACS, a replica i can run ShareDec to decrypt the ciphertexts using its secret key sk i , and broadcasts its decryption shares. When receiving f + 1 valid shares (that pass the verification of Vrf), a replica can use Comb to combine the transactions. Efficiently instantiating CCA secure labeled threshold encryption. We observe that much of the latency in HoneyBadgerBFT is due to usage of pairing-based cryptography, which is much slower than elliptic curve cryptography (cf. <ref type="bibr" target="#b70">[71]</ref>). We thus implement our threshold encryption using the TDH2 scheme by Shoup and Gennaro <ref type="bibr" target="#b84">[85]</ref> using the P-256 curve which provides standard 128-bit security. TDH2 is secure against chosen-ciphertext attacks, under the Decisional Diffie-Hellman (DDH) assumption in the random oracle model <ref type="bibr" target="#b12">[13]</ref>.</p><p>Jumping ahead, while we use a stronger and functionally more complex cryptographic scheme, our experiments show that doing so actually improves the latency of HoneyBadgerBFT greatly. Directly instantiating common coin protocol. Instead of using a threshold signature to derive the common coins as in HoneyBad-gerBFT and other multi-party computation protocols, we choose to directly use threshold coin flipping. Specifically, we use the scheme due to Cachin, Kursawe, and Shoup (CKS) <ref type="bibr" target="#b21">[22]</ref> and implement it again using the P-256 curve that provides 128 bits of security. The threshold PRF scheme is proven secure under the Computational Diffie-Hellman (CDH) assumption in the random oracle model. Enabling more efficient and more flexible erasure coding.</p><p>HoneyBadgerBFT uses an erasure-coding library zfec <ref type="bibr" target="#b91">[93]</ref> that supports Reed-Soloman codes only and supports at most 128 servers.</p><p>We integrate the C erasure coding library Jerasure 2.0 <ref type="bibr" target="#b72">[73]</ref> with our BEAT framework. This allows us to remove the restriction that HoneyBadgerBFT can only support at most 128 replicas, use more efficient erasure-coding schemes (e.g., Cauchy Reed-Soloman codes <ref type="bibr" target="#b74">[75]</ref>), and flexibly choose between erasure-coding scheme parameters to improve performance. Distributed key generation. Our threshold encryption and threshold PRF are discrete-log based, and BEAT0 and all subsequent BEAT instances allow efficient distributed key generation <ref type="bibr" target="#b38">[39,</ref><ref type="bibr" target="#b56">57]</ref>, which should be run during setup. The implementation of distributed key generation, however, is outside the scope of the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">BEAT1 AND BEAT2 -LATENCY OPTIMIZED</head><p>This section presents two latency-optimized protocols in BEAT: BEAT1 and BEAT2. BEAT1. Via a careful study of latency for each HoneyBadgerBFT subprotocol, we find that 1) most of latency comes from threshold encryption and threshold signatures, and 2) somewhat surprisingly, when the load is small and there is low contention, erasurecoded reliable broadcast (AVID broadcast) <ref type="bibr" target="#b23">[24]</ref> causes significant latency. To test the actual latency overhead incurred by erasure-coded broadcast, we implement a variant of HoneyBadgerBFT, HB-Bracha, which replaces erasure-coded broadcast with a popular, replicationbased reliable broadcast protocol -Bracha's broadcast <ref type="bibr" target="#b18">[19]</ref>. We find that when the client load is small, HB-Bracha outperforms HoneyBadgerBFT in terms of latency by 20%∼60%. This motivates us to devise BEAT1.</p><p>BEAT1 replaces the AVID broadcast protocol in BEAT0 with Bracha's broadcast. It turns out that when the load is small, BEAT1 is consistently faster than BEAT0, though the difference by percentage is not as significant as that between HB-Bracha and Honey-BadgerBFT. However, when the load becomes larger, BEAT1 has significantly higher throughput, just as the case between HB-Bracha and HoneyBadgerBFT. BEAT2. In BEAT0, our use of CCA-secure, labeled threshold encryption is at the server side, to prevent the adversary from choosing which servers' proposals to include. BEAT2 opportunistically moves the use of threshold encryption to the client side, while still using Bracha's broadcast as in BEAT1.</p><p>In BEAT2, when the ciphertexts are delivered, it is too late for the adversary to censor transactions. Thus, the adversary does not know what transactions to delay, and can only delay transactions from specific clients. BEAT2 can be combined with anonymous communication networks to achieve full liveness. BEAT2 additionally achieves causal order <ref type="bibr" target="#b20">[21,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b78">79]</ref>, which prevents the adversary from inserting derived transactions before the original, causally prior transactions. Causal order is a rather useful property for blockchain applications that process client transactions in a "first come, first served" manner, such as trading services, financial payments, and supply chain management.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">BEAT3 -BANDWIDTH OPTIMIZED BFT STORAGE</head><p>This section presents BEAT3, an asynchronous BFT storage system. BEAT3 significantly improves all performance metrics that we know of -latency (compared to HoneyBadgerBFT), bandwidth, storage overhead, throughput, and scalability. Deployment scenarios. Recall that the safety and liveness properties of BFT storage remain the same as those of general SMR, with the only exception that the state may not be replicated at each server (but instead may be erasure-coded). BEAT3 can be used for blockchain applications that need append-only ledgers, and specific blockchains where the consensus protocol serves as an ordering service, such as Hyperledger Fabric <ref type="bibr" target="#b6">[7,</ref><ref type="bibr" target="#b86">87]</ref>. BEAT3. BEAT3 achieves better performance by using a novel combination of a bandwidth-efficient information dispersal scheme (AVID-FP <ref type="bibr" target="#b44">[45]</ref>) and an ABA protocol <ref type="bibr" target="#b71">[72]</ref>. In comparison, Hon-eyBadgerBFT, BEAT0, BEAT1, and BEAT2 use a combination of reliable broadcast and an ABA protocol. AVID-FP has optimal bandwidth consumption which does not depend on the number of replicas. The bandwidth required to disperse a block M in AVID-FP is only O(|M |), while the bandwidth in AVID broadcast (used in HoneyBadgerBFT) is O(n|M |). Technically speaking, AVID-FP has a much smaller communication complexity than AVID-CT because replicas in AVID-FP agree upon a small constant-size fingerprinted cross-checksum instead of on the block itself (i.e., the bulk data).</p><p>Our basic idea is to replace AVID broadcast used in HoneyBad-gerBFT with an (n, m) AVID-FP protocol, where n = m + 2f and m ≥ f + 1. Accordingly, at the end of the AVID-FP protocol, each replica now stores some fingerprinted cross-checksum and the corresponding erasure-coded fragment. There is, however, a challenge to use the approach. In AVID-FP, a correct replica cannot reconstruct its fragment if it is not provided by the AVID-FP client who proposes some transaction (here, some other replica in our protocol). Namely, as mentioned by Hendricks et al. <ref type="bibr" target="#b44">[45]</ref>, even with a successful dispersal, only f + 1 correct replicas, instead of all correct replicas, may have the corresponding fragments. However, ABA expects all correct replicas to deliver the transaction during the broadcast/dispersal stage (to correctly proceed). Note that we cannot trivially ask replicas in AVID-FP to reconstruct their individual fragment or reconstruct the whole transaction, which would nullify the bandwidth benefit of using AVID-FP.</p><p>We observe that AVID-FP actually agrees on the fingerprinted cross-checksum of the transaction. It is good enough for us to proceed to the ABA protocol once each replica delivers the fingerprinted cross-checksum. The consequence for BEAT3 is just as in AVID-FP: at least f + 1 correct replicas have their fragments, and some correct replicas may not have their fragments. This causes no problem, as the data is retrievable using f + 1 = m correct fragments. Each replica just needs to send the client the fingerprinted cross-checksum and its fragment. The client can then reconstruct the transaction.</p><p>More formally, validity, agreement, and totality of the ACS using AVID-FP follow directly from the properties of asynchronous verifiable information dispersal, just as the case of using reliable broadcast. The only difference is that the ACS using AVID-FP now delivers a fingerprinted cross-checksum. We just need to prove that our ACS is functionally correct. This follows easily from correctness of asynchronous verifiable information dispersal: if a fingerprinted cross-checksum is delivered, then the corresponding data (i.e., transaction) is retrievable, and all clients are able to retrieve the data and the data was previously proposed by some server. Bandwidth comparison. To order transactions of size B, the communication complexity of BEAT1, BEAT2, and HB-Bracha is O(n 2 B), the complexity of HoneyBadgerBFT and BEAT0 is O(nB), while the communication complexity of BEAT3 is only O(B). This improvement is significant, as it allows running BEAT in bandwidthrestricted environments, allows more aggressive batching, and greatly improves scalability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">BEAT4 -FLEXIBLE READ</head><p>This section presents a general optimization for erasure-coded BEAT instances that significantly reduce read bandwidth. For many blockchain applications, particularly data-intensive ones, it is common for clients to read only a fraction of the data block. Additionally, for many applications using smart contracts, clients may be interested in seeing the first few key terms of a large contract instead of the lengthy, detailed, and explanatory terms.</p><p>Our technique relies on a novel erasure-coded reliable broadcast protocol, AVID-FP-Pyramid, that reduces read bandwidth. AVID-FP-Pyramid uses pyramid codes <ref type="bibr" target="#b50">[51]</ref>. As reviewed in Sec. <ref type="bibr" target="#b3">4</ref> We extend the central theorem used in <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46]</ref> to the case of pyramid codes and to the case for fragments. We derive the following new lemma. Lemma 9.1. For an (m +д 0 L +д 1 , m) fingerprinted cross-checksum fpcc, any probabilistic adversary A can produce with negligible probability a target data fragment index (resp., data fragment indexes) and two sets of fragments (that may have different sizes) such that each fragment is consistent with fpcc for its index and they can be decoded into two different data fragments for the target index (resp., different sets of fragments for the target indexes).</p><p>The target data fragment index(es) may be an index of one of data fragment, indexes of all data fragments, or any number of indexes in between. The two set of fragments that A provides can be of different sizes, and the decoding approaches for two sets may differ (may it be a group level or global level decoding).</p><p>The proof the lemma is an adaptation to the one due to Hendricks et al. <ref type="bibr" target="#b44">[45,</ref><ref type="bibr">Theorem 3.4]</ref>. In proving Theorem 3.4 <ref type="bibr" target="#b44">[45]</ref>, the key claim is that two different sets of m fragments for the same fragment indexes and the same consistent fingerprinted cross-checksum imply that at least one fragment from the two sets is different, which is the starting point of their proof. Following the same argument, we can show that the probability that two fragments with the same index are different is bounded by ϵ ′ + q • ϵ, where ϵ ′ is the advantage of attacking the hash function, q is the total number random oracle queries, and ϵ is the probability of the collisions in the fingerprinting function. The proof applies to any linear erasure-coding schemes, including pyramid codes. AVID-FP-Pyramid. Now we describe AVID-FP-Pyramid, an asynchronous verifiable information dispersal protocol that compared to AVID-FP, further reduces read bandwidth. Instead of using a conventional MDS erasure code, AVID-FP-Pyramid uses a pyramid code. In an MDS code, m valid fragments can be used to reconstruct the original block. In a pyramid code, we need in general m +д 0 (L − 1) valid fragments to reconstruct the block. Therefore, we have to make sure that in our new AVID protocol at least m+д 0 (L−1)+f servers receive consistent fragments, of which f servers might be faulty. Moreover, one needs to make sure that m</p><formula xml:id="formula_8">+ д 0 L + д 1 ≥ m + д 0 (L − 1) + 2f , i.e., f ≤ (д 0 + д 1 )/2</formula><p>, which ensures that the total number of replicas do not overflow.</p><p>Given a pyramid code (n, m) where n = m + д 0 L + д 1 that can tolerate arbitrary д = д 0 + д 1 erasures, we construct AVID-FP-Pyramid where f ≤ m and f ≤ (д 0 + д 1 )/2. Specifically, AVID-FP-Pyramid consists of a triple of protocols (disperse, retrieve, read) which are described as follows. Dispersal. To disperse a block B, a client applies the (n, m) pyramid code to generate n fragments {d i } n i=1 and the fingerprinted crosschecksum fpcc. The server then sends each server i its fragment d i and fpcc.</p><p>Upon receiving a disperse message, a server i verifies that the fragment d i is consistent with fpcc. Upon receiving m + д 0 (L − 1) + f echo messages with matching fingerprinted cross-checksum fpcc, a server sends a ready message containing fpcc to all servers.</p><p>If receiving f + 1 ready with matching fingerprinted crosschecksum fpcc, and if a server does not yet send a ready message, it sends a ready message to all other servers.</p><p>Upon receiving 2f + 1 ready messages with matching fpcc, it stores and delivers fpcc. Retrieval. The retrieval protocol is almost the same as that in AVID-FP, with only a parameter difference. To retrieve a block, a client retrieves a fragment and fingerprinted cross-checksum from each server, waiting for matching fingerprinted cross-checksums from f + 1 servers and consistent fragments from m + д 0 (L − 1) servers.</p><p>These fragments are then decoded and the resulting block is returned.</p><p>Read. To read a single fragment d i , one could choose one of the following two options. In the first option, which we term as the optimistic mode, a client requests from all servers the fingerprinted cross-checksum and only the target server i for the fragment. If it does not receive the fragment in time (set arbitrarily by the client), it queries the servers at the group level that contains the server i, and all servers in the local group should send their fragments. The client will repeat the procedure from the group level until it receives m + д 0 (L − 1) fragments with matching fpcc and then recovers the fragment. In the second, which we term as the balanced mode, a client directly queries all servers at the group level, expecting the fragments from these group level servers. Definition and security. While we could be more general, we provide a definition for AVID-FP-Pyramid that is specifically tailored for our purpose.</p><p>An (n, m)-asynchronous verifiable information dispersal scheme is a triple of protocols (disperse, retrieve, read) that satisfy the following with high probability:</p><p>• Termination: If a correct client initializes disperse(M) then all correct servers will eventually complete dispersal disperse(M). BEAT-FR. Replacing the AVID-FP protocol in BEAT3 with our AVID-FP-Pyramid protocol, we obtain a new BFT storage protocol -BEAT-FR which has reduced read bandwidth. Corollary 9.3. BEAT-FR is a BFT storage.</p><p>Instantiating BEAT-FR: BEAT4. BEAT-FR is a generic asynchronous BFT framework that reduces read bandwidth. BEAT4 is an instantiation to BEAT-FR for concrete parameters. In BEAT4, we set L = 2, m is even, and д 0 = 1, which allows us to tolerate one failure within the local group, and reduces the read bandwidth by 50%. In BEAT4, we have n = m + 2f + 1, m = f + 1, and n = 3m − 1. Note that the number of echo messages which a replica has to wait before it can send ready message in BEAT4 is m + f . Technique applicability. We comment that our technique presented in the section is general. While it is described for the setting of AVID-FP, it can be applied to all erasure-coded asynchronous verifiable information dispersal and erasure-coded reliable broadcast protocols, including AVID-CT <ref type="bibr" target="#b23">[24]</ref> and AVID broadcast <ref type="bibr" target="#b23">[24]</ref>.</p><p>Therefore, the technique can be used to improve both erasure-coded BFT storage (BEAT3) and general SMR (BEAT0).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">IMPLEMENTATION AND EVALUATION 10.1 Implementation</head><p>We utilize the HoneyBadgerBFT prototype as the baseline to implement six asynchronous BFT protocols, including five BEAT protocols (BEAT0 to BEAT4) and HB-Bracha. HB-Bracha is implemented to understand the latency overhead caused by erasure coding. HB-Bracha replaces the underlying erasure-coded reliable broadcast (AVID broadcast) with Bracha's Broadcast <ref type="bibr" target="#b18">[19]</ref>, with the rest of the components intact.</p><p>Each of the six protocols involves 6,000 to 8,000 lines of code in Python. The underlying erasure-coding schemes (Reed-Soloman codes and pyramid codes) and fingerprinted cross-checksum, however, are implemented in C. The design and implementation of BEAT is modular, and we have implemented the following building blocks for the protocols. Erasure coding support. HoneyBadgerBFT is 100% Python, and uses the zfec library to implement the Reed-Soloman code, an MDS erasure code. The zfec library, while popular in Python projects, suffers from both efficiency and usability issues: it supports only the traditional Reed-Soloman code implementation and supports only a word size (finite field size, a key tunable parameter in erasure coding for efficiency) of 8. Moreover, due to the usage of an erasure-coding library zfec <ref type="bibr" target="#b91">[93]</ref>, HoneyBadgerBFT supports at most 2 <ref type="bibr" target="#b7">8</ref> replicas.</p><p>In BEAT, we instead use Jerasure 2.0 <ref type="bibr" target="#b72">[73]</ref>, a C library for erasurecoding, to implement the underlying erasure-coding schemes (including Reed-Soloman codes and pyramid codes). Jerasure 2.0 supports a variety of other coding schemes (including Cauchy Reed-Soloman codes <ref type="bibr" target="#b74">[75]</ref>), and allows fine-grained parameter tuning. Fingerprinted cross-checksum. We observe that for efficiency reasons one cannot separate the implementation of fingerprinting functions from the underlying erasure-coding support. The only implementation of fingerprinting is due to Hendricks et al. <ref type="bibr" target="#b44">[45,</ref><ref type="bibr" target="#b45">46]</ref>. They implemented their own erasure coding scheme using Rabin's information dispersal scheme <ref type="bibr" target="#b76">[77]</ref> and the corresponding fingerprinted cross-checksum using Shoup's NTL <ref type="bibr" target="#b83">[84]</ref>. While their fingerprinted cross-checksum is efficient, the erasure coding scheme is rather slow.</p><p>In contrast, we use GF-Complete <ref type="bibr" target="#b73">[74]</ref>, the Jerasure's underlying Galois Field library using Intel SSID, to implement the fingerprinted cross-checksum primitive. Erasure coding schemes have three parameters n, m, and w, where n is the number of fragments (also the number of replicas), m is the number of data fragments (where m = f + 1 in our protocols), and w is the word size (the index size of the Galois Field GF(2 w )). It is required that n + m &lt; 2 w and therefore n &lt; 2 w . The word size w is typically set to be between 4 and 16 for efficiency, and indeed w = 32 is the largest value supported by Jerasure. However, for our applications, we need to use larger w = 64 or 128 for the security of fingerprinted cross-checksum. We therefore extend Jerasure to include these large w's.</p><p>The specific fingerprinting function we implemented is the evaluation fingerprinting <ref type="bibr" target="#b81">[82]</ref>. Currently, we apply Horner's rule to evaluate the polynomial directly, without leveraging faster lookup tables. While the implementation can be further improved, we find that the implementation can already improve all performance metrics significantly. We implement fingerprinted cross-checksum in C, with 3,500 lines of code.</p><p>Finally, we use Cython <ref type="bibr" target="#b10">[11]</ref> to wrap the C code in Python and support functions including Reed-Solomon codes, pyramid codes, matrix generation, coding padding, and fingerprinted cross-checksum. The implementation involves around 1,000 lines of code in Python. <ref type="bibr" target="#b2">3</ref> Threshold cryptography. We use the TDH2 scheme <ref type="bibr" target="#b84">[85]</ref> for CCA-secure labeled threshold encryption and the threshold PRF scheme <ref type="bibr" target="#b21">[22]</ref> for distributed coin flipping. We implement both schemes using the Charm <ref type="bibr" target="#b1">[2]</ref> Python library. We use NIST recommended P-256 curve to implement both schemes to provide standard 128-bit security.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10.2">Evaluation</head><p>Overview. We deploy and test our protocols on Amazon EC2 utilizing up to 92 nodes from ten different regions in five different continents. Each node is a general purposed t2.medium type with two virtual CPUs and 4GB memory. We evaluate our protocols in both LAN and WAN settings, where the LAN nodes are selected from the same Amazon EC2 region, and the WAN nodes are uniformly selected from different regions. We evaluate the protocols under different network sizes (number of replicas) and contention levels (batch sizes). For each experiment, we use f to represent the network size, where 3f + 1 nodes are launched in total for BEAT0 to BEAT3, HB-Bracha, and HoneyBadgerBFT (abbreviated as HB in the figures), and 3f + 2 nodes are used for BEAT4. We vary the batch size where nodes propose 1 to 20,000 transactions at a time. The consequence for throughput is significant: with the same bandwidth, BEAT3 and BEAT4 can process an order of magnitude more batched transactions, leading to significantly higher throughput. Our evaluation, however, does not set the bandwidth this way, but rather assumes the bandwidth is ample and assumes all protocols use the same batch size. The readers should be aware that BEAT3 and BEAT4 have much higher throughput if using a larger batch size. Latency. We first evaluate the latency in the LAN setting with f = 1, 2, 5, 10, and 15, respectively. We examine and compare the average latency under no contention where each node proposes a single transaction (with variable size) at a time and no concurrent requests are sent by the clients. In the LAN setting, network latency is relatively small, so the overhead is mainly caused by the protocols themselves. We report our result for f = 1, 2 in <ref type="figure" target="#fig_10">Figure 3</ref>.</p><p>When f = 1, BEAT0, BEAT1, BEAT2, and BEAT3 are around 2× faster than HoneyBadger, and when f becomes larger, they are even faster than HoneyBadger. When f = 1, BEAT4 is about as fast as PyECLib <ref type="bibr" target="#b75">[76]</ref> is popular python library for erasure-coding: it has a Python interface but implements C based library, Liberasurecode <ref type="bibr" target="#b60">[61]</ref>, which allows us to use existing erasure-coding library such as Jerasure <ref type="bibr" target="#b72">[73]</ref> and Intel(R) ISA-L. We choose not to use PyECLib, primarily because the underlying Liberasurecode has implemented data structures that are not necessary for our purpose. We therefore (have to) write our own wrapper for Jerasure and fingerprinted cross-checksum using Cython <ref type="bibr" target="#b10">[11]</ref>.  HoneyBadger. This is primarily because BEAT4 has one more node, and the added overhead for the underlying consensus protocols and threshold cryptography is particularly visible when f is small. As f increases, HoneyBadger is much slower than BEAT4. Meanwhile, the difference between BEAT3 and BEAT4 becomes smaller; when f is 15, we barely notice the difference between them (not shown).</p><p>The differences among BEAT0, BEAT1, and BEAT2 are rather small when the batch size is 1, but becomes much more visible when the batch size becomes larger. However, the difference between BEAT1 and BEAT2 is not as large as the difference between HoneyBadger and HB-Bracha. Meanwhile, when the batch size exceeds 1,000, BEAT0 becomes faster than BEAT1 (not shown).</p><p>We further assess the latency breakdown for HoneyBadgerBFT, BEAT0, BEAT1, and HB-Bracha in order to better understand why we have these results. As illustrated in <ref type="figure" target="#fig_11">Figure 4</ref>, we evaluate the time for encrypting transactions, consensus protocols, and decrypting and combining transactions. We find the encryption and decryption for BEAT0 and BEAT1 are about three times faster than those in HoneyBadger and HB-Bracha. In addition, BEAT0 and BEAT1 use threshold PRF to produce the common coins for the consensus, and the latency of the consensus is also reduced by about 50%. HB-Bracha also achieves lower latency than HoneyBadgerBFT due to the use of latency-optimized Bracha's broadcast. This also explains why BEAT1 has lower latency than BEAT0 when the batch size is small. Throughput. We evaluate the throughput of the protocols under different contention levels. We present the results in the LAN setting in <ref type="figure" target="#fig_13">Figure 5</ref>(a) and the the result in the WAN setting in <ref type="figure" target="#fig_13">Figure 5(b)</ref>. Both cases set f = 1. We also show latency vs. throughput in <ref type="figure" target="#fig_13">Figure 5</ref>(c).</p><p>We first notice that BEAT0 slightly outperforms HoneyBad-gerBFT in both settings. This is expected since BEAT0 employs optimized threshold cryptography. This also matches the result for the latency under no contention. In comparison, while BEAT1, BEAT2, and HB-Bracha are latency optimized, they do not outperform HoneyBadgerBFT in terms of throughput. We observe that in both the LAN setting and WAN setting, BEAT1, BEAT2, and HB-Bracha achieve higher throughput than HoneyBadgerBFT when the batch size is small. However, when batch size is higher than 5000, all the three protocols have 20% to 30% lower throughput than HoneyBadgerBFT. This is mainly because HB-Bracha consumes higher network bandwidth, which causes degradation when the batch size is large. This underscores the wisdom in designing HoneyBadgerBFT.</p><p>BEAT3 and BEAT4 outperform HoneyBadgerBFT consistently. They also outperform BEAT0, BEAT1, and BEAT2 consistently, though under low contention in the LAN setting, BEAT1 has larger throughput than the other protocols. These results also meet our expectation since BEAT3 and BEAT4 are bandwidth optimized. Again, we stress that we compare the performance of the protocols under the same batch size. BEAT3 and BEAT4 actually use much lower network bandwidth than the other protocols, and so for the same bandwidth budget, BEAT3 and BEAT4 (with more aggressive batching) will achieve much better throughput compared with other protocols. Scalability. We evaluate the scalability of BEAT0, BEAT3, and Hon-eyBadger by varying f from 1 to 30. We report our comparison between BEAT3 and HoneyBadger in <ref type="figure" target="#fig_13">Figure 5</ref>(d) (without BEAT0, for ease of illustration). We observe that the throughput for both protocols is in general higher when the number of replicas is smaller. Peak throughput for BEAT3 is reached in all the cases when the batch size is greater than 15,000. In the most extreme case for our experiment, where f = 30 and batch size is 20,000, the average latency is about 1.5 minutes. As we can see in the figure, BEAT3 outperforms HoneyBadgerBFT in all the cases. However, the difference between BEAT3 and HoneyBadgerBFT becomes smaller as the number of replicas grows. This is in part due to the fact that in large-scale networks, network latency may dominate the overhead of the protocol. BEAT0 has performance between BEAT3 and Hon-eyBadger, and again when f increases their difference becomes smaller.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">LESSONS LEARNED</head><p>We implemented six new protocols (BEAT instances and HB-Bracha). While many of these protocols use similar components, maintaining, deploying, and comparing different BEAT instances takes tremendous effort. While one of our goals is to make BEAT modular and extensible, in practice it is still challenging to develop all the variants of the protocols. This is in part because even for the same function (e.g., threshold encryption), different APIs need to maintained. In fact, changing a small function in a BEAT instance may need to touch a large number of related functions accordingly.</p><p>On the other hand, we find that perhaps surprisingly, it may be easier to develop and deploy asynchronous BFT than partially synchronous BFT, for at least two reasons. First, protocols assuming partial synchrony rely on view change subprotocols, which are very  difficult to implement well from our own experience and from the fact that a significant number of academic papers choose not to implement the view change protocols. Second, because of native robustness against timing and liveness attacks for asynchronous BFT, we simply do not need to take further measures to ensure robustness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">CONCLUSION</head><p>We describe the design and implementation of BEAT, a family of practical asynchronous BFT protocols that are efficient, flexible, versatile, and extensible. We deploy and evaluate the five BEAT protocols using 92 instances on Amazon EC2, and we show BEAT protocols are significantly more efficient than HoneyBadgerBFT, the most efficient asynchronous BFT known. We also develop new distributed system ingredients, including generalized fingerprinted cross-checksum and new asynchronous verifiable information dispersal, which might be of independent interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A CORRECTNESS PROOF</head><p>Proof of Theorem 9.2. Termination is simple, as in AVID-FP. If a correct server initiates disperse, the server erasures codes the transaction, and sends fragments and the fingerprinted cross-checksum to each server. As the server initiating disperse is correct, at least n − f ≥ m +д 0 (L − 1) + f correct servers receive disperse messages, and send echo messages to all servers. Each server will eventually receive m + д 0 (L − 1) + f echo messages, and then sends a ready message, if it has not done so. Each correct server will eventually receive at lest 2f + 1 ready messages, and will then store the fingerprinted cross-checksum and complete. Agreement follows exactly as in AVID-FP. If some correct server completes disperse(M), then the server must have received 2f + 1 ready messages and at least f + 1 ready messages much have come from correct servers. This means that all correct servers will eventually receive ready messages from these correct servers. As our protocol implements the amplification step as in all other Bracha's broadcast like broadcast, all correct servers will send ready messages, and all of them will eventually receive at least 2f + 1 ready messages. Agreement thus follows.</p><p>We first prove the first part of availability. In our protocol, if a correct server completes disperse, it must have received 2f +1 ready messages, and at least one correct server received m + д 0 (L − 1) + f echo messages. Therefore, at least m + д 0 (L − 1) correct servers stored consistent fragments. According to the property of pyramid codes, these fragments can be used to reconstruct the original block. Accordingly, if f + 1 correct servers complete disperse, any client that initiates retrieve will receive m +д 0 (L − 1) consistent fragments and f + 1 matching fingerprinted cross-checksums. The client can then decode the fragments to generate some block.</p><p>We now prove the second part of availability. Following an analogous line of the above argument, if a correct server completes disperse, at least m + д 0 (L − 1) correct servers stored consistent fragments. If f + 1 correct servers complete disperse, any client that initiates read(i) for i ∈ [1..m] will receive f + 1 matching fingerprinted cross-checksums. If the fragment i happens to be available or there is less than д 0 failures in the local group, the fragment will be available for the client. Otherwise, another round of interaction is needed, and the client will obtain m + д 0 (L − 1) consistent fragments and reconstruct the fragment needed.</p><p>We now prove correctness. We first claim that if some correct server delivers fpcc 1 and some correct server delivers fpcc 2 , then fpcc 1 = fpcc 2 . The proof is quite "standard" for a quorum based protocol: if fpcc 1 is delivered then m + д 0 (L − 1) + f servers echoed fpcc 1 , of which at least m +д 0 (L − 1) is correct. The same applied to fpcc 2 . As a correct server will only echo once, there are at least 2m + 2д 0 (L − 1) + f servers echoed, which is larger than the total server (note that L ≥ 2 and 2f ≤ (д 0 + д 1 )). This leads to a contradiction. Thus, any block decoded during retrieve or any fragment during read is consistent with the same fpcc. By Theorem 3.4 in <ref type="bibr" target="#b44">[45]</ref> and by Lemma 9.1, the probability that clients do not obtain the same block or fragment(s) is negligible.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>Agreement: If any correct replica delivers an operation m, then every correct replica delivers m. • Total order: If a correct replica has delivered m 1 , m 2 , • • • , m s and another correct replica has delivered</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>A basic (10,6) pyramid code from a (9,6) MDS code.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 1</head><label>1</label><figDesc>uses an example to describe pyramid codes and shows how they can reduce read bandwidth and system I/O. The example builds a<ref type="bibr" target="#b9">(10,</ref><ref type="bibr" target="#b5">6)</ref> pyramid code from a (9, 6) linear, MDS code. In While there is no need to require m divides L for pyramid codes, in practice one almost always uses equal-size sets. Typically, L can be set to 2. the (9, 6) MDS code, there are 6 data fragments and 3 redundant fragments. The redundant fragments (d 7 , d 8 , and d 9 ) are linear combinations of the data fragments. For instance, d 7 can be written asd 7 = 6 j=1 b 7j d j ,where b 7j 's are coding coefficients. We then divide the data fragments equally (setting L = 2), and compute one redundant fragment for each group: d 7−1 = available, one can just use 3 fragments (d 2 , d 3 , and d 7−1 ) to recover d 1 . If there is more than one failure in the local group, one would need to use the traditional MDS decoding algorithm to recover the faulty local fragment. One may need to compute the sum of d 7−1 and d 7−2 to recover d 7 if necessary. Fingerprinted cross-checksum. A fingerprinted cross-checksum [45] is data structure used by a server to verify that its fragment corresponds to a unique original data block. An (n, m) fingerprinted cross-checksum fpcc consists of an array fpcc.cc[ ] of n values and an array fpcc.fp[ ] of m values. The first array is a cross-checksum [40, 60] that contains the n hashes of the n coded fragments. The second array holds homomorphic fingerprints of data fragments that preserve the property of linear codes. Let h be a collision-resistant hash function and H be a hash function modeled as a random oracle. A homomorphic fingerprinting function fingerprint takes as input a random key and a data fragment and outputs a small field element. A fragment d is consistent with fpcc for index i ∈ [1..n], if fpcc.cc[i] = h(d) and fingerprint(r , d) = encode(fpcc.fp[1], • • • , fpcc.fp[m]), where r = H(fpcc.cc[1], • • • , fpcc.cc[n]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>• Agreement: If some correct server completes disperse(M), all correct servers eventually complete disperse(M). • Availability: If f + 1 correct servers complete disperse(M), a correct client can run retrieve( ) to eventually reconstruct some block M ′ . • Correctness: If f + 1 correct servers complete disperse(M), all correct clients that run retrieve( ) eventually retrieve the same block M ′ . If the client that initiated disperse(M) was correct, then M ′ = M.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>•</head><label></label><figDesc>Agreement: If two correct servers deliver two messages M and M ′ then M = M ′ . • Totality: If some correct server delivers a message M, all correct servers deliver M. • Validity: If a correct sender broadcasts a message M, all correct servers deliver M.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>3 Figure 2 :</head><label>32</label><figDesc>The HoneyBadgerBFT protocol.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>, a (m +д 0 L +д 1 , m) pyramid code can tolerate arbitrary д = д 0 +д 1 erasures. Let n = m +д 0 L+д 1 . We define for a (m +д 0 L+д 1 , m) pyramid code a tailored fingerprinted cross-checksum. Our (m +д 0 L +д 1 , m) fingerprinted cross-checksum fpcc consists of an array fpcc.cc[ ] that holds the hashes of all n coded fragments. The second array fpcc.fp[ ] still contains m values that are fingerprints of the first m data fragments, and because pyramid codes are linear, all the fingerprints of coded fragments can be derived by these m fingerprints, just as all the coded fragments can be derived by the original m fragments. We say a fragment d is consistent with fpcc for index i ∈ [1..n], if fpcc.cc[i] = h(d) and fingerprint(r , d)= encode (fpcc.fp[1], • • • , fpcc.fp[m]), where r = H(fpcc.cc[1], • • • , fpcc.cc[n]).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>(Concretely, server i checks if fpcc.cc[i] = h(d) and fingerprint(r , d)= encode (fpcc.fp[1], • • • , fpcc.fp[m]), where r = H(fpcc.cc[1], • • • , fpcc.cc[n]).) If this is true, the server stores the fragment and sends an echo message containing fpcc (and only fpcc) to all servers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>• Agreement: If some correct server completes disperse(M), all correct servers eventually complete disperse(M). • Availability: If f + 1 correct servers complete disperse(M), a correct client can run retrieve( ) to eventually reconstruct some block M ′ . Additionally, if f + 1 correct servers complete disperse(M), a correct client can run read(i) where i ∈ [1..m] to eventually obtain a fragment d i . • Correctness: If f + 1 correct servers complete disperse(M), all correct clients that run retrieve( ) eventually retrieve the same block M ′ . If the client that initiated disperse(M) was correct, then M ′ = M. Additionally, if f + 1 correct servers complete disperse(M), all correct clients that run read(i) for i ∈ [1..m] eventually obtain the same fragment d ′ i . If the client that initiated disperse(M) was correct, then d ′ i = d i , where d i is the i-th data fragment of M. Theorem 9.2. AVID-FP-Pyramid is an asynchronous verifiable information dispersal protocol as defined above.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Bandwidth. The protocols mentioned above have rather different communication complexity. To order transactions of size B, the communication complexity of BEAT1, BEAT2, and HB-Bracha is O(n 2 B), the communication complexity of HoneyBadgerBFT and BEAT0 is O(nB), while the communication complexity of BEAT3 is only O(B).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 3 :</head><label>3</label><figDesc>Latency of the protocols in the LAN setting under no contention.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 4 :</head><label>4</label><figDesc>Latency breakdown in the LAN setting with f = 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Throughput for f = 1 where the nodes are from the same Amazon EC2 Throughput for f = 1 where the nodes are from 4 Amazon EC2 regions in different continents. Latency vs. Throughput in the WAN setting with f = 1. Scalability of BEAT3 and HoneyBadgerBFT. Solid lines represent the BEAT3. Dashed lines with the same mark represent the result for HoneyBadgerBFT with the same number of replicas.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 5 :</head><label>5</label><figDesc>Performance of the protocols. (The pictures are best viewed in color.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1 :</head><label>1</label><figDesc>Characteristics of BEAT protocols.</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">j=1 b 7j d j and d 7−2 = 6 j=4 b 7j d j , respectively. Clearly, we have d 7−1 + d 7−2 = d 7 . They are local (group) redundant fragments, and d and d 9 are global redundant fragments. If the fragment d 1 is not</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENT</head><p>The authors are indebted to our shepherd Haibo Chen and the CCS reviewers for their helpful comments that greatly improve our paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Fault-scalable Byzantine fault-tolerant services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abd-El-Malek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wylie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Charm: a framework for rapidly prototyping cryptosystems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Akinyele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptographic Engineering</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="111" to="128" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
		<ptr target="https://aws.amazon.com/" />
	</analytic>
	<monogr>
		<title level="j">Amazon Web Services (AWS</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Prime: Byzantine replication under attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Amir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Coan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Kirsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Lane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE TDSC</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="564" to="577" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<ptr target="https://www.hyperledger.org/wp-content/uploads/2018/08/HL_Whitepaper_IntroductiontoHyperledger.pdf" />
		<title level="m">Hyperledger Whitepaper: An introduction to Hyperledger</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Erasure-coded Byzantine storage with separate metadata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Androulaki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dobre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vukolic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="76" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Hyperledger Fabric: a distributed operating system for permissioned blockchains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Androulaki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EuroSys</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P-L</forename><surname>Aublin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Knezevic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Quema</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vukolic</surname></persName>
		</author>
		<title level="m">The next 700 BFT protocols. TOCS</title>
		<imprint>
			<date type="published" when="2015-01" />
			<biblScope unit="volume">32</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">RBFT: Redundant Byzantine fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P-L</forename><surname>Aublin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mokhtar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Quema</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Simple and efficient threshold cryptosystem from the gap Diffie-Hellman group</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Baek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Zheng</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">GLOBECOM &apos;03</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="1491" to="1495" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Behnel</surname></persName>
		</author>
		<title level="m">The best of both worlds. Computing in Science &amp; Engineering</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="31" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Keying hash functions for message authentication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Canetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Random oracles are practical: A paradigm for designing efficient protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bellare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Rogaway</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CCS 93</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Asynchronous secure computations with optimal resilience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Ben-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Kelmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>PODC 94</note>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">DepSpace: A Byzantine faulttolerant coordination service</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bessani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Alchieri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Correia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Fraga</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">8</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">State machine replication for the masses with BFT-SMART</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bessani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sousa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Alchieri</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Efficient threshold signature, multisignature and blind signature schemes based on the gap-Diffie-Hellman-group signature scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Boldyreva</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Chosen ciphertext secure public key threshold encryption without random oracles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Boneh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Boyen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Halevi</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>CT-RSA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Asynchronous Byzantine agreement protocols. Information and Computation 75</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Bracha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="130" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The Chubby lock service for loosely-coupled distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OSDI</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Secure and efficient asynchronous broadcast protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Petzold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
	<note>extended abstract</note>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Random oracles in Constantinople: Practical asynchronous Byzantine agreement using cryptography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Kursawe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Cryptology</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="219" to="246" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Secure Intrusion-tolerant replication on the Internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Poritz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="167" to="176" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Asynchronous verifiable information dispersal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tessaro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Optimal resilience for erasure-coded Byzantine distributed storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cachin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tessaro</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="115" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Windows Azure Storage: A highly available cloud storage service with strong consistency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>ACM SOSP</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Practical Byzantine fault tolerance and proactive recovery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Castro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Liskov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="398" to="461" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Making Byzantine fault tolerant systems tolerate Byzantine faults</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Marchetti</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<title level="m" type="main">Google&apos;s globally-distributed database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Corbett</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>OSDI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Corda</surname></persName>
		</author>
		<ptr target="https://github.com/corda/corda" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">HQ replication: A hybrid quorum protocol for Byzantine fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cowling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">PoWerStore: Proofs of writing for efficient and robust storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Dobre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Karame</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Majuntke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Suri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vukolic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>ACM CCS</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">BChain: Byzantine replication with high throughput and embedded reconfiguration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Meling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Peisert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">OPODIS</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">hBFT: Speculative Byzantine fault tolerance with minimum cost</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sean</forename><surname>Sisi Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><surname>Peisert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Levitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transaction on Dependable and Secure Computing</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="58" to="70" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Secure causal atomic broadcast, revisited</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Practical state machine replication with confidentiality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SRDS</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Consensus in the presence of partial synchrony</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dwork</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="288" to="323" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Impossibility of distributed consensus with one faulty process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lynch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="374" to="382" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Secure distributed key generation for discrete-log based cryptosystems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Jarecki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Cryptology</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="51" to="83" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">Securely replicating authentication services. ICDCS</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Gong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
			<publisher>IEEE Computer Society</publisher>
			<biblScope unit="page" from="85" to="91" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<monogr>
		<title level="m" type="main">Efficient Byzantinetolerant erasure-coded storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Goodson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Wylie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="135" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Flat XOR-based erasure codes in storage systems: Constructions, efficient recovery, and tradeoffs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Greenan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Wylie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Mass Storage Systems and Technologies</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Weaver codes: Highly fault tolerant erasure codes for storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Hafner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">USENIX FAST</title>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title level="m" type="main">HoVer erasure codes for disk arrays</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Hafner</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>DSN</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Verifying distributed erasure-coded data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hendricks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="139" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<monogr>
		<title level="m" type="main">Low-overhead Byzantine faulttolerant storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hendricks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Wait-free synchronization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="124" to="149" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Linearizability: a correctness condition for concurrent objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="463" to="492" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Obstruction-free synchronization: Doubleended queues as an example</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Herlihy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Luchangco</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Moir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Distributed Computing Systems</title>
		<meeting>the 23rd International Conference on Distributed Computing Systems</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="522" to="529" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tang</surname></persName>
		</author>
		<title level="m">NCCloud: Applying network coding for the storage repair in a Cloud-of-Clouds. USENIX FAST</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Pyramid codes: Flexible schemes to trade space for access efficiency in reliable data storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Storage (TOS)</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
	<note>Earlier version in NCA</note>
</biblStruct>

<biblStruct xml:id="b51">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Simitci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Ogus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Calder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Gopalan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Yekhanin</surname></persName>
		</author>
		<title level="m">Erasure coding in Windows Azure Storage. USENIX ATC&apos;12</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">ZooKeeper: Wait-free coordination for Internet-scale systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Konar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Junqueira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">USENIX ATC</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<monogr>
		<title level="m" type="main">IBM Watson Health Announces Collaboration to Study the Use of Blockchain Technology for Secure Exchange of Healthcare Data</title>
		<ptr target="https://www-03.ibm.com/press/us/en/pressrelease/51394.wss" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">IBM Announces Major Blockchain Solution to Speed Global Payments</title>
		<ptr target="https://www-03.ibm.com/press/us/en/pressrelease/53290.wss" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Iroha</surname></persName>
		</author>
		<ptr target="https://github.com/hyperledger/iroha" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Distributed key generation in the wild</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kate</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Goldberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptology ePrint Archive</title>
		<imprint>
			<biblScope unit="volume">2012</biblScope>
			<biblScope unit="page">377</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<monogr>
		<title level="m" type="main">Rethinking erasure codes for cloud file systems: Minimizing I/O for recovery and degraded reads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Khan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Plank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Pierce</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Huang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>USENIX FAST</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<monogr>
		<title level="m" type="main">Zyzzyva: Speculative Byzantine fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kotla</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Alvisi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dahlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Clement</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wong</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">Distributed fingerprints and secure information dispersal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Krawczyk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th ACM Symposium on Principles of Distributed Computing</title>
		<meeting>the 12th ACM Symposium on Principles of Distributed Computing</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="207" to="218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Liberasurecode</surname></persName>
		</author>
		<ptr target="https://github.com/openstack/liberasurecode" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Concurrent reading and writing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">20</biblScope>
			<biblScope unit="page" from="806" to="811" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Time, clocks, and the ordering of events in a distributed system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="558" to="565" />
			<date type="published" when="1978-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">Using time instead of timeout for fault-tolerant distributed systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trans. Prog. Lang. and Systems</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="254" to="280" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">On interprocess communication. Part I: Basic formalism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="77" to="85" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">On interprocess communication. Part II: Algorithms. Distrib. Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="86" to="101" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">The Byzantine generals problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Lamport</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shostak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Pease</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="382" to="401" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">On the impact of replica placement to the reliability of distributed brick storage systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Lian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDCS</title>
		<imprint>
			<biblScope unit="page" from="187" to="196" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<monogr>
		<title level="m" type="main">The Theory of Error Correcting Codes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">J</forename><surname>Macwilliams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">J A</forename><surname>Sloane</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1977" />
			<publisher>Amsterdam</publisher>
			<pubPlace>North-Holland</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b69">
	<analytic>
		<title level="a" type="main">The honey badger of BFT protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Croman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM CCS</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b70">
	<monogr>
		<title level="m" type="main">Report on pairing-based cryptography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moody</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Peralta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Perlner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Regenscheid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Roginsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
		<respStmt>
			<orgName>Journal of Research of the National Institute of Standards and Technology</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b71">
	<monogr>
		<title level="m" type="main">Signature-free asynchronous Byzan</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mostefaoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Moumen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Raynal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b72">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Plank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Greenan</surname></persName>
		</author>
		<ptr target="http://jerasure.org/jerasure-2.0/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b73">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Plank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Greenan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Miller</surname></persName>
		</author>
		<ptr target="http://lab.jerasure.org/jerasure/gf-complete" />
		<title level="m">Screaming fast Galois field arithmetic using Intel SIMD instructions. FAST 2013</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b74">
	<analytic>
		<title level="a" type="main">Optimizing Cauchy Reed-Solomon codes for fault-tolerant network storage applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Plank</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NCA</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b75">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pyeclib</surname></persName>
		</author>
		<ptr target="https://pypi.python.org/pypi/PyECLib" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b76">
	<analytic>
		<title level="a" type="main">Efficient dispersal of information for security, load balancing, and fault tolerance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">O</forename><surname>Rabin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="335" to="348" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b77">
	<analytic>
		<title level="a" type="main">Polynomial codes over certain finite fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Solomon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Soc. Industrial Appl. Math</title>
		<imprint>
			<date type="published" when="1960" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b78">
	<analytic>
		<title level="a" type="main">How to securely replicate services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Birman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM TOPLAS</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="986" to="1009" />
			<date type="published" when="1994" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b79">
	<analytic>
		<title level="a" type="main">XORing elephants: novel erasure codes for big data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sathiamoorthy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal Proceedings of the VLDB Endowment</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="325" to="336" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b80">
	<analytic>
		<title level="a" type="main">Implementing fault-tolerant services using the state machine approach: A tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surveys</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="299" to="319" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b81">
	<monogr>
		<title level="m" type="main">On fast and provably secure message authentication based on universal hashing. CRYPTO &apos;96</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="313" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b82">
	<monogr>
		<title level="m" type="main">Practical threshold signatures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b83">
	<monogr>
		<title level="m" type="main">NTL: A library for doing number theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<ptr target="http://shoup.net/ntl" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b84">
	<monogr>
		<title level="m" type="main">Securing threshold cryptosystems against chosen ciphertext attack</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shoup</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gennaro</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">98</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b85">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Singularitynet</surname></persName>
		</author>
		<ptr target="https://singularitynet.io/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b86">
	<monogr>
		<title level="m" type="main">A Byzantine fault-tolerant ordering service for the Hyperledger Fabric blockchain platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sousa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Bessani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vukolic</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b87">
	<monogr>
		<title level="m" type="main">HoneyLedgerBFT: Enabling Byzantine fault tolerance for the Hyperledger platform</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Turki</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Salgado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Camacho</surname></persName>
		</author>
		<ptr target="https://www.semanticscholar.org/" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b88">
	<monogr>
		<title level="m" type="main">Byzantine chain replication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Schiper</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b89">
	<monogr>
		<title level="m" type="main">Spin one&apos;s wheels? Byzantine fault tolerance with a spinning primary</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">S</forename><surname>Veronese</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Correia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">N</forename><surname>Bessani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">C</forename><surname>Lung</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b90">
	<monogr>
		<title level="m" type="main">University Launch a Blockchain Food Safety Alliance in China</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Walmart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tsinghua</forename><surname>Com</surname></persName>
		</author>
		<ptr target="https://www-03.ibm.com/press/us/en/pressrelease/53487.wss" />
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b91">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wilcox-O'hearn</surname></persName>
		</author>
		<ptr target="https://pypi.python.org/pypi/zfec" />
		<imprint/>
	</monogr>
	<note>Zfec 1.5.2.</note>
</biblStruct>

<biblStruct xml:id="b92">
	<analytic>
		<title level="a" type="main">APSS: proactive secret sharing in asynchronous systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">B</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Renesse</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inf. Syst. Secur</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="259" to="286" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
