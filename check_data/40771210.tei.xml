<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DDSketch: A Fast and Fully-Mergeable Quantile Sketch with Relative-Error Guarantees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Masson</surname></persName>
							<email>charles.masson@datadoghq.com</email>
						</author>
						<title level="a" type="main">DDSketch: A Fast and Fully-Mergeable Quantile Sketch with Relative-Error Guarantees</title>
					</analytic>
					<monogr>
						<idno type="ISSN">2150-8097</idno>
					</monogr>
					<idno type="DOI">10.14778/3352063.3352135</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>statistics such as the mean and variance are easily maintained for large, distributed data streams, but order statistics (i.e., sample quantiles) can only be approximately summarized. There is extensive literature on maintaining quantile sketches where the emphasis has been on bounding the rank error of the sketch while using little memory. Unfortunately, rank error guarantees do not preclude arbitrarily large relative errors, and this often occurs in practice when the data is heavily skewed. Given the distributed nature of contemporary large-scale systems, another crucial property for quantile sketches is mergeablility, i.e., several combined sketches must be as accurate as a single sketch of the same data. We present the first fully-mergeable, relative-error quantile sketching algorithm with formal guarantees. The sketch is extremely fast and accurate, and is currently being used by Datadog at a wide-scale.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Computing has increasingly moved to a distributed, containerized, micro-service model. Some organizations run thousands of hosts, across several data centers, with each host running a dozen containers each, and these containers might only live for a couple hours <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b9">10]</ref>. Effectively being able to administer and operationalize such a large and disparate fleet of machines requires the ability to monitor, in near real-time, data streams coming from multiple, possibly transitory, sources <ref type="bibr" target="#b2">[3]</ref>.</p><p>The data streams that are being monitored can include application logs, IoT sensor readings <ref type="bibr" target="#b27">[28]</ref>, IP-network traffic information <ref type="bibr" target="#b8">[9]</ref>, financial data, distributed application traces <ref type="bibr" target="#b29">[30]</ref>, usage and performance metrics <ref type="bibr" target="#b0">[1]</ref>, along with a myriad of other measurements and events. The volume of monitoring data being transmitted to a central processing system (usually backed by a time-series database or <ref type="figure">Figure 1</ref>: A distributed web application, with each container sending metrics to the monitoring system. an event storage system) can be high enough that simply forwarding all this information can strain the capacities (network, memory, CPU) of the monitored resources. Ideally a monitoring system helps one discover and diagnose issues in distributed systems-not cause them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Figure 2:</head><p>The average latency of a web endpoint over time (dotted line) is closer to the 75th percentile than it is to the 50th (the two solid lines).</p><p>Our running example will be a web application backed by a distributed system, where the ability to answer any particular request might depend on several underlying services and databases <ref type="figure">(Figure 1)</ref>. The metric we monitor for our example will be the latency of the requests it handles. Every time a worker finishes handling a request, it will note how long it took. Simple summary statistics such as the overall mean and variance can be easily maintained. For instance, the workers can keep counts, sums, and sums of squares of the latency and send those values to the monitoring system (and reset those values) every second. The monitoring system will then be able to aggregate those values and derive metrics-being able to graph the average latency using 1 second intervals, but also rolling up the sums and counts to graph the average latency over much larger time periods using much larger intervals perfectly accurately.</p><p>Unfortunately, the latencies of web requests are usually extremely skewed-the median response time might be in the milliseconds whereas there could be a couple of outlying responses that take minutes ( <ref type="figure" target="#fig_0">Figure 3)</ref>. A simple average, while easy to monitor can be easily skewed by outlying values as can be seen in <ref type="figure">Figure 2</ref>.</p><p>As the average response time is not a particularly useful measure, we are instead interested in tracking quantiles such as the 50th and the 99th percentiles (we will also refer to these as the p50 and p99). The ability to compute quantiles over aggregated metrics has been recognized to be an essential feature of any monitoring system <ref type="bibr" target="#b15">[16]</ref>.</p><p>Quantiles are famously impossible to compute exactly without holding on to all the data <ref type="bibr" target="#b28">[29]</ref>. If one wanted to track the median request latency over time for a web application that is handling millions of requests a second, this would mean sending millions of data points to the monitoring service which could then calculate the median by sorting the data. If one wanted the median aggregated over longer time intervals the monitoring service would have to store all these data points and then calculate the median over the larger set of points.</p><p>Given how expensive calculating exact quantiles can be for both storage and network bandwidth, most monitoring systems will compress the data into sketches and compute approximate quantiles. More formally, given a multiset S of size n over R, the q-quantile item xq ∈ S is the item x whose rank R(x) in the sorted multiset S is 1 + q(n − 1) for 0 ≤ q ≤ 1, where the rank R(x) is the number of elements in S smaller than or equal to x. 1 Some special quantiles include x1, the maximum element of S, and the median x0.5.</p><p>This definition of quantile is also known as the lower quantile. Replacing the floor with a ceiling gives us what's known as the upper quantile.</p><p>There has been a long line of work on sketching data streams so that the rank accuracy is preserved, i.e., for any value v, the sketch provides an estimate rankR such that |R(v) − R(v)| ≤ n (see <ref type="bibr" target="#b26">[27]</ref> and <ref type="bibr" target="#b20">[21]</ref> for excellent surveys on much of this work as well as additional motivation for sketching quantiles).</p><p>Unfortunately, for data sets with heavy tails, rank-error guarantees can return values with large relative errors. Consider again the histogram of 2M request response times in <ref type="figure" target="#fig_0">Figure 3</ref>. If we have a quantile sketch with a rank accuracy of 0.005, and ask for the 99th percentile, we are guaranteed to get a value between the 98.5th and 99.5th percentile. In this case this is anywhere from 2 to 20 seconds, which from an end-user's perspective is the difference between an annoying delay and giving up on the request.</p><p>Given the inadequacy of rank accuracy for tracking the higher order quantiles for distributions with heavy tails, we turn instead to relative accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D</head><p>1.</p><p>xq is an α-accurate q-quantile if |xq−xq| ≤ αxq for a given q-quantile item xq ∈ S. We say that a data structure is an α-accurate (q0, q1)-sketch if it can output α-accurate q-quantiles for all q0 ≤ q ≤ q1.</p><p>To further illustrate the difference between rank accuracy and relative accuracy consider <ref type="figure" target="#fig_2">Figure 4</ref>. The graphs show the actual p50, p75, p90 and p99 values along with the quantile estimates from a sketch with 0.005 rank accuracy and a sketch with 0.01 relative accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Results</head><p>In Section 2 we describe our relative-error sketch, dubbed the Distributed Distribution Sketch (DDSketch), and we discuss different implementation strategies. In Section 3 we prove that the sketch can handle data that is as heavy-tailed as that which comes  from a distribution whose logarithm is subexponential with parameters (σ, b), which includes heavy-tailed distributions such as the log-normal and Pareto distributions. We show that for the Pareto distribution, the size of an α-accurate (o(1), 1)-sketch is:</p><formula xml:id="formula_0">O b log n/δ log((1 + α)/(1 − α))</formula><p>with probability 1 − δ. (Note that our results hold for data coming from any distribution without any independence assumptions as long as the tail of the empirical data is no larger than that for a Pareto distribution). In Section 4 we present our experimental results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related Work</head><p>Quantile sketching dates back to 1980 when Munro and Paterson <ref type="bibr" target="#b28">[29]</ref> demonstrated the first quantile sketching algorithm with formal guarantees. The best known rank-error quantile sketch is that of Greenwald and Khanna <ref type="bibr" target="#b19">[20]</ref> whose deterministic sketch (GK) provides rank accuracy using O((1/ ) log(n )) space.</p><p>In addition to accuracy and size, a desirable property of a sketch is mergeability <ref type="bibr" target="#b1">[2]</ref>. That is, several sketches of different data sets can be combined into a single sketch that can accurately answer quantile queries over the entire data set. Mergeability has increasingly become a necessary property as systems become more distributed. Equi-depth histograms <ref type="bibr" target="#b5">[6]</ref> are a good example of non-mergeable data set synopses as there is no way to accurately combine overlapping buckets. GK is only known to be "one-way" mergeable, that is the merging operation itself can not be distributed.</p><p>There is a line of work using randomness culminating in a rankerror quantile sketch that uses only O((1/ ) log log(1/δ)) space (where δ is the probability of failure) <ref type="bibr" target="#b24">[25]</ref> with full mergeability. However, all of the above solutions, deterministic or randomized, have high relative error for the larger quantiles on heavy-tailed data (in practice we have found it to be worse for the randomized algorithms).</p><p>The problems of having high relative errors on the larger quantiles has been addressed by a line of work that still uses rank error, but promises lower rank error on the quantiles further away from the median by biasing the data it keeps towards the higher (and lower) quantiles <ref type="bibr" target="#b6">[7]</ref>, <ref type="bibr" target="#b7">[8]</ref>, <ref type="bibr" target="#b16">[17]</ref>. The latter, dubbed t-digest, is notable as it is one of the quantile sketch implementations used by Elasticsearch <ref type="bibr" target="#b17">[18]</ref>. These sketches have much better accuracy (in rank) than uniform-rank-error sketches on percentiles like the p99.9, but they still have high relative error on heavy-tailed data sets. Like GK they are only one-way mergeable.</p><p>The only relative-error sketch in the literature to our knowledge is the HDR Histogram <ref type="bibr" target="#b30">[31]</ref> (and is the other quantile sketch implementation used by Elasticsearch). It has extremely fast insertion times (only requiring low-level binary operations), as the bucket sizes are optimized for insertion speed instead of size, and it is fully mergeable (though very slow). The main downside for HDR Histogram is that it can only handle a bounded (though very large) range that might not be suitable for certain data sets. It also has no published guarantees, though much of the analysis we present for DDSketch can be made to apply to a version of HDR Histogram that more closely resembles DDSketch with slightly worse guarantees.</p><p>A recent quantile sketch, called the Moments sketch <ref type="bibr" target="#b18">[19]</ref> takes an entirely different approach by estimating the moments of the underlying distribution. It has notably fast merging times and is fully mergeable. The guaranteed accuracy, however, is only for the average rank error˜ , unlike all the sketches above which have guarantees for the worst-case error (whether rank or relative). The associated size bound is O(1/˜ ). In practice, the sketch also has a bounded range as the moments quickly grow larger, and they will eventually cause floating point overflow errors.</p><p>We compare the performance of DDSketch to GK, HDR, and Moments in Section 4.</p><p>A related line of work exists in constructing histograms (see <ref type="bibr" target="#b5">[6]</ref> for a thorough survey). The accuracy of a histogram is measured using the distance between the actual values and the values of the buckets to which the original values are assigned. The task is to find the histogram with B buckets that minimizes the overall distance. Optimal algorithms <ref type="bibr" target="#b23">[24]</ref> use dynamic programming and are usually considered to be too costly, and thus approximation algorithms are often considered. The most popular distance in the literature is the squared L2 distance (such a histogram is called the v-optimal histogram), but relative-error approximation algorithms exist as well <ref type="bibr" target="#b22">[23]</ref>, <ref type="bibr" target="#b21">[22]</ref> (though these algorithms use Ω(n) space).</p><p>Note that while one can try to use these histograms to answer quantile queries, there are no guarantees on the error of any particular quantile query, as the only error guarantees are global and not for any individual item. Moreover, the error guarantees are always relative to an unknown optimal (for the number of buckets) solution, not an absolute error guarantee. There is also no straightforward way to merge histograms as the bucket boundaries are based on the data, which can be wildly different for each histogram.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">DDSKETCH</head><p>We will first describe the most basic version of our algorithm that will be able to give α-accurate q-quantiles for any 0 ≤ q ≤ 1. It is straightforward to insert items into this sketch as well as delete items and merge sketches. Then we will show how to modify the sketch so that it gives α-accurate q-quantiles for q0 ≤ q ≤ 1 with bounded size. Section 2.2 will go over various implementation options for the sketch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Sketch Details</head><p>Let γ := (1+α)/(1−α). The sketch works by dividing R&gt;0 into fixed buckets. We index our buckets by i ∈ Z, and each bucket Bi counts the number of values x that fall between:</p><formula xml:id="formula_1">γ i−1 &lt; x ≤ γ i .</formula><p>That is, given a value x we will assign it to the bucket indexed by log γ (x) :</p><formula xml:id="formula_2">Algorithm 1: Insert(x) Input: x ∈ R&gt;0 i ← log γ (x) ; Bi ← Bi + 1;</formula><p>Deletion works similarly. Since the bucket boundaries are independent of the data, any two sketches using the same value for γ can be merged by simply summing up the buckets that share an index.</p><p>A simple lemma shows that every value gets assigned to a bucket whose boundary values are enough to return a relative-error approximation to its value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L</head><p>2. For a given q-quantile item xq ∈ S and bucket index i = log γ (xq) , letxq = 2γ i /(γ + 1). Thenxq is an α-accurate q-quantile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P</head><p>. Note that by definition of γ:</p><formula xml:id="formula_3">α = 1 − 2 γ + 1 = 2γ γ + 1 − 1</formula><p>Moreover, γ i−1 &lt; xq ≤ γ i . So if xq ≥xq, then:</p><formula xml:id="formula_4">xq −xq xq = 1 −x q xq ≤ 1 −x q γ i = 1 − 2γ i γ i (γ + 1) = α</formula><p>Similarly if xq ≤xq, then:</p><formula xml:id="formula_5">xq − xq xq =x q xq − 1 &lt;x q γ i−1 − 1 = 2γ i γ i−1 (γ + 1) − 1 = α</formula><p>Combining both cases:</p><formula xml:id="formula_6">|xq −xq| ≤ αxq.</formula><p>To answer quantile queries, the sketch sums up the buckets until it finds the bucket containing the q-quantile value xq:</p><formula xml:id="formula_7">Algorithm 2: Quantile(q) Input: 0 ≤ q ≤ 1 i0 ← min({j : Bj &gt; 0}); count ← Bi 0 ; i ← i0; while count ≤ q(n − 1) do i ← min({j : Bj &gt; 0 ∧ j &gt; i}); count ← count + Bi; end while return 2γ i /(γ + 1);</formula><p>Given Lemma 2, the following Proposition easily follows: P</p><p>3. Given α &gt; 0 and 0 ≤ q ≤ 1, Quantile(q) return an α-accurate q-quantile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P</head><p>. Let's refer to the ordered elements of the multiset S as</p><formula xml:id="formula_8">x (1) ≤ • • • ≤ x (n)</formula><p>, so that by definition of the quantile, xq = x ( 1+q(n−1) ) . We will also write c(x) the number of elements in S that are less than or equal to x. Note that for any j, we always have c(x (j) ) ≥ j. Quantile(q) outputs 2γ i /(γ + 1) where i = min( j : c(γ j ) &gt; q(n − 1) ). Given Lemma 2, it is enough to prove that i = log γ x ( 1+q(n−1) ) .</p><p>Let k be the largest integer so that x (k) ≤ γ i . It is clear that x (k) is in the bucket of index i, so that i = log γ x (k) . By definition of k, k = c(x (k) ) and, because there is no element of S in the bucket of index i that is greater than x (k) , we also know that</p><formula xml:id="formula_9">c(x (k) ) = c(γ i ). Thus, k = c(x (k) ) = c(γ i ) &gt; q(n − 1) and, given that k is an integer, k ≥ 1 + q(n − 1) follows. Therefore, i = log γ x (k) ≥ log γ x ( 1+q(n−1) ) . By contradiction, if i &gt; log γ x ( 1+q(n−1) ) , then i − 1 ≥ log γ x ( 1+q(n−1) ) and γ i−1 ≥ x ( 1+q(n−1) )</formula><p>. As a consequence:</p><formula xml:id="formula_10">c(γ i−1 ) ≥ c(x ( 1+q(n−1) ) ) ≥ 1 + q(n − 1) &gt; q(n − 1),</formula><p>which violates the definition of i. Hence, i = log γ x ( 1+q(n−1) ) , and the result follows.</p><p>However buckets are stored in memory (e.g., as a dictionary that maps indices to bucket counters, or as a list of bucket counters for contiguous indices), the memory size of the sketch is at least linear in the number of non-empty buckets. Therefore, a down-side to the basic version of DDSketch is that for worst-case input, its size can grow as large as n, the number of elements inserted into it. A simple modification will allow us to guarantee logarithmic size bounds for non-degenerate input, and Section 3 will show that the modification will never affect the ability to answer q-quantile queries for any constant q.</p><p>The full version of DDSketch is a simple modification that addresses its unbounded growth by imposing a limit of m = f (n) on the number of buckets it keeps track of. It does so by collapsing the buckets for the smallest indices:</p><formula xml:id="formula_11">Algorithm 3: DDSketch-Insert(x) Input: x ∈ R&gt;0 i ← log γ (x) ; Bi ← Bi + 1; if |{j : Bj &gt; 0}| &gt; m then i0 ← min({j : Bj &gt; 0}); i1 ← min({j : Bj &gt; 0 ∧ j &gt; i0}); Bi 1 ← Bi 1 + Bi 0 ; Bi 0 ← 0; end if</formula><p>Given that our sketch has predefined bucket boundaries for a given γ, merging two sketches is straightforward. We just increase the counts of the buckets for one sketch by those of the other. This, however, might increase the size of the sketch beyond the limit of m = f (n), where n is now the number of elements in the resulting merged sketch. As with the insertion, we stay within the limit by collapsing the buckets with smallest indices:</p><formula xml:id="formula_12">Algorithm 4: DDSketch-Merge(S ) Input: DDSketch S foreach i : Bi &gt; 0 ∨ B i &gt; 0 do Bi ← Bi + B i ; end foreach while |{j : Bj &gt; 0}| &gt; m do i0 ← min({j : Bj &gt; 0}); i1 ← min({j : Bj &gt; 0 ∧ j &gt; i0}); Bi 1 ← Bi 1 + Bi 0 ; Bi 0 ← 0; end while</formula><p>We trade off the benefit of a bounded size with not being able to correctly answer q-quantile queries if xq belongs to a collapsed bucket. The next lemma shows a sufficient condition for a quantile q to be α-accurately answered by our algorithm: x1 ≤ xqγ m−1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P</head><p>. For any particular quantile q, xq will be α-accurate as long as it belongs to one of the m buckets kept by the sketch. Let's refer to that bucket index as iq, which holds values between γ iq −1 and γ iq . If the maximum bucket (that holds x1) has index i1 ≤ iq + m − 1, then the bucket iq has definitely not been collapsed. Thus, given that x1 ≤ xqγ m−1 , then γ i 1 −1 &lt; x1 ≤ xqγ m−1 ≤ γ iq γ m−1 , and i1 − 1 &lt; iq + m − 1, which is equivalent to i1 ≤ iq + m − 1 as these indices are integers.</p><p>We'll discuss the trade-offs between the accuracy α, the minimum accurate quantile q, the number of items n, and the size of the sketch m in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Implementation Details</head><p>Most systems often have built-in timeouts and a minimum granularity, so the values coming into a sketch usually have an effective minimum and maximum. Importantly, our sketch does not need to know what those values are beforehand.</p><p>It is straightforward to extend DDSketch to handle all of R by keeping a second sketch for negative numbers. The indices for the negative sketch need to be calculated on the absolute values, and collapses start from the highest indices.</p><p>Like most sketch implementations, it is useful to keep separate track of the minimum and maximum values. Given how buckets are defined for DDSketch, we also keep a special bucket for zero (and all values within floating-point error of zero when calculating the index, which involves computing the logarithm of the input value).</p><p>The size of the sketch can be set to grow by setting m = c log n, which will match the upper bounds discussed in Section 3, but in practice m is usually set to be a constant large enough to handle a wide range of values. As an example, for α = 0.01, a sketch of size 2048 can handle values from 80 microseconds to 1 year, and cover all quantiles.</p><p>If m is set to a constant, it often makes sense to preallocate the sketch buckets in memory and keep all the buckets between the minimum and maximum buckets (perhaps implemented as a ring buffer). If the sketch is allowed to grow with n, then the sketch can either grow with every order of magnitude of n, or one can implement the sketch in a sparse manner so that only buckets with values greater than 0 are kept (sacrificing speed for space efficiency).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">DISTRIBUTION BOUNDS</head><p>For most practical applications, e.g., tracking the latency of web requests to a particular endpoint, one cares about constant quantiles such as those around the median such as 0.25, 0.5, 0.75, or those towards the edge such as 0.9, 0.95, 0.99, 0.999. Thus by Proposition 4, we will focus on the necessary conditions for x1 ≤ xqγ m−1 or:</p><formula xml:id="formula_13">log(x1) − log(xq) log(γ) + 1 ≤ m.<label>(1)</label></formula><p>for q = Θ(1), though our results will apply for q = Ω(1/ √ n). (For simplicity, we will assume that qn is a whole number in this section.)</p><p>For any fixed γ and m, it is easy to come up with a data set S for which the condition does not hold, e.g., S = γ 1 , γ 2 , . . . , γ 2m . Given that distribution-free results are impossible, for our formal results, we will instead assume that our data is i.i.d. from a particular family of distributions, and then show how large the sketch would have to be for Equation 1 to hold. We are able to obtain good bounds for families of distributions as general as those whose logarithms are subexponential (e.g., Pareto distributions). While our bounds are obtained by assuming i.i.d., in practice, as long as the tail of the empirical distribution is no fatter than that of a Pareto, we do not need to assume anything about the data generating process at all.</p><p>We will bound the LHS of Equation 1 by showing that with probability greater than 1 − δ1 the sample quantile xq is greater than a quantile just below it. Then we will show that with probability greater than 1 − δ2, the sample maximum is less than some bound. Finally by the union bound we get that the probability that both bounds apply is greater than 1 − δ1 − δ2. In practice, the probability of failing these bounds is smaller as the sample maximum and sample quantiles become quickly independent as n grows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sample Quantiles</head><p>Let capital X1, . . . , Xn denote n independent real-valued random variables drawn from a distribution with cdf F :</p><formula xml:id="formula_14">R → [0, 1].</formula><p>The generalized inverse of F , F −1 (p) is known as the quantile function of F . Let X (1) ≤ X (2) ≤ • • • ≤ X (n) denote the order statistics of X1, . . . , Xn (i.e., the ordered random variables).</p><p>The next Lemma shows that with high probability a lower sample quantile can't fall too far below the actual quantile.</p><formula xml:id="formula_15">L 5. Let X (1) ≤ X (2) ≤ • • • ≤ X (n)</formula><p>be the order statistics for i.i.d. random variables Xi distributed according to F . Let t = log(1/δ1)/2n and t &lt; q ≤ 1/2, then</p><formula xml:id="formula_16">Pr X (qn) &gt; F −1 (q − t) ≥ 1 − δ1.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P</head><p>. The proof follows Chvátal's proof of a special case of the Hoeffding bound <ref type="bibr" target="#b4">[5]</ref>. For any single random variable X drawn from a distribution with cdf F , Pr[X ≤ F −1 (p)] = p. Then for any particular order statistic and any x ≥ 1:</p><formula xml:id="formula_17">Pr X (k) ≤ F −1 (p) = n i=k n i p i (1 − p) n−i ≤ n k n i p i (1 − p) n−i x i−k + k−1 0 n i p i (1 − p) n−i x i−k = x −k n 0 n i p i (1 − p) n−i x i = x −k (px + (1 − p)) n<label>(2)</label></formula><p>where the last equality is by the Binomial Theorem. Equation 2 is minimized when x = (1 − p)k/p(n − k), and taking k = qn, our bound becomes:</p><formula xml:id="formula_18">p(n − k) (1 − p)k k (1 − p)n n − k n = p q qn (1 − p) (1 − q) n(1−q)</formula><p>(3) Note that for x ≥ 1, p ≤ q ≤ 1/2, and that the bound is trivial when p = q. However, if we take p = q − t, we get:</p><formula xml:id="formula_19">(3) = exp −qn log q q − t − (1 − q) n log 1 − q 1 − q + t = exp −n q q−t q x − 1 − q 1 − x dx = exp −n q q−t q − x x(1 − x) dx ≤ exp −4n q q−t (q − x)dx = exp −2nt 2 = δ1</formula><p>for t = log(1/δ1)/2n, and where the last inequality uses the fact that x(1 − x) ≤ 1/4 for all x ∈ R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Sample Maximums</head><p>We will first bound the sample maximum for subexponential distributions, which include the Gaussian, logistic, chi-squared, exponential, and many others. D 6. A random variable X ∈ R is said to be subexponential with parameters (σ, b) if</p><formula xml:id="formula_20">E [exp (λ(X − EX))] ≤ exp σ 2 λ 2 /2 , for 0 ≤ λ ≤ 1/b.</formula><p>Using Chernoff-type techniques, one can obtain concentration inequalities for subexponential variables <ref type="bibr" target="#b3">[4]</ref>. <ref type="bibr">T</ref> 7. Let X be a subexponential random variable with parameters (σ, b). Then,</p><formula xml:id="formula_21">Pr [X − EX ≥ t] ≤ exp −t 2 /2σ 2 for 0 ≤ t ≤ σ 2 /b, and</formula><formula xml:id="formula_22">Pr [X − EX ≥ t] ≤ exp (−t/2b) for t &gt; σ 2 /b.</formula><p>Now we can lower-bound the sample maximum by the complement of the event that none of the sample is greater than t.</p><formula xml:id="formula_23">C 8. Let X (1) ≤ X (2) ≤ • • • ≤ X (n)</formula><p>be the order statistics for i.i.d. subexponential random variables Xi with parameters (σ, b), and t = 2b log(n/δ2). Then the sample maximum is less than t with probability at least − δ2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P . By Theorem 7,</head><p>Pr</p><formula xml:id="formula_24">X (n) − EX &gt; t &lt; 1 − 1 − e −t/2b n = 1 − 1 − δ2 n n &lt; δ2,</formula><p>where the final inequality is by Bernoulli's inequality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Sketch Size Bounds</head><p>For subexponential distributions, we can bound Equation 1 by combining Lemma 5 and Corollary 8:</p><formula xml:id="formula_25">T 9. Let X (1) ≤ X (2) ≤ • • • ≤ X<label>(</label></formula><p>n) be the order statistics for i.i.d. random variables Xi distributed according to a subexponential distribution F with parameters (σ, b). Then with probability at least 1 − δ1 − δ2, DDSketch is an α-accurate (q, 1)sketch with size at most (log X (n) − log X (qn) )/ log(γ) + 1, which is bounded from above by:</p><formula xml:id="formula_26">log (2b log (n/δ2) + EX) − log F −1 (q − t) log(γ) + 1</formula><p>for γ = (1 + α)/(1 − α), t = log(1/δ1)/2n, and t &lt; q ≤ 1/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Exponential.</head><p>For concreteness, let's take δ1 = δ2 = e −10 and α = 0.01 (i.e., γ ≈ 1.02), and let's consider the exponential distribution with cdf F (t; λ) = 1 − exp(−λt) for t ≥ 0, and 0 otherwise. The exponential distribution is subexponential with parameters (2/λ, 2/λ).</p><p>If n &gt; 320, then p &gt; 3/8, and the sample median is at least F −1 (p) &gt; −λ −1 log(1−3/8) &gt; 0.47/λ. The sample maximum <ref type="bibr" target="#b1">2</ref> is at most 4λ −1 (log(n) + 10 + 1/4), and 1/ log(γ) &lt; 51 so we can bound the size from Theorem 9 by: 51(log(4 log n + 41) − log(0.47)) + 1.</p><p>This means that even with a sketch of size 273 one can 0.01accurately maintain the upper half order statistics of over a million <ref type="bibr" target="#b1">2</ref> The factor of 4 can be removed from the bound for the sample maximum if we analyze the exponential distribution directly instead of using the generic bounds for subexponential distributions. samples with probability greater than 0.99991. This grows doubleexponentially, so a sketch of size 1000 can 0.01-accurately maintain the upper half order statistics of over exp(exp <ref type="bibr" target="#b16">(17)</ref>) values with that same probability.</p><p>Pareto. The double logarithm in our size bound from Theorem 9 allows us to handle distributions with much fatter tails as well. The Pareto distribution distribution has cdf F (t; a, b) = 1 − (b/t) a . If X is a random variable drawn from this distribution, then Y = log(X/b) ∼ Exp(a). Thus, we can reuse the arguments above to get that with probability at least 1 − δ1 − δ2:</p><formula xml:id="formula_27">log(X (n) ) &lt; 4a −1 log(n/δ2) + a −1 + log(b) and log(X (n/2) ) &gt; −a −1 log(1/2 + log(1/δ1)/2n) + log(b).</formula><p>As before, let's take δ1 = δ2 = e −10 , α = 0.01, and assume that n &gt; 320. With probability greater than 1 − e −10 − e −10 ≈ 0.99991:</p><formula xml:id="formula_28">log(X (n) ) − log(X (n/2) ) log(γ) + 1 &lt; 51a −1 (4 log n + 11) + 1</formula><p>Given that Pareto distributions have exponentially fatter tails than exponential distributions, the sketch size upper bounds increase accordingly. Taking a = 1, this means that we require a sketch of size 3380 to 0.01-accurately maintain the upper half order statistics of over a million samples with probability greater than 0.99991. A sketch of size 10000, can 0.01-accurately maintain the upper half order statistics of over exp(46) values with that same probability.</p><p>Other Distributions. We focused on subexponential tails and the Pareto distribution in this section as we believe it to best represent the worst case for practical use-cases of quantile sketching. For lighter tails such as subgaussians and thus for lognormal distributions, we can of course get much tighter bounds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">EVALUATION</head><p>We provide implementations of DDSketch in Java <ref type="bibr" target="#b11">[12]</ref>, Go <ref type="bibr" target="#b12">[13]</ref> and Python <ref type="bibr" target="#b13">[14]</ref>. Our Java implementation provides multiple versions of DDSketch: buckets can be stored in a contiguous way (for fast addition) or in a sparse way (for smaller memory footprint). The number of buckets can grow indefinitely or be bounded with a fixed maximum of m buckets, collapsing the buckets of lowest or highest indices. The mapping of the values to their bucket indices can be logarithmic, as defined above, but we also provide alternative mappings that are faster to evaluate while still ensuring relative accuracy guarantees. Those mappings make the most of the binary representation of floating-point values, which provides a costless way to evaluate the logarithm to the base 2. In between a linear or quadratic interpolation can be used so that the logarithm to any base can be approximated. Those mappings define buckets whose sizes are not optimal under the constraint of ensuring relative accuracy guarantee as some of them are smaller than necessary. Their faster evaluation than the memory-optimal logarithmic mapping comes at the cost of requiring more buckets to cover a given range of values, and therefore a memory footprint overhead in DDSketch. We refer to this version of the code as DDSketch (fast) in our experiments.</p><p>We compare DDSketch against the Java implementation <ref type="bibr" target="#b30">[31]</ref> of HDR Histogram, our Java implementation of the GKArray version of the GK sketch <ref type="bibr" target="#b11">[12]</ref>, as well as the Java implementation of the Moments sketch <ref type="bibr" target="#b14">[15]</ref> (all three discussed in Section 1.2). HDR Histogram is a relative-error sketch for non-negative values. Its accuracy is expressed as the number of significant decimal digits d of the values. GKArray guarantees that the rank error of the estimated quantiles will be smaller than after adding values. The Moments sketch has guarantees on the average rank error bounded by the number of moments k that are estimated.</p><p>We consider three data sets, and compare the size in memory of the sketches, the speed of adding values and merging sketches, and the accuracy of the estimated quantiles. The measurements are performed with the Java implementations of all four sketches.</p><p>The sketch parameters are chosen so that the targeted relative accuracy for DDSketch and HDR Histogram is 1%. For GKArray, we use a rank accuracy that gives roughly similar memory footprints as DDSketch. For the Moments sketch, we use the maximum recommended numbers of moments, as per the Java implementation documentation, and we also use the arcsinh transform (called compression in the code), which makes the sketch more accurate for distributions with heavy tails. Those parameters are summarized in <ref type="table" target="#tab_1">Table 2</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Data Sets</head><p>We use three data sets for our experiments, whose distributions are shown in <ref type="figure" target="#fig_4">Figure 5</ref>. The pareto data set contains synthetic data generated from a Pareto distribution with a = b = 1. The span data set is a set of span durations of the distributed traces of requests that Datadog received over a few hours. The durations are integers in units of nanoseconds, and it includes a wide range of values (from 100 to 1.9 × 10 12 ). The power dataset is the global active power measurements from the UCI Individual Household Electric Power Consumption dataset <ref type="bibr" target="#b25">[26]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Sketch Size In Memory</head><p>How much space a sketch takes up in memory will be an important consideration in many applications. For each of the four sketches, the parameters chosen will determine the accuracy of the sketch as well as its size. An increase in accuracy generally requires a larger sketch. <ref type="figure">Figure 6</ref> plots the sketch size in memory as n increases.</p><p>We see that DDSketch (fast) can be up to twice the size of DDSketch, and that HDR Histogram is significantly larger. Both GKArray and the Moments sketch are much smaller, and the Moments sketch in particular is completely independent of the size of the input.</p><p>If one runs DDSketch with a limit placed on the number of bins the sketch can contain, when the maximum number of bins is reached, DDSketch starts to combine the smallest bins together as needed, meaning that the lower quantile estimates may not meet the relative accuracy guarantee. In our experiments this maximum was never reached, and we have not found this to be an issue. <ref type="figure">Figure 7</ref> plots the number of DDSketch bins for the pareto data set. The number of bins is around 900 for n = 10 10 , less than half the limit of 2048. It is also worth noting that the actual sketch size required for the Pareto distribution is much smaller than the upper bounds we calculated in Section 3.3.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Add and Merge Speeds</head><p>In this section, we compare the performance of the sketches in terms of the time required to add values to a sketch and to merge sketches together. <ref type="figure" target="#fig_7">Figure 8</ref> shows the average time required to add n values to an empty sketch divided by n. It takes less than 5 seconds to add a hundred million values to an empty DDSketch on a 3.1GHz MacBook Pro. GKArray is the slowest for insertions by far, being around six times slower than the Moments sketch. Adding to an HDR Histogram is faster than adding to the standard version of DDSketch as HDR Histogram has a simpler index calculation than DDSketch which has to calculate logarithms. DDSketch (fast) is the fastest in terms of insertion speed, though this was obtained by an increase in the sketch size as we saw in Section 6. <ref type="figure" target="#fig_8">Figure 9</ref> plots the average time required to merge two sketches of roughly the same size, as a function of the number of values in the merged sketch. Merging two DDSketches is very fast-it takes around 10 microseconds or less to merge two sketches containing up to fifty million values each-depending on the data set and size, it can be more than an order of magnitude faster than GKArray or HDR Histogram. The Moment sketch has the fastest merge speeds of all the algorithms, as each sketch only holds on to k = 20 values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Sketch Accuracy</head><p>DDSketch guarantees a relative error in its quantile estimates of at most α, while GKArray guarantees a rank error of less than . HDR Histogram has an implied relative-error guarantee of 10 −d where d is the number of significant digits. Therefore we compare both the average relative and rank errors in <ref type="figure" target="#fig_10">Figures 10 and 11</ref>, for the p50, p95, and p99 estimates. Note that for GKArray, for n ≤ 1/ , all the values are retained so that both the relative error and rank error will be zero. <ref type="figure" target="#fig_10">Figure 10</ref> shows that for all three data sets DDSketch has a consistent relative error less than α for all values of n. For the heavytailed pareto and span data sets, the relative error sketches (DDSketch and HDR Histogram) have much smaller relative error than either GKArray or Moments. The discrepancy is especially striking for the higher quantiles, as the values returned can be several orders of magnitude off the actual value. The Moments sketch has particular difficulty with the span data set as it has trouble dealing with such a large range of values.</p><p>In terms of rank error, the guarantee of GKArray can be clearly seen in <ref type="figure">Figure 11</ref>. No such guarantee is provided for DDSketch and HDR Histogram, yet they perform better than the Moments sketch which has a guarantee on average, and even GK for the higher quantiles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">CONCLUSION</head><p>Datadog's use-case for distributed quantile sketching comes from our agent-based monitoring where we need to accurately aggregate data coming from disparate sources in our high-throughput, lowlatency, distributed data processing engine. To get a sense of the scale, some of our customers have endpoints that handle over 10M points per second, and DDSketch provides accurate latency quantiles for these endpoints.</p><p>After our initial evaluation of existing quantile sketching algorithms, we settled on the Greenwald-Khanna algorithm as it could handle arbitrary values, and provided the best compromise between accuracy, size, insertion speed, and merge time. (The implementation we provide comes from our work in optimizing the algorithm.)</p><p>Unfortunately, the relative-accuracy errors for higher quantiles generated by the rank-error sketch proved to be unacceptable, which led us to develop DDSketch. Unlike HDR Histogram, which is designed to handle a bounded range and has poor merge speeds, DDSketch is a flexible relativer error sketch that can handle arbitrarily large ranges, and has fast merge speeds. Compared to GK, the relative accuracy of DDSketch is comparable for dense data sets, while for heavy-tailed data sets the improvement in accuracy can be measured in orders of magnitude. The rank error is also comparable to if not better than that of GK. Additionally, it is much faster in both insertion and merge.  <ref type="formula">10 3 10 4 10 5 10 6 10 7 10 8</ref>N Values 10 -3 10 -2 10 -1 10 0 10 1 2 3 4 5 6 <ref type="bibr">7 8</ref> Relative Error in p99 </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">ACKNOWLEDGMENT</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Histograms for p0-p95 and p0-p100 of 2 million web request response times. (Bars for p93-p100 exist but are shorter than the minimum pixel height.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Actual quantiles vs. 0.005-rank-accurate and 0.01-relative-accurate quantiles of a data stream (20 batches of 100,000 values).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>P 4 .</head><label>4</label><figDesc>DDSketch can α-accurately answer a given qquantile query if:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Histograms of the pareto, span and mpcat-obs data sets. The y-axes of the pareto and span data sets are plotted on log scales due to their heavy-tailed nature.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :Figure 7 :</head><label>67</label><figDesc>Sketch size in memory in kB. Number of bins in DDSketch for the pareto data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :</head><label>8</label><figDesc>Average time required to add a value to a sketch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 9 :</head><label>9</label><figDesc>Average time required to merge two sketches as a function of number of values in the merged sketch.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 10 :</head><label>10</label><figDesc>Relative errors of p50, p95, and p99 estimates.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 : Quantile Sketching Algorithms</head><label>1</label><figDesc></figDesc><table><row><cell></cell><cell>guarantee</cell><cell>range</cell><cell>mergeability</cell></row><row><cell>DDSketch</cell><cell>relative</cell><cell>arbitrary</cell><cell>full</cell></row><row><cell>HDR Histogram</cell><cell>relative</cell><cell>bounded</cell><cell>full</cell></row><row><cell>GKArray</cell><cell>rank</cell><cell>arbitrary</cell><cell>one-way</cell></row><row><cell>Moments</cell><cell cols="2">avg rank bounded</cell><cell>full</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 : Experiment Parameters</head><label>2</label><figDesc></figDesc><table><row><cell>DDSketch</cell><cell>α = 0.01 m = 2048</cell></row><row><cell>HDR Histogram</cell><cell>d = 2</cell></row><row><cell>GKArray</cell><cell>= 0.01</cell></row><row><cell>Moments sketch</cell><cell>k = 20 compression enabled</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research has made use of data provided by the International Astronomical Union's Minor Planet Center.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Scuba: Diving into data at facebook</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Barykin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Borkar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Chopra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Gerea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Merl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Metzler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Reiss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Subramanian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Wiener</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Zed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="1057" to="1067" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Mergeable summaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Phillips</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS &apos;12</title>
		<meeting>the 31st ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS &apos;12<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="23" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Site Reliability Engineering: How Google Runs Production Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Beyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Petoff</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><forename type="middle">R</forename><surname>Murphy</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>Reilly Media, Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Metric Characterization of Random Variables and Random Processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">V</forename><surname>Buldygin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">V</forename><surname>Kozachenko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>American Mathematical Society</publisher>
			<pubPlace>Rhode Island, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The tail of the hypergeometric distribution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Mathematics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="285" to="287" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Synopses for massive data: Samples, histograms, wavelets, sketches. Foundations and Trends R in Databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garofalakis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Haas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Jermaine</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1" to="294" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Effective computation of biased quantiles over data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">21st International Conference on Data Engineering, ICDE&apos;05</title>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="20" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Space-and time-efficient deterministic algorithms for biased quantiles over data streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS &apos;06</title>
		<meeting>the 25th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems, PODS &apos;06<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Gigascope: a stream database for network applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Cranor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Spataschek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Shkapenyuk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2003 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="647" to="651" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">8 emerging trends in container orchestration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Datadog</surname></persName>
		</author>
		<ptr target="https://www.datadoghq.com/container-orchestration" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="volume">Accessed</biblScope>
			<biblScope unit="page" from="2018" to="2030" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">8 surprising facts about real docker adoption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Datadog</surname></persName>
		</author>
		<ptr target="https://www.datadoghq.com/docker-adoption/" />
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="volume">Accessed</biblScope>
			<biblScope unit="page" from="2018" to="2030" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Datadog</surname></persName>
		</author>
		<ptr target="https://github.com/DataDog/sketches-java" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Datadog</surname></persName>
		</author>
		<ptr target="https://github.com/DataDog/sketches-go" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Datadog</surname></persName>
		</author>
		<ptr target="https://github.com/DataDog/sketches-py" />
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Moments sketch</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Dawn</surname></persName>
		</author>
		<ptr target="https://github.com/stanford-futuredata/momentsketch" />
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The tail at scale</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Barroso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="74" to="80" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Dunning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Ertl</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1902.04023</idno>
		<title level="m">Computing extremely accurate quantiles using t-digests</title>
		<imprint>
			<date type="published" when="2019" />
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Elasticsearch reference: Percentiles aggregation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Elasticsearch</surname></persName>
		</author>
		<ptr target="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-aggregation.html" />
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="2018" to="2027" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Moment-based quantile sketches for efficient high cardinality aggregation queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">S</forename><surname>Tai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Sharan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Bailis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1647" to="1660" />
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Space-efficient online computation of quantile summaries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Greenwald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2001 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;01</title>
		<meeting>the 2001 ACM SIGMOD International Conference on Management of Data, SIGMOD &apos;01<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="58" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Quantiles and equidepth histograms over streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">B</forename><surname>Greenwald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Khanna</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Stream Management</title>
		<editor>M. Garofalakis, J. Gehrke, and R. Rastogi</editor>
		<meeting><address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="45" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Approximation and streaming algorithms for histogram construction problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Database Systems (TODS)</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="396" to="438" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Rehist: Relative error histogram construction algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Shim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 30th International Conference on Very Large Data Bases, VLDB &apos;04</title>
		<meeting>the 30th International Conference on Very Large Data Bases, VLDB &apos;04</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="300" to="311" />
		</imprint>
		<respStmt>
			<orgName>VLDB Endowment</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Optimal histograms with quality guarantees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">V</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Koudas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Muthukrishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Poosala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">C</forename><surname>Sevcik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Suel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24rd International Conference on Very Large Data Bases, VLDB &apos;98</title>
		<meeting>the 24rd International Conference on Very Large Data Bases, VLDB &apos;98</meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="275" to="286" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Optimal quantile approximation in streams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Karnin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Lang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Liberty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 57th IEEE Symposium on Foundations of Computer Science (FOCS), FOCS &apos;16</title>
		<meeting>the 57th IEEE Symposium on Foundations of Computer Science (FOCS), FOCS &apos;16<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="71" to="78" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Uci machine learning repository</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lichman</surname></persName>
		</author>
		<ptr target="https://archive.ics.uci.edu/ml/datasets/individual+household+electric+power+consumption" />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Quantiles over data streams: experimental comparisons, new analyses, and further improvements</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Yi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Cormode</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PVLDB</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="449" to="472" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">The design of an acquisitional query processor for sensor networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Madden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Franklin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Hellerstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2003 ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the 2003 ACM SIGMOD International Conference on Management of Data</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="491" to="502" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Selection and sorting with limited storage</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">I</forename><surname>Munro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Paterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="315" to="323" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">So, you want to trace your distributed system? key design insights from years of practical experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">R</forename><surname>Sambasivan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Shafer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">R</forename><surname>Ganger</surname></persName>
		</author>
		<idno>CMU-PDL-14-102</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">Hdrhistogram: A high dynamic range (hdr) histogram</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Tene</surname></persName>
		</author>
		<ptr target="http://hdrhistogram.org/" />
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="2018" to="2027" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
