<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">How to Memorize a Random 60-Bit String</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marjan</forename><surname>Ghazvininejad</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Information Sciences Institute Department of Computer Science</orgName>
								<orgName type="institution">University of Southern California</orgName>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
							<email>knight@isi.edu</email>
							<affiliation key="aff1">
								<orgName type="department">Information Sciences Institute Department of Computer Science University of Southern California</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">How to Memorize a Random 60-Bit String</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:45+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>User-generated passwords tend to be memorable, but not secure. A random, computergenerated 60-bit string is much more secure. However, users cannot memorize random 60bit strings. In this paper, we investigate methods for converting arbitrary bit strings into English word sequences (both prose and poetry), and we study their memorability and other properties.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Passwords chosen by users (e.g., "Scarlet%2") are easy to remember, but not secure <ref type="bibr" target="#b1">(Florencio and Herley, 2007)</ref>. A more secure method is to use a system-assigned 60-bit random password, such as 0010100010100...00101001. However, this string is hard to memorize. In this paper, we convert such strings into English phrases, in order to improve their memorability, using natural language processing to select fluent passphrases.</p><p>Our methods are inspired by an XKCD cartoon 1 that proposes to convert a randomly-chosen 44-bit password into a short, nonsensical sequence of English words. The proposed system divides the 44-bit password into four 11-bit chunks, and each chunk provides an index into a 2048-word English dictionary. XKCD's example passphrase is correct horse battery staple: -&gt; staple The four-word sequence is nonsense, but it is easier to memorize than the 44-bit string, and XKCD hypothesizes that users can improve memorability by building an image or story around the four words.</p><p>In this paper, we investigate other methods for converting a system-generated bit string into a memorable sequence of English words. Our methods produce whole sentences, e.g.</p><p>Fox news networks are seeking views from downtown streets.</p><p>as well as short poems, e.g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Diversity inside replied, Soprano finally reside.</head><p>We also move to 60-bit passwords, for better security. One source claims:</p><p>As of 2011, available commercial products claim the ability to test up to 2,800,000,000 passwords a second on a standard desktop computer using a highend graphics processor. 2 If this is correct, a 44-bit password would take one hour to crack, while a 60-bit password would take 11.3 years.</p><p>Our concrete task is as follows: It makes me think of union pacific resource said it looks like most commercial networks . Some companies keep their windows rolled down so you don't feel connected to any community .</p><p>Contains extreme violence and it was a matter of not only its second straight loss . Parking and utilities have been searching for a third straight road win . It was the same girl and now a law professor in the former east german town . I know a man who said he was chief of staffs in a real and deep conversation .  • Input: A random, system-generated 60-bit password.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Frequency</head><p>• Output: An English word sequence with two properties:</p><p>-It is memorable.</p><p>-We can deterministically recover the original input 60-bit string from it.</p><p>This implies that we map 2 60 distinct bit strings into 2 60 distinct English sequences. If a user memorizes the English word sequence supplied to them, then they have effectively memorized the 60-bit string.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Password Generation Methods</head><p>We now describe our baseline password generation method, followed by four novel methods. In Section 3 we experimentally test their memorability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">XKCD Baseline</head><p>Our baseline is a version of XKCD. Instead of a 2048-word dictionary, we use a 32,7868-word dictionary. We assign each word a distinct 15-bit code.</p><p>At runtime, we take a system-assigned 60-bit code and split it into four 15-bit sequences. We then substitute each 15-bit segment with its corresponding word. By doing this, we convert a random 60-bit code into a 4-word password.</p><p>The first row of <ref type="table" target="#tab_3">Table 1</ref> shows three sample XKCD passwords, along with other information, such as the average number of characters (including spaces).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">First Letter Mnemonic</head><p>XKCD passwords are short but nonsensical, so we now look into methods that instead create longer but fluent English sentences. We might think to guarantee fluency by selecting sentences from an alreadyexisting text corpus, but no corpus is large enough to contain 2 60 (∼ 10 18 ) distinct sentences. Therefore, we must be able to synthesize new English strings.</p><p>In our first sentence generation method (First Letter Mnemonic), we store our input 60-bit code in the first letters of each word. We divide the 60-bit code into 4-bit sections, e.g., '0100-1101-1101-...'. Every 4-bit sequence type corresponds to an English letter  or two, per <ref type="table" target="#tab_5">Table 2</ref>. We build a word-confusion network (or "sausage lattice") by replacing each 4-bit code with all English words that start with a corresponding letter, e.g.:</p><formula xml:id="formula_0">0100 1101 1111 ... 0011 ---- ---- ---- ---- income my frog ... octopus is miner feast ... of inner priest gratuitous ... oregon ... ... ... ...</formula><p>This yields about 10 74 paths, some good (is my frog. . . ) and some bad (income miner feast. . . ).</p><p>To select the most fluent path, we train a 5-gram language model with the SRILM toolkit <ref type="bibr" target="#b10">(Stolcke, 2002)</ref> on the English Gigaword corpus. 3 SRILM also includes functionality for extracting the best path from a confusion network. <ref type="table" target="#tab_3">Table 1</ref> shows sample sentences generated by the method. Perhaps surprisingly, even though the sentences are much longer than XKCD (15 words versus 4 words), the n-gram language model (LM) score is a bit better. The sentences are locally fluent, but not perfectly grammatical.</p><p>We can easily reconstruct the original 60-bit code by extracting the first letter of each word and applying the Table 2 mapping in reverse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">All Letter Method</head><p>Most of the characters in the previous methods seem "wasted", as only the word-initial letters bear information relevant to reconstructing the original 60-Bit Sequence  <ref type="table" target="#tab_6">Table 3</ref>. Additionally, we nondeterministically introduce a space (or not) between each pair of letters. This yields 4 • 10 84 possible output strings per input, 3 • 10 56 of which consist of legal English words. From those 3 • 10 56 strings, we choose the one that yields the best word 5-gram score.</p><formula xml:id="formula_1">Mapped Characters 0 e, o, i, h, r, c, u, f, g, b, v, x ,q 1 t, a, n, s, d, l, m, w, y, p, k, j, z</formula><p>It is not immediately clear how to process a letterbased lattice with a word-based language model. We solve this search problem by casting it as one of machine translation from bit-strings to English. We create a phrase translation table by pairing each English word with a corresponding "bit phrase", using Table 3 in reverse. Sample entries include:</p><p>din ||| 1 0 1 through ||| 1 0 0 0 0 0 0 yields ||| 1 0 0 1 1 1</p><p>We then use the Moses machine translation toolkit <ref type="bibr" target="#b6">(Koehn et al., 2007)</ref> to search for the 1-best translation of our input 60-bit string, using the phrase table and a 5-gram English LM, disallowing re-ordering. <ref type="table" target="#tab_3">Table 1</ref> shows that these sentences are shorter than the mnemonic method (11.8 words versus 15 words), without losing fluency.</p><p>Given a generated English sequence, we can deterministically reconstruct the original 60-bit input string, using the above phrase table in reverse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Frequency Method</head><p>Sentence passwords from the previous method contain 70.8 characters on average (including spaces). Classic studies by <ref type="bibr" target="#b8">Shannon (1951)</ref> and others estimate that printed English may ultimately be compressible to about one bit per character. This implies we might be able to produce shorter output (60 characters, including space) while maintaining normal English fluency.</p><p>Our next technique (Frequency Method) modifies the phrase table by assigning short bit codes to frequent words, and long bit codes to infrequent words. For example:</p><p>din ||| 0 1 1 0 1 0 1 0 0 through ||| 1 1 1 1 yields ||| 0 1 0 1 1 1 0 1</p><p>Note that the word din is now mapped to a 9-bit sequence rather than a 3-bit sequence. More precisely, we map each word to a random bit sequence of length max(1, −α × log P(word) + β) . By changing variables α and β we can vary between smooth but long sentences (α = 1 and β = 0) to XKCD-style phrases (α = 0 and β = 15). <ref type="table" target="#tab_3">Table 1</ref> shows example sentences we obtain with α = 2.5 and β = −2.5, yielding sentences of 9.7 words on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Poetry</head><p>In ancient times, people recorded long, historical epics using poetry, to enhance memorability. We follow this idea by turning each system-assigned 60-bit string into a short, distinct English poem. Our format is the rhyming iambic tetrameter couplet:</p><p>• The poem contains two lines of eight syllables each.</p><p>• Lines are in iambic meter, i.e., their syllables have the stress pattern 01010101, where 0 represents an unstressed syllable, and 1 represents a stressed syllable. We also allow 01010100, to allow a line to end in a word like Angela.</p><p>• The two lines end in a pair of rhyming words. Words rhyme if their phoneme sequences match from the final stressed vowel onwards. We obtain stress patterns and phoneme sequences from the CMU pronunciation dictionary. <ref type="bibr">4</ref> Monosyllabic words cause trouble, because their stress often depends on context <ref type="bibr" target="#b4">(Greene et al., 2010)</ref>. For example, eighth is stressed in eighth street, but not in eighth avenue. This makes it hard to guarantee that automatically-generated lines will scan as intended. We therefore eject all monosyllabic words from the vocabulary, except for six unstressed ones <ref type="bibr">(a, an, and, the, of, or)</ref>.</p><p>Here is a sample poem password:</p><p>The le-gen-da-ry Ja-pan-ese ↓ ↑ ↓ ↑ ↓ ↑ ↓ ↑ Sub-si-di-ar-ies ov-er-seas ↓ ↑ ↓ ↑ ↓ ↑ ↓ ↑</p><p>Meter and rhyme constraints make it difficult to use the Moses machine translation toolkit to search for fluent output, as we did above; the decoder state must be augmented with additional short-and longdistance information <ref type="bibr" target="#b3">(Genzel et al., 2010)</ref>.</p><p>Instead, we build a large finite-state acceptor (FSA) with a path for each legal poem. In each path, the second line of the poem is reversed, so that we can enforce rhyming locally.</p><p>The details of our FSA construction are as follows. First, we create a finite-state transducer (FST) that maps each input English word onto four sequences that capture its essential properties, e.g.:</p><p>create -&gt; 0 1 create -&gt; 0 1 EY-T create -&gt; 1r 0r create -&gt; EY-T 1r 0r</p><p>Here, EY-T represents the rhyme-class of words like create and debate. The r indicates a stress pattern in the right-to-left direction.</p><p>We then compose this FST with an FSA that only accepts sequences of the form: 1 0 1 0 1 0 1 X X 1r 0r 1r 0r 1r 0r 1r 0r where X and X are identical rhyme classes (e.g., EY-T and EY-T).</p><p>It remains to map an arbitrary 60-bit string onto a path in the FSA. Let k be the integer representation of the 60-bit string. If the FSA contains exactly 60 paths, we can easily select the kth path using the following method. At each node N of the FSA, we store the total number of paths from N to the final state-this takes linear time if we visit states in reverse topological order. We then traverse the FSA deterministically from the start state, using k to guide the path selection.</p><p>Our FSA actually contains 2 79 paths, far more than the required 2 60 . We can say that the information capacity of the English rhyming iambic tetrameter couplet is 79 bits! Some are very good: Fortunately, because our FSA contains over a million times the required 2 60 paths, we can avoid these bad outputs. For any particular 60-bit string, we have a million poems to choose from, and we output only the best one.</p><p>More precisely, given a 60-bit input string k, we extract not only the kth FSA path, but also the k + i • 2 60 paths, with i ranging from 1 to 999,999. We explicitly list out these paths, reversing the second half of each, and score them with our 5-gram LM. We output the poem with the 1-best LM score. <ref type="table" target="#tab_3">Table 1</ref> shows sample outputs.</p><p>To reconstruct the original 60-bit string k, we first find the FSA path corresponding to the user-recalled English string (with second half reversed). We use depth-first search to find this path. Once we have the path, it is easy to determine which numbered path it is, lexicographically speaking, using the nodelabeling scheme above to recover k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experiments</head><p>We designed two experiments to compare our methods.</p><p>The first experiment tests the memorability of passwords. We asked participants to memorize a password from a randomly selected method 5 and recall it two days later. To give more options to users,</p><p>In all experiments, we omit the First Letter Mnemonic, due to its low performance in early tests.  <ref type="table">Table 4</ref>: Memorability of passwords generated by our methods. "Recalls" indicates how many participants returned to type their memorized English sequences, and "Correct Recalls" tells how many sequences were accurately remembered.</p><p>Method Name User preference XKCD 5% All Letter Method 39% Frequency Method 37% Poetry 19% <ref type="table">Table 5</ref>: User preferences among passwords generated by our methods.</p><p>we let them select from the 10-best passwords according to the LM score for a given 60-bit code.</p><p>Note that this flexibility is not available for XKCD, which produces only one password per code. users participated in this experiment, 44 returned to recall the password, and 22 successfully recalled the complete password. <ref type="table">Table 4</ref> shows that the Poetry and XKCD methods yield passwords that are easiest to remember.</p><p>In the second experiment, we present a separate set of users with passwords from each of the four methods. We ask which they would prefer to use, without requiring any memorization. <ref type="table">Table 5</ref> shows that users prefer sentences over poetry, and poetry over XKCD. <ref type="table">Table 4</ref> shows that the Poetry and XKCD methods yield passwords that are easiest to memorize. Complete sentences generated by the All Letter and Frequency Methods are harder to memorize. At the same time <ref type="table">Table 5</ref> shows that people like the sentences better than XKCD, so it seems that they overestimate their ability to memorize a sentence of 10-12 words. Here are typical mistakes (S = system-generated, R = as recalled by user):</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Analysis</head><p>(S) Still looking for ruben sierra could be in central michigan (R) I am still looking for ruben sierra in central michigan (S) That we were required to go to college more than action movies (R) We are required to go to college more than action movies (S) No dressing allowed under canon law in the youth group (R) No dresses allowed under canon law for youth groups</p><p>Users remember the gist of a sentence very well, but have trouble reproducing the exact wording. Post-experiment interview reveal this to be partly an effect of overconfidence. Users put little mental work into memorizing sentences, beyond choosing among the 10-best alternatives presented to them. By contrast, they put much more work into memorizing an XKCD phrase, actively building a mental image or story to connect the four otherwise unrelated words.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Future Directions</head><p>Actually, we can often automatically determine that a user-recalled sequence is wrong. For example, when we go to reconstruct the 60-bit input string from a user-recalled sequence, we may find that we get a 62-bit string instead. We can then automatically prod the user into trying again, but we find that this is not effective in practice. An intriguing direction is to do automatic error-correction, i.e., take the user-recalled sequence and find the closest match among the 2 60 English sequences producible by the method. Of course, it is a challenge to do this with 1-best outputs of an MT system that uses heuristic beam search, and we must also ensure that security is maintained.</p><p>We may also investigate new ways to re-rank nbest lists. Language model scoring is a good start, but we may prefer vivid, concrete, or other types of words, or we may use text data associated with the user (papers, emails) for secure yet personalized password generation. <ref type="bibr" target="#b2">Gasser (1975)</ref>, <ref type="bibr" target="#b0">Crawford and Aycock (2008)</ref>, and <ref type="bibr" target="#b9">Shay et al. (2012)</ref> describe systems that produce meaningless but pronounceable passwords, such as "tufritvi" . However, their systems can only assign ∼ 2 30 distinct passwords. <ref type="bibr" target="#b5">Jeyaraman and Topkara (2005)</ref> suggest generating a random sequence of characters, and finding a mnemonic for it in a text corpus. A limited corpus means they again have a small space of systemassigned passwords. We propose a similar method in Section 2.2, but we automatically synthesize a new mnemonic word sequence. <ref type="bibr" target="#b7">Kurzban (1985)</ref> and <ref type="bibr" target="#b9">Shay et al. (2012)</ref> use a method similar to XKCD with small dictionaries. This leads to longer nonsense sequences that can be difficult to remember.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We introduced several methods for generating secure passwords in the form of English word sequences. We learned that long sentences are seemingly easy to remember, but actually hard to reproduce, and we also learned that our poetry method produced relatively short, memorable passwords that are liked by users.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>1 http://xkcd.com/93644-bit passwordEnglish phrase --------------------------</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 1</head><label>1</label><figDesc></figDesc><table><row><cell>: Comparison of methods that convert system-assigned 60-bit strings into English word sequences. Average</cell></row><row><cell>word lengths range from 4 (XKCD) to 15 (First Letter Mnemonic). Average character lengths include spaces. LM</cell></row><row><cell>score refers to the log probability assigned by a 5-gram English language model trained on the Gigaword corpus.</cell></row><row><cell>Capacity tells how many English word sequences are available for an individual 60-bit input string.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>Mapping function between 4-bit sequences and English letters in the First Letter Mnemonic method.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head>Table 3 :</head><label>3</label><figDesc>Mapping function between bits and English characters in the All Letter Method. bit string. Our next technique (All Letter Method) non-deterministically translates every bit into an English letter, per</figDesc><table /><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">http://en.wikipedia.org/wiki/Password cracking</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3">https://catalog.ldc.upenn.edu/LDC2011T07</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">http://www.speech.cs.cmu.edu/cgi-bin/cmudict</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank James Bedell, Aliya Deri, Tomer Levinboim, Jonathan May, Nima Pourdamghani and the anonymous reviewers for their very helpful comments. This work was supported in part by DARPA contract FA-8750-13-2-0045.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Kwyjibo: automatic domain name generation. Software: Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heather</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Aycock</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="1561" to="1567" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A largescale study of web password habits</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinei</forename><surname>Florencio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cormac</forename><surname>Herley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th international conference on World Wide Web</title>
		<meeting>the 16th international conference on World Wide Web</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="657" to="666" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Electronic Systems Division, Air Force Systems Command</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Morrie</forename><surname>Gasser</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1975" />
			<publisher>USAF</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
	<note>A random word generator for pronounceable passwords</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Poetic statistical machine translation: rhyme and meter</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dmitriy</forename><surname>Genzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakob</forename><surname>Uszkoreit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franz</forename><surname>Och</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2010 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="158" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automatic analysis of rhythmic poetry with applications to generation and translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erica</forename><surname>Greene</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tugba</forename><surname>Bodrumlu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="524" to="533" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Have your cake and eat it too-infusing usability into text-password based authentication systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sundararaman</forename><surname>Jeyaraman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Umut</forename><surname>Topkara</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACSAC</title>
		<meeting>ACSAC</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Moses: Open source toolkit for statistical machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Koehn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hieu</forename><surname>Hoang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexandra</forename><surname>Birch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Callison-Burch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marcello</forename><surname>Federico</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicola</forename><surname>Bertoldi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brooke</forename><surname>Cowan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wade</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christine</forename><surname>Moran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Zens</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 45th Annual Meeting of the ACL, Demo and Poster Sessions</title>
		<meeting>the 45th Annual Meeting of the ACL, Demo and Poster Sessions</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="177" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Easily remembered passphrases: a better approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Stanley A Kurzban</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGSAC Review</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2-4</biblScope>
			<biblScope unit="page" from="10" to="21" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Prediction and entropy of printed English</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claude</forename><forename type="middle">E</forename><surname>Shannon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell System Technical Journal</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="50" to="64" />
			<date type="published" when="1951" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Correct horse battery staple: Exploring the usability of system-assigned passphrases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Shay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrick</forename><forename type="middle">Gage</forename><surname>Kelley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saranga</forename><surname>Komanduri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michelle</forename><forename type="middle">L</forename><surname>Mazurek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Blase</forename><surname>Ur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Timothy</forename><surname>Vidas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lujo</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicolas</forename><surname>Christin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lorrie</forename><forename type="middle">Faith</forename><surname>Cranor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Symposium on Usable Privacy and Security</title>
		<meeting>the Eighth Symposium on Usable Privacy and Security</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page">7</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">SRILM-an extensible language modeling toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Stolcke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">INTERSPEECH</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="901" to="904" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
