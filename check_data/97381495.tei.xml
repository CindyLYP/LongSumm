<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Prudent Engineering Practice for Cryptographic Protocols</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Abadi</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><surname>Needhamt</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Systems Research Center</orgName>
								<orgName type="institution">~ *maQsrc.dec.com. Digital Equipment Corporation</orgName>
								<address>
									<addrLine>130 Lytton Ave</addrLine>
									<postCode>94301</postCode>
									<settlement>Palo Alto</settlement>
									<region>California</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="laboratory">Com-puter Laboratory, New Museums Site</orgName>
								<orgName type="institution">University of Cambridge</orgName>
								<address>
									<addrLine>Pembroke St</addrLine>
									<postCode>CB1 3QG</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Prudent Engineering Practice for Cryptographic Protocols</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:43+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present principles for the design of cryptographic protocols. The principles are neither necessary nor sufficient for correctness. They are however helpful, in that adherence to them would have avoided a considerable number of published errors. Our principles are informal guidelines. They complement formal methods, but do not assume them. In order to demonstrate the actual applicability of these guidelines, we discuss some instructive examples from the literature.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>It has been evident for a number of years that cryptographic protocols, as used in distributed systems for authentication and related purposes, are prone to design errors of every kind. A considerable body of literature has come into being in which various formalisms are proposed for investigating and analyzing protocols to see whether they contain various kinds of blunders. (Liebl's bibliography <ref type="bibr">[ll]</ref> contains references to protocols and formalisms.) Although sometimes useful, these formalisms do not of themselves suggest design rules; they are not directly beneficial in seeing how to avoid trouble.</p><p>We present principles for the design of cryptographic protocols. The principles are not necessary for correctness, nor are they sufficient. They are however helpful, in that adherence to them would have contributed to the simplicity of protocols and avoided a considerable number of published confusions and mistakes.</p><p>We arrived at our principles by noticing some common features among protocols that are difficult to analyze. If these features are avoided, it becomes less necessary to resort to formal toolsand also easier to do so if there is good reason to. The principles themselves are informal guidelines, and useful independently of any logic.</p><p>We illustrate the principles with examples. We draw our examples from the published literature, in order to demonstrate the actual applicability of our guidelines. Some of the oddities and errors that we analyze here have been documented previously (in particular, in <ref type="bibr" target="#b3">[4]</ref>  <ref type="bibr">Varadharajan,</ref><ref type="bibr">Allen,</ref><ref type="bibr">and Black [29]</ref>, and Woo and Lam <ref type="bibr" target="#b29">[32]</ref>. We believe they are all instructive.</p><p>Generally, we choose examples from the authentication literature, but the principles are applicable elsewhere, for example to electronic-cash protocols (e.g., <ref type="bibr" target="#b18">[15]</ref>). We focus on traditional cryptography, and on protocols of the sort commonly implemented with the DES <ref type="bibr" target="#b24">[18]</ref> and the RSA <ref type="bibr" target="#b21">[26]</ref> algorithms. In particular, we do not consider the subtleties of interactive schemes for signatures (eg, <ref type="bibr" target="#b6">[7]</ref>). Moreover, we do not discuss the choice of cryptographic mechanisms with adequate protection properties, the correct implementation of cryptographic primitives, or their appropriate use; these subjects are discussed elsewhere (e.g., <ref type="bibr" target="#b27">[30,</ref><ref type="bibr">171)</ref>.</p><p>Throughout, we concentrate on the simple facts with the largest potential applicability and payoff. Admittedly, the literature is full of ingenious protocols and attacks. We do not attempt to organize the principles that underly this ingenuity, and perhaps it is not necessary. We hope that our simple principles and examples will be of help to the engineering of robust cryptographic protocols.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Basics</head><p>A protocol, for present purposes, is a set of rules or conventions defining an exchange of messages among a set of two or more partners. These partners are users, processes, or machines, which we will generically refer to as principals. In a cryptographic protocol the whole or part of some or all of the messages is encrypted. We interpret the term encryption fairly broadly, applying it for example to signature operations. Encryption and decryption are for present purposes defined as key-dependent transformations of a message which may only be inverted by using a definite key; the keys used for encryption and decryption are the same or different, depending on the cryptographic algorithm used.</p><p>We find two overarching principles for the design of secure cryptographic protocols. One principle is concerned with the content of a message and will 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>the other with the circumstances in which it be acted upon:</p><p>Every message should say what it meansits interpretation should depend only on its content.</p><p>The conditions for a message to be acted upon should be clearly set out so that someone reviewing a design may see whether they are acceptable or not.</p><p>Next we explain these general principles. They lead to other, more specific recommendations, which we discuss in the subsequent sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Explicit communication</head><p>In full, our first basic principle is: Principle 1 Every message should say what it means: the interpretation of the message should depend only on its content. It should be possible to write down a straightforward English sentence describing the content-though if there is a suitable formalism available that is good too.</p><p>For example, an authentication server S might send a message whose meaning may be expressed thus: "After receiving bit-pattern P , S sends to A a session key K intended to be good for conversation with B". All elements of this meaning should be explicitly represented in the message, so that a recipient can recover the meaning without any context. In particular, if any of P , S , A, B , or K are left to be inferred from context, it may be possible for one message to be used deceitfully in place of another.</p><p>Principle 1 is not completely original. In [4], we recommend the use of a logical notation in generating and describing protocols-essentially proposing a method to follow the principle. Establishing the correspondence between the logical protocol and its concrete implementation can be a simple matter of parsing, as for example in [31, Section 4.3.21. Although a precise comparison of informal ideas is difficult, we also find an affinity with Boyd and Mao's proposal that protocols should be robust in the sense that "authentication of any message in the protocol depends only on information contained in the message itself or already in the possession of the recipient" <ref type="bibr" target="#b2">[3]</ref>. An operational variant on this theme appears in the work of Woo and Lam, who call a protocol full information if "its initiator and responder always include in their outgoing encrypted messages all the information they have gathered" [33].</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Appropriate action</head><p>For a message to be acted upon, it not merely has to be understood but a whole variety of other conditions have to hold too. These often consist of what may informally be regarded as statements of trust, though this anthropomorphic notion should be used with care. Statements of trust cannot be wrong though they may be considered inappropriate. For example, if someone believes that choosing session keys should be done by a suitably trusted server rather than by one of the participants in a session, then he will not wish to use a protocol such as the Widemouthed-frog protocol <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle 2</head><p>In general, we have:</p><p>The conditions for a message to be acted upon should be clearly set out so that someone reviewing a design may see whether they are acceptable or not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Secrecy</head><p>The secrecy of certain pieces of information is essential to the functioning of cryptographic protocols. Obviously, a protocol should not publicize the cryptographic keys used for communicating sensitive data.</p><p>None of the our principles makes this point explicitly. Rather, all of our principles warn against mistakes that often imply the loss of secrecy, integrity, and authenticity. Some of the examples clarify how the principles relate to the need for secrecy.</p><p>There may be more to say about secrecy guidelines for cryptographic protocols, but these are outside the scope of the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Examples and other principles</head><p>Below we discuss many concrete examples where errors would have been avoided by use of our two basic principles. We also introduce other principles. Some of these are clearly corollaries of the basic ones, others are not. In particular, we recommend:</p><p>Hopefully, the two basic principles will encourage a certain lucidity in the design of cryptographic protocols, and thereby make it easier to follow our other principles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Notation</head><p>We adopt notation common in the literature. That notation is not quite uniform and, in examples, we make compromises between uniformity of this paper and faithfulness to original notation.</p><p>In this paper, the symbols A and B often represent arbitrary principals, S represents a server, T a timestamp, N a nonce (a quantity generated for the purpose of being recent), K a key, and K-' its inverse. In symmetric cryptosystems such as DES, K and K-' are always equal. For asymmetric cryptosystems such as RSA, we assume for simplicity that the inversion operation is an involution (so ~-1 -l equals K ) ; we tend to use K-' for the secret part and K for the public part of a key pair ( K , K-'). We write { X } K to represent X encrypted under K ; anyone who knows { X } K and the inverse of K can obtain X . If K is secret, we may refer to { X } K as a signed message, and to the encryption operation as a signature.</p><p>For example, </p><formula xml:id="formula_0">Message 4 B -+ A : { T a + l</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Naming</head><p>The most immediate instance of Principle 1 prescribes being explicit about names of principals: If the identity of a principal is essential to the meaning of a message, it is prudent to mention the principal's name explicitly in the message.</p><p>The names relevant for a message can sometimes be deduced from other data and from what encryption keys have been applied. However, when this information cannot be deduced, its omission is a blunder with serious consequences.</p><p>The principle is obvious and simple, yet it is commonly ignored. We give several examples of fairly different natures. This third message is encrypted for both secrecy and authenticity. When A sends this message to B , it is important that no other principal obtain K,b; the use of Kb provides this guarantee. f i rthermore, the intent is that, when B receives the message, B should know that A sent it (because of the signature with K;'). Finally, B should know that the message was intended for B (because of the use of K b ) .</p><p>Unfortunately nothing provides this final guarantee, with dramatic consequences. Any principal B with which A opens communication can pretend to a third party C that it actually is A, for the duration of validity of the timestamp.</p><p>For simplicity, we omit the exchanges which yield the public certificates CA, CB, and CC. When</p><p>The protocol is flawed. The connection between the messages is not sufficient. In particular, nothing connects B's query to S with S's reply. The protocol is therefore vulnerable to an attack, as follows. Suppose that B is willing to talk to A and to C roughly at the same time; A may be off-line. Then C can impersonate A:</p><formula xml:id="formula_1">Message 1 C --f B : Message 1' C --f B : Message 2 B -+ A : Message 2' B -+ C : Message 3 C + B : Message 3' C t E : Message 4 B -+ S : Message 4' B -+ S : Message 5 S -+ B : Message 5' S + B :</formula><p>where NF is the result of decrypting { N b } K c , using Kas. In Messages 1 and l', C tells B that both A and C want to establish a connection. In Messages 2 and 2', B replies with two challenges;</p><p>C receives one normally, and captures the other one, which was destined to A's address. In Messages 3 and 3', C replies to both challenges. On A's behalf, it can send anything. On its own behalf, C responds to the challenge intended for A. In Messages 4 and 4', B consults S about the two responses. Messages 5 and 5' are the replies from S. One of these replies matches nothing, while the other one contains the challenge intended for A. On the basis of these replies, then, B must believe that A is present.</p><p>The existence of this attack demonstrates that the messages in the protocol are not sufficiently explicit about the identity of the principals in question. (After we contacted them, Woo and Lam came to the same conclusion Its intent is to allow two principals A and B to obtain a session key, with the mediation of local servers and gateways.</p><p>On the other hand, the fundamental flaw of the protocol is rather simple. One immediately sees that neither A nor B ever receives a message that contains the other's name. Obviously, this opens the door for confusions between different connections. It also allows some easy attacks to defeat the protocol. After we contacted them, the authors published a correction [13], where names appear in messages explicitly. 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Encryption</head><p>The next group of principles and examples concern encryption. They are generally related to Principle 1, since they concern what encryption means and on what it does not mean.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">The uses of encryption</head><p>As the examples below illustrate, encryption is used for a variety of purposes in the present con-</p><formula xml:id="formula_2">text [ 1 91.</formula><p>0 Encryption is sometimes used for the preservation of confidentiality. In such case it is assumed that only intended recipients know the key needed to recover a message. When a principal knows K-' and sees { X ) K , it may deduce that X was intended for a principal who knows K-'; and it may even deduce that X was intended for itself, given additional information.</p><p>0 Encryption is sometimes used to guarantee authenticity. In such case it is assumed that only the proper sender knew the key used to encrypt a message. The encryption clearly contributes to the overall meaning of the message. The extreme situation is that where a principal shows that a key is known by encrypting a null message or a timestamp.</p><p>0 While encryption guarantees confidentiality and authenticity, it also serves in binding together the parts of a message: receiving { X , Y } K is not always the same as receiving { X } K and { Y } K . When encryption is used only to bind parts of a message, signature is sufficient. The meaning attached to this binding is rather protocol-dependent, and often subtle.</p><p>0 Finally, encryption can serve in producing random numbers. There is a vast theory that explains the relation between one-way functions and random-number generators.</p><p>At the level of abstraction that we consider, one typically assumes that random numbers are available without examining how they are constructed (but see Example 7.1).</p><p>There is considerable confusion about the uses and meanings of encryption. If the cryptography is asymmetric it may be obvious what is intended; if the cryptography is symmetric, it is generally not.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle 4</head><p>Be clear as to why encryption is being done. Encryption is not wholly cheap, and not asking precisely why it is being done can lead to redundancy. Encryption is not synonymous with security, and its improper use can lead to errors.  <ref type="bibr" target="#b5">[6]</ref> and in order to reduce the total number of messages required. Like the Needham-Schroeder protocol on which it is based, the Kerberos protocol relies on symmetric-key cryptography. A slightly simplified version of the protocol goes:</p><formula xml:id="formula_3">Message 1 A + S : A , B Message 2 S + A : {T,, L, K a b , B , Message 3 A + B : {T,, L , K a b , A } K~~, Message 4 B + A : { T a + 1 )~~~</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ITS, L, K a b , A } K b , ) K a s { A , Ta}K,t,</head><p>Here, T, and T a are timestamps, and L is a lifetime. Initially the server S shares the keys K a , and Kbs with the principals A and B; after execution, A and B share Kab. This protocol serves to illustrate different uses of encryption; we describe the protocol step by step: Examples 6.1 and 6.2, below, illustrate the interaction of encryption and nonces. In short, encryption is often used for binding when a nonce provides an association between a message and an implicit name. Following Principle 3, we make this missing name explicit. The use of both encryption and nonces is then much simpler and economical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Signing encrypted data</head><p>Signature is used, as the name suggests, to indicate which principal last encrypted a message. It is frequently taken as also guaranteeing that the signing principal knew the message content. It is hard, but fortunately unnecessary to be precise about what knowing is. An informal notion is sufficient for stating the next principle: Principle 5</p><p>When a principal signs material that has already been encrypted, it should not be inferred that the principal knows the content of the message. On the other hand, it is proper to infer that the principal that signs a message and then encrypts it for privacy knows the content of the message.</p><p>Failure to follow this principle can lead to errors, as in the next example. Example 5.1 The CCITT X.509 standard contains a set of three protocols using between one and three messages <ref type="bibr" target="#b4">[5]</ref>. The protocols are intended for signed, secure communication between two principals, assuming that each knows the public key of the other.</p><p>The CCITT proposal has problems. We discuss one problem described in <ref type="bibr" target="#b3">[4]</ref>; it appears already in the one-message protocol:</p><formula xml:id="formula_4">Message 1 A -+ B : A , {Ta, Nay B , X,, {ya)Kb)K;'</formula><p>Here, T, is a timestamps, N , is a nonce (not used), and X , and Y, are user data. The X.509 protocol actually uses hashing to reduce the amount of encryption. We do not show this because it does not affect our argument about X.509.</p><p>The protocol is intended to ensure the integrity of X , and Ya, assuring the recipient of their origin, and to guarantee the privacy of Y,.</p><p>However, although Ya is transferred in a signed message, there is no evidence to suggest that the sender is actually aware of the data sent in the private part of the message. This corresponds to a scenario where some third party intercepts a message and removes the existing signature while adding his own, blindly copying the encrypted section within the signed message. This problem can be avoided by several means, the simplest of which is to sign the secret data before it is encrypted for privacy. 0 A particular case of the principle concerns hash functions: Example 5.2 It is common to use hash functions in order to save on encryption with asymmetrickey systems (see for example <ref type="bibr" target="#b20">[25,</ref><ref type="bibr">103)</ref>. In particular, A can send a signed, confidential message to B as follows:</p><formula xml:id="formula_5">Message 1 A + B : { X } K &amp; , { H ( x ) } K ; l</formula><p>where H is a one-way hash function. When A sends this message, only B discovers X , and B knows that A signed the hash of X . For example,</p><p>if X is a request for an operation, B may then infer that A supports X . We should think of oneway hashing as encryption, and then Principle 5 applies. In this instance, it means that B cannot be certain that A knew X . For example, if X is a secret such as a password, B cannot be certain that A knew the secret; A may have received H ( X ) from a friend. 0</p><p>In general, we recommend careful examination of those protocols that require a principal to sign material that is already encrypted, and such that the principal cannot decrypt it. On the other hand, signing before encrypting is not a bill of health; see Much encryption can be avoided when names are included in S's reply:</p><p>An important part of the meaning of a message is made up of temporal information. Further, one common precondition for acting upon a message is that there is reason to believe that the message is fresh, and hence not a replay of an old one. This has to be inferred from something in the message, and evidently whatever this is should be bound together with the rest of the message so that the magic talisman cannot be attached to a message being replayed. It is important to understand properly how the freshness component works, and what is being assumed about it.</p><p>The next group of principles and examples concern time. They all address what must be assumed about proofs of timeliness, and what they actually prove.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Timestamps, sequence numbers, and other nonces</head><p>When guarding against replay of messages from an earlier run of the same protocol it is common to use nonces as part of a challenge-response exchange. A message is sent which leads to a reply which could only have been produced in knowledge of the first message. The objective is to guarantee that the second message is made after the first was sent, and sometimes to bind the two together. There is sometimes confusion about nonces-are they guaranteed new, random, unpredictable? Whence we propose:  <ref type="figure">A : {Na, A, B</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, Kab}Ka,</head><p>The protocol is not only more efficient but also conceptually simpler after this modification. 0 Example 6.2 Example 3.2 describes a protocol due to Woo and Lam. Looking back at the use of encryption in that protocol, we notice that the purpose of encryption in Message 4 is to bind two parts of a message. Looking back at the use of nonces, we notice that Nb provides only a proof of freshness, but not an association to the name A as was intended.</p><p>As we argue in Example 3.2, Message 5 should mention the name A explicitly for the sake of security. With that change, the binding of Message 4 becomes unnecessary. Further, Nb needs to be viewed only as a proof of freshness. The protocol is now simply: It is not essential for nonces to be unpredictable. In fact, the value of a counter makes a proper nonce. However, predictable nonces should be used with caution:</p><formula xml:id="formula_6">Message 1 A --t B : A Message 2 B -+ A : Nb Message 3 A -+ B : {Nb}K,,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle 7</head><p>The use of a predictable quantity (such as the value of a counter) can serve in guaranteeing newness, through a challengeresponse exchange. But if a predictable quantity is to be effective, it should be protected so that an intruder cannot simulate a challenge and later replay a response.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 7.1 Protocols that rely on synchro-</head><p>nized clocks must be accompanied by protocols to access time servers. These protocols cannot themselves rely on synchronized clocks, but they can rely either on random nonces or on predictable nonces.</p><p>Using random nonces, we may have: This protocol would not work if N, were predictable. An attacker C could make A set its clock back: early on, C makes a request for the current time using a future value of the nonce, saves S's response, and then forwards the response to A when A uses this value in a challenge.</p><formula xml:id="formula_7">Message</formula><p>When N, is predictable, it should be protected:</p><p>Message 1 A -+ S : A, { N a }~, .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Message 2 S -+ A : {T,, { N~) K , , ) K , .</head><p>The attack is no longer possible. Note that it is not important for N, to remain secret (and after all we have assumed it is predictable). The encryption in Message 1 serves to construct a quantity {N,}K,, that only A and S can predict from one that anyone can predict.</p><p>A similar exchange arises in the context of Kerberos. Neuman and Stubblebine suggest using Kerberos itself to obtain the time from a time server <ref type="bibr" target="#b13">[22]</ref>. The quantity used as a nonce is roughly predictable: it is an incorrect timestamp; since it is encrypted, we expect no difficulties. 0 Freshness can also be proved by the use of timestamps. Timestamps are appealing because they seem easier to use than random numbers. However, their use is not always correct. There are number of aspects of prudent practice in the use of timestamps, and they are often misunderstood. One use of timestamps is as a kind of nonce. In this case the ultimate user of the timestamp, as part of a response, is the same as the originator of the challenge of which the timestamp was part. This style of use does not depend on clock synchronization at all, but does need care because the timestamp may be to a large extent predictable. Another style of use does depend on clock synchronization. The recipient of a message looks at a timestamp in it, and only accepts the message if the timestamp is within a reasonable interval of the recipient's local time. In this case we have:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle 8</head><p>If timestamps are used as freshness guarantees by reference to absolute time, then the difference between local clocks at various machines must be much less than the allowable age of a message deemed to be valid. Furthermore, the time maintenance mechanism everywhere becomes part of the trusted computing base.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 8.1</head><p>Timestamps have received abundant attention in the authentication literature. Gong, in particular, has described problems arising from the use of incorrect timestamps <ref type="bibr" target="#b7">[8]</ref>. Therefore, we keep this example brief, summarizing Gong's example for the Kerberos system.</p><p>In Kerberos, as elsewhere, a principal with a slow clock is exposed to all sorts of difficulties, since the principal may mistake expired certificates for current ones. It is more interesting that a fast clock can also be an opportunity for attackers. If a principal A signs a request at time TO using a timestamp T, with To &lt; T , an attacker C can replay this request near time T. The effect of the request at time T may benefit C , for example if C is using A's workstation at time T .</p><p>Bellovin and Merritt have discussed further problems in Kerberos, some of them in the use of timestamps. 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">What is fresh: use vs. generation</head><p>Roughly, a bit-pattern is fresh if any message that contains it must be recent. Clearly, it does not suffice that the bit-pattern participate in one recent message, if it may also participate in old ones. This observation is most important for keys: Principle 9</p><p>A key may have been used recently, for example to encrypt a nonce, yet be quite old, and possibly compromised. Recent use does not make the key look any better than it would otherwise. Having obtained Kbs, B is able to verify using Tb that S has replied to a fresh message, so that the session key is indeed fresh.</p><p>However, B obtains no proof that Kbs is fresh. All that B can deduce is that Kbs has been used recently-but it may be an old, compromised key. 0</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Recognizing messages and encodings</head><p>It seems important that principals recognize messages for what they are, and can associate them correctly with the current step of whatever protocol they are executing. There are two possible forms of confusion (which could in principle happen together): between the current message and a message of similar purpose form a previous run of the protocol, and between the current message and a message belonging elsewhere in the protocol, or to another protocol. Snekkenes <ref type="bibr" target="#b22">[27]</ref> and Syverson <ref type="bibr">[28]</ref> have constructed examples of protocols where these confusions can arise.</p><p>We believe that these confusions are less important when all our principles are correctly followed. If a message says what it means then we have no reason to be concerned with its context. The message is meaningful (or meaningless) on its own, whether we know that it belongs in a particular protocol instance or not.</p><p>Still, mapping a message to the appropriate protocol instance is convenient when it contributes to the compact encoding of the message.</p><p>For example, Message 1 of the Wide-mouthedfrog protocol always means something of the form: "the signer (with key Ka3) says at time T, that &amp;b is a good key to talk to B" (see Example 11.2). If the principal who receives a message can be certain that the message is Message 1 of an instance of the Wide-mouthed-frog protocol, then the message can be encoded com-</p><p>We arrive at the following recommendation: pactly: {Ta, B , Kab}K,,-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle 10</head><p>If an encoding is used to present the meaning of a message, then it should be possible to tell which encoding is being used. In the common case where the encoding is protocol dependent, it should be possible to deduce that the message belongs to this protocol, and in fact to a particular run of the protocol, and to know its number in the protocol.</p><p>Mapping a message to the appropriate protocol instance is often trivial if the message obeys our other principles. If the message contains sufficient timeliness guarantees and sufficient names, then the current instance cannot be confused with an old instance, or an instance for other principals. It could be confused with a concurrent instance for the same principals.</p><p>Next we give an example where this principle is relevant, but where other more important principles apply as well. Example 10.1 If signature or confidentiality are mediated by symmetric-key encryption then a particular form of confusion is associated with the direction in which a message is intended to pass.</p><p>In The purpose of incrementing a nonce has often been misunderstood. For example, a "+1" operation appears in Kerberos, where it is unnecessary. The messages would be clearer if they were rewritten: Guided by the principle that messages should say what they mean, however, we ought to rewrite the messages:  <ref type="bibr">[l]</ref>: if principal A appears on the ACL for an operation then A is trusted when it says that the operation should be performed (that is, when it makes a request). It</p><formula xml:id="formula_8">Message 4 B + A : Nb, { B</formula><p>The use of timestamps makes explicit for the first time a question of trust. When can a principal A rely on another principal B putting a correct timestamp in a message? The answer usually given is that this is acceptable if A trusts B in relation to timestamps. The idea of trust is pervasive and a little elusive. A careful classification of types of trust is given in <ref type="bibr" target="#b31">[34]</ref> and is taken further by Klein in her doctoral thesis. There are questions both of practice and philosophy to do with trust relations-for example whether they are transitive or not-which it would not be appropriate to pursue here. We may simply say that A trusts B in regard to some function if a loss of security to A could follow from B not behaving in the specified way; it is usually difficult or impossible for A to verify B's good behavior.</p><p>There is some measure of trust involved whenever one principal acts on the content of a message from another. It is essential that this trust be properly understood.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Principle 11</head><p>The protocol designer should know which trust relations his protocol depends on, and why the dependence is necessary. The reasons for particular trust relations being acceptable should be explicit though they will be founded on judgement and policy rather than on logic.</p><p>Example 11.1 Complete loss of security could follow from a Kerberos server issuing wrong timestamps. The server, and its source of time, must be trusted by all concerned. This, it may be pointed out, is a case in which clients can to some extent monitor the good behavior of the trusted server because the correct time is public and global. If a client reads GPS time it will have reason for suspicion if Kerberos' time is much at variance. 0 Example 11.2 The Wide-mouthed-frog protocol uses symmetric-key cryptography and an authentication server. It transfers a key from A to can be a complex matter to determine whether the statement of trust that the ACL represents is appropriate. Often, the question of whether it is appropriate makes little sense, particularly in the context of completely discretionary access control policies. Nonetheless, understanding ACL's and their consequences is crucial for security. 0</p><p>In practice it is not very common for complicated inferences about trust to be necessary. With the exception of the chains of trust of Example 11.3, which are likely to be simpler in practice than they might be in theory, it is usually not difficult to isolate the trust relations being relied on in a particular circumstance. It is valuable to do so explicitly, because this may lead to useful debate about the appropriateness of these trust relations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusion</head><p>We have found the principles and examples described in this paper useful in our own work. Perhaps it is because of this that they bear a certain subjective character. We do however believe that they respond to an immediate general need, in a discipline where some basic mistakes appear in print several times.</p><p>Many of our suggestions can be embodied in development methods and in formalisms. While these are helpful, we tried to emphasize an informal understanding of some issues essential for security. We hope that our guidelines will contribute to the improvement of the practice of designing cryptographic protocols.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3 . 1</head><label>31</label><figDesc>In [6, p. 5351, Denning and Sacco propose a protocol for key exchange based on an asymmetric cryptosystem. In the first two messages of this protocol, A obtains certificates CA and CB that connect A and B with their public keys K, and Kb, respectively. The exact form of CA and CB is not important for our purposes. The interesting part of the protocol is Message 3. There, A sends to B a key Kat, for subsequent encrypted communication between A and B , with a timestamp T,. The protocol is: Message 1 A -+ S : A, B Message 2 S -+ A : CA, CB Message 3 A + B : CA, CB, { { K a b , T a )~, -l }Kb</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>[33].) Reasoning as in Example 3.1, we may remove the flaw, by changing the last message of the protocol to A further change is discussed in Example 6.2. 0 Example 3.3 A more dramatic example is provided by the basic Internet protocol of Lu and Sundareshan [12, pp. 1016-10171. This protocol is rather complicated for a detailed description.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Example 4 . 1</head><label>41</label><figDesc>The Kerberos protocol [16] is based on the original Needham-Schroeder protocol [20], but makes use of timestamps as nonces in order to remove flaws demonstrated by Denning and Sacco</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Message 1 A + B : M , A, B , Message 2 B +. S : M , A, B , {Na 7 M , A, B } Kas {Na, M , A, B } K ,~, {Nb, M , A, B}Kb. {Nb, Kab}Kbs Message 3 s + B : hf, {Na, Kab}KaS, Message 4 B + A : M , {Na, Kab}Ka, This is the first protocol analyzed in [4]. Perhaps because of our relative inexperience, we were rather bold in the idealization of this protocol-in assigning meanings to these messages. As a consequence, we suggested in passing that the encryption of Nb in Message 2 is unnecessary. As Mao and Boyd have since explained in detail [14], the encryption of Na and Nb is essential: because Na and Nb are bound with the names A and B by encryption in Messages 1 and 2, they can serve as secure references to A and B in Messages 3 and 4. Encryption is being used not for secrecy, but for binding; nonces are exploited not only as proofs of timeliness but as substitutes for names.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Message 4 B</head><label>4</label><figDesc>--t s : A , {Nb}K,, Message 5 s + B : { A , Nb}Kbs 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>1 A + S : A, N, Message 2 S --f A : {T,, N a }~, , where T, is the current time and N, is a random nonce, used as a challenge. After this exchange, A accepts T, as the current time if the response arrived reasonably soon after the challenge. Reiter exploits random nonces roughly in this manner [24].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Example 9 . 1</head><label>91</label><figDesc>The Needham-Schroeder protocol and the Kerberos protocol are similar in structure and in goal; the Needham-Schroeder protocol reads:Message 1 A + S : A, B , N, Message 2 S --f A : {N,, B ,Kab, Message 3 A + B : {Kab, A } K~, Message 4 B --+ A : {Nb}Kab Message 5 A + B : {Nb + l }~,~ {Kab, As in Kerberos, only A makes contact with S, who provides A with the session key, Kab, and a certificate encrypted with B's key Kbs conveying the session key to B. Then B decrypts this certificate and carries out a nonce handshake with A to be assured that A is present currently, since the certificate might have been a replay. As explained in Section 7, Message 5 contains Nb + 1 rather than Nb in order to distinguish this message from Message 4. Messages 4 and 5 of the Needham-Schroeder protocol were intended to convince B that A is present and active. They do not (and in fact were not intended to) convince B that Kab is fresh, and it was pointed out by Denning and Sacco that compromise of a session key could allow an intruder to deceive B [6]. Once the importance of freshness of Kab is recognized, a solution may be found by using timestamps, as suggested by Denning and Sacco. In another solution, described in [21], B send a nonce to S, and then S includes it in its certificate. 0Example 9.2 In [29], Varadharajan, Allen, and Black present several protocols for delegation in distributed systems. We take as an example the one for delegation in a Kerberos environment [29, p. 2731. In this protocol, client B shares the key Kbt with the authentication server; B has generated a timestamp Tb and wants a key Kbs to communicate with another server S. The authentication server gives Kbs and {Kbs)Kbt to s. Then S constructs {Tb + l }~~~, and sends: Message 5 S + B : s, B , {Tb + 1 )~~~~ { K b s ) K b t The authors reason:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>the Needham-Schroeder protocol, a participant sends a challenge Nb and receives Nb + 1 as a response (see Example 9.1): Message 4 B ---f A : { N b } K a b Message 5 A ---t B : {Nb + 1 )~~~ The purpose of incrementing Nb is to distinguish the challenge from the response. Without this increment, an attacker could send B's message back to B , who could mistake it for A's reply.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Message 4 B</head><label>4</label><figDesc>+ A : {N-S Message 4: N b } K a b Message 5 A + B : {N-S Message 5: Nb}Kab though in fact any way of making the two messages different will do. (This is an instance of our suggestion to Syverson mentioned in [28].)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>6], Lu and Sundareshan [la],</head><label></label><figDesc>). Other examples are new: protocols by Denning and Sacco [</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>A Message 2 B -+ A : Nb Message 3 A + B : { N b } K a s Message 5 S + B : { N b } K b S Message B : { A , { N b ) K a , } K b a Here Nb is</head><label></label><figDesc>a nonce, S is a server, and K,, and Kbs are keys that A and B share with S.</figDesc><table><row><cell>Principle 3</cell><cell>A opens communication with B ,</cell></row><row><cell></cell><cell>Message 3 A -+ B : CA, CB,</cell></row><row><cell></cell><cell>{ { K a b , T a ) K ; l } K b</cell></row><row><cell></cell><cell>B removes the outer encryption, reencrypts with</cell></row><row><cell></cell><cell>K,, sends:</cell></row><row><cell></cell><cell>Message 3' B -+ C : CA, CC,</cell></row><row><cell></cell><cell>{ { K a b , T o ) K , -~} K ,</cell></row><row><cell></cell><cell>and C will believe that the message is from A.</cell></row><row><cell></cell><cell>In particular, C might send sensitive information</cell></row><row><cell></cell><cell>under K,b, and B may see it when perhaps only</cell></row><row><cell></cell><cell>A should.</cell></row><row><cell></cell><cell>The intended meaning of Message 3 is roughly</cell></row><row><cell></cell><cell>"At time T,, A says that Kab is a good key for</cell></row><row><cell></cell><cell>communication between A and B". Any ade-</cell></row><row><cell></cell><cell>quate format for Message 3 should contain all of</cell></row><row><cell></cell><cell>these elements expressly or by implication. The</cell></row><row><cell></cell><cell>obvious one is:</cell></row><row><cell></cell><cell>Message 3 A -+ B : CA, CB,</cell></row><row><cell></cell><cell>{ { A , Kab, % }~, -l } K b</cell></row><row><cell></cell><cell>although the name A might be deducible from</cell></row><row><cell></cell><cell>KL1. It is important that this format must not</cell></row><row><cell></cell><cell>be used for anything else; we return to this point</cell></row><row><cell></cell><cell>in Section 7. 0</cell></row><row><cell></cell><cell>Example 3.2 In [32, pp. 42-43], Woo and</cell></row><row><cell></cell><cell>Lam present an authentication protocol based on</cell></row><row><cell></cell><cell>symmetric-key cryptography. When B wants to</cell></row><row><cell></cell><cell>check that it is in A's presence, it runs:</cell></row><row><cell></cell><cell>Message 1 A -+ B : Basi-</cell></row><row><cell></cell><cell>cally, A claims his identity (Message l); B pro-</cell></row><row><cell></cell><cell>vides a nonce challenge (Message 2); A returns</cell></row><row><cell></cell><cell>this challenge encrypted under K,, (Message 3);</cell></row><row><cell></cell><cell>B passes this message on to S for verification,</cell></row><row><cell></cell><cell>bound with A's name under Kb, (Message 4); S</cell></row><row><cell></cell><cell>decrypts using A's key and reencrypts under B's</cell></row><row><cell></cell><cell>(Message 5 ) . If S replies { N b } K b s , then B should</cell></row><row><cell></cell><cell>be convinced that A has responded to the chal-</cell></row><row><cell></cell><cell>lenge Nb.</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Encryption is not essential for Message 1. Without encryption, though, an attacker can flood S with requests for keys, by falsifying instances of Message l. It is common for designers not to focus on this sort of vulnerability. this case, the second part of Message 3 could be omitted altogether, and B could use T, in Message 4. (Were we to propose a change in Kerberos, however, it would not be removing an encryption in Message 3 but rather eliminating the double encryption in Message 2, which would become</figDesc><table><row><cell>In i T S ,</cell></row></table><note>00 Message 2 requires encryption: Kab should remain confidential, and S should sign the message as a proof of authenticity.0 We may however question why double en- cryption is used in Message 2. Most prob- ably, this use of double encryption is sim- ply inherited from the Needham-Schroeder protocol (see Example 9.1). As in that pro- tocol, double encryption does not add any- thing from the points of view of confiden- tiality or authenticity, and it is not entirely free of cost. It does provide a guarantee: when B re- ceives the first part of Message 3, it knows that A must have extracted it from Mes- sage 2, and hence that A must have looked a similar use of encryption in a variant of the Otway-Rees protocol [23].) This interpreta- tion of encryption is sound, but slightly un- usual, and probably not what the protocol designers had in mind.at Message 2. (Heintze and Tygar [9] d' lSCUSS0 In the second part of Message 3, encryp- tion is used for an entirely different purpose: A encrypts Ta with Kab in order to prove knowledge of Kab near time T'.In general, Ta may be a few hours newer than T,. However, if Ta is not much dif- ferent from T,, the encryption is redundant: the use of double encryption in Message 2 gives adequate proof of knowledge of Kab.L, K a b , B}Kas, {Z, L, K a b , A}Kbb*)0 The encryption in Message 4 serves an anal- ogous purpose.0</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>Otway and Rees describe the following protocol. It allows two parties A and B to establish a shared key Kab, with the help of a server S with whom they share keys K,, and KbS, respectively, using the nonces M ,</figDesc><table><row><cell>Principle 6</cell></row><row><cell>Be clear what properties you are assuming</cell></row><row><cell>about nonces. What may do for ensuring</cell></row><row><cell>temporal succession may not do for ensuring</cell></row><row><cell>association-and perhaps association is best</cell></row><row><cell>established by other means.</cell></row></table><note>Example 6.1 In [23],Message 1 A + B : A, B , Na Message 2 B + S : A, B , N,, Nb Message 3 S + B : {Nay A, B , Kab}Kas, { Nb 7 A, B Kab } Kbs Message 4 B +</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>First, A sends a session key Kab to S, including a timestamp T,. Then S checks T, and forwards the message to B , together with its own timestamp T,. Finally, B checks T, and accepts the session key Kab for communication with A. the principal that owns it. Since there is no global source of authority, it is not surprising that this is an area where questions of transitivity of trust come up. It may happen that the only way A can find out B's public key is by accepting a certificate from CA1 for CAP'S public key which is used to sign a certificate for CAS'S public key . . . which is used to sign a certificate for B's public key, for example. In this case A knows and trusts CA1 but has never heard of the other certification authorities-and maybe even distrusts them. It is usually taken for granted that the two principals in an authentication dialogue are honestly working to the common end of establishing a secure communication channel for subsequent use. This is not always the case, as may be seen in communication between potential enemies or between security forces and terrorists. Possible sorts of bad behavior are disclosure of keys and forgery of messages. Therefore, if this assumption is made in a particular case then it should be explicit. An access control list (ACL) is a statement of trust</figDesc><table><row><cell>8 Trust</cell><cell cols="2">B via S in only two messages:</cell></row><row><cell></cell><cell cols="2">Message 1 A + S : A, {"a, B , K a b } K , .</cell></row><row><cell></cell><cell cols="2">Message 2 S -+ ? : {T,, A, K a b } K b s</cell></row><row><cell></cell><cell cols="2">Thus, A is trusted to choose a session key. This</cell></row><row><cell></cell><cell cols="2">kind of trust is often thought unacceptable be-</cell></row><row><cell></cell><cell cols="2">cause of the quality requirements placed on key</cell></row><row><cell></cell><cell cols="2">generation such as secrecy, non-repetition, un-</cell></row><row><cell></cell><cell cols="2">predictability, and doubtless more. 0</cell></row><row><cell></cell><cell cols="2">Example 11.3 Principals associate public keys</cell></row><row><cell></cell><cell cols="2">with other principals by consulting public-key</cell></row><row><cell></cell><cell cols="2">certificates. These certificates can be issued by</cell></row><row><cell></cell><cell cols="2">certification authorities (CAS). CAS are trusted</cell></row><row><cell></cell><cell cols="2">to certify a key only after proper steps have been</cell></row><row><cell></cell><cell>taken to identify</cell></row><row><cell></cell><cell></cell><cell>says that Kab is</cell></row><row><cell></cell><cell cols="2">a good key to talk to A, sometime</cell></row><row><cell></cell><cell cols="2">after receiving K a b } K a b</cell></row><row><cell></cell><cell>Message 5 A + B :</cell><cell>{ A says that K,b is</cell></row><row><cell></cell><cell cols="2">a good key to talk to B , sometime</cell></row><row><cell></cell><cell cols="2">after receiving Nb}Kab</cell></row><row><cell></cell><cell cols="2">Of course, shorter encodings of these meanings</cell></row><row><cell></cell><cell cols="2">can be constructed. Not only there is no risk of</cell></row><row><cell></cell><cell cols="2">confusion between these two messages: each of</cell></row><row><cell></cell><cell cols="2">them is self-contained, and it is not important to</cell></row><row><cell></cell><cell cols="2">know that they are part of a particular instance</cell></row><row><cell></cell><cell cols="2">of the Needham-Schroeder exchange. U</cell></row></table><note>0 Example 11.40 Example 11.5</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="0">Be clear on how encryption is used, and on the meaning of encryption.0 Be clear on how the timeliness of messages is proved, and on the meaning of temporal information in messages.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We have benefited from discussions with Mike Burrows and Butler Lampson. In particular, we discovered many of the examples in this paper in collaboration with Mike Burrows. The authors of the papers from which we drew our examples have also been helpful.</p><p>Raphael Yahalom, Michael Reiter, and anonymous referees all made useful comments on earlier versions of this paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A Calculus for Access Control in Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Plotkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Programming Languages and Systems</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="706" to="734" />
			<date type="published" when="1993-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Limitations of the Kerberos Authentication System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Bellovin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Merritt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Communication Review</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="119" to="132" />
			<date type="published" when="1990-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Limitations of Logical Analysis of Cryptographic Protocols. Eurocrypt &apos;93</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Boyd</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Mao</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>to appear</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A Logic of Authentication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">A preliminary version appeared as Digital Equipment Corporation Systems Research Center report</title>
		<imprint>
			<date type="published" when="1989-02" />
			<biblScope unit="volume">426</biblScope>
			<biblScope unit="page" from="233" to="271" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Recommendation X.509 and IS0 9594-8: The Directory-Authentication Framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ccitt</forename><surname>Ccitt Blue</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Book</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988-03" />
			<pubPlace>Geneva</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">E</forename><surname>Denning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Sacco</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Timestamps in Key Distribution Protocols. CACM</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="533" to="536" />
			<date type="published" when="1981-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Zero Knowledge Proofs of Identity</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Feige</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fiat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing</title>
		<meeting>the Nineteenth Annual ACM Symposium on Theory of Computing</meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="210" to="217" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Security Risk of Depending on Synchronized Clocks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Gong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="54" />
			<date type="published" when="1992-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Timed Models for Protocol Security. CMU Technical Report CMU-CS-92-100</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Heintze</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Tygar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Authentication in Distributed Systems: Theory and practice</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wobber</surname></persName>
		</author>
		<imprint>
			<publisher>ACM</publisher>
			<pubPlace>Trans</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Encryption for Authentication in Large Net</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Using actions on Computer Systems</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="993" to="999" />
			<date type="published" when="1978-12" />
		</imprint>
	</monogr>
	<note>works of Computers. CACM</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Authentication in Distributed Systems: A BibliOgraPhY-Operating Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">M</forename><surname>Liebl ; R</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">D</forename><surname>Needham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Au-Review</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="31" to="41" />
			<date type="published" when="1993-10" />
		</imprint>
	</monogr>
	<note>thentication Revisited. Operating Systems</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Sundareshan* Secure Communication in Internet Environments: A Hierarchical Key Management Scheme for End-To-End Encryption</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M*k</forename><surname>Lu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="1014" to="1023" />
			<date type="published" when="1989-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Note on the Use of Timestamps as Nonces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Neuman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Stubblebine</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Operating Systems Review</title>
		<imprint>
			<date type="published" when="1993-04" />
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="10" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient and Timely Mutual Authentication</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Otway</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rees</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="8" to="10" />
			<date type="published" when="1987-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Enhanced Protocols for Hierarchical Encryption Key Management for Secure Communication in</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">P</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Sundareshan</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Cor-ne11 University. Available as Technical Re-Internet Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">K</forename><surname>Reiter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="658" to="660" />
			<date type="published" when="1992-04" />
		</imprint>
	</monogr>
	<note type="report_type">Ph.D. Thesis</note>
	<note>A Security Architecture for Fault-Tolerant Systems</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Towards Formal port 93-1367</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Mao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Boyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ings of the Computer Security Foundations Workshop VU</title>
		<imprint>
			<date type="published" when="1993-07" />
			<biblScope unit="page" from="147" to="158" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Sci-Analysis of Security Protocols. Proceedence, Cornel1 University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">NetCash: A Design for Practical Electronic Currency on the Internet</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Medvinsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Neuman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1993 ACM Conference on Computer and Communications Security</title>
		<meeting>the 1993 ACM Conference on Computer and Communications Security</meeting>
		<imprint>
			<biblScope unit="page" from="102" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Kerberos Authentication and Authorization System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Neuman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">I</forename><surname>Schiller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Saltzer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
	<note>Project Athena Technical Plan Section E.2.1, MIT</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The MD4 Message Digest Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Rivest</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in Cryptology: Crypto &apos;90</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="303" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A Method for Obtaining Digital Signatures and Public-key Cryptosystems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Rivest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Shamir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Adleman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="120" to="126" />
			<date type="published" when="1978-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Roles in Cryptographic Protocols</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Snekkenes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1992 IEEE Symposium on Security and Privacy</title>
		<meeting>the 1992 IEEE Symposium on Security and Privacy</meeting>
		<imprint>
			<biblScope unit="page" from="105" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Protocol Failures in Cryptosysterns* Of the IEEE 76</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Moore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">cols for Repeated Authentication. Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="594" to="602" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
	<note>Syverson. On Key Distribution Proto-</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">National Bureau of Standards. Data Encryption Standard. FIPS Pub</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="24" to="30" />
			<date type="published" when="1977-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Varadharajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Allen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>An</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Cryptography and Secure Analysis of the Proxy Problem in Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1991 IEEE Symposium on Security and Privacy, Channels. Distributed Systems</title>
		<editor>Ed., S. Mullender</editor>
		<meeting>the 1991 IEEE Symposium on Security and Privacy, Channels. Distributed Systems</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="255" to="275" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">L</forename><surname>Voydock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">T</forename><surname>Kent</surname></persName>
		</author>
		<title level="m">Security Mechanisms in High-Level Network Protocols, Computing Surveys</title>
		<imprint>
			<date type="published" when="1983" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="135" to="171" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Authentication in the Taos Operating System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wobber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Burrows</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lampson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Fourteenth ACM Symposium on Operating System Principles</title>
		<meeting>the Fourteenth ACM Symposium on Operating System Principles</meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="256" to="269" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<title level="m" type="main">Authentication for Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">Y C</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-01" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="39" to="52" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">A Lesson on Authentication Protocol Design</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">Y C</forename><surname>Woo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
	<note>Manuscript</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Trust Relations in Secure Systems-A Distributed Aut hent icat ion Perspective</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yahalom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Beth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1993 IEEE Symposium on Security and Pri-WUCY</title>
		<meeting>the 1993 IEEE Symposium on Security and Pri-WUCY</meeting>
		<imprint>
			<biblScope unit="page" from="150" to="164" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
