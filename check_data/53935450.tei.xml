<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Towards a Hands-Free Query Optimizer through Deep Learning</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Marcus</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Brandeis University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Olga</forename><surname>Papaemmanouil</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Brandeis University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Towards a Hands-Free Query Optimizer through Deep Learning</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:42+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Query optimization remains one of the most important and well-studied problems in database systems. However, traditional query optimizers are complex heuristically-driven systems, requiring large amounts of time to tune for a particular database and requiring even more time to develop and maintain in the first place. In this vision paper, we argue that a new type of query optimizer, based on deep reinforcement learning, can drastically improve on the state-of-the-art. We identify potential complications for future research that integrates deep learning with query optimization, and describe three novel deep learning based approaches that can lead the way to end-to-end learning-based query optimizers.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">INTRODUCTION</head><p>Query optimization, e.g. transforming SQL queries into physical execution plans with good performance, is a critical and well-studied problem in database systems (e.g. <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b30">31,</ref><ref type="bibr" target="#b34">35]</ref>). Despite their long research history, the majority of existing query optimization systems share two problematic properties: 1. They are, or are composed of, carefully tuned and complex heuristics designed using many years of developerbased experience. Furthermore, these heuristics often require even more tuning by expert DBAs to improve query performance on each individual database (e.g. tweaking optimization time cutoffs, adding query hints, updating statistics, tuning optimizer "knobs"). 2. They take a "fire and forget" approach in which the observed performance of a execution plan is never leveraged by the optimization process in the future, hence preventing query optimizers from systematically "learning from their mistakes." Of course, there are several notable exceptions. Many optimizers use feedback from query execution to update cardinality estimates <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b31">32]</ref>, and many adaptive query processing systems <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b33">34]</ref> incorporate feedback as well. However, in this vision paper, we argue that recent advances in deep reinforcement learning (DRL) <ref type="bibr" target="#b1">[2]</ref> can be applied to query optimization, resulting in a "hands-free" optimizer that (1) can tune itself for a particular database automatically without requiring intervention from expert DBAs, and (2) tightly incorporates feedback from past query optimizations and executions in order to improve the performance of query execution plans generated in the future.</p><p>Deep reinforcement learning is a process in which a machine learns a task through continuous feedback with the help of a neural network <ref type="bibr" target="#b27">[28]</ref>. It is a iterative learning process where the machine (an agent) repeatedly selects actions and receives feedback about the quality of the actions selected. DRL algorithms train a neural network model over multiple rounds (episodes), aiming to maximize the performance of their selected actions (policies). This performance feedback, the indicator of whether or not an agent is performing well or poorly, is referred to as the reward signal.</p><p>While deep learning has been previously applied to database systems (e.g. indexes <ref type="bibr" target="#b14">[15]</ref>, physical design <ref type="bibr" target="#b22">[23]</ref>, and entity matching <ref type="bibr" target="#b20">[21]</ref>), deep reinforcement learning has not received much attention. Despite applications in multiple domains <ref type="bibr" target="#b1">[2]</ref>, applying DRL algorithms to query optimization generates a number of research challenges. First, DRL algorithms initially perform very poorly, and require extensive training data before achieving competitive performance. Second, it is generally assumed that that the reward signal is cheap to calculate. In query optimization, the most natural performance indicator to use is the query latency. However, training on (and hence executing) large numbers of query plans (especially poorly optimized query plans) and collecting their latency for feedback as a reward signal to a DRL agent can be extremely expensive. Using the optimizer's cost model as a performance indicator is also problematic, as cost models are themselves complex, brittle, and often rely on inaccurate statistics and oversimplified assumptions.</p><p>Second, the enormous size of the query plan search space for any given query causes naive applications of DRL to fail. For instance, while DRL can be used to learn policies that tackle join order enumeration <ref type="bibr" target="#b17">[18]</ref>, training these models to additionally capture physical operator and access path selection dramatically lengthens the training process and hinders convergence to an effective policy.</p><p>In this vision paper, we describe and analyze potential solutions to the above challenges, each representing directions for further research that tightly integrates deep learningbased theory with query optimization. We propose two novel DRL approaches: learning from demonstration and cost model bootstrapping. The first approach involves ini-tially training a model to imitate the behavior of a stateof-the-art query optimizer, and then fine-tuning that model for increased performance. The second approach involves using existing cost models as guides to help DRL models learn more quickly. Finally, we propose and analyze the design space of an incremental training approach that involves learning the complexities of query optimization in a step-by-step fashion.</p><p>We start in Section 2 with an brief introduction to DRL and an overview of a case study DRL-based join enumerator in Section 3. In Section 4, we detail the three main challenges that DRL-based query optimizers need to overcome.</p><p>In Section 5, we analyze our proposed future research directions, and we conclude in Section 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">DEEP REINFORCEMENT LEARNING</head><p>Reinforcement Learning (RL) <ref type="bibr" target="#b35">[36]</ref> is a machine learning technique that enables an agent to learn in an interactive environment by trial and error using feedback from its own actions and experiences. More formally, an agent interacts with an environment. The environment tells the agent its current state, st, and a set of potential actions At = {a0, a1, . . . , an} that the agent may perform. The agent selects an action a ∈ At, and the environment gives the agent a reward rt based on that action. The environment additionally gives the agent a new state st+1 and a new action set At+1. This process repeats until the agent reaches a terminal state, where no more actions are available. This marks the end of an episode, after which a new episode begins. The agent's goal is to maximize its reward over episodes by learning from its experience (previous actions, states, and rewards). This is achieved by balancing the exploration of new never-before-tried actions with the exploitation of knowledge collected from past actions. Policy Gradient One subset of reinforcement learning techniques is policy gradient methods <ref type="bibr" target="#b36">[37]</ref>. Here the agents select actions based on a parameterized policy π θ , where θ is a vector that represents the policy parameters. Given a state st and an action set At, the policy π θ outputs one of the potential actions from At.</p><p>Reinforcement learning aims to optimize the policy π θ over episodes, i.e., to identify the policy parameters θ that optimizes the expected reward. The expected reward that a policy will receive per episode is denoted Jπ(θ). A reinforcement learning agent thus seeks the vector θ that maximizes the reward Jπ(θ), but the reward Jπ(θ) is typically not feasible to precisely compute. Hence, policy gradient methods search for such a vector θ by constructing an estimator E of the gradient of the expected reward: E(θ) ≈ ∇ θ Jπ(θ).</p><p>Real-world applications require that any change to the policy parameterization has to be smooth, as drastic changes can (1) be hazardous for the system and (2) cause the policy to fluctuate too severely, without ever converging. For these reasons, given an estimate E, gradient ascent/descent methods <ref type="bibr" target="#b24">[25]</ref> tune the initial parameters θ by increasing each parameter in θi by a small value when the gradient ∇ θ i Jπ(θ) is positive (the positive gradient indicates that a larger value of θi will increase the reward), and decreasing the parameters in θi by a small value when the gradient is negative. Deep Reinforcement Learning In DRL, policy gradient deep learning methods (e.g., <ref type="bibr" target="#b28">[29,</ref><ref type="bibr" target="#b29">30]</ref>) represent the policy π θ as a neural network, where θ is the network weights. The policy is improved by adjusting the weights of the network based on the reward signal from the environment. Here, the neural network receives as input a representation of the current state, and transforms it through a number of hidden layers. Each layer transforms (through an activation function) its input data and and passes its output to the subsequent layer. Eventually, data is passed to the final action layer. Each neuron in the action layer represents an action, and these outputs are normalized to form a probability distribution. The policy selects actions by sampling from this probability distribution, aiming to balance exploration and exploitation. Selecting the mode of the distribution instead of sampling from the distribution would represent a pure exploitation strategy. Choosing an action uniformally at random would represent a pure exploration strategy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">CASE STUDY: REJOIN</head><p>One of the key challenges in applying RL to a particular domain is "massaging" the problem into the terms of reinforcement learning (i.e., designing its actions, states, and rewards). In this section, we present a case study of Re-JOIN, a deep reinforcement learning join order enumerator. We first give a brief overview 1 of ReJOIN, and highlight key experimental results. While ReJOIN focused exclusively on join order enumeration (it did not perform operator or index selection), it represents an example of how query optimization may be framed in the terms of reinforcement learning. Overview ReJOIN performs join ordering in a bottom-up fashion, modeling the problem in the terms of reinforcement learning. Each query sent to the optimizer represents an episode, and ReJOIN learns over multiple episodes (i.e., continuously learning as queries are sent). Each state represents subtrees of a binary join tree, in addition to information about query join and selection predicates. Each action represents combining two subtrees together into a single tree. A subtree can represent either an input relation or a join between subtrees. The episode ends when all input relations are joined (a terminal state). At this point, ReJOIN assigns a reward to the final join ordering based on the optimizer's cost model. The final join ordering is sent to the optimizer to perform operator selection, index selection, etc., and the final physical plan is executed.</p><p>Intuitively, ReJOIN uses a neural network to iteratively build up a join order. When the optimizer's cost model determines that the resulting query plan (using the join ordering selected by ReJOIN) is good (i.e., a low cost), ReJOIN adjusts its neural network to produce similar join orderings. When the optimizer's cost model determines the resulting plan is bad (i.e., a high cost), ReJOIN adjusts its neural network to produce different join orderings. State and Actions The framework is shown in <ref type="figure">Figure 1</ref>. Formally, given a query q accessing relations r1, r2, . . . , rn, we define the initial state of the episode for q as s1 = {r1, r2, . . . , rn}. This state is expressed as a state vector. This state vector is fed through a neural network, which produces a probability distribution over potential actions. The action set Ai for any state is every unique ordered pair of integers from 1 to |si|, inclusive:</p><formula xml:id="formula_0">Ai = [1, |si|] × [1, |si|].</formula><p>The action (x, y) ∈ Ai represents joining the xth and yth elements of si together. The output of the neural network is used to select an action (i.e., a new join), which is sent back to the environment, which transitions to a new <ref type="bibr" target="#b0">1</ref> Details about ReJOIN can be found in <ref type="bibr" target="#b17">[18]</ref>. </p><formula xml:id="formula_1">si+1 = (si − {si[x], si[y]}) ∪ {si[x] si[y]}.</formula><p>The new state is fed into the neural network. The reward for every nonterminal state (a partial ordering) is zero, and the reward for an action arriving at a terminal state s f (a complete ordering) is the reciprocal of the cost of the join tree t,</p><formula xml:id="formula_2">M (t), represented by s f , 1 M (t) .</formula><p>Periodically, the agent uses its experience to tweak the weights of the neural network, aiming to earn larger rewards. Example <ref type="figure" target="#fig_0">Figure 2</ref> shows an example of this process. Each of the relations in the SQL query are initially treated as subtrees. At each step, the set of possible actions contains every possible pair of subtrees. For example, in <ref type="figure" target="#fig_0">Figure 2</ref>, ReJOIN selects the action <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b2">3]</ref>, so relations A and C are joined. The reward for this action is determined by a DBMS' optimizer cost model. At the next step, ReJOIN selects the action <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b2">3]</ref>, so relations B and D are joined. Finally, the action <ref type="bibr" target="#b0">[1,</ref><ref type="bibr" target="#b1">2]</ref> is selected, and the A C and B D subtrees are joined. The resulting state of the system is a terminal state, as no more actions can be selected. The resulting join ordering is sent to a traditional query optimizer, and the optimizer's cost model is used to determine the quality of the join ordering (the reward). Experimental Results <ref type="figure" target="#fig_2">Figure 3</ref> shows several key experimental results from ReJOIN. <ref type="figure" target="#fig_2">Figure 3a</ref> shows the average performance of ReJOIN compared to PostgreSQL during training. The graph demonstrates that ReJOIN has the ability to learn join orderings that lead to query executions plan with latency close and even better than the ones of Post-greSQL. However, converging to a good model takes time. Even for the "limited" search space of join order enumeration, ReJOIN had to process nearly 9000 queries to become competitive with PostgreSQL. <ref type="figure" target="#fig_2">Figure 3b</ref> shows that the final join orderings selected by ReJOIN (after training) are superior to PostgreSQL according to the optimizer's cost model. While the produced query plans were faster in terms of latency as well <ref type="bibr" target="#b17">[18]</ref>, potential errors in the cost model, and the high human cost of developing and maintaining the cost model, makes directly optimizing for latency much more desirable. <ref type="figure" target="#fig_2">Figure 3c</ref> shows the time required for PostgreSQL and ReJOIN to select a join ordering. Counter-intuitively, ReJOIN's deep reinforcement learning algorithm (after training) is faster than Post-greSQL's built-in join order enumerator in many cases. ReJOIN is, to the best of our knowledge, the first direct application of deep reinforcement learning to query optimization. Another promising work <ref type="bibr" target="#b21">[22]</ref> has examined how deep reinforcement learning can produce embedded representations of substeps of the query optimization process which correlate strongly with cardinality, with an eye towards a more principled deep reinforcement learning powered query optimizer. Even more recent work <ref type="bibr" target="#b15">[16]</ref> demonstrates how a deep Q-learning <ref type="bibr" target="#b19">[20]</ref> approach, with a small amount of pre-training, can perform well when true cardinalities are used as inputs and the optimization target is one of several analytic cost models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">LEARNING-BASED QUERY OPTIMIZA-TION: RESEARCH CHALLENGES</head><p>Inspired by our experience with ReJOIN <ref type="bibr" target="#b17">[18]</ref> as well as other existing work in the area <ref type="bibr" target="#b21">[22]</ref>, we argue that applications of DRL theory to query optimization is both promising and possible. However, we next identify three key research challenges that must be overcome in order to achieve an end-to-end DRL-powered query optimizer. Search Space Size While previous work <ref type="bibr" target="#b17">[18]</ref> has demonstrated that reinforcement learning techniques can find good policies in limited search spaces (e.g., join order enumeration in isolation), the entire search space for execution plans is significantly larger. The ReJOIN prototype required 9000 iterations to become competitive with the PostgreSQL optimizer, and in that case only join ordering was considered (no index or operator selection, etc.). Accounting for operator selection, access path selection, etc. creates such a large search space that approaches from earlier work cannot be easily scaled up. In fact, a naive extension of ReJOIN to cover the entire execution plan search space yielded a model that did not out-perform random choice even with 72 hours of training time. Theoretical results <ref type="bibr" target="#b13">[14]</ref> support this observation, suggesting that adding additional non-trivial dimensions to the problem increases convergence time drastically. Performance Indicator Deep reinforcment learning algorithms generally make several assumptions about the metric to optimize, i.e., the reward signal, that are difficult to guarantee in the context of query optimization. Abstractly, the metric to optimize in query optimization is the latency of the resulting execution plan. However, we next discuss why using latency as a reward signal leads to two unfortunate complications, namely that the query latency offers neither a dense nor a linear reward signal.  Many deep reinforcement learning algorithms <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b28">29]</ref> assume that, or perform substantially better when, the reward signal is dense: provided progressively as the environment is navigated, e.g. each action taken by a reinforcement learning agent achieves some reward. Furthermore, DRL algorithms often assume that rewards are linear, i.e. the algorithms attempt to maximize the sum of many small rewards within an episode. Neither of these assumptions hold in the context of query optimization: query latency is not dense (it can only be measured after a plan has been executed), and it is not linear (e.g., subtrees may be executed in parallel).</p><p>One may reasonably consider using a traditional query optimizer's cost model as a reward signal instead of query latency, as the optimizer's cost model may appear to provide a dense linear reward. This approach has two major drawbacks. First, these cost models tend to be complex, handtuned (by database engineers and DBAs) heuristics. Using a cost model as the reward signal for a DRL query optimizer simply "kicks the can down the road," moving complexity and human effort from designing optimization heuristics to tweaking optimizer cost models. Second, the cost model's estimation of the quality of an execution plan may not always accurately represent the latency of the execution plan (e.g., a query with a high optimizer cost might outperform a query with lower optimizer cost). Therefore, using DRL to find execution plans with a low cost as determined by a cost model might not always achieve the best possible results. Performance Evaluation Overhead An often-unstated assumption made by many DRL algorithms is that the reward of an action can be determined in constant time -e.g., that determining the performance of an agent for a particular episode in which the agent performs poorly is no more time-consuming than calculating the reward for an episode in which the agent performs well. For example, the time to determine the current score of a player in a video game does not change based on whether or not the score is high or low. If the latency of an execution plan is used as a reward signal, this assumption does not hold: poor execution plans can take significantly longer to evaluate than good execution plans (hours vs. seconds). Since traditional DRL algorithms start with no information, their initial policies cannot be better than random choice, which will often result in very poor plans <ref type="bibr" target="#b16">[17]</ref>. Hence, a naive DRL approach that simply uses query latency as the reward signal would take a prohibitive amount of time to converge to good results. <ref type="bibr">2 2</ref> We confirmed this experimentally by using query latency as the reward signal in ReJOIN. The initial query plans produced could not be executed in any reasonable amount of time. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">RESEARCH DIRECTIONS</head><p>Here, we outline potential approaches to handle the challenges we highlighted. First, we discuss two drastically different approaches, demonstration learning and cost-model bootstrapping, which both avoid the pitfalls identified in Section 4 in interesting ways. We then touch upon incremental learning, and propose three techniques that decompose the problem of query optimization in a principled way across various axes, and analyze the resulting design space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Learning From Demonstration</head><p>One way to avoid the pitfalls of using query latency directly as the performance indicator (reward) for DRL algorithms is learning from demonstration (LfD) <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b25">26]</ref>. Intuitively, this approach works by first training a model to imitate the behavior of an expert. Once this mimicry reaches acceptable levels, the model is fine-tuned by applying it to the actual environment. This learn-by-imitation technique mirrors how children learn basic behaviors like language and walking by watching adults, and then fine-tune those behaviors by practicing themselves.</p><p>Here, we propose using a traditional DBMS' query optimizer -such as the PostgreSQL query optimizer -as an expert. In this approach, illustrated in <ref type="figure" target="#fig_3">Figure 4</ref>, a model is initially allowed to observe how the traditional query optimizer (the expert) optimizes a query. During this phase, the model is trained to mimic the optimizer's selected actions (e.g., indexes, join orderings, pruning of bad plans, etc). Assuming that a traditional optimizer will be able to prune-out unfeasible plans, this process allows a DRL model to learn by observing the execution time of only feasible plans.</p><p>Once the model achieves good mimicry, it is then used to optimize queries directly, bypassing the optimizer. In this second phase, the model initially closely matches the actions of the traditional query optimizer, but now begins to slowly fine-tune itself based on the observed query latency. Here, the agent updates its neural network based on the latency of the execution plans it constructs. If the performance of the model begins to slip, it is re-trained to match the traditional query optimizer until performance improves. In practice, choosing the point at which the model is again trained to mimic the traditional query optimizer is critical to improve the performance of the algorithm <ref type="bibr" target="#b10">[11]</ref>. By leveraging learning from demonstration, one can train a query optimization model that learns with small overhead, without having to execute a large number of bad plans, therefore massively accelerating learning.</p><p>While specific techniques and formalizations vary <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b35">36]</ref>, we outline the general process here. 1. A large query workload, W , is executed one query at a time. Each q ∈ W is transformed by the traditional query optimizer into a physical plan through a number of actions ai at various intermediary states si, which are recorded as an episode history:</p><formula xml:id="formula_3">Hq = [(a0, s0), (a1, s1), . . . , (an, sn)]</formula><p>For example, at the initial state s0, a query optimizer performing a greedy bottom-up join order selection process may choose an action a0 signifying that two particular relations should be joined, or a query optimizer that first performs storage selection may choose an action signifying that data for a certain relation should come from a particular index. All episode histories are saved. 2. The resulting physical plans are executed, and the latency of each query q ∈ W , Lq, is measured and saved. 3. Next, the agent is trained, for each q ∈ W , on the Hq and Lq data (Phase 1 in <ref type="figure" target="#fig_3">Figure 4</ref>). Specifically, for each action/state pair (ai, si) ∈ Hq, the agent is taught to predict that taking action ai in state si eventually results in a query latency of Lq. Similar to the off-policy learning approach of <ref type="bibr" target="#b21">[22]</ref>, the agent thus learns a reward prediction function: a function that guesses the quality of a given action at a given state. 4. Once the agent has proficiency guessing the outcome of the traditional optimizer's actions, the agent can finetune itself. Now, the agent will be creating a query plan for an incoming query q. For a given state si, an action ai is selected by running every possible action though the reward prediction function and selecting the action which is predicated to result in the lowest latency. <ref type="bibr" target="#b2">3</ref> This process repeats until a physical execution plan is created and executed. The model is then trained (fine-tuned) on the resulting history Hq and observed latency Lq. 5. Hopefully, the performance of the model will eventually exceed the performance of the traditional query optimizer. However, if the model's performance slips, it is partially re-trained with samples from the traditional query optimizer's choices when processing the queries in the initial workload W .</p><p>In many implementations, an action besides the one predicted to result in the lowest latency may be selected with small probability <ref type="bibr" target="#b19">[20]</ref> to enable additional exploration. Since the behavior of the model in the second phase should not initially stray too far from the behavior of the expert system <ref type="bibr" target="#b10">[11]</ref>, we do not have to worry about executing any exceptionally poor query plans. Additionally, since the second training phase only needs to fine-tune an already-performant model, the delayed reward signal is of far less consequence. In fact, the initial behavior of the model may outpeform the traditional query optimizer in certain circumstances, for example if the trained model were to observe a systemic error in the performance of traditional optimizer, such as the traditional optimizer handling two similar situations in two significantly different ways, one of which causes substantially increased query latency. In this case, the trained model may automatically avoid the errors of the traditional optimizer (which has no capability to learn from its mistakes) through observation alone.</p><p>An important issue here is that, since the experience collected based on the traditional optimizer is necessarily covering a narrow part of the action space (it excludes "bad" plans, and thus also excludes the corresponding sequence of actions that would produce them), many state-actions have never been observed and have no training data to ground them to realistic cost. For instance, a nested-loop-join or a table scan may never/rarely be picked by the traditional optimizer for a particular workload/database, and hence the model does not learn how to evaluate these actions correctly. However, since the model is trained on experiences containing significantly faster execution plans, there is no reason for the model to attempt to explore these extremely poor plans.</p><p>Experimental results from other problem domains (e.g. arcade games <ref type="bibr" target="#b10">[11]</ref> and a few systems applications <ref type="bibr" target="#b26">[27]</ref>), show that deep reinforcement learning agents which initially learn from demonstration can master tasks with significantly less training time than their tabula rasa counterparts. This result holds even when the expert is flawed (e.g. when the expert is a human player who does not know a particular shortcut or strategy), implying that learning-from-demonstration techniques can improve upon, and not just imitate, existing expert systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Cost Model Bootstrapping</head><p>A traditional, but still widely used and researched, approach to improving the performance of reinforcement learning algorithms on problems when the performance indicator (reward) is only available at the end of an episode (sparse) is to craft a heuristic reward function. This heuristic reward function estimates the utility of a given state using a heuristic constructed by a human being: for example, when a robot is learning to navigate a maze, it may use an "as-thecrow-flies" heuristic to estimate its proximity to the maze's exit. In the game of chess, a popular heuristic to evaluate the value of a particular board position is to count the number of pieces captured by both sides. Sometimes, this heuristic may be incorrect (e.g., it may rate a dead-end very near the exit as a desirable position, or it may highly-rate a board position in which many pieces have been captured but the opponent has an obvious winning move), but in general there is a strong relationship between the value of the heuristic function and the actual reward.</p><p>Luckily, the database community has invested significantly into designing optimizer cost models, which can be used for exactly this purpose. While imperfect, modern cost models, like "as-the-crow-flies" distance, can normally differentiate between good and catastrophic plans. We thus propose using these cost models as heuristic reward functions. This approach, depicted in <ref type="figure" target="#fig_4">Figure 5</ref>, first uses the optimizer's cost model as a reward signal (Phase 1) and then, once training has converged, switches the reward signal to the observed query latency (Phase 2). In this way, the optimizer's cost model acts as "training wheels," allowing the DRL model to explore strategies that produce catastrophic query plans without requiring execution. Once the DRL model has stabilized and starts to pick predominately good plans, the "training wheels" can be removed and the DRL model can fine-tune itself using the "true" reward signal, query latency.</p><p>Cost model bootstrapping brings about a number of complications which require further exploration by the database community. Generally, an optimizer's cost model output is a unitless value, meant to compare alternative query plans but not meant to directly correlate with execution latency. For example, an optimizer's cost estimate for a set of query plans may range from 10 to 50, but the latency of these query plans may range from 100s to 200s. Switching the range of the reward signal from 10-50 to 100-200 will cause the DRL model to assume that its performance has suddenly decreased (the DRL model was getting query plans with costs in the range 10-50 in Phase 1, and at the start of Phase 2 the costs suddenly jump to be in range 100-200). This sudden change could cause the DRL model to begin exploring previously-discarded strategies, requiring the execution of poor execution plans. The change in variance could also have a detrimental effect <ref type="bibr" target="#b11">[12]</ref>.</p><p>One way to potentially fix this issue would be to tune the units of the cost model to more precisely match execution latency, but the presence of cardinality estimation errors makes this difficult <ref type="bibr" target="#b16">[17]</ref>. Instead of adjusting the optimizer's estimates to match the query latency, another approach could be to adjust the query latency to match the optimizer cost. This could be implemented by simply scaling the query latency observed in Phase 2 to fall within the range of cost model estimates observed in Phase 1.</p><p>One could implement this scaling by noting the optimizer cost estimates and query execution latencies during the end of Phase 1 (when the DRL model has converged). Let Cmax and Cmin be the maximum and minimum observed optimizer cost, and let Lmax and Lmin be the maximum and minimum observed query execution times. Then, in Phase 2, when the DRL model proposes an execution plan with an observed latency of l, the reward r l could be:</p><formula xml:id="formula_4">r l = Cmin + l − Lmin Lmax − Lmin (Cmax − Cmin)</formula><p>In This scaling could be done linearly, as above, or using a more complex (but probably monotonic) function. This simple solution would likely need to be adjusted to handle workload shifts, changes in hardware, changes in physical design, etc.</p><p>Another potential approach, partially suggested in <ref type="bibr" target="#b15">[16]</ref>, is to first train a neural network model to optimize for the operator cost, and then transfer the weights of the later layers of the network into a new network that trains directly on query latency. This technique, known as "transfer learning", has seen wide success in other fields <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b37">38]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Incremental Learning</head><p>In this section, we discuss potential techniques to incrementally learn query optimization by first training a model to handle simple cases and slowly introducing more complexity. This approach makes the extremely large search space more manageable by dividing it into smaller pieces. Similar incremental approaches has shown success in other applications of reinforcement learning <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b8">9,</ref><ref type="bibr" target="#b32">33]</ref>.</p><p>We begin by examining how the task of query optimization can be decomposed into simpler pieces in a number of ways. We note that the difficulty of a query optimization task is primarily controlled by two dimensions: the number of relations in the query, and the number of optimization tasks that need to be performed. This is illustrated in <ref type="figure" target="#fig_5">Figure 6</ref>. The first axis is the number of relations in the query. If a DRL model must optimize queries containing only a single relation, then the search space of query plans is very small (there are no join orderings or join operators to consider). However, if a DRL model must optimize queries containing many relations, then the search space is much larger.</p><p>The second axis is the number of optimization tasks to perform. Consider a simplified query optimization pipeline (illustrated in <ref type="figure">Figure 8</ref>) containing four phases: join ordering, index selection, join operator selection, and aggregate operator selection. Performing any prefix of the pipeline is a simpler task than performing the entire pipeline: e.g., determining a join ordering and selecting indexes is a simpler task than determining a join ordering, selecting indexes, and determining join operators.</p><p>Thus, the lower-left hand side of <ref type="figure" target="#fig_5">Figure 6</ref> corresponds to "easy" cases, e.g. few stages of the pipeline and few relations. The upper-right hand side of <ref type="figure" target="#fig_5">Figure 6</ref> corresponds to "hard" cases, e.g. most stages of the pipeline and many relations. This insight illuminates a large design space for incremental learning approaches. In general, an incremental learning approach will be divided into phases. The first phase will use "easier" cases (the bottom left-hand part of the chart), training until relatively good performance is achieved. Then, subsequent phases will introduce more complex examples to  <ref type="figure">Figure 8</ref>: Learning incrementally the model, allowing the model to slowly and smoothly learn more complex cases (the top right-hand part of the chart). <ref type="figure">Figure 7</ref> illustrates three simple incremental learning approaches, with light colors representating the initial training phases and dark colors representing the subsequent training phases. We next discuss each of these approaches in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.1">Increasing optimization actions (pipeline)</head><p>Our first proposed approach is pipeline-based incremental learning, illustrated in <ref type="figure">Figure 8</ref>. A model is first trained on a small piece of the query optimization pipeline, e.g. join order selection. During this first phase, traditional query optimization techniques are used to take the output of the model and construct a complete execution plan (ReJOIN <ref type="bibr" target="#b17">[18]</ref> is essentially this first phase). Once the model achieves good performance in this first phase, the model is then slightly modified and trained on the first two phases of the query optimization pipeline, e.g. join order selection and index selection. This process is repeated until the model has learned the entire pipeline.</p><p>Extending ReJOIN to support this approach would be relatively straightforward. As shown in <ref type="bibr" target="#b17">[18]</ref>, the first phase of query optimization (join order enumeration) can be effectively learned. Once this initial training is complete, the action space can be extended to support index selection: instead of having one action per relation, the extended action space would have one action per relational data structure, e.g. one action for a relation's B-tree index, one action for a relation's row-order storage, one action for a relation's hash index, etc. The knowledge gained from the previous training phase should help the model train significantly faster in subsequent phases.</p><p>The pipeline approach has the advantages of incremental learning (e.g., a managable growth of the state space), but comes with several drawbacks that need to be further investigated. First, the early training phases requires access to a traditional implementation of the later stages of the query optimization pipeline. While such implementations are available in a range of DBMSes today, the dependency on a traditional query optimizer is not ideal. Second, each phase of the training process will not bring about a uni-  <ref type="figure">Figure 9</ref>: Learning from small examples form increase in complexity. It is conceivable that some stages of the pipeline are fundamentally more complex than others (for example, join order selection is likely more difficult than aggregate operator selection). The non-linearity of complexity going through the query optimization pipeline means that some training phases will require overcoming much larger jumps in complexity than others. This could result in unpredictable training times, or, in the worst case, a jump in complexity to large to learn all at once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.2">Increasing relations</head><p>While the previous approach reduces the size of the search space by focusing on larger and larger parts of the query optimization pipeline, this section proposes limiting the search space by focusing on larger and larger queries. The proposed approach is depicted in <ref type="figure">Figure 9</ref>. In the first training phase, the model learns to master queries over a single relation. In subsequent training phases, the model is trained on queries over two relations, then three relations, etc. In each phase, the entire query optimization pipeline is performed.</p><p>This approach dodges some pitfalls of the pipeline stage approach. Generally, the increase in complexity between optimizing a query with n relations and optimizing a query with n + 1 relations is small. Even though there is an exponential increase in the number of potential join orderings, this is a "quantitative" change as opposed to a "qualitative" change -intuitively, it is easier to learn how to create a join plan with a single additional relation than it is to learn how to perform a new pipeline step.</p><p>A major challenge of this approach is finding candidate queries. Generally, real-world workloads will contain very few queries over a single relation. Even synthetic workloads have very few low-relation-count queries (TPC-H <ref type="bibr" target="#b23">[24]</ref> has only two such templates, JOB <ref type="bibr" target="#b16">[17]</ref> has none). Queries with low relation counts could be synthetically generated, but doing so while matching the characteristics of real-world workloads is a complex task.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.3">Hybrid</head><p>The last approach we explicitly discuss is the hybrid approach, depicted on the right-hand side of <ref type="figure">Figure 7</ref>. In this hybrid approach, the initial training phase learns only the first step of the query optimization pipeline (e.g. join order selection) using only queries over two or fewer relations. The next training phase introduces both another step of the pipeline (e.g. index selection) and queries over three or fewer relations. After all stages of the query optimization pipeline have been incorporated, subsequent training phases increase the number of relations considered. This approach provides the smallest increase in complexity from training phase to subsequent training phase. However, the hybrid approach suffers from some of the disadvantages of both the relations and pipeline based approach: it depends on a traditional optimizer and it requires queries with relatively few relations for training purposes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">CONCLUSIONS</head><p>We have argued that recent advances in deep reinforcement learning open up new research avenues towards a "handsfree" query optimizer, potentially improving the speed of relational queries and significantly reducing time spent tuning heuristics by both DBMS designers and DBAs. We have identified how the large search space, delayed reward signal, and costly performance indicators provide substantial hurdles to naive applications of DRL to query optimization. Finally, we have analyzed how recent advances in reinforcement learning, from learning from demonstration to bootstrapping to incremental learning, open up new research directions for directly addressing these challenges. Other complexities We argue that deep reinforcement learning can greatly decrease the amount of human effort required to develop and tune database management systems. However, these deep learning techniques come with their own complexities as well: training configurations (e.g. learning rate), network architectures, activation function selection, etc. While deep learning researchers are quickly making inroads towards automating many of these decisions <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b18">19]</ref>, future research should carefully analyze the tradeoffs between tuning deep learning systems and tuning traditional query optimizers. Other applications While query optimization is a good candidate for applying DRL to database internals, a wide variety of other core DBMS concepts (e.g.cache management, concurrency control) could benefit from applications of machine learning as well. Careful applications of machine learning across the entire DBMS, not just the query optimizer, could bring about a massive increase in performance and capability.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>ReJOIN examplestate. The state si+1 after selecting the action (x, y) is</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Effectiveness and efficiency results</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Learning from demonstration</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 :</head><label>5</label><figDesc>Cost Model Bootstrapping</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>d e x s e le c ti o n A g g . o p e ra to rs Complexity diagram</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>o rd e r In d e x s e le c ti o n J o in o p e ra to rs A g g . o p e ra to rs In d e x s e le c ti o n A g g . o p e ra to rs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Summary Our experiental analysis of ReJOIN<ref type="bibr" target="#b17">[18]</ref> yielded interesting conclusions: 1. While ReJOIN is eventually able to learn a join ordering policy that outperforms PostgreSQL (both in terms of optimizer cost and query latency), doing so requires a substantial, but not prohibitive, training overhead. 2. ReJOIN's use of a traditional query optimizer's cost model as a reward signal allowed for join orderings to be evaluated quickly. However, this implies that ReJOIN's performance depends on the existence of a well-tuned cost model. 3. Counter-intuitively, ReJOIN's DRL algorithm is faster than PostgreSQL's built-in join order enumerator in many cases. Notably, the bottom-up nature of ReJOIN's algorithm is O(n), where PostgreSQL's greedy bottom-up algorithm is O(n 2 ).</figDesc><table /><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Self-tuning Histograms: Building Histograms Without Looking at Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Aboulnaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;99</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Brief Survey of Deep Reinforcement Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Arulkumaran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Signal</title>
		<imprint>
			<biblScope unit="page">17</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Towards a Robust Query Optimizer: A Principled and Practical Approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Babcock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;05</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Designing Neural Network Architectures using Reinforcement Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Baker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICLR &apos;17</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Deep Learning of Representations for Unsupervised and Transfer Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML WUTL &apos;12</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Incremental Reinforcement Learning for Designing Multi-agent Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Buffet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AGENTS &apos;01</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Adaptive Selectivity Estimation Using Query Feedback</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">M</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;94</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cruz</forename><surname>De La</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">V</forename><surname>Jr</surname></persName>
		</author>
		<title level="m">Pre-training Neural Networks with Human Demonstrations for Deep Reinforcement Learning. arXiv &apos;17</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Erickson</surname></persName>
		</author>
		<title level="m">Incremental Learning for Complex Environments in Deep Reinforcement Learning. arXiv &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Volcano Optimizer Generator: Extensibility and Efficient Search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Graefe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICDE &apos;93</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Deep Q-learning from Demonstrations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Hester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ioffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML&apos;15</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kaftan</surname></persName>
		</author>
		<idno>arXiv &apos;18</idno>
		<title level="m">A Lightweight Primitive for Adaptive Query Processing</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Near-Optimal Reinforcement Learning in Polynomial Time</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kearns</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning &apos;01</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The Case for Learned Index Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kraska</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krishnan</surname></persName>
		</author>
		<title level="m">Learning to Optimize Join Queries With Deep Reinforcement Learning. arXiv &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">How Good Are Query Optimizers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Leis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Really? VLDB &apos;15</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Deep Reinforcement Learning for Join Order Enumeration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Marcus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">aiDM &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Miikkulainen</surname></persName>
		</author>
		<title level="m">Evolving Deep Neural Networks. arXiv &apos;17</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Human-level control through deep reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Mnih</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Deep Learning for Entity Matching: A Design Space Exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mudgal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning State Representations for Query Optimization with Deep Reinforcement Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ortiz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DEEM &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Self-Driving Database Management Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pavlo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CIDR &apos;17</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">New TPC Benchmarks for Decision Support and Web Commerce. SIGMOD &apos;00</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Poess</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">An overview of gradient descent optimization algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ruder</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Learning from Demonstration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Schaal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS&apos;96</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schaarschmidt</surname></persName>
		</author>
		<title level="m">Reinforcement Learning in Computer Systems by Learning From Demonstrations. arXiv &apos;18</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">Deep learning in neural networks: An overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schmidhuber</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schulman</surname></persName>
		</author>
		<title level="m">Proximal Policy Optimization Algorithms. arXiv &apos;17</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Trust Region Policy Optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schulman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICML &apos;15</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Access Path Selection in a Relational Database Management System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Selinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGMOD &apos;89</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">LEO -DB2&apos;s LEarning Optimizer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stillger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB &apos;01</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Transfer Learning for Reinforcement Learning Domains: A Survey</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">E</forename><surname>Taylor</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">9</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">A Reinforcement Learning Approach for Adaptive Query Processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Tzoumas</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page">8</biblScope>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Join Order Selection (Good Enough Is Easy)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Waas</surname></persName>
		</author>
		<idno>BNCD &apos;00</idno>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Q-learning. Machine learning &apos;92</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">J</forename><surname>Watkins</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Simple statistical gradient-following algorithms for connectionist reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning &apos;92</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">How Transferable Are Features in Deep Neural Networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Yosinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NIPS &apos;14</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
