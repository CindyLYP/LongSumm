<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /Users/cindy/tmp/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Theoretical Computer Science</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Haller</surname></persName>
							<email>philipp.haller@epfl.ch</email>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Odersky</surname></persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">EPFL</orgName>
								<address>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="institution">EPFL</orgName>
								<address>
									<addrLine>Station 14</addrLine>
									<postCode>1015</postCode>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Theoretical Computer Science</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1016/j.tcs.2008.09.019</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-01-31T12:44+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>Concurrent programming Actors Threads Events</keywords>
			</textClass>
			<abstract>
				<p>There is an impedance mismatch between message-passing concurrency and virtual machines, such as the JVM. VMs usually map their threads to heavyweight OS processes. Without a lightweight process abstraction, users are often forced to write parts of concurrent applications in an event-driven style which obscures control flow, and increases the burden on the programmer. In this paper we show how thread-based and event-based programming can be unified under a single actor abstraction. Using advanced abstraction mechanisms of the Scala programming language, we implement our approach on unmodified JVMs. Our programming model integrates well with the threading model of the underlying VM.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Concurrency issues have lately received enormous interest because of two converging trends: first, multi-core processors make concurrency an essential ingredient of efficient program execution. Second, distributed computing and web services are inherently concurrent. Message-based concurrency is attractive because it might provide a way to address the two challenges at the same time. It can be seen as a higher-level model for threads with the potential to generalize to distributed computation. Many message passing systems used in practice are instantiations of the actor model <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b1">2]</ref>. A popular implementation of this form of concurrency is the Erlang programming language <ref type="bibr" target="#b3">[4]</ref>. Erlang supports massively concurrent systems such as telephone exchanges by using a very lightweight implementation of concurrent processes <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b35">36]</ref>.</p><p>On mainstream platforms such as the JVM <ref type="bibr" target="#b33">[34]</ref>, an equally attractive implementation was, as yet, missing. Their standard concurrency constructs, shared-memory threads with locks, suffer from high memory consumption and context-switching overhead. Therefore, the interleaving of independent computations is often modeled in an event-driven style on these platforms. However, programming in an explicitly event-driven style is complicated and error-prone, because it involves an inversion of control <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b12">13]</ref>.</p><p>In previous work <ref type="bibr" target="#b23">[24]</ref>, we developed event-based actors which let one program event-driven systems without inversion of control. Event-based actors support the same operations as thread-based actors, except that the receive operation cannot return normally to the thread that invoked it. Instead the entire continuation of such an actor has to be a part of the receive operation. This makes it possible to model a suspended actor by a continuation closure, which is usually much cheaper than suspending a thread.</p><p>In this paper we present a unification of thread-based and event-based actors. An actor can suspend with a full thread stack (receive) or it can suspend with just a continuation closure (react). The first form of suspension corresponds to thread-based, the second form to event-based programming. The new system combines the benefits of both models.</p><p>$ A preliminary version of the paper appears in the proceedings of <ref type="bibr">COORDINATION 2007</ref><ref type="bibr">, LNCS 4467, June 2007</ref> Threads support blocking operations such as system I/O, and can be executed on multiple processor cores in parallel. Eventbased computation, on the other hand, is more lightweight and scales to larger numbers of actors. We also present a set of combinators that allows a flexible composition of these actors.</p><p>The presented scheme has been implemented in the Scala Actors library. <ref type="bibr" target="#b0">1</ref> It requires neither special syntax nor compiler support. A library-based implementation has the advantage that it can be flexibly extended and adapted to new needs. In fact, the presented implementation is the result of several previous iterations. However, to be easy to use, the library draws on several of Scala's advanced abstraction capabilities; notably partial functions and pattern matching <ref type="bibr" target="#b18">[19]</ref>.</p><p>The user experience gained so far indicates that the library makes concurrent programming in a JVM-based system much more accessible than previous techniques. The reduced complexity of concurrent programming is influenced by the following factors.</p><p>• Since accessing an actor's mailbox is race-free by design, message-based concurrency is potentially more secure than shared-memory concurrency with locks. We believe that message-passing with pattern matching is also more convenient in many cases.</p><p>• Actors are lightweight. On systems that support 5000 simultaneously active VM threads, over 1,200,000 actors can be active simultaneously. Users are thus relieved from writing their own code for thread-pooling.</p><p>• Actors are fully inter-operable with normal VM threads. Every VM thread is treated like an actor. This makes the advanced communication and monitoring capabilities of actors available even for normal VM threads.</p><p>Our integration of a high-level actor-based programming model, providing strong invariants and lightweight concurrency, with existing threading models of mainstream VM platforms is unique to the best of our knowledge. We believe that our approach offers a qualitative improvement in the development of concurrent software for multi-core systems.</p><p>The rest of this paper is structured as follows. Section introduces our programming model and explains how it can be implemented as a Scala library. In Section 3 we present an extension to our programming model that allows us to unify thread-based and event-based models of concurrency under a single abstraction of actors. We also provide an overview and important details of the implementation of the Scala Actors library. Section 4 illustrates the core primitives of Scala Actors using larger examples. Section 5 introduces channels for type-safe and private communication. By means of a case study (Section 6) we show how our unified programming model can be applied to programming advanced web applications. Experimental results are presented in Section 7. Section 8 discusses related and future work, and Section 9 concludes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">The Scala Actors library</head><p>In the following, we introduce the fundamental concepts underlying our programming model and explain how various constructs are implemented in Scala. Section 2.1 shows how first-class message handlers support the extension of actors with new behavior. Actors. The Scala Actors library provides a concurrent programming model based on actors. An actor <ref type="bibr" target="#b27">[28,</ref><ref type="bibr" target="#b1">2]</ref> is a concurrent process that communicates with other actors by exchanging messages. Communication is asynchronous; messages are buffered in an actor's mailbox. An actor may respond to an asynchronous message by creating new actors, sending messages to known actors (including itself), or changing its behavior. The behavior specifies how the actor responds to the next message that it receives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Actors in Scala. Our implementation of actors in Scala adopts the basic communication primitives virtually unchanged from</head><p>Erlang <ref type="bibr" target="#b3">[4]</ref>. The expression a ! msg sends message msg to actor a (asynchronously). The receive operation has the following form:</p><formula xml:id="formula_0">receive { case msgpat 1 =&gt; action 1 ... case msgpat n =&gt; action n }</formula><p>The first message which matches any of the patterns msgpat i is removed from the mailbox, and the corresponding action i is executed (see <ref type="figure" target="#fig_0">Fig. 1</ref> for an example of a message pattern). If no pattern matches, the actor suspends.</p><p>New actors can be created in two ways. In the first alternative, we define a new class that extends the Actor trait. <ref type="bibr" target="#b1">2</ref> The actor's behavior is defined by its act method. For example, an actor executing body can be created as follows:</p><p>class MyActor extends Actor { def act() { body } } Note that after creating an instance of the MyActor class the actor has to be started by calling its start method. The second alternative for creating an actor is as follows. The expression actor {body} creates a new actor which runs the code in body. Inside body, the expression self is used to refer to the currently executing actor. This ''inline'' definition of an actor is often more concise than defining a new class. Finally, we note that every Java thread is also an actor, so even the main thread can execute receive. <ref type="bibr" target="#b2">3</ref> The example in <ref type="figure" target="#fig_0">Fig. 1</ref> demonstrates the usage of all constructs introduced so far. First, we define an orderMngr actor that tries to receive messages inside an infinite loop. The receive operation waits for two kinds of messages. The Order(s, item) message handles an order for item. An object which represents the order is created and an acknowledgment containing a reference to the order object is sent back to the sender s. The Cancel(s, o) message cancels order o if it is still pending. In this case, an acknowledgment is sent back to the sender. Otherwise a NoAck message is sent, signaling the cancellation of a non-pending order.</p><p>The last pattern x in the receive of orderMngr is a variable pattern which matches any message. Variable patterns allow to remove messages from the mailbox that are normally not understood (''junk''). We also define a customer actor which places an order and waits for the acknowledgment of the order manager before proceeding. Since spawning an actor (using actor) is asynchronous, the defined actors are executed concurrently.</p><p>Note that in the above example we have to do some repetitive work to implement request/reply-style communication. In particular, the sender is explicitly included in every message. As this is a frequently recurring pattern, our library has special support for it. Messages always carry the identity of the sender with them. This enables the following additional operations:</p><p>• a !? msg sends msg to a, waits for a reply and returns it.</p><p>• sender refers to the actor that sent the message that was last received by self.</p><p>• reply(msg) replies with msg to sender.</p><p>• a forward msg sends msg to a, using the current sender instead of self as the sender identity.</p><p>With these additions, the example can be simplified as shown on the right-hand side of <ref type="figure" target="#fig_0">Fig. 1</ref>. In addition to the operations above, an actor may explicitly designate another actor as the reply destination of a message send. The expression a.send(msg, b) sends msg to a where actor b is the reply destination. This means that when a receives msg, sender refers to b; therefore, any reply from a is sent directly to b. This allows certain forwarding patterns to be expressed without creating intermediate actors <ref type="bibr" target="#b44">[45]</ref>.</p><p>Looking at the examples shown above, it might seem that Scala is a language specialized for actor concurrency. In fact, this is not true. Scala only assumes the basic thread model of the underlying host. All higher-level operations shown in the examples are defined as classes and methods of the Scala library. In the following, we look ''under the covers'' to find out how each construct is defined and implemented. The implementation of concurrent processing is discussed in Section 3.3.</p><p>Using self outside of an actor definition creates a dynamic proxy object which provides an actor identity to the current thread, thereby making it capable of receiving messages from other actors.</p><p>The send operation ! is used to send a message to an actor. The syntax a ! msg is simply an abbreviation for the method call a.!(msg), just like x + y in Scala is an abbreviation for x.+(y). Consequently, we define ! as a method in the Actor trait:</p><p>trait Actor { val mailbox = new Queue[Any] def !(msg: Any): Unit = ...</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>... }</head><p>The method does two things. First, it enqueues the message argument in the receiving actor's mailbox which is represented as a field of type Queue <ref type="bibr">[Any]</ref>. Second, if the receiving actor is currently suspended in a receive that could handle the sent message, the execution of the actor is resumed.</p><p>The receive { ... } construct is more Interesting. In Scala, the pattern matching expression inside braces is treated as a first-class object that is passed as an argument to the receive method. The argument's type is an instance of PartialFunction, which is a subclass of Function1, the class of unary functions. The two classes are defined as follows. Note that Scala has different namespaces for types and terms. For instance, the name Actor is used both for the object above (a term) and the trait which is the result type of self and actor (a type). In the definition of the actor method, the argument body defines the behavior of the newly created actor. It is a closure returning the unit value. The leading =&gt; in its type indicates that it is passed by name.</p><p>There is also some other functionality in Scala's actor library which we have not covered. For instance, there is a method receiveWithin which can be used to specify a time span in which a message should be received allowing an actor to timeout while waiting for a message. Upon timeout the action associated with a special TIMEOUT pattern is fired. Timeouts can be used to suspend an actor, completely flush the mailbox, or to implement priority messages <ref type="bibr" target="#b3">[4]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.">Extending actor behavior</head><p>The fact that message handlers are first-class partial function values can be used to make actors extensible with new behaviors. A general way to do this is to have classes provide actor behavior using methods, so that subclasses can override them.  <ref type="figure" target="#fig_1">Fig. 2</ref> shows an example. The Buffer class extends the Actor trait to define actors that implement bounded buffers containing at most N integers. We omit a discussion of the array-based implementation (using the buf array and a number of integer variables) since it is completely standard; instead, we focus on the actor-specific parts. First, consider the definition of the act method. Inside an infinite loop it invokes receive passing the result of the reaction method. This method returns a partial function that defines actions associated with the Put(x) and Get message patterns. As a result, instances of the Buffer class are actors that repeatedly wait for Put or Get messages.</p><p>Assume we want to extend the behavior of buffer actors, so that they also respond to Get2 messages, thereby removing two elements at once from the buffer. The Buffer2 class below shows such an extension. It extends the Buffer class, thereby overriding its reaction method. The new method returns a partial function which combines the behavior of the superclass with a new action associated with the Get2 message pattern. Using the orElse combinator we obtain a partial function that is defined as super.reaction except that it is additionally defined for Get2. The definition of the act method is inherited from the superclass which results in the desired overall behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Unified actor model and implementation</head><p>Traditionally, programming models for concurrent processes are either thread-based or event-based. We review their complementary strengths and weaknesses in Section 3.1. Scala Actors unify both programming models, allowing programmers to trade efficiency for flexibility in a fine-grained way. We present our unified, actor-based programming model in Section 3.2. Section 3.3 provides an overview as well as important details of the implementation of the Scala Actors library. Finally, Section 3.4 introduces a set of combinators that allows one to compose actors in a modular way.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Threads vs. events</head><p>Concurrent processes such as actors can be implemented using one of two implementation strategies:</p><p>• Thread-based implementation: The behavior of a concurrent process is defined by implementing a thread-specific method. The execution state is maintained by an associated thread stack (see, e.g., <ref type="bibr" target="#b29">[30]</ref>).</p><p>• Event-based implementation: The behavior is defined by a number of (non-nested) event handlers which are called from inside an event loop. The execution state of a concurrent process is maintained by an associated record or object (see, e.g., <ref type="bibr" target="#b43">[44]</ref>).</p><p>Often, the two implementation strategies imply different programming models. Thread-based models are usually easier to use, but less efficient (context switches, memory consumption) <ref type="bibr" target="#b36">[37]</ref>, whereas event-based models are usually more efficient, but very difficult to use in large designs <ref type="bibr" target="#b40">[41]</ref>.</p><p>Most event-based models introduce an inversion of control. Instead of calling blocking operations (e.g., for obtaining user input), a program merely registers its interest to be resumed on certain events (e.g., signaling a pressed button). In the process, event handlers are installed in the execution environment. The program never calls these event handlers itself. Instead, the execution environment dispatches events to the installed handlers. Thus, control over the execution of program logic is ''inverted''. Because of inversion of control, switching from a thread-based to an event-based model normally requires a global re-write of the program <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Unified actor model</head><p>The main idea of our programming model is to allow an actor to wait for a message using two different operations, called receive and react, respectively. Both operations try to remove a message from the current actor's mailbox given a partial function that specifies a set of message patterns (see Section 2). However, the semantics of receive corresponds to thread-based programming, whereas the semantics of react corresponds to event-based programming. In the following we discuss the semantics of each operation in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1.">The receive operation</head><p>The receive operation has the following type:</p><formula xml:id="formula_1">def receive[R](f: PartialFunction[Any, R]): R</formula><p>If there is a message in the current actor's mailbox that matches one of the cases specified in the partial function f, the result of applying f to that message is returned. Otherwise, the current thread is suspended; this allows the receiving actor to resume execution normally when receiving a matching message. Note that receive retains the complete call stack of the receiving actor; the actor's behavior is therefore a sequential program which corresponds to thread-based programming.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2.">The react operation</head><p>The react operation has the following type:</p><p>def react(f: PartialFunction[Any, Unit]): Nothing</p><p>Note that react has return type Nothing. In Scala's type system a method has return type Nothing iff it never returns normally. This means that the action specified in f that corresponds to the matching message is the last code that the current actor executes. The semantics of react closely resembles event-based programming: the current actor registers the partial function f which corresponds to a set of event handlers, and then releases the underlying thread. When receiving a matching message the actor's execution is resumed by invoking the registered partial function. In other words, when using react, the argument partial function has to contain the rest of the current actor's computation (its continuation) since calling react never returns. In Section 3.4 we introduce a set of combinators that hide these explicit continuations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Implementation</head><p>Before discussing the implementation it is useful to clarify some terminology. In the following Section 3.3.1 and Section 3.3.2 we refer to an actor that is unable to continue (e.g., because it is waiting for a message) as being suspended. Note that this notion is independent of a specific concurrency model, such as threads. However, it is often necessary to indicate whether an actor is suspended in an event-based or in a thread-based way. We refer to an actor that is suspended in a react as being detached (since in this case the actor is detached from any other thread). In contrast, an actor that is suspended in a receive is called blocked (since in this case the underlying worker thread is blocked). More generally, we use the term blocking as a shortcut for thread-blocking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1.">Implementation overview</head><p>In our framework, multiple actors are executed on multiple threads for two reasons:</p><p>(1) Executing concurrent code in parallel may result in speed-ups on multi-processors and multi-core processors.</p><p>(2) Executing two interacting actors on different threads allows actors to invoke blocking operations without affecting the progress of other actors.</p><p>Certain operations provided by our library introduce concurrency, namely spawning an actor using actor, and asynchronously sending a message using the ! operator. We call these operations asynchronous operations. Depending on the current load of the system, asynchronous operations may be executed in parallel. Invoking an asynchronous operation creates a task that is submitted to a thread pool for execution. More specifically, a task is generated in the following three cases:</p><p>(1) Spawning a new actor using actor {body} generates a task that executes body.</p><p>(2) Sending a message to an actor suspended in a react that enables it to continue generates a task that processes the message.</p><p>(3) Calling react where a message can be immediately removed from the mailbox generates a task that processes the message.</p><p>The basic idea of our implementation is to use a thread pool to execute actors, and to resize the thread pool whenever it is necessary to support general thread operations. If actors use only operations of the event-based model, the size of the thread pool can be fixed. This is different if some of the actors use blocking operations such as receive or system I/O. In the case where every worker thread is occupied by a blocked actor and there are pending tasks, the thread pool has to grow.</p><p>For example, consider a thread pool with a single worker thread, executing a single actor a. Assume a first spawns a new actor b, and then waits to receive a message from b using the thread-based receive operation. Spawning b creates a new task that is submitted to the thread pool for execution. Execution of the new task is delayed until a releases the worker thread. However, when a suspends, the worker thread is blocked, thereby leaving the task unprocessed indefinitely. Consequently, a is never resumed since the only task that could resume it (by sending it a message) is never executed. The system is deadlocked.</p><p>In our library, system-induced deadlocks are avoided by increasing the size of the thread pool whenever necessary. It is necessary to add another worker thread whenever there is a pending task and all worker threads are blocked. In this case, the pending task(s) are the only computations that could possibly unblock any of the worker threads (e.g., by sending a message to a suspended actor). To do this, a scheduler thread (which is separate from the worker threads of the thread pool) periodically checks if there is a task in the task queue and all worker threads are blocked. In that case, a new worker thread is added to the thread pool that processes any remaining tasks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2.">Implementation details</head><p>A detached actor (i.e., suspended in a react call) is not represented by a blocked thread but by a closure that captures the actor's continuation. This closure is executed once a message is sent to the actor that matches one of the message patterns specified in the react. When an actor detaches, its continuation closure is stored in a continuation field of the Actor actor's continuation we pass the message that enables the actor to resume as an argument. The idea is that an actor only detaches when react fails to remove a matching message from the mailbox. This means that a detached actor is always resumed by sending it a message that it is waiting for. This message is passed when invoking the continuation. We represent the continuation as a partial function rather than a function to be able to test whether a message that is sent to an actor enables it to continue. This is explained in more detail below.</p><p>The react method saves the continuation closure whenever the receiving actor has to suspend (and therefore detaches): Recall that a partial function, such as f, is usually represented as a block with a list of patterns and associated actions. If a message can be removed from the mailbox (tested using dequeueFirst) the action associated with the matching pattern is scheduled for execution by calling the schedule operation. It is passed a task which contains a delayed computation that applies f to the received message, thereby executing the associated action. Tasks and the schedule operation are discussed in more detail below.</p><formula xml:id="formula_2">def react(f: PartialFunction[</formula><p>If no message can be removed from the mailbox, we save f as the continuation of the receiving actor. Since f contains the complete execution state we can resume the execution at a later point when a matching message is sent to the actor. The instance variable isDetached is used to tell whether the actor is detached (as opposed to blocked in a receive). If it is, the value stored in the continuation field is a valid execution state. The instance variable waitingFor stores a function of type Any =&gt; Boolean that is used to test whether a newly sent message enables the actor to continue. It is needed in addition to the continuation field since the latter cannot be used when the actor is blocked in a receive.</p><p>Finally, by throwing a special exception, control is transferred to the point in the control flow where the current actor was started or resumed. Since actors are always executed as part of tasks, the SuspendActorException is only caught inside task bodies.</p><p>Tasks are represented as instances of the following class (simplified):</p><formula xml:id="formula_3">class Task(cont: () =&gt; Unit) { def run() { try { cont() } // invoke continuation catch { case _: SuspendActorException =&gt; // do nothing } } }</formula><p>The constructor of the Task class takes a continuation of type () =&gt; Unit as its single argument. The class has a single run method that wraps an invocation of the continuation in an exception handler. The exception handler catches exceptions of type SuspendActorException which are thrown whenever an actor detaches. The body of the exception handler is empty since the necessary bookkeeping, such as saving the actor's continuation, has already been done at the point where the exception was thrown.</p><p>Sending a message to an actor involves checking whether the actor is waiting for the message, and, if so, resuming the actor according to the way in which it suspended (i.e., using receive or react): When sending a message to an actor that it does not wait for (i.e., the actor is not suspended or its continuation is not defined for the message), the message is simply enqueued in the actor's mailbox. Otherwise, the internal state of the actor is changed to reflect the fact that it is no longer waiting for a message. Then, we test whether the actor is detached; in this case we schedule a new task that applies the actor's continuation to the newly received message. The continuation was saved when the actor detached the last time. If the actor is not detached (which means it is blocked in a receive), it is resumed by notifying its underlying thread which is blocked on a call to wait.</p><formula xml:id="formula_4">def</formula><p>Spawning an actor using actor {body} generates a task that executes body as part of a new actor: The actor function takes a delayed expression (indicated by the leading =&gt;) that evaluates to Unit as its single argument. After instantiating a new Actor with the given body, we create a new task that is passed a continuation that simply executes the actor's body. Note that the actor may detach later on (e.g., by waiting in a react), in which case execution of the task is finished early, and the rest of the actor's body is run as part of a new continuation which is created when the actor is resumed subsequently.</p><formula xml:id="formula_5">def</formula><p>The schedule operation submits tasks to a thread pool for execution. A simple implementation strategy would be to put new tasks into a global queue that all worker threads in the pool access. However, we found that a global task queue becomes a serious bottle neck when a program creates short tasks with high frequency (especially if such a program is executed on multiple hardware threads). To remove this bottle neck, each worker thread has its own local task queue. When a worker thread generates a new task, e.g., when a message send enables the receiver to continue, the (sending) worker puts it into its local queue. This means that a receiving actor is often executed on the same thread as the sender. This is not always the case, because work stealing balances the work load on multiple worker threads (which ultimately leads to parallel execution of tasks) <ref type="bibr" target="#b5">[6]</ref>. This means that idle worker threads with empty task queues look into the queues of other workers for tasks to execute. However, accessing the local task queue is much faster than accessing the global task queue thanks to sophisticated non-blocking algorithms <ref type="bibr" target="#b30">[31]</ref>. In our framework the global task queue is used to allow non-worker threads (any JVM thread) to invoke asynchronous operations.</p><p>As discussed before, our thread pool has to grow whenever there is a pending task and all worker threads are blocked. Unfortunately, on the JVM there is no safe way for library code to find out if a thread is blocked. Therefore, we implemented a conservative heuristic that approximates the predicate ''all worker threads blocked''. The approximation uses a time-stamp of the last ''library activity''. If the time-stamp is not recent enough (i.e., it has not changed since a multiple of scheduler runs), the predicate is assumed to hold, i.e., it is assumed that all worker threads are blocked. We maintain a global time-stamp that is updated on every call to send, receive etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Composing actor behavior</head><p>Without extending the unified actor model, defining an actor that executes several given functions in sequence is not possible in a modular way.</p><p>For example, consider the two methods below:</p><p>def awaitPing = react { case Ping =&gt; } def sendPong = sender ! Pong</p><p>It is not possible to sequentially compose awaitPing and sendPong as follows:</p><p>actor { awaitPing; sendPong }</p><p>Since awaitPing ends in a call to react which never returns, sendPong would never get executed. One way to work around this restriction is to place the continuation into the body of awaitPing:</p><p>def awaitPing = react { case Ping =&gt; sendPong } However, this violates modularity. Instead, our library provides an andThen combinator that allows actor behavior to be composed sequentially. Using andThen, the body of the above actor can be expressed as follows:</p><p>awaitPing andThen sendPong andThen is implemented by installing a hook function in the actor. This function is called whenever the actor terminates its execution. Instead of exiting, the code of the second body is executed. Saving and restoring the previous hook function permits chained applications of andThen.</p><p>The Actor object also provides a loop combinator. It is implemented in terms of andThen:</p><p>def loop(body: =&gt; Unit) = body andThen loop(body)</p><p>Hence, the body of loop can end in an invocation of react. Similarly, we can define a loopWhile combinator that terminates the actor when a provided guard evaluates to false.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Examples</head><p>In this section we discuss two larger examples. These examples serve two purposes. First, they show how our unified programming model can be used to make parts of a threaded program event-based with minimal changes to an initial actor-based program. Second, they demonstrate the use of the combinators introduced in Section 3.4 to turn a complex program using non-blocking I/O into a purely event-driven program while maintaining a clear threaded code structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.">Producers and iteration</head><p>In the first example, we are going to write an abstraction of producers that provide a standard iterator interface to retrieve a sequence of produced values. Producers are defined by implementing an abstract produceValues method that calls a produce method to generate individual values. Both methods are inherited from a Producer class. For example, <ref type="figure" target="#fig_5">Fig. 3</ref> shows the definition of a producer that generates the values contained in a tree in in-order. <ref type="figure">Fig. 4</ref> shows an implementation of producers in terms of two actors, a producer actor, and a coordinator actor. The producer runs the produceValues method, thereby sending a sequence of values, wrapped in Some messages, to the <ref type="figure">Fig. 4</ref>. Implementation of the producer and coordinator actors. coordinator. The sequence is terminated by a None message. The coordinator synchronizes requests from clients and values coming from the producer. It is possible to economize one thread in the producer implementation. As shown in <ref type="figure" target="#fig_6">Fig. 5</ref>, this can be achieved by changing the call to receive in the coordinator actor into a call to react and using the loop combinator instead of the while loop. By calling react in its outer loop, the coordinator actor allows the scheduler to detach it from its worker thread when waiting for a Next message. This is desirable since the time between client requests might be arbitrarily long.</p><p>By detaching the coordinator, the scheduler can re-use the worker thread and avoid creating a new one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.">Pipes and asynchronous I/O</head><p>In this example, a pair of processes exchanges data over a FIFO pipe. Such a pipe consists of a sink and a source channel that are used for writing to the pipe and reading from the pipe, respectively. The two processes communicate over the pipe as follows. One process starts out writing some data to the sink while the process at the other end reads it from the source. Once all of the data has been transmitted, the processes exchange roles and repeat this conversation.</p><p>To make this example more realistic and interesting at the same time, we use non-blocking I/O operations. A process that wants to write data has to register its interest in writing together with an event handler; when the I/O subsystem can guarantee that the next write operation will not block (e.g., because of enough buffer space), it invokes this event handler.</p><p>The data should be processed concurrently; it is therefore not sufficient to put all the program logic into the event handlers that are registered with the I/O subsystem. Moreover, we assume that a process may issue blocking calls while processing the received data; processing the data inside an event handler could therefore block the entire I/O subsystem, which has to be avoided. Instead, the event handlers have to either notify a thread or an actor, or submit a task to a thread pool for execution.</p><p>In the following, we first discuss a solution that uses threads to represent the end points of a pipe. After that, we present an event-based implementation and compare it to the threaded version. Finally, we discuss a solution that uses Scala Actors. The solutions are compared with respect to synchronization and code structure.</p><p>We use a number of objects and methods whose definitions are omitted because they are not interesting for our discussion. First, processes have a reference sink to an I/O channel. The channel provides a write method that writes the contents of a buffer to the channel. The non-blocking I/O API is used as follows. The user implements an event handler which is a class with a single method that executes the I/O operation (and possibly other code). This event handler is registered with an I/O event dispatcher disp together with a channel; the dispatcher invokes an event handler when the corresponding (read or write) event occurs on the channel that the handler registered with. Each event handler is only registered until it has been invoked. Therefore, an event handler has to be registered with the dispatcher for each event that it should handle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1.">Thread-based pipes</head><p>In the first solution that we discuss, each end point of a pipe is implemented as a thread. <ref type="figure" target="#fig_7">Fig. 6</ref> shows the essential parts of the implementation. The run method of the Proc class on the left-hand side shows the body of a process thread. First, we test whether the process should start off writing or reading. The writeData and readData operations are executed in the according order. After the writing process has written all its data, it has to synchronize with the reading process, so that the processes can safely exchange roles. This is necessary to avoid the situation where both processes have registered a handler for the same kind of I/O event. In this case, a process might wait indefinitely for an event because it was dispatched to the other process. We use a simple barrier of size 2 for synchronization: a thread invoking await on the exch barrier is blocked until a second thread invokes exch.await. The writeData method is shown on the right-hand side of   (the readData method is analogous). First, it fills a buffer with data using the fill method. After that, it registers the writeHnd handler for write events on the sink with the I/O event dispatcher (writeHnd is discussed below). After that, the process enters a loop. First, it waits on the dataReady barrier until the write event handler has completed the next write operation. When the thread resumes, it first resets the dataReady barrier to the state where it has not been invoked, yet. The thread exits the loop when it has written 32 kB of data. Otherwise, it refills the buffer if it has been completed, and re-registers the event handler for the next write operation. The writeHnd event handler implements a single method handleWrite that writes data stored in buf to the sink, thereby counting the number of bytes written. After that, it notifies the concurrently running writer thread by invoking await on the dataReady barrier. <ref type="figure" target="#fig_9">Fig. 7</ref> shows an event-driven version that is functionally equivalent to the previous threaded program. The process constructor which is the body of the Proc class shown on the left-hand side, again, tests whether the process starts out  <ref type="figure" target="#fig_9">Fig. 7</ref> (read events are handled in an analogous manner). As before, the writeHnd handler implements the handleWrite method that writes data from buf to the sink, thereby counting the number of bytes written. To do the concurrent processing the handler submits a task to a thread pool for execution. The definition of this task is shown above. Inside the task we first test whether all data has been written; if so, the next I/O operation (in this case, readData) is invoked depending on the field last that we discussed previously. If the complete contents of buf has been written, it is refilled. Finally, the task re-registers the writeHnd handler to process the next event.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2.">Event-driven pipes</head><p>Compared to thread-based programming, the event-driven style obscures the control flow. For example, consider the writeData method. It does some work, and then registers an event handler. However, it is not clear what the operational effect of writeData is. Moreover, what happens after writeData has finished its actual work? To find out, we have to look inside the code of the registered event handler. This is still not sufficient, since also the submitted task influences the control flow. In summary, the program logic is implicit, and has to be recovered in a tedious way. Moreover, state has to be maintained across event handlers and tasks. In languages that do not support closures this often results in manual stack management <ref type="bibr" target="#b0">[1]</ref>. <ref type="figure" target="#fig_10">Fig. 8</ref> shows the same program using Scala Actors. The Proc class extends the Actor trait; its act method specifies the behavior of an end point. The body of the act method is similar to the process body of the thread-based version. There are two important differences. First, control flow is specified using the andThen combinator. This is necessary since writeData (and readData) may suspend using react. Without using andThen, parts of the actor's continuation not included in the argument closure of the suspending react would be ''lost''. Basically, andThen appends the closure on its right-hand side to whatever continuation is saved during the execution of the closure on its left-hand side. Second, end point actors exchange messages to synchronize when switching roles from writing to reading (and vice versa). The writeData method is similar to its thread-based counterpart. The while loop is replaced by the loopWhile combinator since inside the loop the actor may suspend using react. At the beginning of each loop iteration the actor waits for a Written message signaling the completion of a write event handler. The number of bytes written is carried inside the message which allows us to make bytesWritten a local variable; in the thread-based version it is shared among the event handler and the process. The remainder of writeData is the same as in the threaded version. The writeHnd handler used in the actor-based program is similar to the thread-based version, except that it notifies its process using an asynchronous message send. Note that, in general, the event handler is run on a thread which is different from the worker threads used by our library to execute actors (the I/O subsystem might use its own thread pool, for example). To make the presented scheme work, it is therefore crucial that arbitrary threads may send messages to actors. Conclusion. Compared to the event-driven program, the actor-based version improves on the code structure in the same way as the thread-based version. Passing result values as part of messages makes synchronization slightly clearer and reduces the number of global variables compared to the thread-based program. However, in Section 7 we show that an event-based implementation of a benchmark version of the pipes example is much more efficient and scalable than a purely thread-based implementation. Our unified actor model allows us to implement the pipes example in a purely event-driven way while maintaining the clear code structure of an equivalent thread-based program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3.">Actor-based pipes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Channels and selective communication</head><p>In the programming model that we have described so far, actors are the only entities that can send and receive messages. Moreover, the receive operation ensures locality, i.e., only the owner of the mailbox can receive messages from it. Therefore, race conditions when accessing the mailbox are avoided by design. Types of messages are flexible: they are usually recovered through pattern matching. Ill-typed messages are ignored instead of raising compile-time or run-time errors. In this respect, our library implements a dynamically-typed embedded domain-specific language.</p><p>However, to take advantage of Scala's rich static type system, we need a way to permit strongly-typed communication among actors. For this, we use channels which are parameterized with the types of messages that can be sent to and received from it, respectively. Moreover, the visibility of channels can be restricted according to Scala's scoping rules. That way, communication between sub-components of a system can be hidden. We distinguish input channels from output channels. Actors are then treated as a special case of output channels:</p><formula xml:id="formula_6">trait Actor extends OutputChannel[Any] { ... }</formula><p>The possibility for an actor to have multiple input channels raises the need to selectively communicate over these channels. Up until now, we have shown how to use receive to remove messages from an actor's mailbox. We have not yet shown how messages can be received from multiple input channels. Instead of adding a new construct, we generalize receive to work over multiple channels.</p><p>For example, a model of a component of an integrated circuit can receive values from both a control and a data channel using the following syntax:</p><formula xml:id="formula_7">receive {</formula><p>case DataCh ! data =&gt; ... case CtrlCh ! cmd =&gt; ... }</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Case study</head><p>In this section we show how our unified actor model addresses some of the challenges of programming web applications. In the process, we review event-and thread-based solutions to common problems, such as blocking I/O operations. Our goal is then to discuss potential benefits of our unified approach. Advanced web applications typically pose at least the following challenges to the programmer:</p><p>• Blocking operations. There is almost always some functionality that is implemented using blocking operations. Possible reasons are lack of suitable libraries (e.g., for non-blocking socket I/O), or simply the fact that the application is built on top of a large code base that uses potentially blocking operations in some places. Typically, rewriting infrastructure code to use non-blocking operations is not an option.</p><p>• Non-blocking operations. On platforms such as the JVM, web application servers often provide some parts (if not all) of their functionality in the form of non-blocking APIs for efficiency. Examples are request handling, and asynchronous HTTP requests.</p><p>• Race-free data structures. Advanced web applications typically maintain user profiles for personalization. These profiles can be quite complex (some electronic shopping sites apparently track every item that a user visits). Moreover, a single user may be logged in on multiple machines, and issue many requests in parallel. This is common on web sites, such as those of electronic publishers, where single users represent whole organizations. It is therefore mandatory to ensure race-free accesses to a user's profile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.">Thread-based approaches</head><p>VMs overlap computation and I/O by transparently switching among threads. Therefore, even if loading a user profile from disk blocks, only the current request is delayed. Non-blocking operations can be converted to blocking operations to support a threaded style of programming: after firing off a non-blocking operation, the current thread blocks until it is notified by a completion event. However, threads do not come for free. On most mainstream VMs, the overhead of a large number of threads -including context switching and lock contention -can lead to serious performance degradation <ref type="bibr" target="#b43">[44,</ref><ref type="bibr" target="#b17">18]</ref>. Overuse of threads can be avoided by using bounded thread pools <ref type="bibr" target="#b29">[30]</ref>. Shared resources such as user profiles have to be protected using synchronization operations. This is known to be particularly hard using shared-memory locks <ref type="bibr" target="#b31">[32]</ref>. We also note that alternatives such as transactional memory <ref type="bibr" target="#b24">[25,</ref><ref type="bibr" target="#b25">26]</ref>, even though a clear improvement over locks, do not provide seamless support for I/O operations as of yet. Instead, most approaches require the use of compensation actions to revert the effects of I/O operations, which further complicate the code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.">Event-based approaches</head><p>In an event-based model, the web application server generates events (network and I/O readiness, completion notifications etc.) that are processed by event handlers. A small number of threads (typically one per CPU) loop continuously removing events from a queue and dispatching them to registered handlers. Event handlers are required not to block since otherwise the event-dispatch loop could be blocked, which would freeze the whole application. Therefore, all operations that could potentially block, such as the user profile look-up, have to be transformed into non-blocking versions. Usually, this means executing them on a newly spawned thread, or on a thread pool, and installing an event handler that gets called when the operation is completed <ref type="bibr" target="#b37">[38]</ref>. Usually, this style of programming entails an inversion of control that causes the code to lose its structure and maintainability <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b12">13]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3.">Scala Actors</head><p>In our unified model, event-driven code can easily be wrapped to provide a more convenient interface that avoids inversion of control without spending an extra thread <ref type="bibr" target="#b23">[24]</ref>. The basic idea is to decouple the thread that signals an event from the thread that handles it by sending a message that is buffered in an actor's mailbox. Messages sent to the same actor are processed atomically with respect to each other. Moreover, the programmer may explicitly specify in which order messages should be removed from its mailbox. Like threads, actors support blocking operations using implicit thread pooling as discussed in Section 3.3. Compared to a purely event-based approach, users are relieved from writing their own ad hoc thread pooling code. Since the internal thread pool can be global to the web application server, the thread pool controller can leverage more information for its decisions <ref type="bibr" target="#b43">[44]</ref>. Finally, accesses to an actor's mailbox are race-free. Therefore, resources such as user profiles can be protected by modeling them as (thread-less) actors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Experimental results</head><p>Optimizing performance across threads and events involves a number of non-trivial trade-offs. Therefore, we do not want to argue that our framework is better than event-based systems or thread-based systems or both. Instead, the following basic experiments show that the performance of our framework is comparable to those of both thread-based and event-based systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.">Message passing</head><p>In the first benchmark we measure throughput of blocking operations in a queue-based application. The application is structured as a ring of n producers/consumers (in the following called processes) with a shared queue between each of them. Initially, k of these queues contain tokens and the others are empty. Each process loops removing an item from the queue on its right and placing it in the queue on its left.</p><p>The following tests were run on a 3.00 GHz Intel Pentium 4 processor with 2048 MB memory, running Sun's Java HotSpot VM 1.5.0 under Linux 2.6.15 (SMP configuration). We set the JVM's maximum heap size to 1024 MB to provide for sufficient physical memory to avoid any disk activity. In each case we took the median of 5 runs. The execution times of three equivalent implementations written using (1) our actor library, (2) pure Java threads, and (3) SALSA (version 1.1.1), a Javabased actor language <ref type="bibr" target="#b39">[40]</ref>, respectively, are compared. We run the actor-based version using three different configurations. The first and second configurations fix the number of pool threads to 4 and 1, respectively. The third configuration runs without a thread pool; it is not equivalent with event-based actors, though, since we still create tasks that are put into a queue which is processed by a single thread. Therefore, the third configuration avoids the overhead of work stealing and thread pool resizing. <ref type="figure" target="#fig_11">Fig. 9</ref> shows the number of token passes per second (throughput) depending on the ring size. Note that both scales are logarithmic. For less than 1500 processes, pure Java threads are on average 3 times faster than actors that manage a pool with 4 threads. The overhead that stems from managing the thread pool contributes a factor of 2.6 (threads are on average 14% faster than actors without the runtime system overhead). Using more than a single pool thread increases throughput by about 18%; This performance gain is due to the two hyper threads of the CPU. For 1500 or more processes, the throughput of threads breaks in and reaches a minimum of about 23,000 tokens per second at 4500 processes. At this point, and up until 20,000 processes, throughput of the default actor configuration with 4 pool threads remains constant at about 39,000 tokens per seconds. The VM is unable to create a ring with 5500 threads as it runs out of heap memory. In contrast, using  Scala Actors the ring can be operated with as many as 600,000 processes (since every queue is also an actor this amounts to 1,200,000 simultaneously active actors). Throughput of Scala Actors is on average over 20 times higher than that of SALSA. When creating 2500 processes using SALSA, the VM runs out of heap memory. Conclusion. Purely event-based actors are competitive with native Java threads, even for a small number of processes. However, the overhead of our runtime system that involves work stealing and thread-pool monitoring/resizing can be significant when the number of processes is small. When running with only 10 processes, (multi-threaded) actors are 3.4 times slower than pure Java threads. In this benchmark threads use simple monitor-style synchronization, i.e., synchronized methods where signaling is done between threads accessing the same monitor. Apparently, this style of synchronization is well-supported on modern JVMs. Only for a relatively large number of threads (&gt;= 1000) the overhead of context switching becomes significant (contention is low since each monitor is accessed by only two threads).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.">Multi-core scalability</head><p>In the second experiment, we are interested in the speed-up that is gained by adding processor cores to a system. The following tests were run on a multi-processor with 4 dual-core AMD Opteron 64-Bit processors (2.8 GHz each) with 16 GB memory, running Sun's Java HotSpot 64-Bit Server VM 1.5.0 under Linux 2.6.16. In each case we took the median of runs. We ran direct translations of the Fibonacci (Fib) and Gaussian integration (Integ) programs distributed with Lea's high-performance fork/join framework for Java (FJ) <ref type="bibr" target="#b30">[31]</ref>. The speed-ups as shown in <ref type="figure" target="#fig_0">Fig. 10</ref> are linear as expected since the programs run almost entirely in parallel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3.">I/O performance</head><p>The following benchmark scenario is similar to those used in the evaluation of other thread implementations <ref type="bibr" target="#b41">[42,</ref><ref type="bibr" target="#b32">33]</ref>. We aim to simulate the effects of a large number of mostly-idle client connections. For this purpose, we create a large number  of FIFO pipes and measure the throughput of concurrently passing a number of tokens through them. If the number of pipes is less than 128, the number of tokens is one quarter of the number of pipes; otherwise, exactly tokens are passed concurrently. The idle end points are used to model slow client links. After a token has been passed from one process to another, the processes at the two end points of the pipe exchange roles, and repeat this conversation. <ref type="figure" target="#fig_0">Fig. 11</ref> shows the performance of implementations based on events, threads, and actors under load. The programs used to obtain these results are slightly extended versions of those discussed in Section 4.2. They were run on a 1.60 GHz Intel Pentium M with 512 MB memory, running Sun's Java HotSpot Server VM 1.5.0 under Linux 2.6.17. In each case, we took the average of 5 runs. In the first version, end points are implemented as actors that are run on a single thread without the overhead of the runtime system that we discussed in Section 3.3. The second version uses a purely eventbased implementation; concurrent tasks are run on a lightweight fork/join execution environment <ref type="bibr" target="#b30">[31]</ref>. The third program is basically the same as the first one, except that actors run in ''unified mode'' using the runtime system which manages 4 pool threads by default. The overhead of unified actors compared to purely event-based actors ranges between 8% (4 pipes) and 70% (256 pipes). In the last version, end points are implemented as standard JVM threads. In this example, events are on average 120% faster than threads, unified actors are on average 66% faster. <ref type="figure" target="#fig_0">Fig. 12</ref> shows the performance of the actor-based and thread-based programs when run on a multi-processor machine with 4 hardware threads (2 hyper-threaded Intel Xeon 3.06 GHz with 2 GB memory, running Linux 2.6.11 SMP). When the number of non-idle threads increases from 2 to 4 in the thread-based version, throughput increases by about 26%. After that the additional threads basically induce only additional overhead. In the version that uses our unified model, growing the thread pool from 2 to 4 workers increases throughput on average by 74%. Even though the overhead of the runtime system for our unified actor model can be as high as 70% on a single CPU, this overhead is quickly amortized when the program is run on a multi-processor system. Conclusion. The synchronization patterns found in the network scalability benchmark are more likely to be found in realworld programs than those of the previous benchmarks. Simple monitor-style synchronization is not sufficient; instead, barriers and blocking queues are used to synchronize end points and event handlers. Moreover, threads are likely to be blocked more often, waiting for I/O events. This situation enables actors to amortize their overhead and to reverse the result of the message passing benchmark. For 64 pipes or less, the throughput of actors is on average 69% higher than the throughput of threads. Presumably, thread notification (notify on the JVM) is relatively expensive. On a multi-processor system with 4 hardware threads, only actors enable a significant speed-up in this benchmark.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Related and future work</head><p>Lauer and Needham <ref type="bibr" target="#b28">[29]</ref> note in their seminal work that threads and events are dual to each other. They suggest that any choice of either one of them should therefore be based on the underlying platform. Almost two decades later, Ousterhout <ref type="bibr" target="#b36">[37]</ref> argues that threads are a bad idea not only because they often perform poorly, but also because they are hard to use. More recently, von Behren and others <ref type="bibr" target="#b40">[41]</ref> point out that even though event-driven programs often outperform equivalent threaded programs, they are too difficult to write. The two main reasons are: first, the interactive logic of a program is fragmented across multiple event handlers (or classes, as in the state design pattern <ref type="bibr" target="#b20">[21]</ref>). Second, control flow among handlers is expressed implicitly through manipulation of shared state <ref type="bibr" target="#b9">[10]</ref>. In the Capriccio system <ref type="bibr" target="#b41">[42]</ref>, static analysis and compiler techniques are employed to transform a threaded program into a cooperatively-scheduled event-driven program with the same behavior.</p><p>There are several other approaches that avoid the above control inversion. However, they have either limited scalability, 5 or they lack support of blocking operations. Termite Scheme <ref type="bibr" target="#b22">[23]</ref> integrates Erlang's programming model into Scheme. Scheme's first-class continuations are exploited to express process migration. However, their system apparently does not support multiple processor cores. All published benchmarks were run in a single-core setting. Responders <ref type="bibr" target="#b9">[10]</ref> provide an event-loop abstraction as a Java language extension. Since their implementation spends a VM thread per event-loop, scalability is limited on standard JVMs. SALSA <ref type="bibr" target="#b39">[40]</ref> is a Java-based actor language that has a similar limitation (each actor runs on its own thread). In addition, message passing performance suffers from the overhead of reflective method calls. Timber <ref type="bibr" target="#b4">[5]</ref> is an object-oriented and functional programming language designed for real-time embedded systems. It offers message passing primitives for both synchronous and asynchronous communication between concurrent reactive objects. In contrast to our programming model, reactive objects are not allowed to call operations that might block indefinitely. Frugal objects <ref type="bibr" target="#b21">[22]</ref> (FROBs) are distributed reactive objects that communicate through typed events. FROBs are basically actors with an event-based computation model. Similar to reactive objects in Timber, FROBs may not call blocking operations.</p><p>In languages like Haskell and Scala, the continuation monad can also be used to implement lightweight concurrency <ref type="bibr" target="#b10">[11]</ref>. In fact, it is possible to define a monadic interface for the actors that we present in this paper; however, a thorough discussion is beyond the scope of this paper. Li and Zdancewic <ref type="bibr" target="#b32">[33]</ref> use the continuation monad to combine events and threads in a Haskell-based system for writing high-performance network services. However, they require blocking system calls to be wrapped in non-blocking operations. In our library actors subsume threads, which makes this wrapping unnecessary; essentially, the programmer is relieved from writing custom thread-pooling code.</p><p>The actor model has also been integrated into various Smalltalk systems. Actalk <ref type="bibr" target="#b6">[7]</ref> is an actor library for Smalltalk-80 that does not support multiple processor cores. Actra <ref type="bibr" target="#b38">[39]</ref> extends the Smalltalk/V VM to provide lightweight processes. In contrast, we implement lightweight actors on unmodified VMs.</p><p>Other concurrent programming languages and systems also use actors or actor-like abstractions. ProActive <ref type="bibr" target="#b7">[8]</ref> is a middleware for programming distributed Grid applications. Its main abstractions are a form of deterministic active objects <ref type="bibr" target="#b8">[9]</ref> that communicate using asynchronous method calls and futures. ProActive allows distributing active objects on a large number of machines in a Grid. In contrast, Scala Actors address the trade-off between threads and events for achieving highly scalable multithreading on a single machine. AmbientTalk <ref type="bibr" target="#b15">[16]</ref> provides actors based on communicating event loops <ref type="bibr" target="#b34">[35]</ref>. AmbientTalk implements a protocol mapping <ref type="bibr" target="#b14">[15]</ref> that allows native (Java) threads to interact with actors while preserving non-blocking communication among event-loops. However, the mapping relies on the fact that each actor is always associated with its own VM thread, whereas Scala's actors can be thread-less. While AmbientTalk offers a bridge between two distinct concurrency models, Scala Actors provide a single unified concurrency model.</p><p>In Section 7 we show that our actor implementation scales to a number of actors that is two orders of magnitude larger than what purely thread-based systems such as SALSA support. Moreover, results suggest that our model scales with the number of processor cores in a system. Our unified actor model provides seamless support for blocking operations. Therefore, existing thread-blocking APIs do not have to be wrapped in non-blocking operations. Unlike approaches such as Actra our implementation provides lightweight actor abstractions on unmodified (Java) VMs.</p><p>Our library was inspired to a large extent by Erlang's elegant programming model. Erlang <ref type="bibr" target="#b3">[4]</ref> is a dynamically-typed functional programming language designed for programming real-time control systems. The combination of lightweight isolated processes, asynchronous message passing with pattern matching, and controlled error propagation has been proven to be very effective <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b35">36]</ref>. One of our main contributions lies in the integration of Erlang's programming model into a full-fledged object-oriented and functional language. Moreover, by lifting compiler magic into library code we achieve</p><p>We use the term scalability to refer to the number of concurrent processes; in some related domains, e.g., distributed programming, scalability is often measured in number of machines. compatibility with standard, unmodified JVMs. To Erlang's programming model we add new forms of composition as well as channels, which permit strongly-typed and secure inter-actor communication.</p><p>The idea to implement lightweight concurrent processes using continuations has been explored many times <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b26">27,</ref><ref type="bibr" target="#b11">12]</ref>. However, none of the existing techniques are applicable to VMs such as the JVM because (1) the security model restricts accessing the run-time stack, and (2) heap-based stacks break interoperability with existing code.</p><p>The approach used to implement thread management in the Mach 3.0 kernel <ref type="bibr" target="#b16">[17]</ref> is at least conceptually similar to ours. When a thread blocks in the kernel, either it preserves its register state and stack and resumes by restoring this state, or it preserves a pointer to a continuation function that is called when the thread is resumed. Instead of function pointers we use closures that automatically lift referenced stack variables on the heap avoiding explicit state management in many cases. Moreover, we save a richer continuation in form of a partial function. A partial function allows testing whether it is defined for a given value. We use this test to decide whether an actor should be resumed upon receiving a message.</p><p>There is a rich body of work on building fast web servers, using events or a combination of events and threads (for example SEDA <ref type="bibr" target="#b43">[44]</ref>). However, a comprehensive discussion of this work is beyond the scope of this paper. Ongoing and future work. The Scala Actors library includes a runtime system that provides basic support for remote (i.e., inter-VM) actor communication. In ongoing work we are extending the framework with remote actor references that support volatile connections, similar to ambient references <ref type="bibr" target="#b13">[14]</ref>. Integrating abstractions for fault-tolerant distributed programming (e.g., <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b45">46]</ref>) into Scala Actors is an interesting area for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9.">Conclusion</head><p>In this paper we have shown how thread-based and event-based models of concurrency can be unified. The main idea of our unified programming model is an actor abstraction that provides two kinds of operations for receiving messages.</p><p>The receive operation retains the complete call stack of the receiver while waiting for a message, while the react operation retains only a continuation closure. The first form of suspension corresponds to thread-based, the second form to event-based programming. As a result, our unified concurrency model combines the benefits of threads and events while abstracting commonalities. The presented ideas have been implemented in the Scala Actors library which provides actorbased concurrency supporting high-level communication through messages and pattern matching. We believe that our work closes an important gap between message-passing concurrency and popular VM platforms.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Example: orders and cancellations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>Extending actors with new behavior.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>trait: trait Actor { var continuation: PartialFunction[Any, Unit] val mailbox = new Queue[Any] def !(msg: Any): Unit = ... def react(f: PartialFunction[Any, Unit]): Nothing = ... ... } An actor's continuation is represented as a partial function of type PartialFunction[Any, Unit]. When invoking an</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>!(msg: Any): Unit = synchronized { if (waitingFor(msg)) { waitingFor = (x: Any) =&gt; false if (isDetached) { isDetached = false schedule(new Task({ () =&gt; continuation(msg) })) } else resume() // thread-based resume } else mailbox += msg }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>actor(body: =&gt; Unit): Actor = { val a = new Actor { def act() = body } schedule(new Task({ () =&gt; a.act() })) a }</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 3 .</head><label>3</label><figDesc>Producer that generates all values in a tree in in-order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>Implementation of the coordinator actor using react.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6</head><label>6</label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 6 .</head><label>6</label><figDesc>Thread-based pipes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 7 .</head><label>7</label><figDesc>Event-driven pipes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 8 .</head><label>8</label><figDesc>Actor-based pipes.writing or reading. However, based on this test only one of the two I/O operations is called. The reason is that each I/O operation, such as writeData, registers an event handler with the I/O subsystem, and then returns immediately. The event handler for the second operation may only be installed when the last handler of the previous operation has run. Therefore, we have to decide inside the event handler of the write operation whether we want to read subsequently or not. The last field keeps track of this decision across all event handler invocations. If last is false, we invoke readData after writeData has finished (and vice versa); otherwise, the sequence of I/O operations is finished. The definition of an event handler for write events is shown on the right-hand side of</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 9 .</head><label>9</label><figDesc>Throughput (number of token passes per second) for a fixed number of 10 tokens.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig. 10 .</head><label>10</label><figDesc>Speed-up for Fibonacci and Integration benchmarks.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 .</head><label>11</label><figDesc>Network scalability benchmark on single-processor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 12 .</head><label>12</label><figDesc>Network scalability benchmark on multi-processor.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>Functions are objects which have an apply method. Partial functions are objects which have in addition a method isDefinedAt which tests whether a function is defined for a given argument. Both classes are parameterized; the first type parameter a indicates the function's argument type and the second type parameter b indicates its result type.<ref type="bibr" target="#b3">4</ref> A pattern matching expression { case p 1 =&gt; e 1 ; ...; case p n =&gt; e n } is then a partial function whose methods are defined as follows.• The isDefinedAt method returns true if one of the patterns p i matches the argument, false otherwise.• The apply method returns the value e i for the first pattern p i that matches its argument. If none of the patterns match, a MatchError exception is thrown.The receive construct is realized as a method (of the Actor trait) that takes a partial function as an argument.The implementation of receive proceeds roughly as follows. First, messages in the mailbox are scanned in the order they appear. If receive's argument f is defined for a message, that message is removed from the mailbox and f is applied to it.On the other hand, if f.isDefinedAt(m) is false for every message m in the mailbox, the receiving actor is suspended. The actor and self constructs are realized as methods defined by the Actor object. Objects have exactly one instance at runtime, and their methods are similar to static methods in Java.</figDesc><table><row><cell>abstract class Function1[-a, +b] {</cell></row><row><cell>def apply(x: a): b }</cell></row><row><cell>abstract class PartialFunction[-a, +b] extends Function1[a, b] {</cell></row><row><cell>def isDefinedAt(x: a): Boolean }</cell></row><row><cell>def receive[R](f: PartialFunction[Any, R]): R</cell></row><row><cell>object Actor {</cell></row><row><cell>def self: Actor ...</cell></row><row><cell>def actor(body: =&gt; Unit): Actor ...</cell></row><row><cell>...</cell></row><row><cell>}</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Available as part of the Scala distribution at http://www.scala-lang.org/.2 A trait in Scala is an abstract class that can be mixin-composed with other traits.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4">Parameters can carry + orvariance annotations which specify the relationship between instantiation and subtyping. The -a, +b annotations indicate that functions are contravariant in their argument and covariant in their result. In other words Function1[X1, Y1] is a subtype of Function1[X2, Y2] if X2 is a subtype of X1 and Y1 is a subtype of Y2.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Cooperative task management without manual stack management</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Atul</forename><surname>Adya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jon</forename><surname>Howell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marvin</forename><surname>Theimer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Bolosky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">R</forename><surname>Douceur</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX, USENIX</title>
		<meeting>USENIX, USENIX</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="289" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">ACTORS: A Model of Concurrent Computation in Distributed Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Agha</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Erlang -a survey of the language and its industrial applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe</forename><surname>Armstrong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. INAP</title>
		<meeting>INAP</meeting>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="16" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joe</forename><surname>Armstrong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Virding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claes</forename><surname>Wikström</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
	<note>Concurrent Programming in Erlang, second edition</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Timber: A Programming Language for Real-Time Embedded Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Black</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Carlsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Kieburtz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nordlander</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Cilk: An efficient multithreaded runtime system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Blumofe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="69" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Actalk: A testbed for classifying and designing actor languages in the Smalltalk-80 environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Briot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECOOP</title>
		<meeting>ECOOP</meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="109" to="129" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">ProActive: An integrated platform for programming and running applications on grids and P2P systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Caromel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Delbé</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Di Costanzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Leyton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Methods in Science and Technology</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="69" to="77" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Asynchronous and deterministic objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denis</forename><surname>Caromel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ludovic</forename><surname>Henrio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernard</forename><forename type="middle">Paul</forename><surname>Serpette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL, ACM</title>
		<meeting>POPL, ACM</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="123" to="134" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Responders: Language support for interactive applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Chin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Todd</forename><forename type="middle">D</forename><surname>Millstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECOOP, in: LNCS</title>
		<meeting>ECOOP, in: LNCS</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-07" />
			<biblScope unit="volume">4067</biblScope>
			<biblScope unit="page" from="255" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A poor man&apos;s concurrency monad</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koen</forename><surname>Claessen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="313" to="323" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Adding threads to standard ML</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Cooper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Morrisett</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990-12" />
		</imprint>
		<respStmt>
			<orgName>Carnegie-Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Report CMU-CS-90-186</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Making events less slippery with eel</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Cunningham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eddie</forename><surname>Kohler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. HotOS, USENIX</title>
		<meeting>HotOS, USENIX</meeting>
		<imprint>
			<date type="published" when="2005-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Van Cutsem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jessie</forename><surname>Dedecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stijn</forename><surname>Mostinckx</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Elisa</forename><forename type="middle">Gonzalez</forename><surname>Boix</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Theo</forename><forename type="middle">D</forename><surname>Hondt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><forename type="middle">De</forename><surname>Meuter</surname></persName>
		</author>
		<title level="m">Ambient references: Addressing objects in mobile networks</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="986" to="997" />
		</imprint>
	</monogr>
	<note>OOPSLA Companion</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Linguistic symbiosis between actors and threads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Van Cutsem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stijn</forename><surname>Mostinckx</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><forename type="middle">De</forename><surname>Meuter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICDL, ACM</title>
		<meeting>ICDL, ACM</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="222" to="248" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Ambient-oriented programming in AmbientTalk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jessie</forename><surname>Dedecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Van Cutsem</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stijn</forename><surname>Mostinckx</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D'</forename><surname>Theo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><forename type="middle">De</forename><surname>Hondt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Meuter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECOOP, in: LNCS</title>
		<meeting>ECOOP, in: LNCS</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">4067</biblScope>
			<biblScope unit="page" from="230" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Using continuations to implement thread management and communication in operating systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">P</forename><surname>Draves</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">N</forename><surname>Bershad</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><forename type="middle">F</forename><surname>Rashid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Randall</forename><forename type="middle">W</forename><surname>Dean</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="122" to="136" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Contiki -A lightweight and flexible operating system for tiny networked sensors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Dunkels</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Björn</forename><surname>Grönvall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thiemo</forename><surname>Voigt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. LCN</title>
		<meeting>LCN</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="455" to="462" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Matching objects with patterns</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Burak</forename><surname>Emir</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Odersky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ECOOP</title>
		<editor>Erik Ernst</editor>
		<meeting>ECOOP</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="volume">4609</biblScope>
			<biblScope unit="page" from="273" to="298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Transactors: A programming model for maintaining globally consistent distributed state in unreliable environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Field</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><forename type="middle">A</forename><surname>Varela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. POPL, ACM</title>
		<meeting>POPL, ACM</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="195" to="208" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gamma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Helm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Johnson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Vlissides</surname></persName>
		</author>
		<title level="m">Design Patterns</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Jesper Spring, Frugal mobile objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rachid</forename><surname>Benoit Garbinato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarle</forename><surname>Guerraoui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maxime</forename><surname>Hulaas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Monod</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>EPFL</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Concurrency oriented programming in termite scheme</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guillaume</forename><surname>Germain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Feeley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Monnier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Scheme and Functional Programming</title>
		<meeting>Workshop on Scheme and Functional Programming</meeting>
		<imprint>
			<date type="published" when="2006-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Event-based programming without inversion of control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Haller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Odersky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. JMLC, in: LNCS</title>
		<meeting>JMLC, in: LNCS</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006-09" />
			<biblScope unit="volume">4228</biblScope>
			<biblScope unit="page" from="4" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Language support for lightweight transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Keir</forename><surname>Fraser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA</title>
		<meeting>OOPSLA</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="388" to="402" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Composable memory transactions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tim</forename><surname>Harris</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><surname>Marlow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Simon</forename><forename type="middle">L Peyton</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maurice</forename><surname>Herlihy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PPOPP, ACM</title>
		<meeting>PPOPP, ACM</meeting>
		<imprint>
			<date type="published" when="2005-06" />
			<biblScope unit="page" from="48" to="60" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Engines build process abstractions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">T</forename><surname>Haynes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">P</forename><surname>Friedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. Lisp and Functional Programming</title>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1984-08" />
			<biblScope unit="page" from="18" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<monogr>
		<title level="m" type="main">A universal modular ACTOR formalism for artificial intelligence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carl</forename><surname>Hewitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Bishop</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Steiger</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1973" />
			<publisher>IJCAI</publisher>
			<biblScope unit="page" from="235" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On the duality of operating system structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugh</forename><forename type="middle">C</forename><surname>Lauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><forename type="middle">M</forename><surname>Needham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operating Systems Review</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="3" to="19" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Doug</forename><surname>Lea</surname></persName>
		</author>
		<title level="m">Concurrent Programming in Java</title>
		<imprint>
			<publisher>Addison Wesley</publisher>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">A java fork/join framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Doug</forename><surname>Lea</surname></persName>
		</author>
		<editor>Java Grande</editor>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="36" to="43" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">The problem with threads</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><forename type="middle">A</forename><surname>Lee</surname></persName>
		</author>
		<idno>UCB/EECS-2006-1</idno>
		<imprint>
			<date type="published" when="2006-01" />
		</imprint>
		<respStmt>
			<orgName>University of California, Berkeley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Combining events and threads for scalable network services implementation and evaluation of monadic, application-level concurrency primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peng</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Zdancewic</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. PLDI, ACM</title>
		<meeting>PLDI, ACM</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="189" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">The Java Virtual Machine Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lindholm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Yellin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Concurrency among strangers -programming in E as plan coordination</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">S</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">Dean</forename><surname>Tribble</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Shapiro</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. TGC 2005</title>
		<meeting>TGC 2005</meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="2005" />
			<biblScope unit="volume">3705</biblScope>
			<biblScope unit="page" from="195" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Evaluating distributed functional languages for telecommunications software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Nyström</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><forename type="middle">W</forename><surname>Trinder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">J</forename><surname>King</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Workshop on Erlang, ACM</title>
		<meeting>Workshop on Erlang, ACM</meeting>
		<imprint>
			<date type="published" when="2003-08" />
			<biblScope unit="page" from="1" to="7" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Why threads are A bad idea (for most purposes), Invited talk at USENIX</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Ousterhout</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Flash: An efficient and portable Web server</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Vivek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Pai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willy</forename><surname>Druschel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zwaenepoel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. USENIX</title>
		<meeting>USENIX</meeting>
		<imprint>
			<date type="published" when="1999-06" />
			<biblScope unit="page" from="199" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Actra: A multitasking/multiprocessing smalltalk</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">R</forename><surname>Lalonde</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Duimovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wilson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcaffer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Berry</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="87" to="90" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Programming dynamically reconfigurable open systems with SALSA</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Varela</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gul</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM SIGPLAN Notices</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="20" to="34" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Why events are a bad idea (for high-concurrency servers)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Robert Von Behren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Hot OS, USENIX</title>
		<meeting>Hot OS, USENIX</meeting>
		<imprint>
			<date type="published" when="2003-05" />
			<biblScope unit="page" from="19" to="24" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Capriccio: Scalable threads for internet services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Robert Von Behren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeremy</forename><surname>Condit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Feng</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><forename type="middle">C</forename><surname>Necula</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="268" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Continuation-based multiprocessing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><surname>Wand</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LISP Conference</title>
		<imprint>
			<date type="published" when="1980" />
			<biblScope unit="page" from="19" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">SEDA: An architecture for well-conditioned, scalable internet services</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matt</forename><surname>Welsh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">E</forename><surname>Culler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><forename type="middle">A</forename><surname>Brewer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. SOSP</title>
		<meeting>SOSP</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="230" to="243" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Object-oriented concurrent programming in ABCL/1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akinori</forename><surname>Yonezawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jean-Pierre</forename><surname>Briot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Etsuya</forename><surname>Shibayama</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. OOPSLA</title>
		<meeting>OOPSLA</meeting>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="page" from="258" to="268" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Stabilizers: A modular checkpointing abstraction for concurrent functional programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lukasz</forename><surname>Ziarek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Schatz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suresh</forename><surname>Jagannathan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICFP, ACM</title>
		<meeting>ICFP, ACM</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="136" to="147" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
